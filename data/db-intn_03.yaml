- en: Chapter 2\. B-Tree Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章\. B-树基础
- en: 'In the previous chapter, we separated storage structures in two groups: *mutable*
    and *immutable* ones, and identified immutability as one of the core concepts
    influencing their design and implementation. Most of the mutable storage structures
    use an *in-place update* mechanism. During insert, delete, or update operations,
    data records are updated directly in their locations in the target file.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将存储结构分为两组：*可变*和*不可变*，并确定了不可变性作为影响其设计和实现的核心概念之一。大多数可变存储结构使用*原地更新*机制。在插入、删除或更新操作期间，数据记录直接在目标文件中更新。
- en: Storage engines often allow multiple versions of the same data record to be
    present in the database; for example, when using multiversion concurrency control
    (see [“Multiversion Concurrency Control”](ch05.html#mvcc)) or slotted page organization
    (see [“Slotted Pages”](ch03.html#slotted_pages)). For the sake of simplicity,
    for now we assume that each key is associated only with one data record, which
    has a unique location.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 存储引擎通常允许数据库中存在同一数据记录的多个版本；例如，在使用多版本并发控制（见[“多版本并发控制”](ch05.html#mvcc)）或分槽页组织时（见[“槽页”](ch03.html#slotted_pages)）。为了简单起见，我们暂时假设每个键仅与一个数据记录相关联，该记录具有唯一位置。
- en: One of the most popular storage structures is a B-Tree. Many open source database
    systems are B-Tree based, and over the years they’ve proven to cover the majority
    of use cases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种最受欢迎的存储结构是B-树。许多开源数据库系统基于B-树，多年来它们已被证明可以覆盖大多数使用情况。
- en: 'B-Trees are not a recent invention: they were introduced by Rudolph Bayer and
    Edward M. McCreight back in 1971 and gained popularity over the years. By 1979,
    there were already quite a few variants of B-Trees. Douglas Comer collected and
    systematized some of them [[COMER79]](app01.html#COMER79).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: B-树并非新发明：它们由Rudolph Bayer和Edward M. McCreight在1971年引入，并随着时间的推移而流行起来。到1979年，已经有相当多的B-树变体。Douglas
    Comer收集并系统化了其中一些[[COMER79]](app01.html#COMER79)。
- en: Before we dive into B-Trees, let’s first talk about why we should consider alternatives
    to traditional search trees, such as, for example, binary search trees, 2-3-Trees,
    and AVL Trees [[KNUTH98]](app01.html#KNUTH98). For that, let’s recall what binary
    search trees are.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究B-树之前，让我们先谈谈为什么我们应该考虑传统搜索树的替代方案，例如二叉搜索树、2-3树和AVL树[[KNUTH98]](app01.html#KNUTH98)。为此，让我们回顾一下二叉搜索树是什么。
- en: Binary Search Trees
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉搜索树
- en: A *binary search tree* (BST) is a sorted in-memory data structure, used for
    efficient key-value lookups. BSTs consist of multiple nodes. Each tree node is
    represented by a key, a value associated with this key, and two child pointers
    (hence the name binary). BSTs start from a single node, called a *root node*.
    There can be only one root in the tree. [Figure 2-1](#binary_tree) shows an example
    of a binary search tree.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*二叉搜索树*（BST）是一种排序的内存数据结构，用于高效的键值查找。BST由多个节点组成。每个树节点由一个键、与该键相关联的值以及两个子指针表示（因此称为二进制）。BST从单个称为*根节点*的节点开始。树中只能有一个根。[图2-1](#binary_tree)展示了二叉搜索树的示例。'
- en: '![dbin 0201](assets/dbin_0201.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0201](assets/dbin_0201.png)'
- en: Figure 2-1\. Binary search tree
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1\. 二叉搜索树
- en: 'Each node splits the search space into left and right *subtrees*, as [Figure 2-2](#binary_tree_invariants)
    shows: a node key is *greater than* any key stored in its left subtree and *less
    than* any key stored in its right subtree [[SEDGEWICK11]](app01.html#SEDGEWICK11).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点将搜索空间分为左右*子树*，如[图2-2](#binary_tree_invariants)所示：节点键*大于*存储在其左子树中的任何键，*小于*存储在其右子树中的任何键[[SEDGEWICK11]](app01.html#SEDGEWICK11)。
- en: '![dbin 0202](assets/dbin_0202.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0202](assets/dbin_0202.png)'
- en: Figure 2-2\. Binary tree node invariants
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. 二叉树节点不变性
- en: Following left pointers from the root of the tree down to the leaf level (the
    level where nodes have no children) locates the node holding the smallest key
    within the tree and a value associated with it. Similarly, following right pointers
    locates the node holding the largest key within the tree and a value associated
    with it. Values are allowed to be stored in all nodes in the tree. Searches start
    from the root node, and may terminate before reaching the bottom level of the
    tree if the searched key was found on a higher level.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从树的根节点开始沿左指针向下到叶级（节点没有子节点的级别）可以定位持有树中最小键和相关值的节点。类似地，跟随右指针可以定位持有树中最大键和相关值的节点。允许在树中的所有节点中存储值。搜索从根节点开始，并且如果在更高级别找到搜索键，则可能在未达到树的底层之前终止。
- en: Tree Balancing
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树的平衡化
- en: Insert operations do not follow any specific pattern, and element insertion
    might lead to the situation where the tree is unbalanced (i.e., one of its branches
    is longer than the other one). The worst-case scenario is shown in [Figure 2-3](#binary_tree_balancing)
    (b), where we end up with a *pathological* tree, which looks more like a linked
    list, and instead of desired logarithmic complexity, we get linear, as illustrated
    in [Figure 2-3](#binary_tree_balancing) (a).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 插入操作不遵循任何特定模式，元素插入可能导致树失衡（即其中一个分支比另一个分支更长）。最坏情况如图[2-3](#binary_tree_balancing)
    (b)所示，我们最终得到一个*病态*树，更像是一个链接列表，而不是期望的对数复杂度，如图[2-3](#binary_tree_balancing) (a)所示。
- en: '![dbin 0203](assets/dbin_0203.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0203](assets/dbin_0203.png)'
- en: Figure 2-3\. Balanced (a) and unbalanced or pathological (b) tree examples
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 平衡 (a) 和非平衡或病态 (b) 树示例
- en: 'This example might slightly exaggerate the problem, but it illustrates why
    the tree needs to be balanced: even though it’s somewhat unlikely that all the
    items end up on one side of the tree, at least some of them certainly will, which
    will significantly slow down searches.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能稍微夸张了问题，但它说明了为什么树需要平衡：尽管所有项目都在树的一侧的可能性稍低，但至少其中一些肯定会，这将显著减慢搜索速度。
- en: The *balanced* tree is defined as one that has a height of `log[2] N`, where
    `N` is the total number of items in the tree, and the difference in height between
    the two subtrees is not greater than one^([1](ch02.html#idm46466889485960)) [[KNUTH98]](app01.html#KNUTH98).
    Without balancing, we lose performance benefits of the binary search tree structure,
    and allow insertions and deletions order to determine tree shape.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*平衡*树被定义为高度为`log[2] N`的树，其中`N`是树中的总项目数，并且两个子树之间高度差不超过一^([1](ch02.html#idm46466889485960))
    [[KNUTH98]](app01.html#KNUTH98)。没有平衡，我们将失去二叉搜索树结构的性能优势，并允许插入和删除顺序来确定树的形状。'
- en: 'In the balanced tree, following the left or right node pointer reduces the
    search space in half on average, so lookup complexity is logarithmic: `O(log[2]
    N)`. If the tree is not balanced, worst-case complexity goes up to `O(N)`, since
    we might end up in the situation where all elements end up on one side of the
    tree.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在平衡树中，沿着左或右节点指针平均减少搜索空间的一半，因此查找复杂度是对数的：`O(log[2] N)`。如果树不平衡，最坏情况复杂度会上升到`O(N)`，因为我们可能会陷入所有元素都在树的一侧的情况。
- en: Instead of adding new elements to one of the tree branches and making it longer,
    while the other one remains empty (as shown in [Figure 2-3](#binary_tree_balancing)
    (b)), the tree is *balanced* after each operation. Balancing is done by reorganizing
    nodes in a way that minimizes tree height and keeps the number of nodes on each
    side within bounds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不是将新元素添加到树的一个分支并使其变得更长，而另一个分支保持为空（如图[2-3](#binary_tree_balancing) (b)所示），每次操作后树都会*平衡*。平衡是通过重新组织节点以使树高最小化并保持每侧节点数量在界限内来完成的。
- en: One of the ways to keep the tree balanced is to perform a rotation step after
    nodes are added or removed. If the insert operation leaves a branch unbalanced
    (two consecutive nodes in the branch have only one child), we can *rotate* nodes
    around the middle one. In the example shown in [Figure 2-4](#binary_tree_rotation),
    during rotation the middle node (3), known as a rotation *pivot*, is promoted
    one level higher, and its parent becomes its right child.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 保持树平衡的一种方法是在添加或删除节点后执行旋转步骤。如果插入操作使一个分支失衡（分支中连续两个节点只有一个子节点），我们可以围绕中间节点*旋转*节点。在图[2-4](#binary_tree_rotation)的示例中，旋转过程中间节点（3），称为旋转*枢轴*，被提升到更高一级，其父节点成为其右子节点。
- en: '![dbin 0204](assets/dbin_0204.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0204](assets/dbin_0204.png)'
- en: Figure 2-4\. Rotation step example
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 旋转步骤示例
- en: Trees for Disk-Based Storage
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘存储的树
- en: As previously mentioned, unbalanced trees have a worst-case complexity of `O(N)`.
    Balanced trees give us an average `O(log[2] N)`. At the same time, due to low
    *fanout* (fanout is the maximum allowed number of children per node), we have
    to perform balancing, relocate nodes, and update pointers rather frequently. Increased
    maintenance costs make BSTs impractical as on-disk data structures [[NIEVERGELT74]](app01.html#NIEVERGELT74).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，非平衡树的最坏情况复杂度为`O(N)`。平衡树则给我们提供了平均`O(log[2] N)`的复杂度。与此同时，由于低*分支因子*（分支因子是每个节点允许的最大子节点数），我们经常需要进行平衡、重定位节点和更新指针。增加的维护成本使得二叉搜索树作为磁盘数据结构不切实际[[NIEVERGELT74]](app01.html#NIEVERGELT74)。
- en: 'If we wanted to maintain a BST on disk, we’d face several problems. One problem
    is locality: since elements are added in random order, there’s no guarantee that
    a newly created node is written close to its parent, which means that node child
    pointers may span across several disk pages. We can improve the situation to a
    certain extent by modifying the tree layout and using paged binary trees (see
    [“Paged Binary Trees”](#paged_binary_trees)).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在磁盘上维护一个BST，我们将面临几个问题。一个问题是局部性：由于元素是按随机顺序添加的，不能保证新创建的节点被写入其父节点附近，这意味着节点的子指针可能跨越多个磁盘页面。通过修改树的布局并使用分页二叉树（参见[“分页二叉树”](#paged_binary_trees)），我们可以在一定程度上改善情况。
- en: 'Another problem, closely related to the cost of following child pointers, is
    tree height. Since binary trees have a fanout of just two, height is a binary
    logarithm of the number of the elements in the tree, and we have to perform `O(log[2]
    N)` seeks to locate the searched element and, subsequently, perform the same number
    of disk transfers. 2-3-Trees and other low-fanout trees have a similar limitation:
    while they are useful as in-memory data structures, small node size makes them
    impractical for external storage [[COMER79]](app01.html#COMER79).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题，与跟随子指针的成本密切相关的是树的高度。由于二叉树的扇出只有两个，高度是树中元素数量的二进制对数，我们必须执行`O(log[2] N)`次寻址来定位所搜索的元素，并且随后执行相同数量的磁盘传输。2-3树和其他低扇出树具有类似的限制：虽然它们作为内存数据结构很有用，但小节点大小使它们在外部存储中不切实际[[COMER79]](app01.html#COMER79)。
- en: A naive on-disk BST implementation would require as many disk seeks as comparisons,
    since there’s no built-in concept of locality. This sets us on a course to look
    for a data structure that would exhibit this property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的磁盘上的二叉搜索树（BST）实现需要和比较一样多的磁盘寻址，因为没有内置的局部性概念。这使得我们必须寻找一个能展现这种特性的数据结构。
- en: 'Considering these factors, a version of the tree that would be better suited
    for disk implementation has to exhibit the following properties:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，适合磁盘实现的树的版本必须展示以下特性：
- en: '*High fanout* to improve locality of the neighboring keys.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高扇出*以改进相邻键的局部性。'
- en: '*Low height* to reduce the number of seeks during traversal.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*低高度*以减少遍历过程中的寻址次数。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Fanout and height are inversely correlated: the higher the fanout, the lower
    the height. If fanout is high, each node can hold more children, reducing the
    number of nodes and, subsequently, reducing height.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 扇出和高度成反比：扇出越高，高度越低。如果扇出高，每个节点可以容纳更多的子节点，减少节点数量，从而减少高度。
- en: Disk-Based Structures
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于磁盘的结构
- en: 'We’ve talked about memory and disk-based storage (see [“Memory- Versus Disk-Based
    DBMS”](ch01.html#memory_vs_disk_based_stores)) in general terms. We can draw the
    same distinction for specific data structures: some are better suited to be used
    on disk and some work better in memory.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经以一般术语讨论了内存和基于磁盘的存储（参见[“内存与基于磁盘的DBMS”](ch01.html#memory_vs_disk_based_stores)）。对于特定的数据结构，我们可以做出相同的区分：有些更适合用于磁盘，而有些在内存中工作更好。
- en: As we have discussed, not every data structure that satisfies space and complexity
    requirements can be effectively used for on-disk storage. Data structures used
    in databases have to be adapted to account for persistent medium limitations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，不是每个满足空间和复杂度要求的数据结构都能有效用于磁盘存储。用于数据库的数据结构必须适应持久性介质的限制。
- en: On-disk data structures are often used when the amounts of data are so large
    that keeping an entire dataset in memory is impossible or not feasible. Only a
    fraction of the data can be *cached* in memory at any time, and the rest has to
    be stored on disk in a manner that allows efficiently accessing it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据量非常大，无法或不可行地将整个数据集保存在内存中时，通常会使用磁盘数据结构。只有一部分数据可以在任何时候在内存中*缓存*，其余数据必须以一种允许高效访问的方式存储在磁盘上。
- en: Hard Disk Drives
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬盘驱动器
- en: Most traditional algorithms were developed when spinning disks were the most
    widespread persistent storage medium, which significantly influenced their design.
    Later, new developments in storage media, such as flash drives, inspired new algorithms
    and modifications to the existing ones, exploiting the capabilities of the new
    hardware. These days, new types of data structures are emerging, optimized to
    work with nonvolatile byte-addressable storage (for example, [[XIA17]](app01.html#XIA17)
    [[KANNAN18]](app01.html#KANNAN18)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数传统算法是在旋转硬盘是最广泛的持久存储介质时开发的，这显著影响了它们的设计。后来，存储介质的新发展，如闪存驱动器，启发了新的算法和对现有算法的修改，利用了新硬件的能力。如今，新型数据结构正在出现，优化以与非易失性可寻址存储一起工作（例如，[[XIA17]](app01.html#XIA17)
    [[KANNAN18]](app01.html#KANNAN18)）。
- en: On spinning disks, *seeks* increase costs of random reads because they require
    disk rotation and mechanical head movements to position the read/write head to
    the desired location. However, once the expensive part is done, reading or writing
    contiguous bytes (i.e., sequential operations) is *relatively* cheap.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在旋转硬盘上，*寻道* 增加了随机读取的成本，因为它们需要磁盘旋转和机械磁头移动以定位读/写头到所需位置。但是，一旦昂贵的部分完成，读取或写入连续字节（即顺序操作）就*相对*便宜了。
- en: The smallest transfer unit of a spinning drive is a *sector*, so when some operation
    is performed, at least an entire sector can be read or written. Sector sizes typically
    range from 512 bytes to 4 Kb.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转驱动器的最小传输单位是*扇区*，因此在执行某些操作时，至少可以读取或写入整个扇区。扇区的大小通常在512字节到4 Kb之间。
- en: 'Head positioning is the most expensive part of an operation on the HDD. This
    is one of the reasons we often hear about the positive effects of *sequential*
    I/O: reading and writing contiguous memory segments from disk.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 磁头定位是HDD操作中最昂贵的部分。这也是我们经常听到*顺序* I/O 的积极影响的原因之一：从磁盘读取和写入连续的内存段。
- en: Solid State Drives
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固态硬盘
- en: 'Solid state drives (SSDs) do not have moving parts: there’s no disk that spins,
    or head that has to be positioned for the read. A typical SSD is built of *memory
    cells*, connected into *strings* (typically 32 to 64 cells per string), strings
    are combined into *arrays*, arrays are combined into *pages*, and pages are combined
    into *blocks* [[LARRIVEE15]](app01.html#LARRIVEE15).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 固态硬盘（SSD）没有移动部件：没有旋转的盘片，也没有需要定位读取的磁头。典型的SSD由*存储单元*组成，连接成*串*（通常每串32到64个单元），串组合成*阵列*，阵列组合成*页*，页组合成*块*
    [[LARRIVEE15]](app01.html#LARRIVEE15)。
- en: Depending on the exact technology used, a cell can hold one or multiple bits
    of data. Pages vary in size between devices, but typically their sizes range from
    2 to 16 Kb. Blocks typically contain 64 to 512 pages. Blocks are organized into
    planes and, finally, planes are placed on a *die*. SSDs can have one or more dies.
    [Figure 2-5](#ssd_architecture) shows this hierarchy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的确切技术，单元可以容纳一个或多个数据位。设备的页大小因设备而异，但通常在2到16 Kb之间。块通常包含64到512页。块被组织成平面，最终，平面被放置在*芯片*上。SSD可以有一个或多个芯片。[图 2-5](#ssd_architecture)
    显示了这种层次结构。
- en: '![dbin 0205](assets/dbin_0205.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0205](assets/dbin_0205.png)'
- en: Figure 2-5\. SSD organization schematics
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5\. SSD 组织结构示意图
- en: The smallest unit that can be written (programmed) or read is a page. However,
    we can only make changes to the empty memory cells (i.e., to ones that have been
    erased before the write). The smallest erase entity is not a page, but a block
    that holds multiple pages, which is why it is often called an *erase block*. Pages
    in an empty block have to be written sequentially.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写入（编程）或读取的最小单位是页。但是，我们只能对空白存储单元进行更改（即已经擦除以便写入的单元）。最小的擦除单元不是页，而是包含多个页的块，因此通常被称为*擦除块*。空块中的页必须按顺序写入。
- en: The part of a flash memory controller responsible for mapping page IDs to their
    physical locations, tracking empty, written, and discarded pages, is called the
    Flash Translation Layer (FTL) (see [“Flash Translation Layer”](ch07.html#flash_translation_layer)
    for more about FTL). It is also responsible for *garbage collection*, during which
    FTL finds blocks it can safely erase. Some blocks might still contain live pages.
    In this case, it relocates live pages from these blocks to new locations and remaps
    page IDs to point there. After this, it erases the now-unused blocks, making them
    available for writes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 负责将页ID映射到其物理位置，跟踪空闲、写入和已丢弃页面的闪存控制器部分称为闪存转换层（FTL）（详见[“闪存转换层”](ch07.html#flash_translation_layer)以了解更多关于FTL的信息）。它还负责*垃圾收集*，在此期间，FTL找到可以安全擦除的块。一些块可能仍包含存活页面。在这种情况下，它将存活页面从这些块重新定位到新位置，并重新映射页ID以指向那里。之后，它擦除现在未使用的块，使它们可以进行写入。
- en: Since in both device types (HDDs and SSDs) we are addressing chunks of memory
    rather than individual bytes (i.e., accessing data block-wise), most operating
    systems have a *block device* abstraction [[CESATI05]](app01.html#CESATI05). It
    hides an internal disk structure and buffers I/O operations internally, so when
    we’re reading a *single word* from a block device, the *whole block* containing
    it is read. This is a constraint we cannot ignore and should always take into
    account when working with disk-resident data structures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在设备类型（HDD和SSD）中我们处理的是内存块而不是单个字节（即按数据块访问），大多数操作系统都有*块设备*抽象 [[CESATI05]](app01.html#CESATI05)。它隐藏了内部的磁盘结构，并在内部缓冲I/O操作，因此当我们从块设备中读取一个*单词*时，会读取包含它的*整个块*。这是一个我们不能忽视的约束条件，在处理驻留在磁盘上的数据结构时应始终考虑。
- en: In SSDs, we don’t have a strong emphasis on random versus sequential I/O, as
    in HDDs, because the difference in latencies between random and sequential reads
    is not as large. There is *still* some difference caused by prefetching, reading
    contiguous pages, and internal parallelism [[GOOSSAERT14]](app01.html#GOOSSAERT14).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSD中，与HDD不同，我们不强调随机与顺序I/O之间的差异，因为随机和顺序读取之间的延迟差异不是很大。由于预取、连续页面读取和内部并行性，仍然存在一些由此引起的差异
    [[GOOSSAERT14]](app01.html#GOOSSAERT14)。
- en: Even though garbage collection is usually a background operation, its effects
    may negatively impact write performance, especially in cases of random and unaligned
    write workloads.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管垃圾收集通常是后台操作，但其影响可能会对写入性能产生负面影响，尤其是在随机和不对齐的写入工作负载情况下。
- en: Writing only full blocks, and combining subsequent writes to the same block,
    can help to reduce the number of required I/O operations. We discuss buffering
    and immutability as ways to achieve that in later chapters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 仅写入完整块，并将后续写入组合到同一块中，可以帮助减少所需的I/O操作次数。我们将在后续章节中讨论缓冲和不变性作为实现这一目标的方法。
- en: On-Disk Structures
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘上的数据结构
- en: Besides the cost of disk access itself, the main limitation and design condition
    for building efficient on-disk structures is the fact that the smallest unit of
    disk operation is a block. To follow a pointer to the specific location within
    the block, we have to fetch an entire block. Since we already have to do that,
    we can change the layout of the data structure to take advantage of it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了磁盘访问本身的成本外，构建高效的磁盘结构的主要限制和设计条件是磁盘操作的最小单位是一个块。要跟随指针到块内的特定位置，我们必须获取整个块。既然我们已经这样做了，我们可以改变数据结构的布局以利用它。
- en: We’ve mentioned pointers several times throughout this chapter already, but
    this word has slightly different semantics for on-disk structures. On disk, most
    of the time we manage the data layout manually (unless, for example, we’re using
    [memory mapped files](https://databass.dev/links/64)). This is still similar to
    regular pointer operations, but we have to compute the target pointer addresses
    and follow the pointers explicitly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经多次提到指针，但对于磁盘上的结构，这个词的语义略有不同。在磁盘上，大多数情况下我们手动管理数据布局（除非，例如，我们使用[内存映射文件](https://databass.dev/links/64)）。这与常规指针操作类似，但我们必须计算目标指针地址并显式地跟踪指针。
- en: Most of the time, on-disk offsets are precomputed (in cases when the pointer
    is written on disk before the part it points to) or cached in memory until they
    are flushed on the disk. Creating long dependency chains in on-disk structures
    greatly increases code and structure complexity, so it is preferred to keep the
    number of pointers and their spans to a minimum.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，磁盘偏移量是预先计算的（在指针在指向的部分之前写入磁盘的情况下）或者在内存中缓存，直到它们被刷新到磁盘上。在磁盘结构中创建长依赖链大大增加了代码和结构复杂性，因此最好保持指针数量及其跨度的最小化。
- en: In summary, on-disk structures are designed with their target storage specifics
    in mind and generally optimize for fewer disk accesses. We can do this by improving
    locality, optimizing the internal representation of the structure, and reducing
    the number of out-of-page pointers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，磁盘结构是根据其目标存储特性设计的，通常优化于减少磁盘访问。我们可以通过提高局部性，优化结构的内部表示以及减少页面外指针的数量来实现这一点。
- en: 'In [“Binary Search Trees”](#search_trees), we came to the conclusion that *high
    fanout* and *low height* are desired properties for an optimal on-disk data structure.
    We’ve also just discussed additional space overhead coming from pointers, and
    maintenance overhead from remapping these pointers as a result of balancing. B-Trees
    combine these ideas: increase node fanout, and reduce tree height, the number
    of node pointers, and the frequency of balancing operations.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“二叉搜索树”](#search_trees) 中，我们得出结论，*高扇出* 和 *低高度* 是理想的磁盘数据结构的期望特性。我们刚刚讨论了指针带来的额外空间开销，以及由于平衡导致的这些指针重映射的维护开销。B-树结合了这些思想：增加节点的扇出，并减少树的高度、节点指针的数量以及平衡操作的频率。
- en: Ubiquitous B-Trees
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普遍存在的B-树
- en: We are braver than a bee, and a… longer than a tree…
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们比蜜蜂更勇敢，比树更……长……
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Winnie the Pooh
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小熊维尼
- en: 'B-Trees can be thought of as a vast catalog room in the library: you first
    have to pick the correct cabinet, then the correct shelf in that cabinet, then
    the correct drawer on the shelf, and then browse through the cards in the drawer
    to find the one you’re searching for. Similarly, a B-Tree builds a hierarchy that
    helps to navigate and locate the searched items quickly.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: B-树可以被视为图书馆中的广阔目录室：您首先必须选择正确的柜子，然后是该柜子中的正确架子，接着是架子上的正确抽屉，然后浏览抽屉中的卡片，找到您正在搜索的那一张。类似地，B-树建立了一个层次结构，有助于快速导航和定位搜索的项目。
- en: As we discussed in [“Binary Search Trees”](#search_trees), B-Trees build upon
    the foundation of balanced search trees and are different in that they have higher
    fanout (have more child nodes) and smaller height.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [“二叉搜索树”](#search_trees) 中所讨论的，B-树建立在平衡搜索树的基础上，并且在于它们具有更高的扇出（具有更多的子节点）和较小的高度。
- en: In most of the literature, binary tree nodes are drawn as circles. Since each
    node is responsible just for one key and splits the range into two parts, this
    level of detail is sufficient and intuitive. At the same time, B-Tree nodes are
    often drawn as rectangles, and pointer blocks are also shown explicitly to highlight
    the relationship between child nodes and separator keys. [Figure 2-7](#btree_node_vs_2_3_tree_node_vs_binary_tree_node)
    shows binary tree, 2-3-Tree, and B-Tree nodes side by side, which helps to understand
    the similarities and differences between them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数文献中，二叉树节点被绘制为圆圈。由于每个节点只负责一个键并将范围分成两部分，这个细节水平已经足够直观了。同时，B-树节点通常被绘制为矩形，并且指针块也明确显示，以突出子节点与分隔键之间的关系。[图 2-7](#btree_node_vs_2_3_tree_node_vs_binary_tree_node)
    将二叉树、2-3树和B-树节点并排显示，有助于理解它们之间的相似性和差异。
- en: '![dbin 0207](assets/dbin_0207.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0207](assets/dbin_0207.png)'
- en: Figure 2-7\. Binary tree, 2-3-Tree, and B-Tree nodes side by side
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-7. 二叉树、2-3树和B-树节点并排
- en: 'Nothing prevents us from depicting binary trees in the same way. Both structures
    have similar pointer-following semantics, and differences start showing in how
    the balance is maintained. [Figure 2-8](#binary_tree_alternative_representation)
    shows that and hints at similarities between BSTs and B-Trees: in both cases,
    keys split the tree into subtrees, and are used for navigating the tree and finding
    searched keys. You can compare it to [Figure 2-1](#binary_tree).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能阻止我们以同样的方式描述二叉树。这两种结构具有类似的指针跟随语义，不同之处在于平衡维护的方式。[图 2-8](#binary_tree_alternative_representation)
    显示了这一点，并暗示了二叉搜索树和B-树之间的相似性：在这两种情况下，键将树分成子树，并用于导航树并找到搜索键。您可以将其与 [图 2-1](#binary_tree)
    进行比较。
- en: '![dbin 0208](assets/dbin_0208.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0208](assets/dbin_0208.png)'
- en: Figure 2-8\. Alternative representation of a binary tree
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-8\. 二叉树的替代表示
- en: 'B-Trees are *sorted*: keys inside the B-Tree nodes are stored in order. Because
    of that, to locate a searched key, we can use an algorithm like binary search.
    This also implies that lookups in B-Trees have logarithmic complexity. For example,
    finding a searched key among 4 billion (`4 × 10⁹`) items takes about 32 comparisons
    (see [“B-Tree Lookup Complexity”](#b_tree_complexity) for more on this subject).
    If we had to make a disk seek for each one of these comparisons, it would significantly
    slow us down, but since B-Tree nodes store dozens or even hundreds of items, we
    only have to make one disk seek per level jump. We’ll discuss a lookup algorithm
    in more detail later in this chapter.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: B-树是*有序*的：B-树节点内的键按顺序存储。由此可知，为了定位搜索的键，可以使用类似于二分查找的算法。这也意味着在B-树中进行查找具有对数复杂度。例如，在40亿（`4
    × 10⁹`）项中查找一个搜索的键需要大约32次比较（参见[“B-树查找复杂度”](#b_tree_complexity)了解更多）。如果每个比较都需要进行一次磁盘寻址，这将显著减慢速度，但由于B-树节点存储了数十甚至数百个项目，我们只需进行每次级别跳转的一次磁盘寻址。我们将在本章后面更详细地讨论查找算法。
- en: Using B-Trees, we can efficiently execute both *point* and *range* queries.
    Point queries, expressed by the equality (`=`) predicate in most query languages,
    locate a single item. On the other hand, range queries, expressed by comparison
    (`<`, `>`, `≤`, and `≥`) predicates, are used to query multiple data items in
    order.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用B-树，我们可以高效地执行*点查询*和*范围查询*。在大多数查询语言中，通过等号（`= `）谓词表示的点查询定位单个项。另一方面，通过比较（`<`、`>`、`≤`和`≥`）谓词表示的范围查询用于按顺序查询多个数据项。
- en: B-Tree Hierarchy
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B-树层次结构
- en: 'B-Trees consist of multiple nodes. Each node holds up to `N` keys and `N +
    1` pointers to the child nodes. These nodes are logically grouped into three groups:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: B-树由多个节点组成。每个节点最多容纳`N`个键和`N + 1`个指向子节点的指针。这些节点在逻辑上分为三组：
- en: Root node
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点
- en: This has no parents and is the top of the tree.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有父节点，是树的顶部。
- en: Leaf nodes
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 叶节点
- en: These are the bottom layer nodes that have no child nodes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是没有子节点的底层节点。
- en: Internal nodes
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内部节点
- en: These are all other nodes, connecting root with leaves. There is usually more
    than one level of internal nodes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是其他节点，连接根节点与叶节点。通常存在多个层级的内部节点。
- en: This hierarchy is shown in [Figure 2-9](#b_tree_hierarchy).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层次结构显示在[图 2-9](#b_tree_hierarchy)中。
- en: '![dbin 0209](assets/dbin_0209.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0209](assets/dbin_0209.png)'
- en: Figure 2-9\. B-Tree node hierarchy
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-9\. B-树节点层次结构
- en: Since B-Trees are a *page* organization technique (i.e., they are used to organize
    and navigate fixed-size pages), we often use terms *node* and *page* interchangeably.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于B-树是一种*页面*组织技术（即它们用于组织和导航固定大小的页面），我们经常可以互换使用术语*节点*和*页面*。
- en: The relation between the node capacity and the number of keys it actually holds
    is called *occupancy*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 节点容量与实际保存的键数之间的关系称为*占用率*。
- en: 'B-Trees are characterized by their *fanout*: the number of keys stored in each
    node. Higher fanout helps to amortize the cost of structural changes required
    to keep the tree balanced and to reduce the number of seeks by storing keys and
    pointers to child nodes in a single block or multiple consecutive blocks. Balancing
    operations (namely, *splits* and *merges*) are triggered when the nodes are full
    or nearly empty.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: B-树的特征在于它们的*分支因子*：每个节点存储的键数。更高的分支因子有助于分摊保持树平衡所需的结构更改成本，并通过将键和指向子节点的指针存储在单个或多个连续块中来减少寻址次数。当节点满或几乎为空时，会触发平衡操作（即*分裂*和*合并*）。
- en: Separator Keys
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分隔键
- en: Keys stored in B-Tree nodes are called *index entries*, *separator keys*, or
    *divider cells*. They split the tree into *subtrees* (also called *branches* or
    *subranges*), holding corresponding key ranges. Keys are stored in sorted order
    to allow binary search. A subtree is found by locating a key and following a corresponding
    pointer from the higher to the lower level.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在B-树节点中的键被称为*索引条目*、*分隔键*或*分隔单元*。它们将树分割为*子树*（也称为*分支*或*子范围*），每个子树持有相应的键范围。为了进行二分查找，键以排序顺序存储。通过定位键并从高级到低级跟随相应的指针，可以找到子树。
- en: 'The first pointer in the node points to the subtree holding items *less than*
    the first key, and the last pointer in the node points to the subtree holding
    items *greater than or equal* to the last key. Other pointers are reference subtrees
    *between* the two keys: `K[i-1] ≤ K[s] < K[i]`, where `K` is a set of keys, and
    `K[s]` is a key that belongs to the subtree. [Figure 2-10](#tree_subrange) shows
    these invariants.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 节点中的第一个指针指向保存小于第一个键的项目的子树，而节点中的最后一个指针指向保存大于或等于最后一个键的子树。其他指针引用介于两个键之间的子树：`K[i-1]
    ≤ K[s] < K[i]`，其中 `K` 是一组键，`K[s]` 是属于子树的键。[Figure 2-10](#tree_subrange) 展示了这些不变量。
- en: '![dbin 0210](assets/dbin_0210.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0210](assets/dbin_0210.png)'
- en: Figure 2-10\. How separator keys split a tree into subtrees
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. 分隔键如何将树分割成子树
- en: Some B-Tree variants also have sibling node pointers, most often on the leaf
    level, to simplify range scans. These pointers help avoid going back to the parent
    to find the next sibling. Some implementations have pointers in both directions,
    forming a double-linked list on the leaf level, which makes the reverse iteration
    possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 B 树变体还在叶级别上有兄弟节点指针，以简化范围扫描。这些指针帮助避免返回到父节点以查找下一个兄弟节点。一些实现还在两个方向上具有指针，形成叶级别的双向链表，这样就可以进行反向迭代。
- en: What sets B-Trees apart is that, rather than being built from top to bottom
    (as binary search trees), they’re constructed the other way around—from bottom
    to top. The number of leaf nodes grows, which increases the number of internal
    nodes and tree height.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树不同的是，B 树不是从顶向下构建的，而是反过来从底向上构建的。叶节点的数量增加，内部节点和树的高度也随之增加。
- en: Since B-Trees reserve extra space inside nodes for future insertions and updates,
    tree storage utilization can get as low as 50%, but is usually considerably higher.
    Higher occupancy does not influence B-Tree performance negatively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 B 树在节点内为未来的插入和更新保留了额外空间，树的存储利用率可以低至 50%，但通常要高得多。更高的占用率不会对 B 树的性能产生负面影响。
- en: B-Tree Lookup Complexity
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B-Tree 查找复杂度
- en: 'B-Tree lookup complexity can be viewed from two standpoints: the number of
    block transfers and the number of comparisons done during the lookup.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: B 树查找复杂度可以从两个角度来看待：在查找过程中进行的块传输数量和比较次数。
- en: In terms of number of transfers, the logarithm base is `N` (number of keys per
    node). There are `N` times more nodes on each new level, and following a child
    pointer reduces the search space by the factor of `N`. During lookup, at most
    `log[N] M` (where `M` is a total number of items in the B-Tree) pages are addressed
    to find a searched key. The number of child pointers that have to be followed
    on the root-to-leaf pass is also equal to the number of levels, in other words,
    the height `h` of the tree.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就传输数量而言，对数的底数是 `N`（每个节点的键数）。每个新级别上的节点数增加了 `N` 倍，并且跟随子指针可以将搜索空间减少 `N` 倍。在查找过程中，最多会访问
    `log[N] M`（其中 `M` 是 B 树中的总项数）页来找到所需的键。在从根到叶的过程中还必须跟随子指针的数量等于树的高度 `h`。
- en: From the perspective of number of comparisons, the logarithm base is `2`, since
    searching a key inside each node is done using binary search. Every comparison
    halves the search space, so complexity is `log[2] M`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从比较次数的角度来看，对数的底数是 `2`，因为在每个节点内搜索键都是使用二分搜索完成的。每次比较都将搜索空间减半，因此复杂度是 `log[2] M`。
- en: Knowing the distinction between the number of seeks and the number of comparisons
    helps us gain the intuition about how searches are performed and understand what
    lookup complexity is, from both perspectives.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 知道寻找次数和比较次数之间的区别有助于我们直观地理解搜索的执行过程以及理解查找复杂度的含义。
- en: In textbooks and articles,^([2](ch02.html#idm46466889296840)) B-Tree lookup
    complexity is generally referenced as `log M`. Logarithm base is generally not
    used in complexity analysis, since changing the base simply adds a [constant factor](https://databass.dev/links/65),
    and multiplication by a constant factor does not change complexity. For example,
    given the nonzero constant factor `c`, `O(|c| × n) == O(n)` [[KNUTH97]](app01.html#KNUTH97).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在教科书和文章中，^([2](ch02.html#idm46466889296840)) B 树查找复杂度通常被引用为 `log M`。由于改变对数的底数仅仅添加一个常数因子，并且乘以一个常数因子不会改变复杂度分析。例如，给定非零常数因子
    `c`，`O(|c| × n) == O(n)` [[KNUTH97]](app01.html#KNUTH97)。
- en: B-Tree Lookup Algorithm
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B-Tree 查找算法
- en: Now that we have covered the structure and internal organization of B-Trees,
    we can define algorithms for lookups, insertions, and removals. To find an item
    in a B-Tree, we have to perform a single traversal from root to leaf. The objective
    of this search is to find a searched key or its predecessor. Finding an exact
    match is used for point queries, updates, and deletions; finding its predecessor
    is useful for range scans and inserts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了B树的结构和内部组织，我们可以定义查找、插入和删除的算法。要在B树中查找项目，我们必须从根到叶子执行单次遍历。此搜索的目标是找到搜索的键或其前身。找到精确匹配用于点查询、更新和删除；找到其前身对于范围扫描和插入很有用。
- en: The algorithm starts from the root and performs a binary search, comparing the
    searched key with the keys stored in the root node until it finds the first separator
    key that is greater than the searched value. This locates a searched subtree.
    As we’ve discussed previously, index keys split the tree into subtrees with boundaries
    *between* two neighboring keys. As soon as we find the subtree, we follow the
    pointer that corresponds to it and continue the same search process (locate the
    separator key, follow the pointer) until we reach a target leaf node, where we
    either find the searched key or conclude it is not present by locating its predecessor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 算法从根节点开始执行二分搜索，将搜索的键与存储在根节点中的键进行比较，直到找到第一个大于搜索值的分隔键。这定位到了一个搜索子树。正如我们之前讨论过的那样，索引键将树分割成介于两个相邻键之间的子树。一旦找到子树，我们跟随对应于它的指针并继续相同的搜索过程（定位分隔键，跟随指针），直到达到目标叶子节点，在那里我们要么找到搜索的键，要么通过找到其前身得出不存在的结论。
- en: 'On each level, we get a more detailed view of the tree: we start on the most
    coarse-grained level (the root of the tree) and descend to the next level where
    keys represent more precise, detailed ranges, until we finally reach leaves, where
    the data records are located.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个级别上，我们都可以获得树的更详细视图：我们从最粗粒度级别（树的根）开始，向下降到下一个级别，其中键表示更精确、详细的范围，直到最终到达叶子，其中存储数据记录。
- en: During the point query, the search is done after finding or failing to find
    the searched key. During the range scan, iteration starts from the closest found
    key-value pair and continues by following sibling pointers until the end of the
    range is reached or the range predicate is exhausted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在点查询期间，在找到或未找到搜索的键后进行搜索。在范围扫描期间，从最接近的找到的键值对开始迭代，并通过跟随兄弟指针直到达到范围的末尾或范围谓词耗尽。
- en: Counting Keys
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数键
- en: Across the literature, you can find different ways to describe key and child
    offset counts. [[BAYER72]](app01.html#BAYER72) mentions the device-dependent natural
    number `k` that represents an optimal page size. Pages, in this case, can hold
    between `k` and `2k` keys, but can be partially filled and hold at least `k +
    1` and at most `2k + 1` pointers to child nodes. The root page can hold between
    `1` and `2k` keys. Later, a number `l` is introduced, and it is said that any
    nonleaf page can have `l + 1` keys.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在文献中，您可以找到描述键和子偏移计数的不同方法。[[BAYER72]](app01.html#BAYER72)提到了依赖设备的自然数`k`，表示最佳页面大小。在这种情况下，页面可以容纳`k`到`2k`个键，但可以部分填充并至少包含`k
    + 1`和最多`2k + 1`个指向子节点的指针。根页面可以容纳1到`2k`个键。稍后引入了数字`l`，并且说任何非叶子页面可以有`l + 1`个键。
- en: Other sources, for example [[GRAEFE11]](app01.html#GRAEFE11), describe nodes
    that can hold up to `N` *separator keys* and `N + 1` *pointers*, with otherwise
    similar semantics and invariants.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其他来源，例如[[GRAEFE11]](app01.html#GRAEFE11)，描述了可以容纳最多`N`个*分隔键*和`N + 1`个*指针*的节点，具有类似的语义和不变性。
- en: Both approaches bring us to the same result, and differences are only used to
    emphasize the contents of each source. In this book, we stick to `N` as the number
    of keys (or key-value pairs, in the case of the leaf nodes) for clarity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将我们带到同样的结果，差异仅用于强调每个来源的内容。在本书中，我们坚持将`N`作为清晰度的键数（或在叶节点中的键值对数）。
- en: B-Tree Node Splits
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B树节点分割
- en: To insert the value into a B-Tree, we first have to locate the target leaf and
    find the insertion point. For that, we use the algorithm described in the previous
    section. After the leaf is located, the key and value are appended to it. Updates
    in B-Trees work by locating a target leaf node using a lookup algorithm and associating
    a new value with an existing key.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值插入B树中，我们首先必须定位目标叶子节点并找到插入点。为此，我们使用上一节描述的算法。定位到叶子节点后，将键和值附加到其后。在B树中进行更新通过使用查找算法定位目标叶子节点，并将新值与现有键关联。
- en: 'If the target node doesn’t have enough room available, we say that the node
    has *overflowed* [[NICHOLS66]](app01.html#NICHOLS66) and has to be split in two
    to fit the new data. More precisely, the node is split if the following conditions
    hold:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标节点没有足够的可用空间，则称该节点已*溢出*[[NICHOLS66]](app01.html#NICHOLS66)，必须将其分裂为两个以适应新数据。更精确地说，如果以下条件成立，则会执行节点分裂：
- en: 'For leaf nodes: if the node can hold up to `N` key-value pairs, and inserting
    one more key-value pair brings it *over* its maximum capacity `N`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于叶节点：如果节点可以容纳多达`N`对键-值对，并且插入一个以上的键-值对将其带入*超过*其最大容量`N`。
- en: 'For nonleaf nodes: if the node can hold up to `N + 1` pointers, and inserting
    one more pointer brings it *over* its maximum capacity `N + 1`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非叶节点：如果节点可以容纳多达`N + 1`个指针，并且插入一个以上的指针将其带入*超过*其最大容量`N + 1`。
- en: Splits are done by allocating the new node, transferring half the elements from
    the splitting node to it, and adding its first key and pointer to the parent node.
    In this case, we say that the key is *promoted*. The index at which the split
    is performed is called the *split point* (also called the midpoint). All elements
    after the split point (including split point in the case of leaf node split) are
    transferred to the newly created sibling node, and the rest of the elements remain
    in the splitting node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分配新节点来执行分裂，将一半元素从分裂节点转移到新节点，并将其第一个关键字和指针添加到父节点中。在这种情况下，我们称关键字为*晋升*。执行分裂的索引称为*分裂点*（也称为中点）。在分裂点之后的所有元素（包括叶节点分裂的情况下的分裂点）都被转移到新创建的兄弟节点中，剩余的元素保留在分裂节点中。
- en: If the parent node is full and does not have space available for the promoted
    key and pointer to the newly created node, it has to be split as well. This operation
    might propagate recursively all the way to the root.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父节点已满，并且没有空间可用于提升的关键字和指向新创建节点的指针，则必须对其进行分裂。此操作可能递归地传播到根节点。
- en: As soon as the tree reaches its capacity (i.e., split propagates all the way
    up to the root), we have to split the root node. When the root node is split,
    a new root, holding a split point key, is allocated. The old root (now holding
    only half the entries) is demoted to the next level along with its newly created
    sibling, increasing the tree height by one. The tree height changes when the root
    node is split and the new root is allocated, or when two nodes are merged to form
    a new root. On the leaf and internal node levels, the tree only grows *horizontally*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当树达到其容量上限（即，分裂一直传播到根节点），我们必须分裂根节点。当根节点被分裂时，将分配一个新的根，其中包含一个分裂点关键字。旧根（现在仅保存一半的条目）与其新创建的兄弟节点一起降级到下一层，从而使树的高度增加一层。当根节点分裂并分配新根时，或者当两个节点合并形成新的根时，树的高度发生变化。在叶节点和内部节点级别上，树仅在*水平方向*上增长。
- en: '[Figure 2-11](#b_tree_split_2) shows a fully occupied *leaf* node during insertion
    of the new element `11`. We draw the line in the middle of the full node, leave
    half the elements in the node, and move the rest of elements to the new one. A
    split point value is placed into the parent node to serve as a separator key.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-11](#b_tree_split_2)展示了在插入新元素`11`期间完全占用的*叶*节点的情况。我们在满节点中间画一条线，将一半元素留在节点中，将其余元素移动到新节点中。在父节点中放置一个分裂点值作为分隔符关键字。'
- en: '![dbin 0211](assets/dbin_0211.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0211](assets/dbin_0211.png)'
- en: Figure 2-11\. Leaf node split during the insertion of `11`. New element and
    promoted key are shown in gray.
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-11\. 在插入`11`期间叶节点的分裂。新元素和晋升的关键字显示为灰色。
- en: '[Figure 2-12](#b_tree_split_1) shows the split process of a fully occupied
    *nonleaf* (i.e., root or internal) node during insertion of the new element `11`.
    To perform a split, we first create a new node and move elements starting from
    index `N/2 + 1` to it. The split point key is promoted to the parent.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-12展示了在插入新元素`11`期间*非叶*（即根或内部）节点的分裂过程。为执行分裂，我们首先创建一个新节点，并从索引`N/2 + 1`开始移动元素到新节点中。将分裂点关键字提升到父节点。
- en: '![dbin 0212](assets/dbin_0212.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0212](assets/dbin_0212.png)'
- en: Figure 2-12\. Nonleaf node split during the insertion of `11`. New element and
    promoted key are shown in gray.
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-12\. 在插入`11`期间非叶节点的分裂。新元素和晋升的关键字显示为灰色。
- en: Since nonleaf node splits are always a manifestation of splits propagating from
    the levels below, we have an additional pointer (to the newly created node on
    the next level). If the parent does not have enough space, it has to be split
    as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非叶节点的分裂始终是从下面级别传播的体现，我们有一个额外的指针（指向下一级上新创建的节点）。如果父节点没有足够的空间，则必须对其进行分裂。
- en: It doesn’t matter whether the leaf or nonleaf node is split (i.e., whether the
    node holds keys and values or just the keys). In the case of leaf split, keys
    are moved together with their associated values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是叶子节点还是非叶子节点被分裂（即节点是否包含键和值或仅包含键）都无关紧要。在叶子节点分裂的情况下，键与其关联的值一起移动。
- en: When the split is done, we have two nodes and have to pick the correct one to
    finish insertion. For that, we can use the separator key invariants. If the inserted
    key is less than the promoted one, we finish the operation by inserting to the
    split node. Otherwise, we insert to the newly created one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当分裂完成时，我们有两个节点，必须选择正确的节点完成插入。为此，我们可以使用分隔键不变式。如果插入的键小于提升的键，则通过插入到分裂节点来完成操作。否则，我们插入到新创建的节点中。
- en: 'To summarize, node splits are done in four steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，节点分裂有四个步骤：
- en: Allocate a new node.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个新节点。
- en: Copy half the elements from the splitting node to the new one.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从分裂节点复制一半的元素到新节点。
- en: Place the new element into the corresponding node.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新元素放入相应的节点中。
- en: At the parent of the split node, add a separator key and a pointer to the new
    node.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分裂节点的父节点中，添加一个分隔键和一个指向新节点的指针。
- en: B-Tree Node Merges
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B-Tree 节点合并
- en: Deletions are done by first locating the target leaf. When the leaf is located,
    the key and the value associated with it are removed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 删除通过首先定位目标叶子节点来完成。定位到叶子节点后，将删除与之关联的键和值。
- en: 'If neighboring nodes have too few values (i.e., their occupancy falls under
    a threshold), the sibling nodes are merged. This situation is called *underflow*.
    [[BAYER72]](app01.html#BAYER72) describes two underflow scenarios: if two adjacent
    nodes have a common parent and their contents fit into a single node, their contents
    should be merged (concatenated); if their contents do not fit into a single node,
    keys are redistributed between them to restore balance (see [“Rebalancing”](ch04.html#btree_rebalancing)).
    More precisely, two nodes are merged if the following conditions hold:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相邻节点的值太少（即它们的占用量低于阈值），则合并兄弟节点。此情况称为*下溢*。[[BAYER72]](app01.html#BAYER72)描述了两种下溢场景：如果两个相邻节点有一个共同的父节点并且它们的内容适合单个节点，则它们的内容应合并（连接）；如果它们的内容不适合单个节点，则在它们之间重新分配键以恢复平衡（参见[“重新平衡”](ch04.html#btree_rebalancing)）。更准确地说，如果以下条件成立，则合并两个节点：
- en: 'For leaf nodes: if a node can hold up to `N` key-value pairs, and a combined
    number of key-value pairs in two neighboring nodes is less than or equal to `N`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于叶子节点：如果一个节点最多可以容纳`N`个键值对，并且两个相邻节点中的键值对总数少于或等于`N`。
- en: 'For nonleaf nodes: if a node can hold up to `N + 1` pointers, and a combined
    number of pointers in two neighboring nodes is less than or equal to `N + 1`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非叶子节点：如果一个节点最多可以容纳`N + 1`个指针，并且两个相邻节点中指针的总数少于或等于`N + 1`。
- en: '[Figure 2-13](#b_tree_merge_3) shows the merge during deletion of element `16`.
    To do this, we move elements from one of the siblings to the other one. Generally,
    elements from the *right* sibling are moved to the *left* one, but it can be done
    the other way around as long as the key order is preserved.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-13](#b_tree_merge_3)展示了在删除元素`16`时的合并过程。为此，我们将元素从一个兄弟节点移动到另一个兄弟节点。通常情况下，从*右*兄弟移动到*左*兄弟，但只要保持键的顺序，也可以反过来进行。'
- en: '![dbin 0213](assets/dbin_0213.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0213](assets/dbin_0213.png)'
- en: Figure 2-13\. Leaf node merge
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. 叶子节点合并
- en: '[Figure 2-14](#b_tree_merge_1) shows two sibling nonleaf nodes that have to
    be merged during deletion of element `10`. If we combine their elements, they
    fit into one node, so we can have one node instead of two. During the merge of
    nonleaf nodes, we have to pull the corresponding separator key from the parent
    (i.e., demote it). The number of pointers is reduced by one because the merge
    is a result of the propagation of the pointer deletion from the lower level, caused
    by the page removal. Just as with splits, merges can propagate all the way to
    the root level.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-14](#b_tree_merge_1)展示了在删除元素`10`时需要合并的两个兄弟非叶子节点。如果我们将它们的元素合并，它们可以适合一个节点，因此我们可以只保留一个节点而不是两个。在合并非叶子节点时，我们必须从父节点中提取相应的分隔键（即降级它）。由于合并是由于页面删除引起的指针删除的传播的结果，指针数量减少了一个。就像分裂一样，合并可以一直传播到根级别。'
- en: '![dbin 0214](assets/dbin_0214.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![dbin 0214](assets/dbin_0214.png)'
- en: Figure 2-14\. Nonleaf node merge
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-14\. 非叶子节点合并
- en: 'To summarize, node merges are done in three steps, assuming the element is
    already removed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，假设元素已被删除，节点合并有三个步骤：
- en: Copy all elements from the *right* node to the *left* one.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有元素从*右*节点复制到*左*节点。
- en: Remove the *right* node pointer from the parent (or *demote* it in the case
    of a nonleaf merge).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从父节点中移除*右*节点指针（或在非叶子合并的情况下*降级*它）。
- en: Remove the right node.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除右节点。
- en: One of the techniques often implemented in B-Trees to reduce the number of splits
    and merges is rebalancing, which we discuss in [“Rebalancing”](ch04.html#btree_rebalancing).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在B-树中常实现的一种技术是重新平衡，以减少分裂和合并的次数，我们在[“重新平衡”](ch04.html#btree_rebalancing)中讨论这一技术。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with a motivation to create specialized structures
    for on-disk storage. Binary search trees might have similar complexity characteristics,
    but still fall short of being suitable for disk because of low fanout and a large
    number of relocations and pointer updates caused by balancing. B-Trees solve both
    problems by increasing the number of items stored in each node (high fanout) and
    less frequent balancing operations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从创建专用于磁盘存储的结构的动机开始。二叉搜索树可能具有类似的复杂性特征，但由于扇出低和由平衡导致的大量重定位和指针更新，仍不适合用于磁盘。B-树通过增加每个节点存储的项目数量（高扇出）和较少的平衡操作来解决这两个问题。
- en: After that, we discussed internal B-Tree structure and outlines of algorithms
    for lookup, insert, and delete operations. Split and merge operations help to
    restructure the tree to keep it balanced while adding and removing elements. We
    keep the tree depth to a minimum and add items to the existing nodes while there’s
    still some free space in them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们讨论了内部B-树结构以及查找、插入和删除操作的算法概述。分裂和合并操作有助于重构树结构，以保持平衡，同时添加和删除元素。我们将树的深度保持在最小，并在现有节点中仍有空闲空间时添加项目。
- en: We can use this knowledge to create in-memory B-Trees. To create a disk-based
    implementation, we need to go into details of how to lay out B-Tree nodes on disk
    and compose on-disk layout using data-encoding formats.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些知识创建内存中的B-树。要创建基于磁盘的实现，我们需要详细了解如何在磁盘上布局B-树节点，并使用数据编码格式组成磁盘布局。
- en: ^([1](ch02.html#idm46466889485960-marker)) This property is imposed by AVL Trees
    and several other data structures. More generally, binary search trees keep the
    difference in heights between subtrees within a small constant factor.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm46466889485960-marker)) AVL树和其他几种数据结构都具有这种属性。更一般地说，二叉搜索树保持子树高度之间的差异在一个小常数因子内。
- en: ^([2](ch02.html#idm46466889296840-marker)) For example, [[KNUTH98]](app01.html#KNUTH98).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm46466889296840-marker)) 例如，[[KNUTH98]](app01.html#KNUTH98)。
