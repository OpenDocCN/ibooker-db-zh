- en: Chapter 1\. Query Response Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。查询响应时间
- en: Performance is query response time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能即查询响应时间。
- en: 'This book explores that idea from various angles with a single intent: to help
    you achieve remarkable MySQL performance. *Efficient* MySQL performance means
    *focusing* on the best practices and techniques that directly affect MySQL performance—no
    superfluous details or deep internals required by DBAs and experts. I presume
    that you’re a busy professional who is using MySQL, not managing it, and that
    you need the most results for the least effort. That’s not laziness, that’s efficiency.
    To that end, this book is direct and to the point. And by the end, you will be
    able to achieve remarkable MySQL performance.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书从不同角度探讨这一理念，但其单一意图是帮助你实现显著的MySQL性能。*高效*的MySQL性能意味着*专注*于直接影响MySQL性能的最佳实践和技术——无需DBA和专家深入的细节或内部。我假设你是一个忙碌的专业人士，正在使用MySQL而不是管理它，并且你需要最小的努力获得最大的结果。这不是懒惰，这是效率。因此，本书直截了当，重点突出。到最后，你将能够实现显著的MySQL性能。
- en: MySQL performance is a complex and multifaceted subject, but you do not need
    to become an expert to achieve remarkable performance. I narrow the scope of MySQL
    complexity by focusing on the essentials. MySQL performance begins with query
    response time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的性能是一个复杂而多方面的主题，但要实现显著的性能，你并不需要成为专家。我通过关注基础内容来缩小MySQL复杂性的范围。MySQL性能始于查询响应时间。
- en: '*Query response time* is how long it takes MySQL to execute a query. Synonymous
    terms are: *response time*, *query time*, *execution time*, and (inaccurately)
    *query latency*.^([1](ch01.html#idm45829115580240)) Timing starts when MySQL receives
    the query and ends when it has sent the result set to the client. Query response
    time comprises many stages (steps during query execution) and waits (lock waits,
    I/O waits, and so on), but a complete and detailed breakdown is neither possible
    nor necessary. As with many systems, basic troubleshooting and analysis reveal
    the majority of problems.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询响应时间*是MySQL执行查询所需的时间。同义词包括：*响应时间*、*查询时间*、*执行时间*以及（不准确的）*查询延迟*。^([1](ch01.html#idm45829115580240))
    计时从MySQL接收查询开始，直到发送结果集给客户端结束。查询响应时间包括多个阶段（查询执行过程中的步骤）和等待（锁等待、I/O等待等），但不需要也不可能进行完整和详细的分解。与许多系统一样，基本故障排除和分析揭示了大多数问题。'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Performance increases as query response time decreases. *Improving* query response
    time is synonymous with *reducing* query response time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 性能随查询响应时间的减少而提升。*改善*查询响应时间与*减少*查询响应时间是同义的。
- en: 'This chapter is the foundation. It expounds query response time so that, in
    subsequent chapters, you can learn how to improve it. There are seven major sections.
    The first is a true story to motivate and amuse. The second discusses why query
    response time is the North Star of MySQL performance. The third outlines how query
    metrics are transformed into meaningful reports: query reporting. The fourth addresses
    query analysis: using query metrics and other information to understand query
    execution. The fifth maps out the journey of improving query response time: query
    optimization. The sixth gives an honest and modest schedule for optimizing queries.
    The seventh discusses why MySQL cannot simply go faster—why query optimization
    is necessary.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是基础。它详述查询响应时间，以便在后续章节中，你能学习如何改善它。本章分为七个主要部分。第一部分是一个真实故事，以激励和娱乐。第二部分讨论为什么查询响应时间是MySQL性能的北极星。第三部分概述了如何将查询指标转化为有意义的报告：查询报告。第四部分讨论了查询分析：使用查询指标和其他信息来理解查询执行。第五部分规划了改善查询响应时间的旅程：查询优化。第六部分提供了一个诚实和谦逊的优化查询的时间表。第七部分讨论了为什么MySQL不能简单地变得更快——为什么需要查询优化。
- en: A True Story of False Performance
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个真实故事：虚假性能
- en: In 2004, I was working the night shift at a data center—2 p.m. to midnight.
    It was a great job for two reasons. First, the only employees in the data center
    after 5 p.m. were a handful of engineers monitoring and managing thousands of
    physical servers for an undisclosed number of customers and websites—probably
    tens of thousands of websites. It was an engineer’s dream. Second, there were
    countless MySQL servers that always had problems to fix. It was a gold mine of
    learning and opportunity. But at the time, there were few books, blogs, or tools
    about MySQL. (Though that same year, O’Reilly published the first edition of *High
    Performance MySQL*.) Consequently, the state of the art for “fixing” MySQL performance
    problems was “sell the customer more RAM.” For sales and management it always
    worked, but for MySQL the results were inconsistent.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2004年，我在一个数据中心的夜班工作——下午2点到午夜。这是一个极好的工作，原因有两个。首先，晚上5点后，数据中心里只有少数几位工程师在监控和管理成千上万台物理服务器，为数不明的客户和网站服务——可能是数以万计的网站。对工程师来说，这是一个梦想。其次，总是有无数的MySQL服务器需要解决问题。这是一个学习和机会的金矿。但那时，关于MySQL几乎没有书籍、博客或工具。（尽管同一年，O'Reilly出版了*High
    Performance MySQL*的第一版。）因此，“解决”MySQL性能问题的技术“向客户推销更多内存”成了当时的行业标准。对于销售和管理来说，这总是奏效的，但对于MySQL来说，结果却不一致。
- en: One night I decided not to sell the customer more RAM and, instead, to do a
    technical deep dive to find and fix the true root cause of their MySQL performance
    problem. Their database was powering a bulletin board which had slowed to a crawl
    under the weight of its success—still a common problem today, almost 20 years
    later. To make a long story short, I found a single query missing a critical index.
    After properly indexing the query, performance improved dramatically and the website
    was saved. It cost the customer zero dollars.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个晚上，我决定不再向客户推销更多的内存，而是进行技术深入挖掘，找出并修复他们MySQL性能问题的真正根本原因。他们的数据库用于支持一个公告板，由于其成功而陷入了瘫痪——这在今天仍然是一个常见问题，几乎20年后。长话短说，我发现了一个关键索引丢失的查询。在为查询正确创建索引之后，性能显著提高，网站得以挽救。对客户而言，这一切都是零成本。
- en: Not all performance problems and solutions are that straightforward and glamorous.
    But just shy of 20 years’ experience with MySQL has taught me (and many others)
    that MySQL performance problems are very often solved by the best practices and
    techniques in this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的性能问题及解决方案都如此直接和迷人。然而，几乎二十年来与MySQL的经验教会了我（以及许多其他人），MySQL性能问题往往可以通过本书中的最佳实践和技术得以解决。
- en: North Star
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 北极星
- en: 'I’m a MySQL DBA *and* a software engineer, so I know what it’s like working
    with MySQL as the latter. Especially when it comes to performance, we (software
    engineers) just want it (MySQL) to work. Between shipping features and putting
    out fires, who has time for MySQL performance? And when MySQL performance is poor—or
    worse: when it suddenly becomes poor—the way forward can be difficult to see because
    there are many considerations: where do we begin? Do we need more RAM? Faster
    CPUs? More storage IOPS? Is the problem a recent code change? (Fact: code changes
    deployed in the past can cause performance problems in the future, sometimes days
    in the future.) Is the problem a noisy neighbor? Are the DBAs doing something
    to the database? Has the app has gone viral and it’s the good kind of problem
    to have?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个MySQL DBA，同时也是一名软件工程师，所以我知道作为后者使用MySQL的感受。尤其是在性能方面，我们（软件工程师）只希望（MySQL）能正常工作。在推送功能和解决问题之间，谁有时间处理MySQL的性能问题呢？当MySQL性能不佳时——或者更糟糕的是：当它突然变得不佳时——前进的道路可能会变得难以捉摸，因为有太多的考虑因素：我们从哪里开始？我们需要更多内存吗？更快的CPU？更多的存储IOPS？问题是最近的代码更改吗？（事实上：过去部署的代码更改有时会导致未来几天甚至几天后出现性能问题。）问题是因为“吵闹的邻居”吗？DBA们在数据库上做了什么？应用程序已经热门了吗？这是一种好问题吗？
- en: 'As an engineer whose expertise is the application, not MySQL, that situation
    can be overwhelming. To move forward confidently, start by looking at query response
    time because it is *meaningful* and *actionable*. These are powerful qualities
    that lead to real solutions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个专业应用程序而非MySQL的工程师，这种情况可能会让人感到不知所措。要自信地前进，首先看一下查询响应时间是很有意义和可以采取行动的。这些是导致真正解决方案的强大特性：
- en: Meaningful
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有意义的
- en: Query response time is the only metric anyone truly cares about because, let’s
    be honest, when the database is fast, nobody looks at it or asks questions. Why?
    Because query response time is the only metric we *experience*. When a query takes
    7.5 seconds to execute, we experience 7.5 seconds of impatience. That same query
    might examine a million rows, but we don’t experience a million rows examined.
    Our time is precious.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查询响应时间是任何人真正关心的唯一指标，因为说实话，当数据库运行快速时，没有人会查看它或提问。为什么？因为查询响应时间是我们*体验*到的唯一指标。当一个查询需要7.5秒才能执行时，我们经历了7.5秒的不耐烦。同样的查询可能检查了一百万行，但我们并没有体验一百万行的检查。我们的时间是宝贵的。
- en: Actionable
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可操作的
- en: There’s so much you can do to improve query response time and make everyone
    happy again that you’re holding a book about it. (Do people still hold books in
    the future? I hope so.) Query response time is directly actionable because you
    own the code, so you can change the queries. Even if you don’t own the code (or
    have access to it), you can still indirectly optimize query response time. [“Improving
    Query Response Time”](#query-optimization) addresses direct and indirect query
    optimization.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做很多事情来提高查询响应时间，使所有人都再次感到满意，你正在看一本关于它的书。（未来人们还会拿着书吗？我希望如此。）查询响应时间是可以直接操作的，因为你拥有代码，所以可以更改查询。即使你不拥有代码（或者没有访问权限），你仍然可以间接优化查询响应时间。[“优化查询响应时间”](#query-optimization)讨论了直接和间接的查询优化。
- en: Focus on improving query response time—the North Star of MySQL performance.
    Do not begin by throwing hardware at the problem. Begin by using query metrics
    to determine what MySQL is doing, then analyze and optimize slow queries to reduce
    response time, and repeat. Performance *will* improve.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于提高查询响应时间——MySQL性能的北极星。不要从硬件问题开始。首先使用查询指标确定MySQL正在做什么，然后分析和优化慢查询以减少响应时间，然后重复。性能*会*提升。
- en: Query Reporting
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询报告
- en: 'Query metrics provide invaluable insights into query execution: response time,
    lock time, rows examined, and so on. But query metrics, like all metrics, are
    raw values that need to be collected, aggregated, and reported in a way that’s
    meaningful to (and readable for) engineers. That’s what this section outlines:
    how query metric tools transform query metrics into query reports. But query reporting
    is only a means to an end, as discussed in [“Query Analysis”](#query-analysis).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指标为查询执行提供宝贵的见解：响应时间、锁定时间、检查的行数等等。但是，查询指标和其他指标一样，都是原始值，需要以对工程师有意义和可读的方式进行收集、聚合和报告。这就是本节的内容概述：查询指标工具如何将查询指标转化为查询报告。但是，查询报告只是达到目的的手段，如[“查询分析”](#query-analysis)中所讨论的。
- en: 'Looking ahead, query analysis is the real work: analyzing query metrics (as
    reported) and other information with the goal of understanding query execution.
    To improve MySQL performance, you must optimize queries. To optimize queries,
    you must understand how they execute. And to understand that, you must analyze
    them with pertinent information, including query reports and metadata.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，查询分析才是真正的工作：分析查询指标（如报告所述）和其他信息，目标是理解查询执行。要提高MySQL性能，必须优化查询。要优化查询，必须了解它们的执行方式。为了理解这一点，必须使用相关信息进行分析，包括查询报告和元数据。
- en: 'But first you need to understand query reporting, since it represents the trove
    of query metrics that provide invaluable insights into query execution. The next
    three sections teach you about the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你需要理解查询报告，因为它代表着提供对查询执行宝贵见解的查询指标宝库。接下来的三节将教你以下内容：
- en: 'Sources: query metrics originate from two sources and vary by MySQL distribution
    and version'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：查询指标来自两个来源，并且根据MySQL的分发和版本而有所不同。
- en: 'Aggregation: query metric values are grouped and aggregated by normalized SQL
    statements'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合：通过标准化的SQL语句对查询指标值进行分组和聚合。
- en: 'Reporting: query reports are organized by a high-level profile and a query-specific
    report'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告：查询报告按高级概要和特定查询报告进行组织。
- en: Then you’re ready for [“Query Analysis”](#query-analysis).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你已经准备好进行[“查询分析”](#query-analysis)了。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is not a book about database administration, so this section does not
    discuss the setup and configuration of query metrics in MySQL. I presume this
    is already done or will be done. If not, don’t worry: ask your DBA, hire a consultant,
    or learn how by reading the MySQL manual.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于数据库管理的书籍，因此本节不讨论在MySQL中设置和配置查询指标。我假设这已经完成或将完成。如果没有，不用担心：询问你的数据库管理员，聘请顾问，或者通过阅读MySQL手册来学习。
- en: Sources
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来源
- en: 'Query metrics originate from the [slow query log](https://oreil.ly/Glss3) or
    the [Performance Schema](https://oreil.ly/FNXRq). As the names indicate, the former
    is a log file on disk, and the latter is a database with the same name: `performance_schema`.
    Although completely different in nature (log file on disk as opposed to tables
    in a database), both provide query metrics. The important difference is how many
    metrics they provide: apart from query response time, which both provide, the
    number of metrics ranges from 3 to more than 20.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指标来源于[慢查询日志](https://oreil.ly/Glss3)或[性能模式](https://oreil.ly/FNXRq)。正如名称所示，前者是一个磁盘上的日志文件，而后者是一个同名的数据库：`performance_schema`。尽管在性质上完全不同（磁盘上的日志文件与数据库中的表），它们都提供查询指标。重要的区别在于它们提供的指标数量：除了两者都提供的查询响应时间外，指标数量从3个到20多个不等。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The name *slow query log* is historical. Long ago, MySQL logged only queries
    that took greater than N *seconds* to execute, and the minimum value for N was
    1\. Old versions of MySQL would not log a query that took 900 milliseconds to
    execute because that was “fast.” The slow query log really earned its name. Today,
    the minimum value is zero with a resolution of microseconds. When set to zero,
    MySQL logs every query executed. Therefore, the name is a little misleading, but
    now you know why.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 名称*慢查询日志*有其历史背景。很久以前，MySQL只记录执行时间超过N秒的查询，其中N的最小值为1。旧版本的MySQL不会记录执行时间为900毫秒的查询，因为那时候这被认为是“快速”的。慢查询日志确实因其名而闻名。如今，最小值为零，精确到微秒。当设置为零时，MySQL记录每个执行的查询。因此，名称有点误导，但现在你知道原因了。
- en: 'All things considered, the Performance Schema is the best source of query metrics
    because it exists in every current version and distribution of MySQL, it works
    locally and in the cloud, it provides all nine metrics covered in [“Query Metrics”](#query-metrics),
    and it’s the most consistent. Plus, the Performance Schema contains a wealth of
    other data for deep MySQL analysis, so its usefulness extends far beyond query
    metrics. The slow query log is a good source, too, but it varies considerably:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 综上所述，性能模式是查询指标的最佳数据源，因为它存在于当前MySQL的每个版本和发行版中，在本地和云中都可以使用，提供了“查询指标”中的全部九个指标，并且是最一致的。此外，性能模式还包含丰富的其他数据，可用于深入分析MySQL，因此其实用性远远超出了查询指标。慢查询日志也是一个不错的数据源，但其变化很大：
- en: MySQL
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL
- en: As of MySQL 8.0.14, enable system variable [`log_slow_extra`](https://oreil.ly/ibfRK)
    and the slow query log provides six of the nine metrics in [“Query Metrics”](#query-metrics),
    lacking only `Rows_affected`, `Select_scan`, and `Select_full_join`. It’s still
    a good source, but use the Performance Schema if possible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 截至MySQL 8.0.14，启用系统变量[`log_slow_extra`](https://oreil.ly/ibfRK)，慢查询日志提供了“查询指标”中九个指标中的六个，仅缺少`Rows_affected`、`Select_scan`和`Select_full_join`。虽然仍然是一个良好的数据源，但尽可能使用性能模式。
- en: Before MySQL 8.0.14, which includes MySQL 5.7, the slow query log is bare bones,
    providing only `Query_time`, `Lock_time`, `Rows_sent`, and `Rows_examined`. You
    can still analyze queries with only these four metrics, but the analysis is much
    less insightful. Consequently, avoid the slow query log before MySQL 8.0.14 and
    instead use the Performance Schema.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0.14之前，包括MySQL 5.7在内，慢查询日志非常简陋，仅提供`Query_time`、`Lock_time`、`Rows_sent`和`Rows_examined`。你仍然可以分析这些四个指标的查询，但分析的深度大大降低。因此，在MySQL
    8.0.14之前，尽量避免使用慢查询日志，而是使用性能模式。
- en: Percona Server
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Percona Server
- en: '[Percona Server](https://oreil.ly/ILyh2) provides a significantly greater number
    of metrics in the slow query log when system variable `log_slow_verbosity` is
    configured: all nine metrics covered in [“Query Metrics”](#query-metrics) and
    more. It also supports query sampling (logging a percentage of queries) when system
    variable `log_slow_rate_limit` is configured, which is helpful for busy servers.
    These features make the Percona Server slow query log a great source. See [“Slow
    Query Log”](https://oreil.ly/5JQ06) in the Percona Server manual for details.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[Percona Server](https://oreil.ly/ILyh2)在配置系统变量`log_slow_verbosity`时，在慢查询日志中提供了大量的指标：覆盖了“查询指标”中的全部九个指标及更多。此外，当配置系统变量`log_slow_rate_limit`时，它还支持查询抽样（记录一定百分比的查询），对于繁忙的服务器非常有帮助。这些特性使得Percona
    Server慢查询日志成为一个很好的数据源。详细信息请参阅Percona Server手册中的“慢查询日志”。'
- en: MariaDB Server
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB Server
- en: '[MariaDB Server](https://oreil.ly/oeGJO) 10.x uses the Percona Server slow
    query log enhancements, but there are two notable differences: system variable
    `log_slow_verbosity` is configured differently in MariaDB, and it does not provide
    metric `Rows_affected`. Otherwise, it’s essentially the same and a great source,
    too. See [“Slow Query Log Extended Statistics”](https://oreil.ly/oOVe7) in the
    MariaDB knowledge base for details.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[MariaDB服务器](https://oreil.ly/oeGJO) 10.x 使用了Percona Server的慢查询日志增强功能，但有两个显著的区别：系统变量`log_slow_verbosity`在MariaDB中配置不同，并且不提供指标`Rows_affected`。除此之外，它基本上是相同的，并且也是一个很好的信息来源。详细信息请参阅MariaDB知识库中的[“慢查询日志扩展统计”](https://oreil.ly/oOVe7)。'
- en: The slow query log is disabled by default, but you can enable it dynamically
    (without restarting MySQL). The Performance Schema should be enabled by default,
    though some cloud providers disable it by default. Unlike the slow query log,
    the Performance Schema cannot be enabled dynamically—you must restart MySQL to
    enable it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，慢查询日志处于禁用状态，但可以动态启用它（无需重新启动MySQL）。性能模式应默认启用，尽管某些云提供商默认禁用它。与慢查询日志不同，性能模式无法动态启用
    - 您必须重新启动MySQL才能启用它。
- en: Make sure the best query metric source is used and properly configured. Ask
    your DBA, hire a consultant, or learn how by reading the MySQL manual.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用和正确配置最佳的查询指标来源。向您的数据库管理员询问，聘请顾问，或通过阅读MySQL手册来学习。
- en: Warning
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The slow query log can log *all* queries when [`long_query_time`](https://oreil.ly/NUmuA)
    is set to zero, but be careful: on a busy server, this can increase disk I/O and
    use a significant amount of disk space.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`long_query_time`](https://oreil.ly/NUmuA)设置为零时，慢查询日志可以记录*所有*查询，但请注意：在繁忙的服务器上，这可能会增加磁盘I/O并使用大量磁盘空间。
- en: Aggregation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: Query metrics are grouped and aggregated by query. That sounds obvious since
    they’re called *query* metrics, but some query metric tools can group by username,
    hostname, database, and so on. These alternate groupings are exceptionally rare
    and yield a different type of query analysis, so I don’t address them in this
    book. Since query response time is the North Star of MySQL performance, grouping
    query metrics by query is the best way to see which queries have the slowest response
    time, which forms the basis of query reporting and analysis.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指标按查询分组和聚合。这听起来显而易见，因为它们称为*查询*指标，但一些查询指标工具可以按用户名、主机名、数据库等分组。这些备选分组异常罕见，并产生不同类型的查询分析，因此我在本书中不予讨论。由于查询响应时间是MySQL性能的指南星，按查询分组查询指标是查看哪些查询具有最慢响应时间的最佳方式，这构成了查询报告和分析的基础。
- en: 'There’s one little problem: how do you uniquely identify queries to determine
    the groups to which they belong? For example, system metrics (CPU, memory, storage,
    and so on) are grouped by hostname because hostnames are unique and meaningful.
    But queries don’t have any uniquely identifying properties like hostname. The
    solution: a SHA-256 hash of the normalized SQL statement. [Example 1-1](#query-group-ids)
    shows how a SQL statement is normalized.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小问题：如何唯一标识查询以确定它们所属的组？例如，系统指标（CPU、内存、存储等）按主机名分组，因为主机名是唯一且有意义的。但查询没有像主机名那样具有唯一标识属性。解决方案是：对规范化的SQL语句进行SHA-256哈希处理。[示例 1-1](#query-group-ids)展示了如何规范化SQL语句。
- en: Example 1-1\. SQL statement normalization
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-1\. SQL语句规范化
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_query_response_time_CO1-1)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_query_response_time_CO1-1)'
- en: SQL statement (sample)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句（示例）
- en: '[![2](assets/2.png)](#co_query_response_time_CO1-2)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_query_response_time_CO1-2)'
- en: Digest text (normalized SQL statement)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要文本（规范化的SQL语句）
- en: '[![3](assets/3.png)](#co_query_response_time_CO1-3)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_query_response_time_CO1-3)'
- en: Digest hash (SHA-256 of digest text)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要哈希（摘要文本的SHA-256哈希值）
- en: MySQL normalizes SQL statements to digest texts, then computes the SHA-256 hash
    of the digest text to yield the digest hash. (It’s not necessary to understand
    the full process of normalization; it’s sufficient to know that normalization
    replaces all values with `?` and collapses multiple whitespaces to a single space.)
    Since the digest text is unique, the digest hash is also unique (hash collisions
    notwithstanding).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL将SQL语句规范化为摘要文本，然后计算摘要文本的SHA-256哈希以生成摘要哈希值。（了解规范化的完整过程并不是必要的；知道规范化将所有值替换为`?`并将多个空格折叠为单个空格即可）。由于摘要文本是唯一的，摘要哈希值也是唯一的（哈希冲突除外）。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The MySQL manual uses the term *digest* equivocally to mean either *digest text*
    or *digest hash*. Since the digest hash is computed from the digest text, the
    equivocation is only a language ambiguity, not a technical error. Please allow
    me to equivocate, too, and use *digest* to mean either *digest text* or *digest
    hash* when the technical difference doesn’t matter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 手册在使用术语 *digest* 时含糊地指代 *digest text* 或 *digest hash*。由于 digest hash 是从
    digest text 计算而来的，这种含糊只是语言上的歧义，而非技术错误。请允许我也模棱两可地使用 *digest* 来指代 *digest text*
    或 *digest hash*，在技术上没有区别时。
- en: 'There is an important shift in terminology in the context of query metrics:
    the term *query* changes to be synonymous with *digest text*. The shift in terminology
    aligns with the shift in focus: grouping metrics by query. To group by query,
    *query* must be unique, which is only true of digests.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询指标的语境中，术语发生了重要的术语转变：术语 *query* 变为 *digest text* 的同义词。这种术语转变与关注重点的转变一致：按查询分组的指标。要按查询分组，*query*
    必须是唯一的，这只对 digest 成立。
- en: 'SQL statements are also called *query samples* (or *samples* for short), and
    they may or may not be reported. For security, most query metric tools discard
    samples by default (because they contain real values) and report only digest texts
    and hashes. Samples are required for query analysis because you can [`EXPLAIN`](https://oreil.ly/YSnio)
    them, which produces metadata necessary for understanding query execution. Some
    query metric tools `EXPLAIN` a sample, then discard it, and report the EXPLAIN
    plan (the output of `EXPLAIN`). Others only report the sample, which is still
    very convenient: copy-paste to `EXPLAIN`. If you have neither, then manually extract
    samples from the source or manually write them when needed.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 语句也称为 *查询样本*（或简称为 *样本*），它们可能会被报告，也可能不会。出于安全考虑，大多数查询指标工具默认丢弃样本（因为它们包含真实值），并仅报告
    digest texts 和 hashes。样本对于查询分析至关重要，因为您可以 [`EXPLAIN`](https://oreil.ly/YSnio) 它们，这会生成理解查询执行所必需的元数据。一些查询指标工具会对样本进行
    `EXPLAIN`，然后丢弃它，并报告 EXPLAIN 计划（`EXPLAIN` 的输出）。其他工具仅报告样本，这仍然非常方便：复制粘贴到 `EXPLAIN`。如果两者都没有，那么就需要从源代码手动提取样本，或者在需要时手动编写样本。
- en: Two more clarifications about terminology and then I promise we’ll move on to
    more exciting material. First, terminology varies widely depending on the query
    metric tool, as shown in [Table 1-1](#qm-terms).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于术语的另外两点澄清，然后我保证我们会继续更加有趣的内容。首先，根据查询指标工具的不同，术语会有广泛的变化，如 [表 1-1](#qm-terms)
    所示。
- en: Table 1-1\. Query metric terminology
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1\. 查询指标术语
- en: '| Official (MySQL) | Alternatives |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 官方（MySQL） | 备选项 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| SQL statement | Query |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| SQL 语句 | 查询 |'
- en: '| Sample | Query |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 查询 |'
- en: '| Digest text | Class, family, fingerprint, query |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Digest text | 类别、家族、指纹、查询 |'
- en: '| Digest hash | Class ID, query ID, signature |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 摘要散列 | 类别 ID、查询 ID、签名 |'
- en: 'Second, another term that originated from [Percona](https://www.percona.com)
    is *query abstract*: a SQL statement highly abstracted to its SQL command and
    table list. [Example 1-2](#query-abstract) is the query abstract for `SELECT col
    FROM tbl WHERE id=1`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，另一个源自 [Percona](https://www.percona.com) 的术语是 *查询摘要*：一个高度抽象化的 SQL 语句，简化为其
    SQL 命令和表列表。[示例 1-2](#query-abstract) 是 `SELECT col FROM tbl WHERE id=1` 的查询摘要。
- en: Example 1-2\. Query abstract
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-2\. 查询摘要
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Query abstracts are not unique, but they are useful because they’re succinct.
    Usually, developers only need to see a query abstract to know the full query that
    it represents.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查询摘要并非唯一，但它们很有用，因为它们简洁。通常，开发人员只需看一下查询摘要就能知道它所代表的完整查询。
- en: Brevity is the soul of wit.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简洁是智慧的灵魂。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: William Shakespeare
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 威廉·莎士比亚
- en: 'It’s important to understand that SQL statements are normalized because the
    queries you write are not the queries you see. Most of the time, this is not a
    problem because digest texts closely resemble SQL statements. But the process
    of normalization raises another important point: do not dynamically generate the
    same logical query with different syntax, else it will normalize to different
    digests and be reported as different queries. For example, in the case of a programmatically-generated
    query that changes the `WHERE` clause based on user input:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 SQL 语句的标准化，因为你写的查询和你看到的查询不一样。大多数情况下，这不是问题，因为 digest text 很接近 SQL 语句。但标准化的过程提出了另一个重要的观点：不要基于用户输入动态生成相同逻辑的查询，否则会标准化为不同的
    digest，并报告为不同的查询。例如，在根据用户输入改变 `WHERE` 子句的程序生成查询的情况下：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Those two queries may be logically the same to you and the application, but
    they’re different queries with respect to reporting because they normalize to
    different digests. To my knowledge, no query metric tool allows you to combine
    queries. And it’s technically correct to report those queries separately because
    every condition—especially in the `WHERE` clause—affects query execution and optimization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对你和应用程序而言，这两个查询可能在逻辑上是相同的，但在报告上它们是不同的查询，因为它们归一化到不同的摘要。据我所知，没有任何查询度量工具允许你合并查询。并且单独报告这些查询是技术上正确的，因为每个条件——尤其是在`WHERE`子句中——都会影响查询执行和优化。
- en: 'One point about query normalization: values are removed, so the following two
    queries normalize to the same digest:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于查询规范化的一点：值被移除，因此以下两个查询规范化为相同的摘要：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the digest is the same for both queries, the metrics for both queries
    are grouped, aggregated, and reported as one query.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于摘要对两个查询相同，因此两个查询的度量值被分组、汇总并报告为一个查询。
- en: Enough about terminology and normalization. Let’s talk about reporting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 足够了解术语和规范化了。我们来谈谈报告。
- en: Reporting
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 报告
- en: 'Reporting is a challenge and an art form because a single application can have
    hundreds of queries. Each query has many metrics and each metric has several statistics:
    minimum, maximum, average, percentile, and so forth. On top of that, each query
    has metadata: samples, EXPLAIN plans, table structures, on so on. It’s challenging
    to store, process, and present all this data. Almost every query metric tool presents
    the data in a two-level hierarchy: *query profile* and *query report*. Those terms
    vary by query metric tool, but you will easily recognize each when you see them.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 报告是一个挑战，也是一种艺术形式，因为单个应用程序可以有数百个查询。每个查询有许多指标，每个指标有几个统计数据：最小值、最大值、平均值、百分位数等等。此外，每个查询还有元数据：样本、解释计划、表结构等等。存储、处理和呈现所有这些数据是一项挑战。几乎每个查询度量工具都以两级层次结构呈现数据：*查询概要*和*查询报告*。这些术语因查询度量工具而异，但当你看到它们时，你会轻松辨认出每一个。
- en: Query profile
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询概要
- en: A *query profile* shows slow queries. It is the top-level organization for query
    reporting, usually the first thing you see in a query metric tool. It presents
    query digests and a limited subset of query metrics, which is why it’s called
    a profile.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询概要*显示慢查询。这是查询报告的顶层组织，通常是查询度量工具中看到的第一件事情。它展示查询摘要和一组有限的查询度量指标，因此被称为概要。'
- en: '*Slow* is relative to the *sort metric*: the aggregate value of a query metric
    by which queries are ordered. The first ordered query is called *the slowest*,
    even if the sort metric is not query time (or any time). For example, if the sort
    metric is average rows sent, the first ordered query is still called the slowest.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*慢*是相对于*排序指标*的：通过排序指标对查询指标进行聚合值排序。第一个有序查询即使排序指标不是查询时间（或任何时间），仍然称为*最慢*。例如，如果排序指标是平均发送的行数，则第一个有序查询仍然被称为最慢查询。'
- en: 'Although any query metric can be the sort metric, query time is the universal
    default sort metric. When you reduce query execution time, you free up time that
    allows MySQL to do more work, or possibly do other work more quickly. Sorting
    queries by query time shows you where to begin: the slowest, most time-consuming
    queries.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任何查询指标都可以是排序指标，查询时间是普遍的默认排序指标。当你减少查询执行时间时，你可以释放出时间，使得 MySQL 可以完成更多工作，或者可能更快地完成其他工作。按查询时间对查询进行排序可以告诉你从哪里开始：最慢、耗时最长的查询。
- en: 'What’s not universal is how query time is aggregated. The most common aggregate
    values are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查询时间如何汇总并非普遍适用。最常见的汇总值包括：
- en: Total query time
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 查询总时间
- en: '*Total query time* is the sum of execution time (per query). This is the most
    common aggregate value because it answers an important question: *which query
    does MySQL spend the most time executing?* To answer that, a query metric tool
    adds up all the time MySQL spends executing each query. The query with the greatest
    total time is the slowest, most time-consuming query. Here’s an example of why
    this is important. Suppose query *A* has a 1-second response time and executes
    10 times, while query *B* has a 0.1-second response time and executes 1,000 times.
    Query *A* has a much slower response time, but query *B* is 10 times more time-consuming:
    10 seconds in total versus 100 seconds in total, respectively. In a query profile
    sorted by total query time, query *B* is the slowest query. This is important
    because you free up the most time for MySQL by optimizing query *B*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*总查询时间*是执行时间（每个查询）的总和。这是最常见的聚合值，因为它回答了一个重要问题：*MySQL在执行哪个查询时花费了最多的时间？*为了回答这个问题，一个查询度量工具会累加MySQL执行每个查询所花费的时间。总时间最长的查询是最慢、耗时最长的查询。这里有一个重要的例子。假设查询*A*的响应时间为1秒，执行了10次，而查询*B*的响应时间为0.1秒，执行了1,000次。查询*A*的响应时间较慢，但查询*B*耗时更长：分别为10秒总时间与100秒总时间。在按总查询时间排序的查询分析中，查询*B*是最慢的查询。这很重要，因为通过优化查询*B*，你可以为MySQL释放出最多的时间。'
- en: Percentage execution time
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比执行时间
- en: '*Percentage execution time* is total query time (per query) divided by grand
    total execution time (all queries). For example, if query *C* has a total query
    time of 321 ms and query *D* has a total query time of 100 ms, then grand total
    execution time is 421 ms. Individually, query *C* is (321 ms / 421 ms) × 100 =
    76.2% of grand total execution time, and query *D* is (100 ms / 421 ms) × 100
    = 23.8% of grand total execution time. In other words, MySQL spent 421 ms executing
    queries, 76.2% of which was spent executing query *C*. In a query profile sorted
    by percentage execution time, query *C* is the slowest query. Percentage execution
    time is used by some query metric tools, but not all.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*百分比执行时间*是总查询时间（每个查询）除以总执行时间（所有查询）。例如，如果查询*C*的总查询时间为321毫秒，查询*D*的总查询时间为100毫秒，则总执行时间为421毫秒。单独计算，查询*C*占总执行时间的比例为（321毫秒
    / 421毫秒）× 100 = 76.2%，而查询*D*占总执行时间的比例为（100毫秒 / 421毫秒）× 100 = 23.8%。换句话说，MySQL花费了421毫秒来执行查询，其中76.2%用于执行查询*C*。在按百分比执行时间排序的查询分析中，查询*C*是最慢的查询。百分比执行时间被一些查询度量工具使用，但并非所有都使用。'
- en: Query load
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 查询负载
- en: '*Query load* is total query time (per query) divided by clock time, where *clock
    time* is the number of seconds in the time range. If the time range is 5 minutes,
    then clock time is 300 seconds. For example, if query *E* has a total query time
    250.2 seconds, then its load is 250.2 s / 300 s = 0.83; and if query *F* has a
    total query time of 500.1 seconds, then its load is 500.1 s / 300 s = 1.67\. In
    a query profile sorted by query load, query *F* is the slowest query because its
    load is the greatest.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询负载*是总查询时间（每个查询）除以时钟时间，其中*时钟时间*是时间范围内的秒数。如果时间范围是5分钟，则时钟时间为300秒。例如，如果查询*E*的总查询时间为250.2秒，则它的负载为250.2秒
    / 300秒 = 0.83；如果查询*F*的总查询时间为500.1秒，则它的负载为500.1秒 / 300秒 = 1.67。在按查询负载排序的查询分析中，查询*F*是最慢的查询，因为它的负载最大。'
- en: 'Load is relative to time but also subtly indicative of *concurrency*: multiple
    instances of a query executing at the same time. Query load less than 1.0 means
    that, on average, the query does not execute concurrently. Query load greater
    than 1.0 indicates query concurrency. For example, a query load of 3.5 means that,
    any time you look, you’re likely to see 3.5 instances of the query executing.
    (In reality, 3 or 4 instances of the query since there cannot be 0.5 instances
    of a query.) The higher the query load, the greater the possibility of contention
    if the query accesses the same or nearby rows. Query load greater than 10 is high
    and likely to be a slow query, but there are exceptions. As I write this, I’m
    looking at a query with a load of 5,962. How is that possible? I reveal the answer
    in [“Data Access”](ch03.html#data-access).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 负载相对于时间，但也微妙地显示了*并发性*：同时执行的多个查询实例。负载小于1.0意味着平均而言查询不会并发执行。负载大于1.0表示查询并发性。例如，负载为3.5意味着无论何时查看，可能会看到3.5个查询实例（实际上是3或4个查询实例，因为不能有0.5个查询实例）。负载越高，如果查询访问相同或附近的行，则发生争用的可能性越大。负载大于10是高负载，可能是一个慢查询，但也有例外。正如我写这篇文章时，我正在查看一个负载为5,962的查询。这是怎么可能的？我在《数据访问》中揭示了答案。
- en: When the sort metric uses a nontemporal query metric, like rows sent, a different
    aggregate value (average, maximum, and so on) might make sense depending on what
    you’re trying to diagnose. This is far less common than total query time, but
    it occasionally reveals interesting queries worth optimizing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当排序度量使用非时间查询度量，例如发送的行数时，根据你要诊断的内容可能会有不同的聚合值（平均值、最大值等等）。这比总查询时间要少见得多，但偶尔会发现一些值得优化的有趣查询。
- en: Query report
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询报告
- en: A *query report* shows you everything there is to know about one query. It is
    the second-level organization for query reporting, usually accessed by selecting
    a slow query in the query profile. It presents all query metrics and metadata.
    Whereas the query profile tells you something just by looking at it (which queries
    are the slowest), a query report is an organized information dump used for query
    analysis. As such, the more information, the better because it helps you understand
    query execution.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询报告*向你展示了关于一个查询的所有信息。它是查询报告的第二级组织，通常通过选择查询慢的查询来访问查询概要。它呈现所有的查询度量标准和元数据。而查询概要仅凭一瞥即可告诉你一些信息（哪些查询最慢），查询报告则是用于查询分析的组织信息转储。因此，信息越多越好，因为它帮助你理解查询执行。'
- en: 'Query reports vary dramatically depending on the query metric tool. A bare
    minimum report includes all query metrics from the source and the basic statistics
    for those metrics: minimum, maximum, average, percentile, and so forth. A thorough
    report includes metadata: query samples, EXPLAIN plans, table structures, and
    more. (Samples may be disabled for security purposes because they contain real
    values.) A few query metric tools go further by adding additional information:
    metric graphs, histograms (distributions), anomaly detection, time shift comparison
    (now versus last week), developer notes, SQL comment key-value extraction, and
    so on.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 查询报告根据查询度量工具的不同而有很大差异。最基本的报告包括来自源的所有查询度量标准和这些度量标准的基本统计数据：最小值、最大值、平均值、百分位数等等。彻底的报告包括元数据：查询样本、EXPLAIN计划、表结构等等。由于包含实际值，有些样本出于安全考虑可能已禁用。少数查询度量工具通过添加额外信息进一步扩展：度量图、直方图（分布）、异常检测、时间偏移比较（现在与上周）、开发者注释、SQL注释键值提取等等。
- en: 'Query analysis only requires query metrics in the report. Metadata can be collected
    manually. If the query metric tool you use reports only query metrics, don’t worry:
    that’s a start, but you will need to manually collect EXPLAIN plans and table
    structures, at the very least.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 查询分析仅需要报告中的查询度量标准。元数据可以手动收集。如果你使用的查询度量工具仅报告查询度量标准，不要担心：这是一个开始，但你至少需要手动收集EXPLAIN计划和表结构。
- en: With a query report figuratively in hand, you’re equipped for query analysis.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着一个象征性的查询报告，你已经准备好进行查询分析了。
- en: Query Analysis
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询分析
- en: 'The goal of query analysis is understanding query execution, not solving slow
    response time. That might surprise you, but solving slow response time happens
    *after* query analysis, during query optimization. First, you need to understand
    what you’re trying to change: query execution.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查询分析的目标是理解查询执行，而不是解决响应时间慢的问题。这可能会让你感到惊讶，但解决响应时间慢的问题发生在查询分析之后，在查询优化期间。首先，你需要理解你想要改变的是什么：查询执行。
- en: 'Query execution is like a story with a beginning, middle, and end: you read
    all three to understand the story. Once you understand how MySQL executes a query,
    then you will understand how to optimize it. Understanding through analysis, then
    action through optimization.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 查询执行就像一个有起点、中间和终点的故事：你需要读懂这三部分才能理解整个故事。一旦理解了MySQL如何执行查询，你就会明白如何优化它。通过分析理解，然后通过优化行动。
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'I have helped many engineers analyze queries, and the primary difficulty is
    not understanding the metrics but getting stuck in the analysis: staring deeply
    into the numbers, waiting for a revelation. Don’t get stuck. Carefully review
    all the metrics and metadata—read the whole story—then turn your attention to
    query optimization with the goal of improving response time.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经帮助许多工程师分析查询，主要困难不在于理解度量标准，而在于分析过程中的困境：深入研究数字，等待启示。不要陷入困境。仔细审查所有的度量和元数据——通读整个故事——然后把注意力转向查询优化，目标是提高响应时间。
- en: The following sections address key aspects to an efficient and insightful query
    analysis. Sometimes the cause of slow response time is so obvious that the analysis
    reads more like a tweet than a story. But when it’s not—when the analysis reads
    like a graduate thesis on French existentialism—understanding these aspects will
    help you find the cause and determine a solution.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分讨论了高效和洞察力查询分析的关键方面。有时候，慢响应时间的原因显而易见，分析看起来更像是一条推文而不是一个故事。但当它不是这样的时候 —— 当分析看起来像一篇关于法国存在主义的研究论文时
    —— 理解这些方面将帮助你找到原因并确定解决方案。
- en: Query Metrics
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询指标
- en: From [“Sources”](#query-sources), you know that query metrics vary depending
    on the source, MySQL distribution, and MySQL version. All query metrics are important
    because they help you understand query execution, but the nine metrics detailed
    in the following sections are essential to every query analysis.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据[“来源”](#query-sources)，你知道查询指标因来源、MySQL发行版和MySQL版本而异。所有的查询指标都很重要，因为它们帮助你理解查询执行，但接下来详细描述的九个指标对每个查询分析都是必不可少的。
- en: The Performance Schema provides all nine essential query metrics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 性能模式提供了所有九个关键的查询指标。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Query metric names also vary by source. In the slow query log, query time is
    `Query_time`; but in the Performance Schema, it’s `TIMER_WAIT`. I don’t use either
    convention. Instead, I use human-friendly names like *query time* and *rows sent*.
    Query reporting almost always uses human-friendly names, too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指标名称也因来源而异。在慢查询日志中，查询时间是`Query_time`；但在性能模式中，它是`TIMER_WAIT`。我没有使用任何一种约定。相反，我使用人类友好的名称，如*查询时间*和*发送行数*。查询报告几乎总是使用人类友好的名称。
- en: Query time
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询时间
- en: 'Query time is the most important metric—you knew that already. What you may
    not know is that query time includes another metric: lock time.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 查询时间是最重要的指标 —— 你已经知道这一点。你可能不知道的是，查询时间还包括另一个指标：锁定时间。
- en: 'Lock time is an inherent part of query time, so it’s not surprising that the
    latter includes the former. What’s surprising is that query time and lock time
    are the only two time-based query metrics, with one exception: the Percona Server
    slow query log has metrics for InnoDB read time, row lock wait time, and queue
    wait time. Lock time is important, but there’s an unfortunate technical gotcha:
    it’s accurate only in the slow query log. More on this later.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定时间是查询时间的固有部分，所以查询时间包括锁定时间并不令人意外。令人意外的是，查询时间和锁定时间是唯一的两个基于时间的查询指标，有一个例外：Percona
    Server慢查询日志中有关于InnoDB读取时间、行锁等待时间和队列等待时间的指标。锁定时间很重要，但遗憾的是，有一个技术上的陷阱：它只在慢查询日志中才是准确的。稍后再详谈。
- en: 'Using the Performance Schema, you can see many (but not all) parts of query
    execution. This is off-topic and beyond the scope of this book, but it’s good
    awareness so you know where to look if you need to dig deeper. MySQL instruments
    a bewildering number of *events* that the manual defines as, “anything the server
    does that takes time and has been instrumented so that timing information can
    be collected.” Events are organized in a hierarchy:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用性能模式，你可以看到查询执行的许多部分（但不是所有）。这是不相关的，并超出本书的范围，但这是一个很好的意识，因此你知道如果需要深入挖掘，该去哪里查看。MySQL记录了大量
    *事件*，手册将其定义为“服务器进行的任何花费时间的操作，并已经进行了仪器化，以便收集时间信息。” 事件按层次结构组织：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Transactions
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事务
- en: Transactions are the top-level event because every query executes in a transaction
    ([Chapter 8](ch08.html#ch08) covers transactions).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是顶层事件，因为每个查询都在事务中执行（[第8章](ch08.html#ch08)讨论了事务）。
- en: Statements
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 语句
- en: Statements are queries, to which query metrics apply.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是查询，适用查询指标。
- en: Stages
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段
- en: Stages are “steps during the statement-execution process, such as parsing a
    statement, opening a table, or performing a filesort operation.”
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段是“语句执行过程中的步骤，如解析语句、打开表或执行文件排序操作。”
- en: Waits
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 等待
- en: Waits are “events that take time.” (This definition amuses me. It’s tautological
    and oddly satisfying in its simplicity.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 等待是“花费时间的事件”。（这个定义让我觉得很有趣。它在简洁中又有些自洽和令人满意的复杂性。）
- en: '[Example 1-3](#update-stages) shows the stages for a single `UPDATE` statement
    (as of MySQL 8.0.22).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-3](#update-stages)显示了单个`UPDATE`语句的阶段（截至MySQL 8.0.22）。'
- en: Example 1-3\. Stages for a single `UPDATE` statement
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例1-3. 单个`UPDATE`语句的阶段
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The real output is more complex; I simplified it for easy reading. The `UPDATE`
    statement executed in 15 stages. The actual execution of the `UPDATE` was the
    eighth stage: `stage/sql/updating`. There were 42 waits, but I removed them from
    the output because they’re too far off topic.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际输出更为复杂；我简化了以便易读。在15个阶段执行了`UPDATE`语句。`UPDATE`的实际执行是第八阶段：`stage/sql/updating`。有42个等待，但我将它们从输出中删除，因为它们离题太远。
- en: Performance Schema events (transactions, statements, stages, and waits) are
    the fine details of query execution. Query metrics apply to statements. If you
    need to dig deeper in a query, look in the Performance Schema.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 性能模式事件（事务、语句、阶段和等待）是查询执行的细节。查询指标适用于语句。如果需要深入了解查询，请查看性能模式。
- en: Efficiency is our modus operandi, so don’t get lost in the Performance Schema
    until you need to, which may be never. Query time is sufficient.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 效率是我们的工作方式，所以在你可能永远不需要的情况下，不要陷入性能模式的迷宫中。查询时间足够了。
- en: Lock time
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁等待时间
- en: '*Lock time* is time spent acquiring locks during query execution. Ideally,
    lock time is a minuscule percentage of query time, but values are relative (see
    [“Relative Values”](#values-are-relative)). For example, on one extremely optimized
    database that I manage, lock time is 40% to 50% of query time for the slowest
    query. Sounds terrible, right? But it’s not: the slowest query has a maximum query
    time of 160 microseconds and a maximum lock time of 80 microseconds—and the database
    executes over 20,000 queries per second (QPS).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁等待时间* 是查询执行过程中获取锁所花费的时间。理想情况下，锁等待时间应该是查询时间的极小部分，但实际值是相对的（参见[“相对值”](#values-are-relative)）。例如，在我管理的一个极度优化的数据库中，最慢的查询的锁等待时间占查询时间的40%到50%。听起来很糟糕，对吧？但实际上不是：最慢的查询的最大查询时间为160微秒，最大锁等待时间为80微秒，而数据库每秒执行超过20,000个查询（QPS）。'
- en: Although values are relative, I can safely say that lock time greater than 50%
    of query time is a problem because MySQL should spend the vast majority of its
    time doing work, not waiting. A theoretically perfect query execution would have
    zero wait time, but that’s impossible due to shared resources, concurrency, and
    latency inherent in the system. Still, we can dream.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管值是相对的，但我可以肯定地说，锁等待时间超过查询时间的50%是一个问题，因为MySQL应该花费绝大部分时间在执行工作，而不是等待。理论上完美的查询执行会有零等待时间，但由于系统中的共享资源、并发性和延迟，这是不可能的。不过，我们可以梦想。
- en: 'Remember the unfortunate technical gotcha mentioned earlier? Here it is: lock
    time from the Performance Schema does *not* include row lock waits, only table
    and metadata lock waits. Row lock waits are the most important part of lock time,
    which makes lock time from the Performance Schema nearly useless. By contrast,
    lock time from the slow query log includes all lock waits: metadata, table, and
    row. Lock time from either source does not indicate which type of lock wait. From
    the Performance Schema, it’s certainly metadata lock wait; and from the slow query
    log, it’s probably row lock wait, but metadata lock wait is a possibility, too.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前提到的不幸技术绊脚石吗？在这里：性能模式中的锁等待时间*不*包括行锁等待，仅包括表锁和元数据锁等待。行锁等待是锁等待时间中最重要的部分，这使得性能模式中的锁等待时间几乎无用。相比之下，慢查询日志中的锁等待时间包括所有类型的锁等待：元数据、表和行。来自任一来源的锁等待时间都不指示等待的锁类型。来自性能模式的情况，肯定是元数据锁等待；而来自慢查询日志的情况，可能是行锁等待，但也有可能是元数据锁等待。
- en: Warning
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Lock time from the Performance Schema does not include row lock waits.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 性能模式中的锁等待时间不包括行锁等待。
- en: 'Locks are primarily used for writes (`INSERT`, `UPDATE`, `DELETE`, `REPLACE`)
    because rows must be locked before they can be written. Response time for writes
    depends, in part, on lock time. The amount of time needed to acquire row locks
    depends on concurrency: how many queries are accessing the same (or nearby) rows
    at the same time. If a row has zero concurrency (accessed by only one query at
    a time), then lock time is vanishingly small. But if a row is *hot*—jargon for
    *very frequently accessed*—then lock time could account for a significant percentage
    of response time. Concurrency is one of several data access patterns (see [“Data
    Access Patterns”](ch04.html#access-patterns) in [Chapter 4](ch04.html#ch04)).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定主要用于写入操作（`INSERT`、`UPDATE`、`DELETE`、`REPLACE`），因为必须在写入之前锁定行。 写入的响应时间取决于锁定时间的部分。
    获取行锁所需的时间取决于并发性：同时有多少查询访问相同行（或附近行）。 如果一行的并发性为零（仅由一个查询访问），则锁定时间将几乎为零。 但是如果一行是“热的”——术语用于非常频繁地访问——那么锁定时间可能占响应时间的显著百分比。
    并发性是几种数据访问模式之一（参见 [“数据访问模式”](ch04.html#access-patterns) 在[第四章](ch04.html#ch04)）。
- en: 'For reads (`SELECT`), there are nonlocking and [locking reads](https://oreil.ly/WcyD3).
    The distinction is easy because there are only two locking reads: `SELECT`…`FOR
    UPDATE` and `SELECT`…`FOR SHARE`. If not one of those two, then `SELECT` is nonlocking,
    which is the normal case.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于读取（`SELECT`），有非锁定和[锁定读取](https://oreil.ly/WcyD3)。 区分很容易，因为只有两种锁定读取：`SELECT`…`FOR
    UPDATE` 和 `SELECT`…`FOR SHARE`。 如果不是这两者之一，则 `SELECT` 是非锁定的，这是正常情况。
- en: 'Although `SELECT`…`FOR UPDATE` and `SELECT`…`FOR SHARE` are the only locking
    reads, don’t forget about writes with an optional `SELECT`. In the following SQL
    statements, the `SELECT` acquires shared row locks on table `s`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `SELECT`…`FOR UPDATE` 和 `SELECT`…`FOR SHARE` 是唯一的锁定读取，但不要忘记带有可选 `SELECT`
    的写入操作。 在以下 SQL 语句中，`SELECT` 会在表 `s` 上获取共享行锁：
- en: '`INSERT`…`SELECT FROM s`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`…`SELECT FROM s`'
- en: '`REPLACE`…`SELECT FROM s`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPLACE`…`SELECT FROM s`'
- en: '`UPDATE`…`WHERE`…`(SELECT FROM s)`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`…`WHERE`…`(SELECT FROM s)`'
- en: '`CREATE TABLE`…`SELECT FROM s`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`…`SELECT FROM s`'
- en: Strictly speaking, those SQL statements are writes, not reads, but the optional
    `SELECT` acquires shared row locks on table `s`. See [“Locks Set by Different
    SQL Statements in InnoDB”](https://oreil.ly/SJXcq) in the MySQL manual for details.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这些 SQL 语句是写入操作，而不是读取操作，但是可选的 `SELECT` 会在表 `s` 上获取共享行锁。 有关详细信息，请参阅 MySQL
    手册中的 [“InnoDB 中由不同 SQL 语句设置的锁”](https://oreil.ly/SJXcq)。
- en: 'Locking reads should be avoided, especially `SELECT`…`FOR UPDATE`, because
    they don’t scale, they tend to cause problems, and there is usually a nonlocking
    solution to achieve the same result. With respect to lock time, a locking read
    is like a write: it depends on concurrency. Be careful with `SELECT`…`FOR SHARE`:
    shared locks are compatible with other shared locks, but they’re incompatible
    with exclusive locks, which means shared locks block writes on the same (or nearby)
    rows.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用锁定读取，特别是 `SELECT`…`FOR UPDATE`，因为它们不具备可伸缩性，往往会引起问题，并且通常有非锁定解决方案可以实现相同的结果。
    关于锁定时间，请注意 `SELECT`…`FOR SHARE`：共享锁与其他共享锁兼容，但与排他锁不兼容，这意味着共享锁会阻止对同一行（或附近行）的写入操作。
- en: 'For nonlocking reads, even though row locks are not acquired, lock time will
    not be zero because metadata and table locks are acquired. But acquiring these
    two should be very fast: less than 1 millisecond. For example, another database
    I manage executes over 34,000 QPS but the slowest query is a nonlocking `SELECT`
    that does a full table scan, reading six million rows every execution, with very
    high concurrency: 168 query load. Despite these large values, its maximum lock
    time is 220 microseconds, and average lock time is 80 microseconds.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非锁定读取，即使不会获取行锁，锁定时间也不为零，因为会获取元数据和表锁。 但是获取这两者应该非常快：少于 1 毫秒。 例如，我管理的另一个数据库执行超过
    34,000 QPS，但最慢的查询是一个非锁定的 `SELECT`，每次执行都会进行全表扫描，读取六百万行，具有非常高的并发性：168 查询负载。 尽管存在这些大值，其最大锁定时间为
    220 微秒，平均锁定时间为 80 微秒。
- en: Nonlocking read does *not* mean non-blocking. `SELECT` queries must acquire
    shared metadata locks (MDL) on all tables accessed. As usual with locks, shared
    MDL are compatible with other shared MDL, but one exclusive MDL blocks all other
    MDL. `ALTER TABLE` is the common operation that acquires an exclusive MDL. Even
    using `ALTER TABLE`…`ALGORITHM=INPLACE, LOCK=NONE` or third-party online schema
    change tools like [pt-online-schema-change](https://oreil.ly/EzcrU) and [`gh-ost`](https://oreil.ly/TeHjG),
    an exclusive MDL must be acquired at the end to swap the old table structure for
    the new one. Although the table swap is very quick, it can cause a noticeable
    disruption when MySQL is heavily loaded because *all* table access is blocked
    while the exclusive MDL is held. This problem shows up as a blip in lock time,
    especially for `SELECT` statements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 非锁定读并不意味着非阻塞。对于所有访问的表，`SELECT` 查询必须获取共享的元数据锁（MDL）。与通常的锁定一样，共享的 MDL 可以与其他共享的
    MDL 兼容，但是一个排他的 MDL 会阻止所有其他的 MDL。`ALTER TABLE` 是通常会获取排他 MDL 的操作。即使使用 `ALTER TABLE`…`ALGORITHM=INPLACE,
    LOCK=NONE` 或第三方在线模式更改工具如 [pt-online-schema-change](https://oreil.ly/EzcrU) 和 [`gh-ost`](https://oreil.ly/TeHjG)，在最后交换旧表结构为新表时仍需获取排他
    MDL。虽然表交换非常快速，但是当 MySQL 负载较重时可能会导致显著的中断，因为在持有排他 MDL 时会阻塞*所有*表访问。尤其对于 `SELECT`
    语句来说，这个问题会显示为锁定时间的瞬间波动。
- en: Warning
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`SELECT` can block waiting for metadata locks.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT` 可能会因为等待元数据锁而阻塞。'
- en: 'Locking might be the most complex and nuanced aspect of MySQL. To avoid going
    down the proverbial rabbit hole, let me state five points but defer explanation
    for now. Merely being aware of these points greatly increases your MySQL prowess:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定可能是 MySQL 中最复杂且细微妙的方面。为了避免深入探讨，让我列出五个要点，暂时不做解释。仅仅了解这些要点就大大增加了你的 MySQL 技能：
- en: Lock time can be significantly greater than [`innodb_lock_wait_timeout`](https://oreil.ly/HlWwX)
    because this system variable applies to *each row lock*.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定时间可以显著超过 [`innodb_lock_wait_timeout`](https://oreil.ly/HlWwX)，因为这个系统变量适用于*每个行锁*。
- en: Locking and transaction isolation levels are related.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定和事务隔离级别有关。
- en: InnoDB locks every row it accesses *including rows it does not write*.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InnoDB 会锁定它访问的每一行，*包括它不写入的行*。
- en: Locks are released on transaction commit or rollback, and sometimes during query
    execution.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定会在事务提交或回滚时释放，有时在查询执行期间释放。
- en: 'InnoDB has different types of locks: record, gap, next-key, and more.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InnoDB 有不同类型的锁：记录锁、间隙锁、下一个键锁等等。
- en: '[“Row Locking”](ch08.html#row-locking) goes into detail. For now, let’s put
    it all together and visualize how query time includes lock time. [Figure 1-1](#lock-time-during-query-exec)
    shows locks acquired and released during query execution.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[“行锁定”](ch08.html#row-locking) 进行了详细讨论。现在，让我们把所有内容整合起来，看看查询时间包括的锁定时间。[图 1-1](#lock-time-during-query-exec)
    展示了查询执行期间获取和释放的锁定。'
- en: '![emsp 0101](assets/emsp_0101.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0101](assets/emsp_0101.png)'
- en: Figure 1-1\. Lock time during query execution
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 查询执行期间的锁定时间
- en: 'Labels 1 to 10 mark events and details with respect to locking:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 标签 1 到 10 标记了关于锁定事件和细节的内容：
- en: Acquire shared metadata lock on table
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取表上的共享元数据锁定
- en: Acquire intention exclusive (IX) table lock
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得意向排他（IX）表锁
- en: Acquire row lock 1
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得行锁 1
- en: Update (write) row 1
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新（写入）行 1
- en: Acquire row lock 2
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得行锁 2
- en: Release row lock 2
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放行锁 2
- en: Acquire row lock 3
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得行锁 3
- en: Update (write) row 3
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新（写入）行 3
- en: Commit transaction
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交事务
- en: Release all locks
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放所有锁定
- en: 'Two points of interest:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 两个关键点：
- en: Lock time from the Performance Schema includes only labels `1` and `2`. From
    the slow query log it includes labels `1`, `2`, `3`, `5`, and `7`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自性能模式的锁定时间仅包括标签 `1` 和 `2`。从慢查询日志中，它包括标签 `1`、`2`、`3`、`5` 和 `7`。
- en: Although row 2 is locked (label `5`), it’s not written and its lock is released
    (label `6`) before the transaction commits (label `9`). This can happen, but not
    always. It depends on the query and transaction isolation level.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管行 2 被锁定（标签 `5`），但它没有被写入，并且它的锁定在事务提交（标签 `9`）之前就被释放了（标签 `6`）。这种情况可能发生，但并非总是如此。它取决于查询和事务隔离级别。
- en: That was a lot of information about lock time and locking, but now you are well-equipped
    to understand lock time in your query analysis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才关于锁定时间和锁定的信息很多，但现在你已经具备了理解查询分析中的锁定时间的能力。
- en: Rows examined
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查的行数
- en: '*Rows examined* is the number of rows that MySQL accessed to find matching
    rows. It indicates the selectivity of the query and the indexes. The more selective
    both are, the less time MySQL wastes examining non-matching rows. This applies
    to reads and writes, except `INSERT` unless it’s an `INSERT`…`SELECT` statement.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查的行数* 是MySQL访问以找到匹配行的行数。它表示查询和索引的选择性。两者的选择性越高，MySQL浪费在检查非匹配行的时间就越少。这适用于读取和写入，除非是
    `INSERT`（如果是 `INSERT`…`SELECT` 语句则不适用）。'
- en: 'To understand rows examined, let’s look at two examples. First, let’s use the
    following table, `t1`, and three rows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解检查的行数，让我们看两个例子。首先，让我们使用以下表 `t1` 和三行：
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Column `id` is the primary key, and column `c` is not indexed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `id` 是主键，而列 `c` 则未建立索引。
- en: The query `SELECT c FROM t1 WHERE c = 'b'` matches one row but examines three
    rows because there is no unique index on column `c`. Therefore, MySQL has no idea
    how many rows match the `WHERE` clause. We can see that only one row matches,
    but MySQL doesn’t have eyes, it has indexes. By contrast, the query `SELECT c
    FROM t1 WHERE id = 2` matches and examines only one row because there is a unique
    index on column `id` (the primary key) and the table condition uses the entire
    index. Now MySQL can figuratively see that only one row matches, so that’s all
    it examines. [Chapter 2](ch02.html#ch02) teaches indexes and indexing, which explain
    table conditions and a lot more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 查询 `SELECT c FROM t1 WHERE c = 'b'` 匹配了一行，但检查了三行，因为列 `c` 上没有唯一索引。因此，MySQL 不知道有多少行与
    `WHERE` 子句匹配。我们可以看到只有一行匹配，但MySQL没有眼睛，它有索引。相比之下，查询 `SELECT c FROM t1 WHERE id =
    2` 只匹配并检查了一行，因为列 `id` 上有唯一索引（主键），并且表条件使用了整个索引。现在MySQL可以形象地看到只有一行匹配，因此它只检查了一行。[第二章](ch02.html#ch02)
    讲解了索引和索引技术，这解释了表条件和更多内容。
- en: 'For the second example, let’s use the following table, `t2`, and seven rows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个例子，让我们使用以下表 `t2` 和七行：
- en: '[PRE7]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Column `id` is the same as before (primary key). Column `c` has a *nonunique*
    index. Column `d` is not indexed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `id` 与之前相同（主键）。列 `c` 有一个 *非唯一* 索引。列 `d` 没有建立索引。
- en: 'How many rows will query `SELECT d FROM t2 WHERE c = ''a'' AND d = ''acorn''`
    examine? The answer is: four. MySQL uses the nonunique index on column `c` to
    look up rows matching the condition `c = ''a''`, and that matches four rows. And
    to match the other condition, `d = ''acorn''`, MySQL examines each of those four
    rows. As a result, the query examines four rows but matches (and returns) only
    one row.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 查询 `SELECT d FROM t2 WHERE c = 'a' AND d = 'acorn'` 将会检查多少行？答案是：四行。MySQL 使用列
    `c` 上的非唯一索引来查找满足条件 `c = 'a'` 的行，这匹配了四行。然后，为了匹配另一个条件 `d = 'acorn'`，MySQL 检查了这四行中的每一行。因此，这个查询检查了四行，但只匹配（并返回）了一行。
- en: It’s not uncommon to discover that a query examines more rows than expected.
    The cause is usually the selectivity of the query or the indexes (or both), but
    sometimes it’s because the table has grown a lot larger than expected, so there
    are a lot more rows to examine. [Chapter 3](ch03.html#ch03) examines this further
    (pun intended).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 发现查询检查的行数比预期多并不罕见。原因通常是查询的选择性或索引（或两者）导致的，但有时也因为表的增长超出预期，因此需要检查的行数更多。[第三章](ch03.html#ch03)
    进一步讨论了这一点（顺带说一句）。
- en: Rows examined only tells half the story. The other half is rows sent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 只检查行数只能讲述一半的故事。另一半是发送的行数。
- en: Rows sent
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送的行数
- en: '*Rows sent* is the number of rows returned to the client—the result set size.
    Rows sent is most meaningful in relation to rows examined.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*发送的行数* 是返回给客户端的行数，即结果集的大小。发送的行数与检查的行数之间的关系最有意义。'
- en: Rows sent = Rows examined
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的行数 = 检查的行数
- en: The ideal case is when rows sent and rows examined are equal and the value is
    relatively small, especially as a percentage of total rows, and query response
    time is acceptable. For example, 1,000 rows from a table with one million rows
    is a reasonable 0.1%. This is ideal if response time is acceptable. But 1,000
    rows from a table with only 10,000 rows is a questionable 10% even if response
    time is acceptable. Regardless of the percentage, if rows sent and rows examined
    are equal and the value is suspiciously high, it strongly indicates that the query
    is causing a table scan, which is usually terrible for performance—[“Table scan”](ch02.html#table-scan)
    explains why.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况是，发送的行数与检查的行数相等且该值相对较小，尤其是作为总行数的百分比，而查询响应时间可接受。例如，从一百万行的表中提取1,000行是合理的0.1%。如果响应时间可接受，这是理想情况。但是，从只有10,000行的表中提取1,000行即使响应时间可接受，也是一个值得怀疑的10%。无论百分比如何，如果发送的行数和检查的行数相等且该值异常高，则强烈表明查询导致表扫描，这通常对性能非常不利——[“表扫描”](ch02.html#table-scan)解释了原因。
- en: Rows sent < Rows examined
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Rows sent < Rows examined
- en: Fewer rows sent than examined is a reliable sign of poor query or index selectivity.
    If the difference is extreme, it likely explains slow response time. For example,
    1,000 rows sent and 100,000 rows examined aren’t large values, but they mean 99%
    of rows did not match—the query caused MySQL to waste a lot of time. Even if response
    time is acceptable, an index could dramatically reduce the wasted time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的行数少于检查的行数是查询或索引选择性差的可靠标志。如果差异极大，这很可能解释了慢响应时间。例如，发送1,000行而检查100,000行虽然不是很大的值，但意味着99%的行未匹配——查询导致MySQL浪费了大量时间。即使响应时间可接受，索引也可以大幅减少浪费的时间。
- en: Rows sent > Rows examined
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Rows sent > Rows examined
- en: It’s possible, but rare, to send more rows than were examined. This happens
    under special conditions, like when MySQL can “optimize away” the query. For example,
    `SELECT COUNT(id) FROM t2` on the table in the previous section sends one row
    for the value of `COUNT(id)` but examines zero rows.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 发送的行数大于检查的行数是可能的，但很少见。这种情况发生在特殊条件下，比如MySQL可以“优化掉”查询时。例如，在前一节的表上执行 `SELECT COUNT(id)
    FROM t2` 可以发送一个包含 `COUNT(id)` 值的行，但不检查任何行。
- en: Rows sent is rarely a problem by itself. Modern networks are fast and the MySQL
    protocol is efficient. If your distribution and version of MySQL have the *bytes
    sent* metric in the slow query log (the Performance Schema does not provide this
    query metric), you can use it two ways. First, the minimum, maximum, and average
    values reveal the result set size in bytes. This is usually small, but it can
    be large if the query returns `BLOB` or `JSON` columns. Second, total bytes sent
    can be converted to a network throughput (Mbps or Gbps) to reveal the network
    utilization of the query, which is also usually very small.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭发送的行数本身很少会出现问题。现代网络速度快，MySQL协议高效。如果您的MySQL分布版和版本在慢查询日志中具有*bytes sent*指标（性能模式不提供此查询指标），您可以以两种方式使用它。首先，最小值、最大值和平均值揭示了字节大小的结果集。通常这很小，但如果查询返回`BLOB`或`JSON`列，它可能很大。其次，总发送字节数可以转换为网络吞吐量（Mbps或Gbps），以揭示查询的网络利用率，这通常也非常小。
- en: Rows affected
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rows affected
- en: '*Rows affected* is the number of rows inserted, updated, or deleted. Engineers
    are very careful to affect only the correct rows. It’s a serious bug when the
    wrong rows are changed. Viewed this way, the value of rows affected is always
    correct. But a surprisingly large value could indicate a new or modified query
    that affects more rows than intended.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rows affected* 是插入、更新或删除的行数。工程师们非常小心地只影响正确的行。当更改错误的行时，这是一个严重的错误。从这个角度看，受影响行数的值始终是正确的。但是，一个出乎意料的大值可能表明新的或修改过的查询影响了比预期更多的行。'
- en: 'Another way to view rows affected is as the batch size of bulk operations.
    Bulk `INSERT`, `UPDATE`, and `DELETE` are a common source of several problems:
    replication lag, history list length, lock time, and overall performance degradation.
    Equally common is the question, “How large should the batch size be?” There’s
    no universally correct answer. Instead, you must determine the batch size *and*
    rate that MySQL and the application can sustain without impacting query response
    time. I explain in [“Batch Size”](ch03.html#batch-size), which focuses on `DELETE`
    but is also applicable to `INSERT` and `UPDATE`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 查看受影响行的另一种方法是作为批量操作的批处理大小。批量 `INSERT`、`UPDATE` 和 `DELETE` 是几个问题的常见源头：复制延迟、历史列表长度、锁定时间以及整体性能下降。同样普遍的问题是：“批处理大小应该设置多大？”
    没有通用的正确答案。相反，你必须确定 MySQL 和应用程序可以维持的批处理大小及速率，而不会影响查询响应时间。我在 [“批处理大小”](ch03.html#batch-size)
    中进行了解释，该章节主要关注 `DELETE`，但也适用于 `INSERT` 和 `UPDATE`。
- en: Select scan
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择扫描
- en: '*Select scan* is the number of full table scans on the first table accessed.
    (If the query accesses two or more tables, the next metric applies: select full
    join.) This is usually bad for performance because it means the query isn’t using
    an index. After [Chapter 2](ch02.html#ch02), which teaches indexes and indexing,
    it should be easy to add an index to fix a table scan. If select scan is not zero,
    query optimization is strongly advised.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择扫描* 是访问的第一个表上的全表扫描次数。（如果查询访问了两个或更多表，则应用下一个指标：选择全连接。）这通常对性能不利，因为意味着查询未使用索引。在学习索引和索引后，在
    [第二章](ch02.html#ch02) 之后，添加索引以修复表扫描应该很容易。如果选择扫描不为零，则强烈建议进行查询优化。'
- en: 'It’s possible, but *very* rare, that a query causes a table scan sometimes
    but not always. To determine why, you need a query sample and EXPLAIN plan for
    both: a query sample that causes a table scan, and a query sample that does not.
    One likely reason is how many rows MySQL estimates the query will examine relative
    to index cardinality (the number of unique values in the index), total rows in
    the table, and other costs. (The MySQL query optimizer uses a cost model.) Estimates
    aren’t perfect and sometimes MySQL is wrong, resulting in a table scan or suboptimal
    execution plan, but again: this is *very* rare.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生但非常罕见的是，某个查询有时会导致表扫描，但并非总是如此。要确定原因，需要查询样本和两者的 `EXPLAIN` 计划：一个导致表扫描的查询样本，以及一个不会导致表扫描的查询样本。一个可能的原因是
    MySQL 估计查询将检查的行数相对于索引基数（索引中的唯一值数）、表中总行数和其他成本。 （MySQL 查询优化器使用成本模型。）估计并不完美，有时 MySQL
    错误，导致表扫描或子优化执行计划，但再次强调：这种情况非常罕见。
- en: More than likely, select scan is either all zero or all one (it’s a binary value).
    Be happy if it’s zero. Optimize the query if it’s not zero.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，选择扫描要么全为零，要么全为一（这是一个二元值）。如果为零，那就很高兴。如果不为零，则应优化查询。
- en: Select full join
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择全连接
- en: '*Select full join* is the number of full table scans on tables joined. This
    is similar to select scan but worse—I explain why in a moment. Select full join
    should always be zero; if not, query optimization is practically required.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择全连接* 是加入的表上的全表扫描次数。这类似于选择扫描，但更糟糕——稍后我会解释为什么。选择全连接应该始终为零；如果不是，则实际上需要进行查询优化。'
- en: When you [`EXPLAIN` a query with multiple tables](https://oreil.ly/sRswS), MySQL
    prints the table join order from top (first table) to bottom (last table). Select
    scan applies only to the first table. Select full join applies only to the second
    and subsequent tables.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用多表查询进行 [`EXPLAIN`](https://oreil.ly/sRswS) 时，MySQL 会从顶部（第一个表）到底部（最后一个表）打印表连接顺序。选择扫描仅适用于第一个表。选择全连接仅适用于第二个及后续的表。
- en: 'Table join order is determined by MySQL, not the query.^([2](ch01.html#idm45829113296432))
    [Example 1-4](#explain-3-table) shows the EXPLAIN plan for `SELECT`…`FROM t1,
    t2, t3`: MySQL determines a different join order than the implicit three-table
    join in the query.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表连接顺序由 MySQL 确定，而不是查询本身。^([2](ch01.html#idm45829113296432)) 示例 [1-4](#explain-3-table)
    展示了 `SELECT`…`FROM t1, t2, t3` 的 `EXPLAIN` 计划：MySQL 确定了与查询中隐含的三表连接不同的连接顺序。
- en: Example 1-4\. EXPLAIN plan for three tables joined
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1-4\. 三表连接的 `EXPLAIN` 计划
- en: '[PRE9]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: MySQL reads table `t3` first, then joins table `t1`, then joins table `t2`.
    That join order is different than the query (`FROM t1, t2, t3`), which is why
    you must `EXPLAIN` a query to see its join order.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 首先读取表 `t3`，然后连接表 `t1`，然后连接表 `t2`。这种连接顺序与查询 (`FROM t1, t2, t3`) 不同，这就是为什么必须使用
    `EXPLAIN` 命令来查看其连接顺序。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Always `EXPLAIN` a query to see its join order.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用 `EXPLAIN` 命令查看查询的连接顺序。
- en: 'Select scan applies to table `t3` because it’s the first table in the join
    order and it causes a table scan (indicated by `type: ALL`). Select full join
    would apply to table `t1` if it caused a table scan, but it doesn’t: MySQL joins
    the table using a range scan on the primary key (indicated by `type: range` and
    `key: PRIMARY`, respectively). Select full join applies to table `t2` because
    MySQL joins it using a full table scan (indicated by `type: ALL`).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '选择扫描适用于表`t3`，因为它是连接顺序中的第一个表，并导致表扫描（由`type: ALL`表示）。如果表`t1`导致表扫描，选择全连接将适用于它，但实际上并不会：MySQL使用主键的范围扫描进行表连接（分别由`type:
    range`和`key: PRIMARY`表示）。选择全连接适用于表`t2`，因为MySQL使用全表扫描进行表连接（由`type: ALL`表示）。'
- en: 'The table scan on `t2` is called a *full join* because MySQL scans the full
    table on join. Select full join is worse than select scan because the number of
    full joins that occur on a table during query execution is equal to the product
    of rows from the preceding tables. MySQL estimates three rows from table `t3`
    (indicated by `rows: 3`) and two rows from table `t1` (indicated by `rows: 2`).
    Therefore, 3 × 2 = 6 full joins on table `t2` during query execution. But the
    select full join metric value will be 1 because it counts full joins in the execution
    plan, not during query execution, which is sufficient because even one full join
    is too many.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '表`t2`上的表扫描称为*全连接*，因为MySQL在连接时扫描了整个表。选择全连接比选择扫描更糟糕，因为在查询执行过程中在表上发生的全连接次数等于前面表的行数的乘积。MySQL估计表`t3`有三行（由`rows:
    3`表示）和表`t1`有两行（由`rows: 2`表示）。因此，在查询执行过程中，表`t2`上会有3 × 2 = 6次全连接。但选择全连接的度量值将为1，因为它在执行计划中计算全连接，而不是在查询执行过程中计算，这已足够，因为即使一个全连接也太多。'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of MySQL 8.0.18, the [hash join optimization](https://oreil.ly/zf7Rs) improves
    performance for certain joins, but avoiding full joins remains the best practice.
    See [“Table Join Algorithms”](ch02.html#table-join-algos) for a brief overview
    of hash join.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 截至MySQL 8.0.18，[哈希连接优化](https://oreil.ly/zf7Rs)改进了某些连接的性能，但避免全连接仍然是最佳实践。请参阅[“表连接算法”](ch02.html#table-join-algos)简要了解哈希连接。
- en: Created tmp disk tables
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建临时磁盘表
- en: '*Created tmp disk tables* is the number of temporary tables created on disk.
    It’s normal for queries to create temporary tables in memory; but when an in-memory
    temporary table becomes too large, MySQL writes it to disk. That can affect response
    time because disk access is orders of magnitude slower than memory access.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*Created tmp disk tables*是在磁盘上创建的临时表的数量。查询在内存中创建临时表是正常的；但当内存中的临时表变得过大时，MySQL会将其写入磁盘。这可能会影响响应时间，因为磁盘访问比内存访问慢几个数量级。'
- en: However, temporary tables on disk is not a common problem because MySQL tries
    to avoid them. Excessive “tmp disk tables” indicates a query that can be optimized,
    or (perhaps) the system variable [`tmp_table_size`](https://oreil.ly/8exZw) is
    too small. Always optimize queries first. Change system variables as a last resort—especially
    ones that affect memory allocation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，临时磁盘表并不是常见问题，因为MySQL会尽量避免它们。过多的“tmp disk tables”表明可以优化查询，或者（也许）系统变量[`tmp_table_size`](https://oreil.ly/8exZw)设置得太小。始终首先优化查询。最后才更改系统变量——尤其是影响内存分配的变量。
- en: See [“Internal Temporary Table Use in MySQL”](https://oreil.ly/CeCSv) in the
    MySQL manual for more information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅MySQL手册中的[“MySQL中的内部临时表使用”](https://oreil.ly/CeCSv)。
- en: Query count
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询计数
- en: '*Query count* is the number of query executions. The value is arbitrary unless
    extremely low and the query is slow. “Low and slow” is an odd combination worth
    investigating.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询计数*是查询执行的次数。该值是任意的，除非非常低且查询很慢。“低速”和“慢”是一个值得调查的奇怪组合。'
- en: 'As I write this, I’m looking at a query profile that’s a perfect example: the
    slowest query executed *once* but took 44% of execution time. Other metrics are:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写下这些话时，我正在查看一个完美的查询分析文件：最慢的查询只执行了一次，但占用了44%的执行时间。其他指标包括：
- en: 'Response time: 16 s'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间：16秒
- en: 'Lock time: 110 μs'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定时间：110微秒
- en: 'Rows examined: 132,000'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描的行数：132,000
- en: 'Rows sent: 13'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送的行数：13
- en: Not your everyday query. It looks like an engineer manually executed the query,
    but I can tell from the digest text that it was programmatically generated. What’s
    the story behind this query? To find out, I’ll have to ask the application developers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是每天都能见到的查询。看起来像是工程师手动执行的查询，但从摘要文本中可以看出它是程序生成的。这个查询背后的故事是什么？要找出答案，我必须问问应用程序开发人员。
- en: Metadata and the Application
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元数据与应用程序
- en: 'There’s more to query analysis than query metrics: metadata. In fact, you can’t
    complete a query analysis without at least two pieces of metadata: the EXPLAIN
    plan (also called the *query execution plan*), and the table structure for each
    table. A few query metric tools automatically collect metadata and show it in
    the query report. If your query metric tool does not, don’t worry: it’s easy to
    collect metadata. [`EXPLAIN`](https://oreil.ly/AZvGt) and [`SHOW CREATE TABLE`](https://oreil.ly/Wwp8f)
    report the EXPLAIN plan and table structures, respectively.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 查询分析不仅仅是查询指标：还有元数据。事实上，你无法完成查询分析而没有至少两个元数据：EXPLAIN计划（也称为*查询执行计划*）和每个表的表结构。一些查询指标工具会自动收集元数据并在查询报告中显示。如果你的查询指标工具没有这个功能，不用担心：收集元数据很容易。[`EXPLAIN`](https://oreil.ly/AZvGt)和[`SHOW
    CREATE TABLE`](https://oreil.ly/Wwp8f)分别报告EXPLAIN计划和表结构。
- en: 'Metadata is indispensable for query analysis, query optimization, and MySQL
    performance in general. `EXPLAIN` is a vital tool in your MySQL repertoire. I
    explain it in [“EXPLAIN: Query Execution Plan”](ch02.html#EXPLAIN) and use it
    extensively throughout this book.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据对于查询分析、查询优化和MySQL性能至关重要。`EXPLAIN`是你MySQL工具箱中的重要工具。我在[“EXPLAIN：查询执行计划”](ch02.html#EXPLAIN)中对其进行了解释，并在本书中广泛使用。
- en: 'There’s even more to query analysis than query metrics and metadata: the application.
    Metrics and metadata are must-have for any query analysis, but the story is only
    complete when you know what purpose the query serves: *why* does the application
    execute the query? Knowing this allows you to evaluate changes to the application,
    which is the focus of [Chapter 4](ch04.html#ch04). More than once, I’ve seen engineers
    realize that a query can be a lot simpler—or completely removed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 查询分析不仅仅是查询指标和元数据：还有应用程序。对于任何查询分析来说，指标和元数据是必不可少的，但只有当你知道查询的目的是什么时，故事才算完整：应用程序为什么要执行这个查询？了解这一点可以让你评估对应用程序的更改，这是[第四章](ch04.html#ch04)的重点。不止一次，我看到工程师意识到一个查询可以简单得多，甚至可以完全移除。
- en: Query metrics, metadata, and the application should complete the story. But
    I’d be remiss not to mention that, sometimes, issues outside MySQL and the application
    influence the story—and usually not for the better. [“Noisy Neighbors”](ch09.html#noisy-neighbors)
    is a classic case. If response time is slow but a thorough query analysis doesn’t
    reveal why, then consider outside issues. But don’t be too quick to jump to this
    conclusion; outside issues should be the exception, never the norm.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 查询指标、元数据和应用程序应该完整地呈现故事。但我不得不提到，有时候，MySQL和应用程序之外的问题会影响故事的发展，而且通常不是为了更好。[“吵闹的邻居”](ch09.html#noisy-neighbors)是一个经典案例。如果响应时间很慢，但彻底的查询分析没有揭示原因，那么考虑外部问题。但不要太快就得出这个结论；外部问题应该是例外，而不是规律。
- en: Relative Values
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对值
- en: 'For each query metric, the only objectively good value is zero because, as
    the saying goes, the fastest way to do something is to not do it. Nonzero values
    are always relative to the query and application. For example, one thousand rows
    sent is fine in general, but it could be terrible if the query is supposed to
    return only one row. Relative values are meaningful when considering the full
    story: metrics, metadata, and the application.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个查询指标，唯一客观良好的值是零，因为俗话说，做某事的最快方式就是不做。非零值总是相对于查询和应用程序的。例如，一千行发送通常是可以接受的，但如果查询应该返回的只有一行，那就可能很糟糕。相对值在考虑整个故事时是有意义的：指标、元数据和应用程序。
- en: 'Here’s another true story to illustrate that values are relative and meaningful
    with the full story. I inherited an application that became slower and slower
    over the years. It was an internal application—not used by customers—so fixing
    it wasn’t a priority until it became unbearably slow. In the query profile, the
    slowest query was examining and returning over ten thousand rows—not a full table
    scan, just a lot of rows. Instead of fixating on the values, I went spelunking
    in the source code and discovered that the function executing the query was only
    counting the number of rows, not using the rows. It was slow because it needlessly
    accessed and returned thousands of rows, and it became slower over time because
    the number of rows increased as the database grew. With the full story, the optimization
    was glaringly obvious and simple: `SELECT COUNT(*)`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个真实故事，用来说明价值观是相对而有意义的完整故事。我继承了一个应用程序，随着时间推移变得越来越慢。这是一个内部应用程序，不是客户使用的，因此修复它并非优先考虑，直到它变得无法忍受的慢。在查询分析中，最慢的查询是检查并返回超过一万行——不是全表扫描，只是很多行。我没有固守在数值上，而是深入源代码挖掘，并发现执行查询的函数仅仅是计算行数，而没有使用这些行。它之所以慢是因为它不必要地访问和返回了数千行，随着数据库增长，行数增加，它变得越来越慢。有了完整的故事，优化变得显而易见和简单：`SELECT
    COUNT(*)`。
- en: Average, Percentile, and Maximum
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均值、百分位和最大值
- en: 'It’s standard to talk about query response time as if it’s a single value,
    but it’s not. From [“Aggregation”](#query-aggregation) you know that query metrics
    are grouped and aggregated by query. As a result, query metrics are reported as
    single, statistical values: minimum, maximum, average, and percentile. You are
    undoubtedly familiar with these ubiquitous “stats,” but with respect to query
    response time, the following points may surprise you:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们谈论查询响应时间时会将其看作单一值，但实际上并非如此。从[“聚合”](#query-aggregation)中可以了解到，查询指标是按查询进行分组和聚合的。因此，查询指标被报告为单一的统计值：最小值、最大值、平均值和百分位。您肯定熟悉这些无处不在的“统计”，但关于查询响应时间，以下几点可能会让您感到意外：
- en: Average is overly optimistic
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均值过于乐观
- en: Percentile is an assumption
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分位是一个假设
- en: Maximum is the best representation
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大值是最好的表示
- en: 'Let me explain:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下：
- en: Average
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值
- en: 'Don’t be fooled by the average: if query count is small, a few very large or
    small values can skew the average response time (or any metric). Moreover, without
    knowing the distribution of values, we cannot know what percentage of values the
    average represents. For example, if the average equals the median, then the average
    represents the bottom 50% of values, which are the better (faster) response times.
    In that case, the average is overly optimistic. (Most values are overly optimistic
    if you ignore the worst half.) The average only tells you, at a glance, if the
    query typically executes in a matter of microseconds, milliseconds, or seconds.
    Don’t read more into it than that.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被平均值所愚弄：如果查询计数较少，几个非常大或非常小的值可能会使平均响应时间（或任何指标）偏离。此外，如果不知道值的分布情况，我们就无法知道平均值代表了值的百分比。例如，如果平均值等于中位数，那么平均值代表了底部50%的值，即更好（更快）的响应时间。在这种情况下，平均值过于乐观。（如果忽略最差的一半，大多数值都过于乐观。）平均值只是告诉您，一眼看去，查询通常在微秒、毫秒或秒内执行。不要把它看得太复杂。
- en: Percentile
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位
- en: 'Percentiles solve the problem of averages. Without going into a full explanation
    of percentiles, P95 is the value that 95% of samples are less than or equal to.^([3](ch01.html#idm45829115011648))
    For example, if P95 equals 100 ms, then 95% of values are less than or equal to
    100 ms, and 5% of values are greater than 100 ms. Consequently, P95 represents
    95% of values, which is objectively more representative—and less optimistic—than
    the average. There’s another reason percentiles are used: the small percentage
    of values ignored are considered outliers. For example, network jitter and flukes
    can cause a small percentage of query executions to take longer than normal. Since
    that’s no fault of MySQL, we ignore those execution times as outliers.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位解决了平均值的问题。不详细解释百分位，P95是小于或等于95%样本值的值。例如，如果P95等于100毫秒，则95%的值小于或等于100毫秒，5%的值大于100毫秒。因此，P95代表了95%的值，这比平均值更客观地代表了——并且更不乐观。使用百分位的另一个原因是：忽略掉的小部分值被视为异常值。例如，网络抖动和突发事件可能导致少量查询执行时间超过正常时间。由于这不是MySQL的错，我们将这些执行时间忽略为异常值。
- en: 'Percentiles are standard practice, but they’re also an assumption. Yes, there
    can be outliers, but they should be *proven*, not assumed. Until the top N% are
    proven *not* to be outliers, they are the most interesting values precisely because
    they’re not normal. *What’s causing them?* That’s difficult to answer, which is
    why percentiles are standard practice: it’s easier to ignore the top N% of values
    than to dig deep and find the answer.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 百分位数是标准做法，但它们也是一种假设。是的，可能存在异常值，但它们应该被*证明*，而不是假设。在未能证明前 N% 不是异常值之前，它们是最有趣的值，因为它们不正常。*是什么导致了它们？*
    这很难回答，这就是为什么百分位数是标准做法的原因：忽略前 N% 的值比深入挖掘并找到答案要容易。
- en: The best percentile is P999 (99.9%) because discarding 0.1% of values is an
    acceptable tradeoff between assuming that they’re outliers and the reality that
    outliers do exist.^([4](ch01.html#idm45829115006912))
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳百分位数是 P999（99.9%），因为丢弃0.1%的值是可以接受的权衡，认为它们是异常值和实际存在异常值之间的权衡。^([4](ch01.html#idm45829115006912))
- en: Maximum
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最大
- en: 'Maximum query time solves the problem of percentiles: don’t discard any values.
    The maximum value is not a myth or statistical apparition like the average. Somewhere
    in the world, some application user experienced the maximum query response time—​or
    gave up after a few seconds and left. You should want to know why, and you can
    find the answer. Whereas explaining the top N% of values is difficult because
    there are many values and, thus, many potentially different answers, explaining
    the maximum is a single value and answer. Query metric tools often use the query
    with the maximum response time as the sample, which makes explaining it almost
    trivial because you have the proverbial smoking gun. With that sample, one of
    two things will happen: either it reproduces the problem, in which case you continue
    with the analysis; or, it does not reproduce the problem, in which case you have
    proven that it’s an outlier that can be ignored.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最大查询时间解决了百分位数的问题：不要丢弃任何值。最大值不是像平均值那样的神话或统计幻觉。世界上某个地方的某个应用程序用户体验到了最大查询响应时间，或者在几秒钟后放弃了并离开。你应该想知道为什么，你可以找到答案。而解释前
    N% 的值很困难，因为有许多值，因此可能有许多不同的答案，解释最大值就是一个单一的值和答案。查询度量工具通常使用具有最大响应时间的查询作为样本，这使得解释几乎是微不足道的，因为你有所谓的铁证。有了这个样本，会发生两件事情中的一件：要么它复制了问题，那么你继续分析；要么它不复制问题，那么你已经证明它是一个可以忽略的异常值。
- en: 'Here’s another true story of the former case. An otherwise good application
    would randomly respond very slowly. Minimum, average, and P99 query time were
    all milliseconds, but maximum query time was seconds. Instead of ignoring the
    maximum, I collected query samples of normal and maximum execution time. The difference
    was the size of the `IN` list in the `WHERE` clause: hundreds of values for normal
    query time, and several thousand values for maximum query time. Fetching more
    values takes longer to execute, but milliseconds to seconds is not normal even
    for thousands of values. `EXPLAIN` provided the answer: normal query time used
    an index, but maximum query time caused a full table scan. MySQL can switch query
    execution plans (see [“It’s a Trap! (When MySQL Chooses Another Index)”](ch02.html#its-a-trap)),
    which explains MySQL, but what explains the application? Long story short, the
    query was used to look up data for fraud detection, and occasionally a big case
    would look up several thousand rows at once, which caused MySQL to switch query
    execution plans. Normally, the query was perfectly fine, but digging into the
    maximum response time revealed not only a MySQL gotcha but also an opportunity
    to improve the application and user experience by handling large lookups more
    efficiently.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个前例的真实故事。一个本来不错的应用程序会随机响应非常缓慢。最小、平均和 P99 查询时间都是毫秒级，但最大查询时间却是秒级。与其忽视最大值，我收集了正常和最大执行时间的查询样本。区别在于
    `WHERE` 子句中的 `IN` 列表的大小：正常查询时间的值有数百个，而最大查询时间有数千个。获取更多值需要更长时间执行，但是毫秒到秒对于数千个值来说并不正常。`EXPLAIN`
    提供了答案：正常查询时间使用了索引，但最大查询时间导致全表扫描。MySQL 可以切换查询执行计划（参见[“It’s a Trap! (When MySQL
    Chooses Another Index)”](ch02.html#its-a-trap)），这解释了MySQL，但是应用程序呢？长话短说，查询用于欺诈检测数据查找，偶尔会一次查找数千行，这导致MySQL切换查询执行计划。通常情况下，查询是完全正常的，但深入研究最大响应时间不仅揭示了MySQL的陷阱，还提供了通过更有效地处理大型查找来改善应用程序和用户体验的机会。
- en: Average, percentile, and maximum are useful, just be aware of what they do and
    do not represent.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值、百分位数和最大值都是有用的，只是要注意它们所代表的和不代表的。
- en: 'Also consider the distribution of values between the minimum and maximum. If
    you’re lucky, the query report includes histograms, but don’t count on it: calculating
    histograms for an arbitrary time range is difficult, so almost no query metric
    tool does it. The basic statistics (minimum, maximum, average, and percentile)
    indicate enough of the distribution to determine if the query is *stable*: metrics
    are roughly the same for every execution. (In [Chapter 6](ch06.html#ch06), I return
    to the idea of stability. See [“Normal and Stable: The Best Database Is a Boring
    Database”](ch06.html#normal-and-stable).) Unstable queries complicate the analysis:
    what causes the query to execute differently? The cause is likely outside MySQL,
    which makes it more difficult to find, but it’s necessary to find because stable
    queries are easier to analyze, understand, and optimize.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑最小值和最大值之间的值分布。如果幸运的话，查询报告会包含直方图，但不要指望：为任意时间范围计算直方图是困难的，因此几乎没有查询度量工具会这样做。基本统计数据（最小值、最大值、平均值和百分位数）足以显示分布的大部分情况，以确定查询是否*稳定*：度量在每次执行时大致相同。在
    [第 6 章](ch06.html#ch06) 中，我将回到稳定性的概念。参见 [“正常和稳定：最好的数据库是一种无聊的数据库”](ch06.html#normal-and-stable)。不稳定的查询使分析变得复杂：是什么导致查询的执行方式不同？原因很可能在
    MySQL 之外，这使得查找更加困难，但必须找到，因为稳定的查询更容易分析、理解和优化。
- en: Improving Query Response Time
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高查询响应时间
- en: 'Improving query response time is a journey called *query optimization*. I call
    it a journey to set the proper expectations. Query optimization takes time and
    effort, and there is a destination: faster query response time. To make the journey
    efficient—not a waste of time and effort—there are two parts: direct query optimization
    and indirect query optimization.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 提高查询响应时间是一个称为*查询优化* 的旅程。我称之为旅程是为了设定适当的期望。查询优化需要时间和精力，并且有一个目标：更快的查询响应时间。为了使旅程高效——而不是浪费时间和精力——有两个部分：直接查询优化和间接查询优化。
- en: Direct Query Optimization
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接查询优化
- en: '*Direct query optimization* is changes to queries and indexes. These changes
    solve *a lot* of performance problems, which is why the journey begins with direct
    query optimization. And because these changes are so powerful, the journey often
    ends here, too.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*直接查询优化* 涉及查询和索引的改变。这些改变解决了*大量*性能问题，这也是为什么优化的旅程始于直接查询优化。而由于这些改变如此强大，优化的旅程通常也在此结束。'
- en: 'Let me use an analogy that’s a little simplistic now but will be more insightful
    later. Think of a query as a car. Mechanics have tools to fix a car when it’s
    not running well. Some tools are common (like a wrench), and others are specialized
    (like a dual overhead cam lock). Once a mechanic pops the hood and finds the problem,
    they know which tools are needed to fix it. Likewise, engineers have tools to
    fix a query when it’s running slowly. The common tools are query analysis, [`EXPLAIN`](https://oreil.ly/oB3q9),
    and indexes. The specialized tools are query-specific optimizations. To name only
    a few from [“Optimizing SELECT Statements”](https://oreil.ly/dqEWw) in the MySQL
    manual:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用一个现在有点简化但稍后会更有洞察力的类比。把一个查询想象成一辆车。当车子跑得不顺畅时，技工们有工具来修理它。有些工具是常见的（比如扳手），而其他的则是专用的（比如双顶置凸轮锁）。一旦技工打开引擎盖找到问题，他们就知道需要哪些工具来修理它。同样，工程师在查询运行缓慢时也有工具来修复它。常见的工具包括查询分析、[`EXPLAIN`](https://oreil.ly/oB3q9)
    和索引。而专用工具则是特定于查询的优化。举几个例子来自于 MySQL 手册中的 [“优化 SELECT 语句”](https://oreil.ly/dqEWw)：
- en: Range Optimization
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围优化
- en: Index Merge Optimization
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引合并优化
- en: Hash Join Optimization
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散列连接优化
- en: Index Condition Pushdown Optimization
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引条件下推优化
- en: Multi-Range Read Optimization
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多范围读优化
- en: Constant-Folding Optimization
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量折叠优化
- en: '`IS NULL` Optimization'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS NULL` 优化'
- en: '`ORDER BY` Optimization'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORDER BY` 优化'
- en: '`GROUP BY` Optimization'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUP BY` 优化'
- en: '`DISTINCT` Optimization'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISTINCT` 优化'
- en: '`LIMIT` Query Optimization'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIMIT` 查询优化'
- en: 'In this book, I do not explain query-specific optimizations because [Chapter
    8, “Optimization”](https://oreil.ly/03htc) in the MySQL manual already explains
    them in detail, and it’s authoritative and regularly updated. Plus, query-specific
    optimizations vary by MySQL version and distribution. Instead, I teach indexes
    and indexing in [Chapter 2](ch02.html#ch02): the foundation for knowing which
    query-specific optimizations to use—and how—when fixing a slow query. After [Chapter 2](ch02.html#ch02),
    you will wield specialized tools like the [“Index Condition Pushdown Optimization”](https://oreil.ly/5CEbX)
    like a master mechanic wields a dual overhead cam lock.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我不会解释特定于查询的优化，因为[《优化》第8章](https://oreil.ly/03htc)在MySQL手册中已经详细解释了，并且它是权威的并定期更新的。此外，特定于查询的优化因MySQL版本和发行版而异。相反，我会在[第2章](ch02.html#ch02)教授索引和索引技术：这是知道在修复慢查询时要使用哪些特定查询优化以及如何使用它们的基础。在[第2章](ch02.html#ch02)之后，你将能够像一位高级机械师使用[“索引条件下推优化”](https://oreil.ly/5CEbX)等专业工具。
- en: 'Every so often I talk with an engineer who is surprised and a little unhappy
    when the query optimizations they so assiduously applied do not solve the problem.
    Direct query optimization is necessary but not always sufficient. An optimized
    query can be or become a problem under different circumstances. When you can’t
    optimize a query any further (or you can’t optimize it at all because you don’t
    have access to the source code), you can optimize *around* the query, which leads
    to part two of the journey: indirect query optimization.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 时不时地，我会和一些工程师交谈，他们对他们辛勤应用的查询优化未能解决问题感到惊讶和有些不高兴。直接查询优化是必要的，但不总是足够的。优化过的查询可能在不同情况下会成为问题或者变得有问题。当你无法进一步优化查询（或者根本无法优化它，因为你无法访问源代码）时，你可以围绕查询进行优化，这将引导我们进入第二部分旅程：间接查询优化。
- en: Indirect Query Optimization
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**间接查询优化**'
- en: '*Indirect query optimization* is changes to data and access patterns. Instead
    of changing a query, you change what the query accesses and how: its data and
    access patterns, respectively. These changes indirectly optimize the query because
    query, data, and access patterns are inextricable with respect to performance.
    Changes to one influence the others. It’s easy to prove.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*间接查询优化*是对数据和访问模式的更改。与其更改查询，你可以更改查询访问的内容和方式：分别是它的数据和访问模式。这些更改间接优化了查询，因为查询、数据和访问模式在性能方面是不可分割的。其中一个的变化会影响其他的。这点容易证明。'
- en: 'Suppose you have a slow query. Data size and access patterns don’t matter for
    this proof, so imagine whatever you like. I can reduce query response time to
    near-zero. (Let’s say near-zero is 1 microsecond. For a computer that’s a long
    time, but for a human it’s imperceptible.) The indirect “optimization” is: `TRUNCATE
    TABLE`. With no data, MySQL can execute any query in near-zero time. That’s cheating,
    but it nonetheless proves the point: reducing data size improves query response
    time.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个慢查询。数据大小和访问模式对于这个证明并不重要，所以你可以想象任何你喜欢的情景。我可以将查询响应时间减少到接近零。 （比如说接近零是 1 微秒。对于计算机来说是很长的时间，但对于人类来说几乎是不可察觉的。）间接的“优化”是：`TRUNCATE
    TABLE`。没有数据时，MySQL 可以在接近零的时间内执行任何查询。这是作弊，但它无论如何证明了一个观点：减少数据大小可以提高查询响应时间。
- en: 'Let’s revisit the car analogy. Indirect query optimization is analogous to
    changing major design elements of the car. For example, weight is a factor in
    fuel efficiency: decreasing weight increases fuel efficiency. (Data is analogous
    to weight, which is why `TRUNCATE TABLE` dramatically increases performance—but
    don’t use this “optimization.”) Reducing weight is not a straightforward (direct)
    change because engineers can’t magically make parts weigh less. Instead, they
    have to make significant changes, such as switching from steel to aluminum, which
    can affect many other design elements. Consequently, these changes require a greater
    level of effort.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新思考一下汽车的类比。间接查询优化类似于更改汽车的主要设计元素。例如，重量是燃油效率的一个因素：减少重量可以增加燃油效率。（数据类似于重量，这就是为什么
    `TRUNCATE TABLE` 可以显著提高性能的原因，但不要使用这种“优化”方法。）减少重量不是一个直接的（直接）变化，因为工程师们不能神奇地使零件重量减少。相反，他们必须进行重大的更改，比如从钢材到铝材的转换，这可能会影响许多其他设计元素。因此，这些变化需要更多的努力。
- en: A greater level of effort is why indirect query optimization is part two of
    the journey. If direct query optimization solves the problem, then stop—be efficient.
    (And congratulations.) If it doesn’t and you’re certain the query cannot be further
    optimized, then it’s time to change data and access patterns, which Chapters [3](ch03.html#ch03)
    and [4](ch04.html#ch04) cover.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 更大程度的努力是为什么间接查询优化是旅程的第二部分。如果直接查询优化解决了问题，那么停止——效率至上。（并祝贺你。）如果没有解决问题，并且你确信查询无法进一步优化，那么现在是改变数据和访问模式的时候了，第[3章](ch03.html#ch03)和[4章](ch04.html#ch04)介绍了这部分内容。
- en: When to Optimize Queries
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时优化查询
- en: 'When you fix a slow query, another one takes its place. There will always be
    slow queries, but you should not always optimize them because it’s not an efficient
    use of your time. Instead, recall [“North Star”](#north-star) and ask: is query
    response time acceptable? If not, then please continue optimizing queries. If
    yes, then you’re done for now because when the database is fast, nobody looks
    or asks questions.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修复一个慢查询时，另一个会顶替它的位置。总会有慢查询存在，但你不应总是优化它们，因为这不是高效利用你的时间。相反，请记住[“北极星”](#north-star)并问：查询响应时间是否可接受？如果不是，请继续优化查询。如果是，请暂时告一段落，因为当数据库运行快速时，没人会再去关注或提问。
- en: As a DBA, I would like you to review query metrics (starting with the [“Query
    profile”](#query-profile)) every week and optimize the slowest queries *if needed*,
    but as a software engineer I know that’s not practical and almost never happens.
    Instead, here are three occasions when you should optimize queries.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据库管理员，我希望你每周审查查询指标（从[“查询概要”](#query-profile)开始）并在必要时优化最慢的查询，但作为软件工程师，我知道这是不切实际的，几乎从不发生。而是在这里，有三个场合你应该优化查询。
- en: Performance Affects Customers
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能影响客户
- en: When performance affects customers, it is the duty of engineers to optimize
    queries. I don’t think any engineer would disagree; rather, engineers are eager
    to improve performance. Some might say this is bad advice because it’s reactive,
    not proactive, but my overwhelming experience is that engineers (and even DBAs)
    don’t look at query metrics until customers report that the application is too
    slow or timing out. As long as query metrics are always on and at the ready, this
    is an objectively good time to optimize queries because the need for better performance
    is as real as your customers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当性能影响到客户时，工程师有责任优化查询。我不认为有任何工程师会反对；相反，工程师渴望提高性能。有人可能会说这是个坏建议，因为它是被动而非主动的，但我极力认为工程师（甚至是数据库管理员）在客户报告应用程序过慢或超时之前不会查看查询指标。只要查询指标始终保持开启并准备就绪，这是优化查询的一个绝佳时机，因为客户需要更好的性能同样真实。
- en: Before and After Code Changes
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码更改之前和之后
- en: 'Most engineers don’t argue against prioritizing query optimization before and
    after code changes, but my experience is that they don’t do it, either. I implore
    you to avoid this common pattern: seemingly innocent changes are made to code,
    vetted in staging, deployed to production, then performance starts to “swirl the
    bowl” (a colorful metaphor related to toilets that means “become worse”). What
    happened? The cause is usually changes to queries and access patterns, which are
    closely related. [Chapter 2](ch02.html#ch02) begins to explain why; Chapters [3](ch03.html#ch03)
    and [4](ch04.html#ch04) complete the explanation. For now, the point is: you will
    be a hero if you review query metrics before and after code changes.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工程师不会反对在代码更改之前和之后优先考虑查询优化，但我的经验是，他们也没有这样做。我恳请你避免这种常见模式：代码进行了看似无害的更改，在演绎环境中经过验证，部署到生产环境后，性能开始“旋转碗”（这是一个与马桶相关的色彩丰富的隐喻，意思是“变得更糟”）。发生了什么？通常原因是查询和访问模式的更改，这两者密切相关。[第2章](ch02.html#ch02)开始解释原因；第[3章](ch03.html#ch03)和[4章](ch04.html#ch04)完整解释。目前的重点是：如果在代码更改之前和之后查看查询指标，你将成为英雄。
- en: Once a Month
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个月一次
- en: 'Even if your code and queries do not change, at least two things around them
    are changing: data and access patterns. I hope your application is wildly successful
    and stores ever more data as the number of users climbs “up and to the right.”
    Query response time changes over time as data and access patterns change. Fortunately,
    these changes are relatively slow, usually on the order of weeks or months. Even
    for an application experiencing hyper-growth (for example, adding thousands of
    new users every day to millions of existing users), MySQL is really good at scaling
    up so that query response time remains stable—but nothing lasts forever (even
    the stars die). There is always a point at which good queries go bad. This reality
    becomes clear after Chapters [3](ch03.html#ch03) and [4](ch04.html#ch04). For
    now, the point is: you will rise from hero to legend—possibly with song and story
    written about you—if you review query metrics once a month.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的代码和查询不改变，它们周围的至少两件事情在改变：数据和访问模式。希望你的应用取得巨大成功，随着用户数量的增长，“上升并向右移动”，它存储的数据越来越多。随着数据和访问模式的改变，查询响应时间也会随之改变。幸运的是，这些变化相对较慢，通常在几周或几个月的时间尺度上。即使是经历超级增长的应用（例如，每天向现有数百万用户添加成千上万的新用户），MySQL
    在扩展方面表现非常出色，使得查询响应时间保持稳定——但没有什么能永远持续下去（即使星星也会灭亡）。总会有一个好的查询变坏的时刻。在第 [3](ch03.html#ch03)
    和 [4](ch04.html#ch04) 章之后，这一现实变得清晰。目前的重点是：如果你每个月审查一次查询指标，你可能会从英雄变成传奇——也许还会有歌曲和故事以你为主题。
- en: 'MySQL: Go Faster'
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL：加速
- en: There is no magic or secret to make MySQL significantly faster without changing
    queries or the application. Here’s another true story to illustrate what I mean.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何魔法或秘密可以让 MySQL 在不改变查询或应用程序的情况下显著加快速度。这里有另一个真实故事来说明我的意思。
- en: A team of developers learned that their application was going to be mentioned
    by a celebrity. They expected a flood of traffic, so they planned ahead to ensure
    that MySQL and the application would survive. An engineer on the team asked me
    to help increase MySQL throughput (QPS). I asked, “By how much?” She said, “By
    100x”. I said, “Sure. Do you have a year and a willingness to rearchitect the
    application?” She said, “No, we have one day.”
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开发团队得知他们的应用将被名人提及。他们预计会有大量的流量，因此他们提前计划确保 MySQL 和应用程序能够生存。团队中的一名工程师请我帮忙增加 MySQL
    的吞吐量（QPS）。我问：“增加多少？”她说：“增加 100 倍。”我说：“当然。你有一年的时间和重新架构应用程序的意愿吗？”她说：“不，我们只有一天。”
- en: 'I understand what the engineer was thinking: how much throughput could MySQL
    handle if we *significantly* upgraded the hardware—more CPU cores, more memory,
    more IOPS? There’s no simple or single answer because it depends on many factors
    that this book explores in the coming chapters. But one thing is certain: *time
    is a hard limit*.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我理解工程师的想法：如果我们*显著*升级硬件——更多的 CPU 核心、更多的内存、更多的 IOPS，MySQL 能处理多少吞吐量？这并不是一个简单或单一的答案，因为它取决于这本书在即将探讨的许多因素。但有一件事是肯定的：*时间是一个硬限制*。
- en: 'There are 1,000 milliseconds in 1 second—no more, no less. If a query takes
    100 milliseconds to execute, then its worst-case throughput is 10 QPS per CPU
    core: 1,000 ms / 100 ms/query = 10 QPS. (Its real throughput is likely higher—more
    on this in a moment.) If nothing changes, then there’s simply no more time to
    execute the query with greater throughput.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一秒钟有 1,000 毫秒——多一毫秒不少。如果一个查询执行需要 100 毫秒，那么它的最坏情况吞吐量是每个 CPU 核心 10 个 QPS：1,000
    毫秒 / 100 毫秒/查询 = 10 QPS。（实际吞吐量可能更高——稍后会详细说明。）如果什么都不变，那么就没有更多时间来以更高的吞吐量执行查询了。
- en: 'To make MySQL do more work in the same amount of time, you have three options:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 MySQL 在相同的时间内执行更多工作，你有三个选择：
- en: Change the nature of time
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变时间的本质
- en: Decrease response time
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少响应时间
- en: Increase load
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加负载
- en: Option one is beyond the scope of this book, so let’s focus on options two and
    three.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 选项一超出了本书的范围，所以让我们专注于选项二和选项三。
- en: 'Decreasing response time frees time that MySQL can use to do more work. It’s
    simple math: if MySQL is busy 999 milliseconds out of every second, then it has
    one free millisecond to do more work. If that’s not enough free time, then you
    must decrease the time that the current work is consuming. The best way to accomplish
    that: direct query optimization. Failing that: indirect query optimization. And
    finally: better, faster hardware. The following chapters teach you how.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 减少响应时间释放出 MySQL 可用来执行更多工作的时间。这是简单的数学问题：如果 MySQL 每秒钟忙碌 999 毫秒，那么它就有一毫秒的空闲时间来做更多工作。如果这还不够的话，那么你必须减少当前工作消耗的时间。实现这一目标的最佳方法是：直接的查询优化。如果无法实现这一点：间接的查询优化。最后：更好、更快的硬件。接下来的章节将教会你如何做到这一点。
- en: 'Increasing load—the number of queries executing concurrently—tends to happen
    first because it doesn’t require any query or application changes: simply execute
    more queries at once (concurrently), and MySQL responds by using more CPU cores.
    This happens because one CPU core executes one thread, which executes one query.
    Worst case, MySQL uses N CPU cores to execute N queries concurrently. But the
    worst case is practically nonexistent because response time is not CPU time. A
    nonzero amount of response time is CPU time, and the rest is [off-CPU](https://oreil.ly/drw2d).
    For example, response time might be 10 ms of CPU time and 90 ms of disk I/O wait.
    Therefore, the worst-case throughput for a query that takes 100 milliseconds to
    execute is 10 QPS per CPU core, but its real throughput should be higher since
    the worst case is practically nonexistent. Sounds great, right? Just push MySQL
    harder and voilà: more performance. But you know how the story ends: push MySQL
    too hard and it stops working because every system has finite capacity. MySQL
    can easily push most modern hardware to its limits, but don’t try it until you’ve
    read [“Performance Destabilizes at the Limit”](ch04.html#perf-at-the-limit).'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 增加负载——并发执行的查询数量——往往是首先发生的，因为它不需要任何查询或应用程序更改：只需同时执行更多查询（并发执行），MySQL会通过使用更多CPU核心来响应。这是因为一个CPU核心执行一个线程，该线程执行一个查询。最坏的情况是，MySQL使用N个CPU核心并发执行N个查询。但实际上最坏的情况是几乎不存在，因为响应时间不是CPU时间。响应时间中有非零的CPU时间，其余的是[非CPU](https://oreil.ly/drw2d)时间等待磁盘I/O。例如，响应时间可能是CPU时间的10毫秒和磁盘I/O等待的90毫秒。因此，一个执行时间为100毫秒的查询的最坏情况吞吐量为每CPU核心10个QPS，但实际吞吐量应该更高，因为最坏情况实际上几乎不存在。听起来不错，对吧？只需更加努力地推动MySQL，然后就能获得更好的性能。但你知道故事的结局：过度推动MySQL，它会停止工作，因为每个系统都有有限的容量。MySQL可以轻松推动大多数现代硬件的极限，但在阅读[“性能在极限处不稳定”](ch04.html#perf-at-the-limit)之前不要尝试这样做。
- en: 'Bottom line: MySQL cannot simply *go faster*. To make MySQL go faster, you
    must embark on the journey of direct and indirect query optimization.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确一点：MySQL 不能简单地*变快*。要让MySQL变快，你必须进行直接和间接的查询优化之旅。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter expounded query time so that, in subsequent chapters, you can
    learn how to improve it. The central takeaway points are:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详述了查询时间，以便在随后的章节中学习如何改进它。主要的要点是：
- en: 'Performance is *query response time*: how long it takes MySQL to execute a
    query.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能即*查询响应时间*：MySQL执行查询所需的时间。
- en: Query response time is the North Star of MySQL performance because it is *meaningful*
    and *actionable*.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询响应时间是MySQL性能的北极星，因为它是*有意义*且*可操作*的。
- en: Query metrics originate from the slow query log or the Performance Schema.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询指标来自于慢查询日志或性能模式。
- en: The Performance Schema is the best source of query metrics.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能模式是查询指标的最佳来源。
- en: 'Query metrics are grouped and aggregated by *digest*: normalized SQL statements.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询指标按*摘要*分组和聚合：标准化的SQL语句。
- en: A *query profile* shows slow queries; *slow* is relative to the sort metric.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询配置文件*显示慢查询；*慢*是相对于排序度量的。'
- en: A *query report* shows all available information for one query; it’s used for
    query analysis.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询报告*显示一个查询的所有可用信息；用于查询分析。'
- en: The goal of *query analysis* is understanding query execution, not solving slow
    response time.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询分析*的目标是理解查询执行过程，而不是解决响应时间慢的问题。'
- en: Query analysis uses query metrics (as reported), metadata (EXPLAIN plans, table
    structures, and so on), and knowledge of the application.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询分析使用查询指标（按报告）、元数据（解释计划、表结构等）和应用程序知识。
- en: 'Nine query metrics are essential to every query analysis: query time, lock
    time, rows examined, rows sent, row affected, select scan, select full join, created
    tmp disk tables, and query count.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个查询分析都需要九个查询指标：查询时间、锁定时间、检查的行数、发送的行数、受影响的行数、选择扫描、选择全连接、创建的临时磁盘表和查询计数。
- en: 'Improving query response time (query optimization) is a two-part journey: direct
    query optimization, then indirect query optimization.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改善查询响应时间（查询优化）是一个两部分的过程：直接查询优化，然后间接查询优化。
- en: '*Direct query optimization* is changes to queries and indexes.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接查询优化*是对查询和索引的更改。'
- en: '*Indirect query optimization* is changes to data and access patterns.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*间接查询优化*是对数据和访问模式的更改。'
- en: At the very least, review the query profile and optimize slow queries when performance
    affects customers, before and after code changes, and once a month.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少在性能影响客户之前和之后的代码更改前，以及每月一次，查看查询配置文件并优化慢查询。
- en: To make MySQL go faster, you must decrease response time (free time to do more
    work) or increase load (push MySQL to work harder).
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使MySQL运行更快，您必须减少响应时间（用于执行更多工作的空闲时间）或增加负载（推动MySQL更加努力）。
- en: The next chapter teaches MySQL indexes and indexing—direct query optimization.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将教授MySQL索引和索引——直接查询优化。
- en: 'Practice: Identify Slow Queries'
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践：识别慢查询
- en: 'The goal of this practice is to identify slow queries using [pt-query-digest](https://oreil.ly/KU0hj):
    a command-line tool that generates a query profile and query reports from a slow
    query log.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此实践的目标是使用[pt-query-digest](https://oreil.ly/KU0hj)识别慢查询：这是一个从慢查询日志生成查询概要和查询报告的命令行工具。
- en: Warning
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Use a development or staging MySQL instance—do not use production unless you
    are confident that it will not cause problems. The slow query log is inherently
    safe, but enabling it on a busy server can increase disk I/O.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开发或演示MySQL实例——不要使用生产环境，除非您确信不会引起问题。慢查询日志本质上是安全的，但在繁忙的服务器上启用它可能会增加磁盘I/O。
- en: If you have DBAs who manage MySQL, ask them to enable and configure the slow
    query log. Or, you can learn how by reading [“The Slow Query Log”](https://oreil.ly/Hz0Sz)
    in the MySQL manual. (You need a MySQL user account with `SUPER` privileges to
    configure MySQL.) If you’re using MySQL in the cloud, read the cloud provider
    documentation to learn how to enable and access the slow query log.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有管理MySQL的DBA，请要求他们启用和配置慢查询日志。或者，您可以通过阅读MySQL手册中的[“慢查询日志”](https://oreil.ly/Hz0Sz)来学习如何操作（您需要一个具有`SUPER`权限的MySQL用户帐户来配置MySQL）。如果您在云中使用MySQL，请阅读云服务提供商的文档，了解如何启用和访问慢查询日志。
- en: 'MySQL configurations vary, but the simplest way to configure and enable the
    slow query log is:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的配置各不相同，但配置和启用慢查询日志的最简单方法是：
- en: '[PRE10]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Zero in the first statement, `SET GLOBAL long_query_time=0;`, causes MySQL
    to log *every query*. Be careful: on a busy server, this can increase disk I/O
    and use gigabytes of disk space. If needed, use a slightly larger value like `0.0001`
    (100 microseconds) or `0.001` (1 millisecond).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一条语句中，`SET GLOBAL long_query_time=0;`会导致MySQL记录*每个查询*。请注意：在繁忙的服务器上，这可能会增加磁盘I/O并使用大量磁盘空间。如果需要，请使用稍大一些的值，如`0.0001`（100微秒）或`0.001`（1毫秒）。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Percona Server and MariaDB Server support slow query log sampling: set system
    variable `log_slow_rate_limit` to log every Nth query. For example, `log_slow_rate_limit
    = 100` logs every 100th query, which equals 1% of all queries. Over time, this
    creates a representative sample when combined with `long_query_time = 0`. When
    using this feature, be sure that the query metric tool accounts for sampling,
    else it will under report values. `pt-query-digest` accounts for sampling.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Percona Server和MariaDB Server支持慢查询日志抽样：设置系统变量`log_slow_rate_limit`以记录每N个查询中的第N个。例如，`log_slow_rate_limit
    = 100`表示每100个查询记录一次，相当于所有查询的1%。随着时间的推移，结合`long_query_time = 0`，这将创建一个代表性的样本。在使用此功能时，请确保查询度量工具能够考虑抽样，否则它会报告不准确的值。`pt-query-digest`已考虑了抽样。
- en: The last statement, `SELECT @@GLOBAL.slow_query_log_file;`, outputs the slow
    query log filename that you need as the first command line argument to `pt-query-digest`.
    You can dynamically change this variable if you want to log to a different file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句，`SELECT @@GLOBAL.slow_query_log_file;`，输出您需要作为`pt-query-digest`第一个命令行参数的慢查询日志文件名。如果需要，您可以动态更改此变量以将日志记录到不同的文件中。
- en: 'Second, run `pt-query-digest` with the slow query log filename as the first
    command line argument. The tool will print a lot of output; but for now, look
    at the `Profile` near the top of the output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，使用`pt-query-digest`将慢查询日志文件名作为第一个命令行参数运行。该工具会输出大量内容；但现在，只需查看输出顶部附近的`Profile`：
- en: '[PRE11]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding output is a text-based table listing the slowest queries from
    the slow query log. In this example, `SELECT tbl` (a query abstract) is the slowest
    query, accounting for 53.8% of total execution time. (By default, `pt-query-digest`
    sorts queries by percentage execution time.) Below the query profile, a query
    report is printed for each query.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是一个基于文本的表格，列出了慢查询日志中最慢的查询。在本例中，`SELECT tbl`（一个查询摘要）是最慢的查询，占总执行时间的53.8%。（默认情况下，`pt-query-digest`按百分比执行时间对查询进行排序。）在查询概要下方，为每个查询打印了一个查询报告。
- en: 'Explore the `pt-query-digest` output. Its manual documents the output, and
    there is a trove of information on the internet because the tool is widely used.
    Also check out [Percona Monitoring and Management](https://oreil.ly/rZSx2): a
    comprehensive database monitoring solution that uses [Grafana](https://grafana.com)
    to report query metrics. Both tools are free, open source, and supported by [Percona](https://percona.com).'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 探索`pt-query-digest`的输出。其手册详细记录了输出内容，在互联网上有大量信息，因为这个工具被广泛使用。还要查看[Percona 监控与管理](https://oreil.ly/rZSx2)：这是一个综合性的数据库监控解决方案，使用[Grafana](https://grafana.com)报告查询指标。这两个工具都是免费的、开源的，并得到[Percona](https://percona.com)的支持。
- en: 'By reviewing slow queries, you know exactly which queries to optimize for the
    most efficient performance gains. More importantly, you’ve begun to practice MySQL
    performance like an expert: with a focus on queries, because performance is query
    response time.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过审查慢查询，您可以准确知道哪些查询需要优化以获得最高效的性能提升。更重要的是，您已经开始像专家一样练习 MySQL 性能：专注于查询，因为性能就是查询响应时间。
- en: '^([1](ch01.html#idm45829115580240-marker)) Latency is delay inherent in the
    system. Query response time is not a delay inherent in MySQL; it comprises various
    latencies: network, storage, and so on.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm45829115580240-marker)) 延迟是系统固有的延迟。查询响应时间不是 MySQL 中固有的延迟；它包括各种延迟：网络延迟、存储延迟等等。
- en: ^([2](ch01.html#idm45829113296432-marker)) Unless `STRAIGHT_JOIN` is used—but
    don’t use this. Let the MySQL query optimizer choose the join order for the best
    query execution plan. It’s almost always right, so trust it unless you can prove
    it wrong.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#idm45829113296432-marker)) 除非使用`STRAIGHT_JOIN`—但不要使用这个选项。让 MySQL
    查询优化器选择最佳的查询执行顺序。它几乎总是正确的，所以除非能证明它错了，否则要相信它。
- en: ^([3](ch01.html#idm45829115011648-marker)) For a full explanation of percentiles,
    see [HackMySQL](https://hackmysql.com/p95).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#idm45829115011648-marker)) 欲了解百分位数的详细解释，请参阅[HackMySQL](https://hackmysql.com/p95)。
- en: ^([4](ch01.html#idm45829115006912-marker)) P95, P99, and P999 are conventional.
    I’ve never seen other percentiles used with MySQL—median (P50) and maximum (P100)
    notwithstanding.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01.html#idm45829115006912-marker)) P95、P99 和 P999 是常规的百分位数。我从未见过 MySQL
    使用其他百分位数的情况——中位数（P50）和最大值（P100）除外。
