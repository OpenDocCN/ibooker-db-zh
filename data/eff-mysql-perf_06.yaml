- en: Chapter 6\. Server Metrics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 服务器指标
- en: 'MySQL metrics are closely related to MySQL performance—that’s obvious. After
    all, the purpose of metrics in any system is to measure and report how the system
    is operating. What’s not obvious is how they are related. It’s not unreasonable
    if you currently see MySQL metrics as depicted in [Figure 6-1](#mysql-metrics-blackbox):
    MySQL is a black box with metrics inside that, in some way, indicate something
    about MySQL.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL指标与MySQL性能密切相关——这是显而易见的。毕竟，任何系统中指标的目的都是测量和报告系统的运行情况。不明显的是它们如何相关。如果你当前看到MySQL指标如[图6-1](#mysql-metrics-blackbox)所示：MySQL是一个黑匣子，其中的指标以某种方式指示MySQL的一些情况，那也不是没有道理。
- en: '![emsp 0601](assets/emsp_0601.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0601](assets/emsp_0601.png)'
- en: 'Figure 6-1\. MySQL as a black box: metrics are not revealing'
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 第6章图示1：MySQL作为黑匣子：指标无法揭示
- en: 'That view is not unreasonable (or uncommon) because MySQL metrics are often
    discussed but never taught. Even in my career with MySQL, I have never read or
    heard an exposition of MySQL metrics—and I have worked with people who created
    them. The lack of pedagogy for MySQL metrics is due to a false presumption that
    metrics do not require understanding or interpretation because their meaning is
    self-evident. That presumption has a semblance of truth when considering a single
    metric in isolation, such as `Threads_running`; it’s the number of threads running—what
    more is there to know? But isolation is the fallacy: MySQL performance is revealed
    through a spectrum of MySQL metrics.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种观点并不无理（或者不常见），因为MySQL指标经常被讨论但从未被教授。即使在我的MySQL职业生涯中，我也从未阅读过或听说过关于MySQL指标的阐述——我曾与创建这些指标的人一起工作。对MySQL指标缺乏教学的原因是一种错误的假设，即指标不需要理解或解释，因为它们的含义是不言自明的。这种假设在考虑单个指标时似乎是正确的，比如`Threads_running`；它是运行线程的数量——还有什么需要知道的？但孤立是错误的：MySQL的性能通过一系列MySQL指标揭示出来。
- en: Think of MySQL as a prism. The application figuratively shines a workload into
    MySQL. That workload physically interacts with MySQL and the hardware on which
    it runs. Metrics are the spectrum revealed by the figurative refraction of the
    workload through MySQL, as depicted in [Figure 6-2](#mysql-metrics-prism).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 把MySQL想象成一个棱镜。应用程序象征性地将工作负载投射到MySQL中。这个工作负载在物理上与MySQL及其运行的硬件相互作用。指标是通过这种象征性的工作负载通过MySQL折射出的光谱，如[图6-2](#mysql-metrics-prism)所示。
- en: '![emsp 0602](assets/emsp_0602.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0602](assets/emsp_0602.png)'
- en: 'Figure 6-2\. MySQL as a prism: metrics reveal workload performance'
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 第6章图示2：MySQL作为棱镜：指标揭示工作负载性能
- en: 'In the physical sciences, this technique is called *spectrometry*: understanding
    matter through its interaction with light. For MySQL, this is more than a clever
    analogy, it’s the actual relationship between MySQL metrics and MySQL server performance,
    and there are two proofs:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理科学中，这种技术称为*光谱学*：通过其与光的相互作用来理解物质。对于MySQL而言，这不仅仅是一个巧妙的类比，而是MySQL指标与MySQL服务器性能之间的实际关系，并有两个证明：
- en: When you shine a light through a real prism, the resulting color spectrum reveals
    properties of the light, not the prism. Likewise, when you run a workload on MySQL,
    the resulting metrics reveal properties of the workload, not MySQL.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你通过真实的棱镜照射光线时，产生的颜色光谱揭示了光的属性，而不是棱镜本身。同样地，当你在MySQL上运行工作负载时，产生的指标揭示了工作负载的属性，而不是MySQL的。
- en: 'Given previous chapters—especially [“MySQL Does Nothing”](ch04.html#mysql-does-nothing)—performance
    is directly attributable to workload: queries, data, and access patterns. Without
    a workload, all metric values are zero (generally speaking).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鉴于前几章——特别是[“MySQL什么也不做”](ch04.html#mysql-does-nothing)——性能直接归因于工作负载：查询、数据和访问模式。没有工作负载，所有的指标值都是零（一般而言）。
- en: Viewed this way, MySQL metrics can be taught in a new light, and that is the
    focus of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式看，MySQL指标可以被以一种新的方式教授，这正是本章的重点。
- en: 'This analogy has another pedagogical utility: it separates MySQL metrics into
    *spectra* (the plural of *spectrum*). This is very useful because MySQL metrics
    are vast and unorganized (several hundred metrics strewn throughout MySQL), but
    effective teaching requires focus and organization. As a result, the [“Spectra”](#spectra)
    section, which illuminates over 70 metrics divided into 11 spectra, makes up the
    bulk of this chapter.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类比还有另一个教育上的用途：将MySQL指标分解成*光谱*（光谱的复数）。这非常有用，因为MySQL指标非常广泛且杂乱（分散在MySQL中的几百个指标），但有效的教学需要焦点和组织。因此，“光谱”部分，将超过70个指标分为11个光谱，占据了本章的大部分内容。
- en: 'A final note before we shine a light on MySQL: only a fraction of metrics are
    essential for understanding and analyzing MySQL server performance. The relevance
    and importance of the remaining metrics varies widely:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为MySQL开绿灯之前的最后一条注意事项：理解和分析MySQL服务器性能仅需关注一小部分指标。其余指标的相关性和重要性差异很大：
- en: Some are noise
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些只是噪音
- en: Some are historical
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些是历史性的
- en: Some are disabled by default
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些默认情况下是禁用的
- en: Some are very technically specific
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些非常技术特定
- en: Some are only useful in specific cases
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些仅在特定情况下有用
- en: Some are informational, not proper metrics
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些只是信息性的，而不是合适的度量标准
- en: Some are inscrutable by feeble mortal creatures
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些被微不足道的凡人所难解
- en: 'This chapter analyzes the spectra of MySQL metrics that are essential for understanding
    how the workload interacts with and affects MySQL server performance. There are
    six major sections. The first draws a distinction between query performance and
    server performance. Previous chapters focus on the former, but this chapter focuses
    on the latter. The second is boring—you’ll see why. The third lists key performance
    indicators (KPIs) that quickly gauge MySQL performance. The fourth explores the
    field of metrics: a model to more deeply understand how metrics describe and relate
    to MySQL server performance. The fifth presents the spectra of MySQL metrics:
    over 70 MySQL metrics organized into 11 spectra—an epic and exciting journey that
    tours the inner workings of MySQL, after which you will see MySQL in a new light.
    The sixth addresses important topics related to monitoring and alerting.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析了MySQL指标的光谱，这些指标对理解工作负载如何影响MySQL服务器性能至关重要。本章包括六个主要部分。第一部分区分了查询性能和服务器性能。之前的章节侧重于前者，而本章侧重于后者。第二部分比较枯燥——你会明白为什么。第三部分列出了快速衡量MySQL性能的关键绩效指标（KPI）。第四部分探讨了指标的领域：一个更深入理解指标如何描述和与MySQL服务器性能相关联的模型。第五部分介绍了MySQL指标的光谱：超过70个MySQL指标组织成11个光谱——一次史诗般的旅程，带领你深入了解MySQL的内部工作原理，之后你将以新的视角看待MySQL。第六部分讨论了与监控和警报相关的重要主题。
- en: Query Performance Versus Server Performance
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询性能与服务器性能对比
- en: 'MySQL performance has two sides: query performance and server performance.
    Previous chapters address *query performance*: improving response time by optimizing
    the workload. This chapter addresses *server performance*: analyzing the performance
    of MySQL as a function of executing the workload.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL性能有两个方面：查询性能和服务器性能。之前的章节涉及*查询性能*：通过优化工作负载来提高响应时间。本章涉及*服务器性能*：分析MySQL作为执行工作负载功能的性能。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, *MySQL performance* means *server performance*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，*MySQL性能*意味着*服务器性能*。
- en: In simplest terms, the workload is input and server performance is output, as
    shown in [Figure 6-3](#query-and-server-perf).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，工作负载是输入，服务器性能是输出，如[图6-3](#query-and-server-perf)所示。
- en: If you put an optimized workload into MySQL, you get high performance out of
    MySQL. Server performance is almost always an issue with the workload, not MySQL.
    Why? Because MySQL is incredibly good at executing a variety of workloads. MySQL
    is a mature, highly optimized data store—*decades* of tuning by world-class database
    experts. That’s why the first five chapters of this book extol query performance,
    and only one chapter (this one) analyzes server performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将优化的工作负载输入MySQL，你将获得高性能的MySQL输出。服务器性能几乎总是与工作负载有关，而不是MySQL本身。为什么？因为MySQL在执行各种工作负载时非常出色。MySQL是一个经过充分优化的成熟数据存储系统——世界级数据库专家调优了几十年。这就是为什么本书的前五章赞扬查询性能，而仅有一章（本章）分析服务器性能的原因。
- en: '![emsp 0603](assets/emsp_0603.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0603](assets/emsp_0603.png)'
- en: Figure 6-3\. Query and server performance
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3\. 查询和服务器性能
- en: 'There are three reasons to analyze server performance:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个原因需要分析服务器性能：
- en: Concurrency and contention
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和争用
- en: 'Concurrency leads to contention that reduces query performance. A query executed
    in isolation exhibits different performance when executed with other queries.
    Recall the Universal Scalability Law in [Equation 4-1](ch04.html#usl): contention
    (`α`) is in the divisor of the equation, which means it reduces throughput as
    load increases. Unless you’re living in a different universe than the rest of
    us, concurrency and contention are unavoidable.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并发导致争用，降低查询性能。单独执行的查询与其他查询同时执行时表现不同。回顾[方程式4-1](ch04.html#usl)中的普适可扩展性定律：争用(`α`)位于方程式的分母，这意味着随着负载增加，它会降低吞吐量。除非你生活在不同于我们其他人的宇宙中，否则并发和争用是不可避免的。
- en: Analyzing server performance is most useful and most commonly undertaken to
    see how MySQL handles the workload when all queries (concurrency) are competing
    for shared and limited system resources (contention). Certain workloads have very
    little—if any—contention, while other workloads kill performance—both query and
    server performance—despite the best efforts of MySQL. The access pattern trait
    [“Concurrency”](ch04.html#ap-concurrency) is, unsurprisingly, a major factor in
    contention, but all the access pattern traits are important, too. Analyzing server
    performance reveals how well the queries in the workload play together. As engineers
    responsible for those queries, we need to ensure that they play well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 分析服务器性能最有用且最常见的目的是看看MySQL在所有查询（并发）竞争共享和有限系统资源（争用）时如何处理工作负载。某些工作负载几乎没有争用，而其他工作负载则尽管MySQL尽力也会导致查询和服务器性能下降。访问模式特征[“并发性”](ch04.html#ap-concurrency)在争用中是一个重要因素，但所有访问模式特征也同样重要。分析服务器性能揭示了工作负载中的查询如何相互影响。作为负责这些查询的工程师，我们需要确保它们能良好协作。
- en: Tuning
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 调优
- en: 'Server performance is directly *but not entirely* attributable to workload.
    There are three additional factors in server performance: MySQL, operating system,
    and hardware. In query performance, it’s presumed that MySQL, operating system,
    and hardware are properly configured and adequate for the workload. Problems (like
    faulty hardware) and bugs notwithstanding, these three affect performance far
    less than the workload because we’re living in an age of abundance: MySQL is very
    mature and highly optimized, operating systems are advanced and sophisticated,
    and hardware is fast and affordable.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器性能直接*但不完全*归因于工作负载。服务器性能还受三个因素影响：MySQL、操作系统和硬件。在查询性能方面，假设MySQL、操作系统和硬件都已正确配置并适合工作负载。尽管存在问题（如故障硬件）和错误，但相较于工作负载，这三个因素对性能的影响要小得多，因为我们生活在一个丰盛的时代：MySQL非常成熟且高度优化，操作系统先进且复杂，硬件快速且价格合理。
- en: 'Matters discussed in [“MySQL Tuning”](ch02.html#mysql-tuning) still hold true:
    tuning MySQL is akin to squeezing blood from a turnip. You most likely never need
    to tune MySQL. But if you do, it requires analyzing server performance with a
    known and stable workload; otherwise, you cannot be certain that any performance
    gains are the result of tuning—it’s basic science: controls, variables, reproducibility,
    and falsifiability.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“MySQL调优”](ch02.html#mysql-tuning)中讨论的事项仍然适用：调优MySQL就像从萝卜中榨血一样困难。你很可能永远不需要调优MySQL。但如果你确实需要，它需要用已知且稳定的工作负载分析服务器性能；否则，你无法确定任何性能增益是否是调优的结果。这是基础科学：控制变量、可变性、可重复性和可反驳性。
- en: Performance regressions
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 性能回归
- en: 'I praise MySQL throughout this book, but I would be remiss if I did not, at
    least once, clearly state: sometimes, MySQL is wrong. But MySQL did not become
    the most popular open source relational database in the world by being wrong.
    It is usually correct, and suspecting a performance regression (or bug) is the
    last resort of experts after ensuring that query performance, MySQL tuning, and
    faulty hardware are not the problem.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我一直在赞扬MySQL，但如果我不至少明确一次地说：有时候，MySQL是错的，那我就有失职了。但MySQL并非凭空成为全球最流行的开源关系型数据库。它通常是正确的，在确保查询性能、MySQL调优和故障硬件不是问题之后，怀疑性能回归（或错误）是专家的最后手段。
- en: The blog posts [“Checkpointing in MySQL and MariaDB”](https://oreil.ly/MuRIt)
    and [“More on Checkpoints in InnoDB MySQL 8”](https://oreil.ly/NDQkP) by renowned
    MySQL expert Vadim Tkachenko contain perfect examples of analyzing server performance
    to reveal a performance regression. It’s normal for Vadim to be doing this type
    of work; the rest of us plod through much simpler problems, like indexing and
    whether or not to have a third cup of coffee before lunch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL专家Vadim Tkachenko的博客文章[“MySQL和MariaDB中的检查点”](https://oreil.ly/MuRIt)和[“InnoDB
    MySQL 8中的更多检查点”](https://oreil.ly/NDQkP)提供了分析服务器性能以揭示性能回归的完美示例。Vadim进行这类工作是很正常的；我们其他人则在处理更简单的问题，比如索引和午餐前是否喝第三杯咖啡。
- en: Concurrency and contention are the implicit focus of this chapter because they
    are the responsibility of the engineers who maintain the application that executes
    the queries. Tuning and performance regressions are the responsibility of MySQL
    DBAs and experts. Learning to analyze server performance for the former (concurrency
    and contention) is excellent training for the latter because the difference is
    primarily a matter of focus. I hope the former sparks an interests in the latter
    because the MySQL industry needs more DBAs and experts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和争用是本章的隐含重点，因为它们是负责执行查询的应用程序维护工程师的责任。调整和性能退化是MySQL DBA和专家的责任。学习分析服务器性能对前者（并发和争用）是优秀的训练，因为两者的区别主要是关注的焦点。我希望前者引起对后者的兴趣，因为MySQL行业需要更多的DBA和专家。
- en: 'Normal and Stable: The Best Database Is a Boring Database'
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正常和稳定：最好的数据库是一个无聊的数据库
- en: 'For the most part, *normal* and *stable* are intuitively understood by engineers
    once they become familiar with the application and how its workload runs on MySQL.
    Humans are good at pattern recognition, so it’s easy to see when the charts for
    any metric are unusual. Therefore, I won’t belabor terminology that is generally
    well understood, but I need to make two clarifying points to ensure that we’re
    on the same page, and to address the rare times when engineers ask “What is normal?”
    with respect to MySQL performance:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，*普通*和*稳定*对于工程师来说一旦熟悉应用程序及其在MySQL上的工作负载运行方式就很直观了。人类擅长模式识别，因此很容易看出任何指标图表是否异常。因此，我不会详细解释通常为人所理解的术语，但我需要澄清两点以确保我们理解一致，以及解决工程师偶尔询问“什么是正常？”关于MySQL性能时的情况：
- en: Normal
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正常
- en: Every application, workload, MySQL configuration, and environment are different.
    Therefore, normal is whatever performance MySQL exhibits for your application
    on a typical day when everything is working properly. That normal—your normal—is
    the baseline for determining if some aspect of performance is higher or lower,
    faster or slower, better or worse than normal. It’s as simple as that.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序、工作负载、MySQL配置和环境都是不同的。因此，正常是MySQL在你的应用程序上典型工作日正常运行时表现出来的性能。那个正常——你的正常——是确定性能某个方面是否高于或低于、更快或更慢、更好或更差的基准。就是这么简单。
- en: 'When I state a presumptive norm like “It’s normal for `Threads_running` to
    be less than 50,” it’s only an abbreviation of language, short for “A stable value
    for `Threads_running` is less than 50 given my experience, and given that current
    hardware typically has less than 48 CPU cores, and given that benchmarks show
    that MySQL performance does not currently scale well past 64 running threads.”
    But if 60 threads running is normal and stable for your application, then great:
    you have achieved extraordinary performance.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说一个假定的规范如“`Threads_running`少于50是正常的”时，这只是语言的缩写，简而言之是“根据我的经验，`Threads_running`的稳定值应小于50，以及当前硬件通常具有少于48个CPU核心，并且基准测试显示MySQL性能目前无法有效扩展超过64个运行线程。”但如果60个线程运行对于你的应用程序是正常和稳定的，那太好了：你已经取得了非凡的性能。
- en: Stable
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定
- en: 'Don’t lose sight of stable performance in your quest for greater performance.
    [“Performance Destabilizes at the Limit”](ch04.html#perf-at-the-limit) illustrates
    and explains why squeezing maximum performance from MySQL is not the goal: at
    the limit, performance destabilizes, and then you have bigger problems than performance.
    Stability does not limit performance; it ensures that performance—at any level—is
    sustainable, because that’s what we really want: MySQL fast all the time, not
    sometimes.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在追求更高性能时不要失去稳定性能的视线。[“性能在极限处不稳定”](ch04.html#perf-at-the-limit)说明并解释了为什么从MySQL中挤取最大性能不是目标：在极限处，性能会不稳定，那时你会面临比性能更大的问题。稳定性不限制性能；它确保性能——在任何水平上——都是可持续的，因为这才是我们真正想要的：MySQL始终快速，而不仅仅是有时候。
- en: 'At times, MySQL performance is glamorous—the highs, the lows, the screaming
    fans and packed stadiums—but the real art is optimizing the database into pristine
    boredom: all queries respond quickly, all metrics are stable and normal, and all
    users are happy.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，MySQL的性能是迷人的——高潮、低谷、尖叫的粉丝和挤满的体育场——但真正的艺术是将数据库优化到完美的无聊：所有查询快速响应，所有指标稳定和正常，所有用户都满意。
- en: Key Performance Indicators
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键性能指标
- en: 'Four metrics quickly gauge MySQL performance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 四个指标快速评估MySQL性能：
- en: Response time
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 响应时间
- en: 'Response time is no surprise: as noted in [“North Star”](ch01.html#north-star),
    it’s the only metric anyone truly cares about. Even if response time is great,
    you must factor in other KPIs. For example, if every query fails with an error,
    response time might be amazing (near zero), but that’s not normal. The goal is
    normal and stable response time, and lower is better.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 响应时间不足为奇：正如在[“北极星”](ch01.html#north-star)中指出的那样，它是任何人真正关心的唯一指标。即使响应时间很好，你也必须考虑其他关键绩效指标。例如，如果每个查询都失败并显示错误，响应时间可能非常好（接近零），但这并不正常。目标是正常和稳定的响应时间，较低更好。
- en: Errors
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: 'Errors is the rate of errors. Which errors? At least query errors, but ideally
    all errors: query, connection, client, and server. Don’t expect a zero error rate
    because, for example, there’s nothing you, the application, or MySQL can do if
    a client aborts a connection. The goal is a normal and stable error rate, and
    lower (near zero) is better.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是错误率。哪些错误？至少是查询错误，但理想情况下应该是所有错误：查询、连接、客户端和服务器。不要期望零错误率，因为例如，如果客户端中止连接，你、应用程序或MySQL都无能为力。目标是正常和稳定的错误率，较低（接近零）更好。
- en: QPS
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: QPS
- en: 'Queries per second is also no surprise: executing queries is the main purpose
    and work of MySQL. QPS indicates performance, but it does not equal performance.
    Abnormally high QPS, for example, can signal problems. The goal is normal and
    stable QPS, and the value is arbitrary.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒查询也不足为奇：执行查询是MySQL的主要目的和工作。QPS指示性能，但并不等同于性能。异常高的QPS例如可能会信号问题。目标是正常和稳定的QPS，而值则是任意的。
- en: Threads running
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行线程
- en: Threads running gauges how hard MySQL is working to achieve QPS. One thread
    executes one query, so you must consider both metrics because they’re closely
    related. The goal is normal and stable threads running; lower is better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行线程评估MySQL为实现QPS而努力的程度。一个线程执行一个查询，因此你必须考虑这两个指标，因为它们密切相关。目标是正常和稳定的运行线程，较低更好。
- en: 'I expound these metrics in [“Spectra”](#spectra). Here, the point is that these
    four metrics are the KPIs for MySQL: when the values for all four are normal,
    MySQL performance is practically guaranteed also to be normal. Always monitor
    response time, errors, QPS, and threads running. Whether or not to alert on them
    is discussed later in [“Alert on User Experience and Objective Limits”](#alert-on).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[“光谱”](#spectra)中详述了这些指标。在这里，重点是这四个指标是MySQL的关键绩效指标：当这四个值都正常时，MySQL性能基本上也是正常的。始终监控响应时间、错误、QPS和运行线程。是否在它们上发出警报将在[“用户体验和目标限制上发出警报”](#alert-on)中讨论。
- en: 'Simplifying the performance of a complex system to a handful of metrics is
    not unique to MySQL or computers. For example, you have vital signs (I hope):
    height, weight, age, blood pressure, and heart rate. Five biological metrics succinctly
    and accurately gauge your health. Likewise, four MySQL metrics succinctly and
    accurately gauge server performance. That’s nifty, but what’s really insightful
    is the field of metrics in which all metrics are situated.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂系统的性能简化为少数几个指标并不是MySQL或计算机的特有现象。例如，你有生命体征（希望如此）：身高、体重、年龄、血压和心率。五个生物指标简洁而准确地衡量你的健康。同样，四个MySQL指标简洁而准确地衡量服务器性能。这很巧妙，但真正有见地的是所有指标都位于的指标领域中。
- en: Field of Metrics
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标领域
- en: Every MySQL metric belongs to one of six classes shown as boxes in [Figure 6-4](#field-of-metrics).
    Collectively, I call it the *field of metrics*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MySQL指标都属于[图 6-4](#field-of-metrics)中显示的六个类之一。总体上，我称之为*指标领域*。
- en: '![emsp 0604](assets/emsp_0604.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0604](assets/emsp_0604.png)'
- en: Figure 6-4\. Field of metrics
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 指标领域
- en: MySQL performance cannot be fully understood by analyzing metrics in isolation
    because performance is not an isolated property. Performance is the result of
    many factors for which there are many related metrics. The field of metrics is
    a model to understand how metrics are related. The relationships connect the proverbial
    dots (the metrics) to complete the intricate picture that is MySQL performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 分析孤立的指标不能充分理解MySQL的性能，因为性能不是孤立的属性。性能是许多因素的结果，这些因素有许多相关的指标。指标领域是一个模型，用于理解指标如何相关。这些关系将谚语点（指标）连接起来，完成MySQL性能的复杂图景。
- en: Response Time
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应时间
- en: Response time metrics indicate *how long* MySQL takes to respond. They are top
    level in the field because they encompass (or hide) details from lower levels.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 响应时间指标表示MySQL响应所需的时间。它们处于领域的顶层，因为它们包含（或隐藏）来自较低层的详细信息。
- en: Query response time is, of course, the most important one and the only one commonly
    monitored. MySQL executes statements in stages, and stages can be timed. These
    are response time metrics, too, but they measure around query execution, not within
    it. Actual query execution is just one stage of many. If you recall [Example 1-3](ch01.html#update-stages)
    in [Chapter 1](ch01.html#ch01), executing the actual `UPDATE` of an `UPDATE` statement
    was only 1 of 15 stages. Consequently, stage response times are mostly used by
    MySQL experts to investigate deep server performance issues.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 查询响应时间当然是最重要的，并且是唯一经常监控的。MySQL在阶段中执行语句，可以对阶段进行计时。这些也是响应时间指标，但它们是围绕查询执行而不是在查询内部。实际的查询执行只是许多阶段中的一个阶段。如果你回想一下[例子
    1-3](ch01.html#update-stages) 在[第1章](ch01.html#ch01)中，执行实际的`UPDATE`语句只是15个阶段中的1个。因此，阶段响应时间主要由MySQL专家用于调查深层服务器性能问题。
- en: 'Response time metrics are important but also completely opaque: what was MySQL
    doing that accounts for the time? To answer that, we must dig deeper into the
    field.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 响应时间指标很重要，但也完全不透明：MySQL 在这段时间内究竟做了什么？为了回答这个问题，我们必须深入探讨该领域。
- en: Rate
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率
- en: Rate metrics indicate *how fast* MySQL completes a discrete task. Queries per
    second (QPS) is the ubiquitous and universally known database rate metric. Most
    MySQL metrics are rates because—no surprise—MySQL does many discrete tasks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 速率指标显示了MySQL完成离散任务的*速度*。每秒查询数（QPS）是普遍而广为人知的数据库速率指标。大多数MySQL指标都是速率，因为——不奇怪——MySQL执行许多离散任务。
- en: When a rate increases, it can increase related utilizations. Some rates are
    innocuous and don’t increase utilization, but the important and commonly monitored
    rates do increase utilization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个速率增加时，它可能会增加相关的利用率。有些速率是无害的，并不会增加利用率，但重要且常被监控的速率确实会增加利用率。
- en: The rate-utilization relationship presumes no other changes. That means you
    can increase a rate without increasing utilization only if you change something
    about the rate or the utilization that it affects. It’s usually easier to change
    the rate rather than the utilization because the rate is the cause in the relationship.
    For example, when QPS increases across the board, CPU utilization could increase
    because more queries require more CPU time. (Increasing QPS could increase other
    utilizations; CPU is just one example.) To avoid or reduce the increase in CPU
    utilization, you should optimize the queries so they require less CPU time to
    execute. Or, you could increase the number of CPU cores by scaling up the hardware,
    but [“Better, Faster Hardware!”](ch02.html#better-faster-hardware) and [“Better,
    Faster Hardware?”](ch04.html#better-faster-hardware-again) address the shortcomings
    of this approach.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 速率与利用率的关系假定没有其他变化。这意味着，只要你改变了某个速率或其影响的利用率，你就可以增加速率而不增加利用率。通常情况下，改变速率比改变利用率要容易，因为速率是关系中的原因。例如，当整体QPS增加时，CPU利用率可能会增加，因为更多查询需要更多的CPU时间。（增加QPS可能会增加其他利用率；CPU只是一个例子。）为了避免或减少CPU利用率的增加，你应优化查询，使其执行时需要的CPU时间更少。或者，你可以通过扩展硬件来增加CPU核心数，但是["更好，更快的硬件！"](ch02.html#better-faster-hardware)和["更好，更快的硬件？"](ch04.html#better-faster-hardware-again)解决了这种方法的缺点。
- en: 'The rate-utilization relationship is not a novel insight—you probably already
    knew it—but it’s important to highlight because it’s the beginning of a series
    of relationships that unify the field. Don’t feel sorry for utilization: it pushes
    back.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 速率与利用率的关系并不是一个新颖的见解——你可能已经知道了，但需要强调的是，这是统一领域关系序列的开端。不要为利用率感到抱歉：它是一种推动力。
- en: Utilization
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用率
- en: 'Utilization metrics indicate *how much* MySQL uses a finite resource. Utilization
    metrics are everywhere in computers: CPU usage, memory usage, disk usage, and
    so on. Since computers are finite machines, almost everything can be expressed
    as a utilization because nothing has infinite capacity—not even the cloud.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 利用率指标显示了MySQL使用有限资源的*程度*。利用率指标在计算机中无处不在：CPU使用率，内存使用率，磁盘使用率等等。由于计算机是有限的机器，几乎所有东西都可以表达为利用率，因为没有什么是无限的——即使是云。
- en: '*Bounded rates* can be expressed as a utilization. A rate is bounded if there
    is a maximum rate. Disk I/O, for example, is usually expressed as a rate (IOPS),
    but every storage device has a maximum rate. Therefore, disk I/O utilization is
    the current rate over the maximum rate. By contrast, *unbounded rates* cannot
    be expressed as a utilization because there’s no maximum rate: QPS, bytes sent
    and received, and so forth.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*有界速率*可以表示为利用率。如果存在最大速率，则速率是有界的。例如，磁盘I/O通常表示为速率（IOPS），但每个存储设备都有一个最大速率。因此，磁盘I/O利用率是当前速率除以最大速率。相比之下，*无界速率*无法表示为利用率，因为没有最大速率：例如，QPS，发送和接收的字节数等。'
- en: 'When a utilization increases, it can decrease related rates. I bet you’ve seen
    or experienced something like this before: a rogue query causes 100% disk I/O
    utilization, which causes QPS to drop precipitously, which causes an outage. Or,
    MySQL uses 100% of memory and is killed by the operating system kernel, which
    causes the ultimate rate decrease: to zero. This relationship is an expression
    of the USL (recall [Equation 4-1](ch04.html#usl)) because utilization increases
    contention (`α`) and coherency (`β`), which are in the divisor of the equation.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当利用率增加时，它可能会减少相关速率。我敢打赌你之前见过或经历过这样的情况：一个恶意查询导致100%磁盘I/O利用率，从而导致QPS急剧下降，引发停机。或者，MySQL使用了100%的内存并被操作系统内核终止，这会导致最终速率降至零。这种关系是USL的表达（回想[方程式4-1](ch04.html#usl)），因为利用率增加争用（`α`）和一致性（`β`），这些因素都是方程式的除数。
- en: What happens at *or near* 100% utilization? MySQL waits. In [Figure 6-4](#field-of-metrics),
    this is indicated by the arrow between *Utilization* and *Wait*—the utilization-wait
    relationship. The arrow is labeled *Stall* because query execution waits, then
    resumes—perhaps many times. I emphasize *or near* because, as discussed in [“Performance
    Destabilizes at the Limit”](ch04.html#perf-at-the-limit), stalls can occur before
    100% utilization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近或达到100%利用率时会发生什么？MySQL等待。在[图6-4](#field-of-metrics)中，箭头指示*利用率*和*等待*之间的关系——利用率-等待关系。箭头标记为*停滞*，因为查询执行会等待，然后恢复——也许会发生多次。我强调*或接近*，因为正如在[“性能在极限时不稳定”](ch04.html#perf-at-the-limit)中讨论的那样，停滞可以发生在100%利用率之前。
- en: 'Stalls are anti-stable but unavoidable for two reasons: MySQL load is usually
    greater than hardware capacity; and latency is inherent in all systems, especially
    hardware. The first reason can be ameliorated by reducing load (optimizing the
    workload) or increasing hardware capacity. The second reason is difficult to address
    but not impossible. If, for example, you still use spinning disks, upgrading to
    NVMe storage will dramatically reduce storage latency.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 停滞是反稳定的，但由于两个原因是不可避免的：MySQL负载通常大于硬件容量；延迟在所有系统中都是固有的，特别是在硬件中。第一个原因可以通过减少负载（优化工作负载）或增加硬件容量来缓解。第二个原因难以解决，但并非不可能。例如，如果仍在使用旋转磁盘，升级到NVMe存储将显著减少存储延迟。
- en: Wait
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待
- en: Wait metrics indicate idle time during query execution. Waits occur when query
    execution stalls due to contention and coherency. (Waits also occur due to MySQL
    bugs or performance regressions, but these are exceedingly rare enough not to
    raise concern.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 等待指标表示查询执行过程中的空闲时间。当由于争用和一致性而导致查询执行停滞时，就会发生等待。 （等待也可能由于MySQL的错误或性能退化而发生，但这些情况极为罕见，不值得担忧。）
- en: 'Wait metrics are calculated as rates or response times (depending on the metric),
    but they merit a separate class because they reveal when MySQL is *not working*
    (idle), which is the opposite of performance. *Not working* is why the wait class
    in [Figure 6-4](#field-of-metrics) is darker: MySQL has gone dark.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 等待指标根据速率或响应时间（取决于指标）进行计算，但它们值得一个单独的类别，因为它们揭示了MySQL何时*未工作*（空闲），这与性能相反。*未工作*是为什么[图6-4](#field-of-metrics)中的等待类别更暗的原因：MySQL已经暗淡。
- en: Waits are unavoidable. Eliminating waits is not the goal; the goal is reducing
    and stabilizing them. When waits are stabilized and reduced to an acceptable level,
    they effectively disappear, blending into response time as an inherent part of
    query execution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 等待是不可避免的。消除等待不是目标；目标是减少和稳定等待时间。当等待时间稳定且减少到可接受的水平时，它们实际上会消失，在查询执行的响应时间中融入作为一个固有部分。
- en: 'When MySQL waits too long, it times out—the wait-error relationship. The most
    important, high-level MySQL waits have configurable timeouts:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当MySQL等待时间过长时，它会超时——等待-错误的关系。最重要的高级MySQL等待具有可配置的超时时间：
- en: '[`MAX_EXECUTION_TIME`](https://oreil.ly/H0fwi) (SQL statement optimizer hint)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`MAX_EXECUTION_TIME`](https://oreil.ly/H0fwi)（SQL语句优化提示）'
- en: '[`max_execution_time`](https://oreil.ly/2rdKw)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`max_execution_time`](https://oreil.ly/2rdKw)'
- en: '[`lock_wait_timeout`](https://oreil.ly/WD6p7)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`lock_wait_timeout`](https://oreil.ly/WD6p7)'
- en: '[`innodb_lock_wait_timeout`](https://oreil.ly/4uT4F)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`innodb_lock_wait_timeout`](https://oreil.ly/4uT4F)'
- en: '[`connect_timeout`](https://oreil.ly/R7HwC)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`connect_timeout`](https://oreil.ly/R7HwC)'
- en: '[`wait_timeout`](https://oreil.ly/C7M9a)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`wait_timeout`](https://oreil.ly/C7M9a)'
- en: Use these but don’t rely on them because, for example, take a guess at the default
    value for `lock_wait_timeout`. The default value for `lock_wait_timeout` is 31,536,000
    seconds—365 days. Establishing default values is not easy, so we must give MySQL
    some leeway, but wow—365 days. Consequently, applications should always employ
    code-level timeouts, too. Long-running transactions and queries are a common problem
    because MySQL is fast but, perhaps, too patient.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不要依赖这些方法，因为比如，试着猜一下`lock_wait_timeout`的默认值。`lock_wait_timeout`的默认值是31,536,000秒—365天。设定默认值并不容易，因此我们必须给MySQL一些余地，但哇—365天。因此，应用程序应始终使用代码级的超时机制。长时间运行的事务和查询是一个常见问题，因为MySQL虽然快，但可能太宽容了。
- en: Error
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误
- en: 'Error metrics indicate errors. (I allow myself one tautological statement in
    this book; there it is.) Wait timeouts are one type of error, and there are many
    more (see [“MySQL Error Message Reference”](https://oreil.ly/Jtpqd) for more).
    I don’t need to enumerate MySQL errors because, with respect to server performance
    and MySQL metrics, the point is simple and clear: an abnormal error rate is bad.
    Like waits, errors are also calculated as rates, but they merit a separate class
    because they indicate when MySQL or the client (the application) has failed, which
    is why the error class in [Figure 6-4](#field-of-metrics) is darker.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 错误指标显示错误。（在本书中，我允许自己做一个同义反复的声明；这就是它。）等待超时是一种错误类型，还有许多其他错误（详见[“MySQL错误消息参考”](https://oreil.ly/Jtpqd)）。我不需要列举MySQL的错误，因为就服务器性能和MySQL指标而言，要点是简单明了的：异常错误率是不好的。像等待一样，错误也被计算为速率，但它们值得一个单独的类别，因为它们表明MySQL或客户端（应用程序）失败了，这就是为什么[图6-4](#field-of-metrics)中的错误类别更加黑暗的原因。
- en: 'To reiterate a point about errors from [“Key Performance Indicators”](#kpi):
    don’t expect a zero error rate because, for example, there’s nothing you, the
    application, or MySQL can do if a client aborts a connection.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调关于来自[“关键性能指标”](#kpi)的错误的一点：不要期望零错误率，因为比如，如果客户端中止连接，你、应用程序或MySQL都无能为力。
- en: Access Pattern
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问模式
- en: Access pattern metrics indicate how the application uses MySQL. These metrics
    relate to [“Data Access Patterns”](ch04.html#access-patterns). For example, MySQL
    has metrics for each type of SQL statement (`Com_select`, `Com_insert`, and so
    on) that relate to [“Read/Write”](ch04.html#ap-read-write).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 访问模式指标显示应用程序如何使用MySQL。这些指标与[“数据访问模式”](ch04.html#access-patterns)相关。例如，MySQL为每种类型的SQL语句（`Com_select`、`Com_insert`等）都有指标，与[“读/写”](ch04.html#ap-read-write)有关。
- en: As indicated in [Figure 6-4](#field-of-metrics), access pattern metrics underlie
    higher level metrics. The `Com_select` access pattern metric counts the number
    of `SELECT` statements executed. This can be represented as a rate (`SELECT` QPS)
    or a utilization (`% SELECT`); either way, it reveals something deeper about server
    performance that helps explain higher level metrics. For example, if response
    time is abysmal and the access pattern metric `Select_full_join` is high, that’s
    a smoking gun (see [“Select full join”](ch01.html#Select-full-join)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6-4](#field-of-metrics)所示，访问模式指标构成更高层次的指标。`Com_select`访问模式指标统计执行的`SELECT`语句的数量。这可以表示为速率（`SELECT`
    QPS）或利用率（`% SELECT`）；无论哪种方式，它都揭示了关于服务器性能更深层次的信息，有助于解释更高级别的指标。例如，如果响应时间糟糕，而访问模式指标`Select_full_join`很高，那就是一个罪魁祸首（参见[“Select
    full join”](ch01.html#Select-full-join)）。
- en: Internal
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部
- en: 'There’s a seventh class of metrics shown in [Figure 6-5](#field-of-metrics-with-internal):
    internal metrics.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-5](#field-of-metrics-with-internal)显示的有第七类指标：内部指标。'
- en: '![emsp 0605](assets/emsp_0605.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0605](assets/emsp_0605.png)'
- en: Figure 6-5\. Field of metrics with internal metrics
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5\. 带有内部指标的度量字段
- en: I didn’t mention this class at the beginning of [“Field of Metrics”](#field-of-metrics-toc)
    because, as engineers and users of MySQL, we’re not supposed to know or care about
    it. But it’s the most interesting—if not arcane—part of the field, and I want
    you to be fully informed in case you need or want to fathom the depths of MySQL.
    Down here, things are esoteric.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[“指标领域”](#field-of-metrics-toc)的开头没有提到这一类，因为作为MySQL的工程师和用户，我们不应该知道或关心它。但这是最有趣的—如果不是神秘的—领域的一部分，我希望你完全了解，以防您需要或想要深入了解MySQL的深度。在这里，事情就有点深奥了。
- en: Of course, *esoteric* is subjective. What I consider to be an internal metric
    might be the most favorite and useful rate metric for another engineer. But metrics
    like `buffer_page_read_index_ibuf_non_leaf` make a strong case for the internal
    class of metrics. That metric indicates the number of non-leaf index pages read
    in the change buffer. Not exactly your daily bread.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*深奥* 是主观的。我认为是内部度量的指标可能是另一位工程师最喜欢和有用的速率度量。但像 `buffer_page_read_index_ibuf_non_leaf`
    这样的指标充分说明了内部度量类的重要性。该指标表示变更缓冲区中读取的非叶子索引页数。并不是你每天都会接触到的内容。
- en: Spectra
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光谱
- en: 'Prepare yourself for another journey: into the penumbra of MySQL metrics. This
    section examines over 70 MySQL metrics divided into 11 spectra, some of which
    have sub-spectra. I organize MySQL metrics into spectra for two reasons:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为另一次旅程做好准备：进入MySQL指标的半影区域。本节探讨了分成11个光谱的70多个MySQL指标，其中一些有子光谱。我将MySQL指标分为光谱有两个原因：
- en: Spectra give the journey waypoints. Without them, we face a vast and unorganized
    universe swirling with nearly *one thousand* metrics from different sources that
    vary by MySQL version, distribution, and configuration.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光谱提供了旅程的路标。没有它们，我们面对的将是一个庞大而无序的宇宙，涌动着来自不同来源的近 *一千* 种指标，这些指标因MySQL版本、发行版和配置的不同而异。
- en: Spectra reveal important areas of MySQL to understand and monitor with respect
    to performance.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光谱揭示了MySQL性能方面重要的领域。
- en: 'Even with spectra illuminating a path through the darkness, we need a metric
    naming convention to talk clearly and precisely about the MySQL metrics and system
    variables that constitute each spectrum. The reason is simple: MySQL does not
    have a metric naming convention, and there is no industry standard, either. [Table 6-1](#metric-naming-convention)
    is the MySQL metric naming convention that I use in this book.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有光谱照亮黑暗中的路径，我们也需要一个度量命名约定来清晰而准确地讨论MySQL指标和系统变量，这些组成了每个光谱。原因很简单：MySQL没有度量命名约定，行业标准也不存在。[表 6-1](#metric-naming-convention)
    是我在本书中使用的MySQL度量命名约定。
- en: Table 6-1\. MySQL metric naming convention
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. MySQL度量命名约定
- en: '| Example | Refers to |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | 参考对象 |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Threads_running` | Global status variables |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `Threads_running` | 全局状态变量 |'
- en: '| `var.max_connections` | Global system variables |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `var.max_connections` | 全局系统变量 |'
- en: '| `innodb.log_lsn_checkpoint_age` | InnoDB metrics |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `innodb.log_lsn_checkpoint_age` | InnoDB度量 |'
- en: '| *`replication lag`* | Derived metrics |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| *`replication lag`* | 派生度量 |'
- en: 'Most metrics are global status variables that you have likely seen or used
    by executing [`SHOW GLOBAL STATUS`](https://oreil.ly/NacuT): `Aborted_connects`,
    `Queries`, `Threads_running`, and so forth. In MySQL and this book, global status
    variable names begin with a single uppercase letter followed by lowercase letters,
    even if the first word is an acronym: `Ssl_client_connects`, *not* `SSL_client_connects`.
    (This is one aspect of MySQL metrics that is consistent.) By contrast, global
    system variables are lowercase; and to make them more distinct, I prefix them
    with `var.`, which is important given the next convention. InnoDB metrics are
    also lowercase, like `lock_timeouts`. Since that can look like a global system
    variable, I prefix InnoDB metrics with `innodb.`, like `innodb.lock_timeouts`.
    Derived metrics are ubiquitous in monitoring but not native to MySQL. *`Replication
    lag`*, for example, is a metric that nearly every monitor will emit, but the precise
    metric name depends on the monitor, which is why I use a descriptive name without
    underscore characters rather than a specific technical name.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数指标都是全局状态变量，通过执行 [`SHOW GLOBAL STATUS`](https://oreil.ly/NacuT) 你可能已经看到或使用过：`Aborted_connects`,
    `Queries`, `Threads_running` 等等。在MySQL和本书中，全局状态变量名称以单个大写字母开头，后跟小写字母，即使第一个单词是缩写：`Ssl_client_connects`，*不是*
    `SSL_client_connects`。（这是MySQL度量中一致的一个方面。）相比之下，全局系统变量是小写的；为了使它们更加独特，我在它们前面加上 `var.`，这在考虑到下一个约定时很重要。InnoDB的度量也是小写的，例如
    `lock_timeouts`。由于这可能看起来像全局系统变量，我在InnoDB度量前面加上 `innodb.`，例如 `innodb.lock_timeouts`。派生度量在监控中普遍存在，但不是MySQL本身的特性。例如，*`Replication
    lag`* 是几乎每个监视器都会输出的度量，但具体的度量名称取决于监视器，这就是为什么我使用一个描述性名称而不是特定的技术名称来描述它，而不带有下划线字符。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The InnoDB metrics in this section require enabling certain counters or modules.
    For example, starting MySQL with `inno​db_​mon​itor_​enable=​module_​log,​mod⁠ule_​buffer,​module_​trx`.
    See [`var.innodb_monitor_enable`](https://oreil.ly/nFKFT) and [“InnoDB INFORMATION_SCHEMA
    Metrics Table”](https://oreil.ly/e0wpA) in the MySQL manual.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的InnoDB指标需要启用特定的计数器或模块。例如，使用`inno​db_​mon​itor_​enable=​module_​log,​mod⁠ule_​buffer,​module_​trx`启动MySQL。在MySQL手册的[`var.innodb_monitor_enable`](https://oreil.ly/nFKFT)和[“InnoDB
    INFORMATION_SCHEMA Metrics Table”](https://oreil.ly/e0wpA)中查看更多信息。
- en: 'Second to last bit of mental equipment: *global* refers to the entire MySQL
    server: all clients, all users, all queries, and so on—combined. By contrast,
    there are *session* and *summary* metrics. Session metrics are global metrics
    scoped to a single client connection. Summary metrics are usually a subset of
    global metrics scoped to a variety of aspects: account, host, thread, transaction,
    and so on. This chapter looks only at global metrics since they underlie all metrics.
    (Global metrics are also the original: in ancient times, MySQL had only global
    metrics; then it added session metrics; then it added summary metrics.)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二点心理准备：*全局*指的是整个MySQL服务器：所有客户端、所有用户、所有查询等等——合在一起。相比之下，还有*会话*和*摘要*指标。会话指标是限定于单个客户端连接的全局指标。摘要指标通常是全局指标的一个子集，涵盖各种方面：账户、主机、线程、事务等等。本章仅关注全局指标，因为它们是所有指标的基础。（全局指标也是最初的：在古老的时代，MySQL只有全局指标；后来它增加了会话指标；然后增加了摘要指标。）
- en: 'Last bit of mental equipment before we begin the journey: most MySQL metrics
    are simple counters, and only a few are gauges. I explicitly note the gauges;
    otherwise, counter is implied. Let’s begin!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始旅程之前，最后一点心理准备：大多数MySQL指标都是简单的计数器，只有少数是计量器。我明确指出计量器；否则，默认是计数器。让我们开始吧！
- en: Query Response Time
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询响应时间
- en: Global query response time is one of the four [“Key Performance Indicators”](#kpi).
    Surprisingly, MySQL did not have this metric until version 8.0. As of MySQL 8.0.1,
    you can obtain the 95th percentile (P95) global query response time in milliseconds
    from the [Performance Schema](https://oreil.ly/dj06D) by executing the query in
    [Example 6-1](#qrt-query).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 全局查询响应时间是四个[“关键性能指标”](#kpi)之一。令人惊讶的是，在MySQL 8.0之前，MySQL并没有这个指标。从MySQL 8.0.1开始，你可以通过在[性能模式](https://oreil.ly/dj06D)中执行[示例 6-1](#qrt-query)中的查询来获取95th百分位（P95）全局查询响应时间（以毫秒计）。
- en: Example 6-1\. Global 95th percentile query response time
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 全局95th百分位查询响应时间
- en: '[PRE0]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That query returns a percentile very close to—but not exactly—the P95: 95.2%
    instead of 95.0%, for example.^([1](ch06.html#idm45829110960368)) The difference
    is negligible and does not affect monitoring.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那个查询返回的百分位非常接近于但不完全等于P95：例如，是95.2%而不是95.0%。这种差异微乎其微，不会影响监控。
- en: 'You can replace `0.95` in the query to return a different percentile: `0.99`
    for P99, or `0.999` for P999. I prefer and advise P999 for the reasons stated
    in [“Average, Percentile, and Maximum”](ch01.html#avg-p-max-distro).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将查询中的`0.95`替换为返回不同百分位数：`0.99`表示P99，或`0.999`表示P999。基于[“平均值、百分位数和最大值”](ch01.html#avg-p-max-distro)中所述的原因，我更推荐使用P999。
- en: The rest of this section is for MySQL 5.7 and older—skip it if you’re running
    MySQL 8.0 or newer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节其余部分适用于MySQL 5.7及更早版本，如果你使用的是MySQL 8.0或更新版本，请跳过此部分。
- en: MySQL 5.7 and older
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 5.7及更早版本
- en: 'MySQL 5.7 and older do not expose a global query response time metric. Only
    query metrics include response time (see [“Query time”](ch01.html#Query-time)),
    but that is per-query response time. To calculate global response time, you would
    need to aggregate it from every query. That’s possible, but there are two better
    alternatives: upgrade to MySQL 8.0; or, switch to Percona Server or MariaDB, which
    have a plug-in to capture global response time.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 5.7及更早版本不公开全局查询响应时间指标。只有查询指标包括响应时间（见[“查询时间”](ch01.html#Query-time)），但那是每个查询的响应时间。要计算全局响应时间，你需要从每个查询中聚合它。虽然这是可能的，但有两个更好的选择：升级到MySQL
    8.0；或者切换到Percona Server或MariaDB，它们有一个插件用于捕获全局响应时间。
- en: Percona Server 5.7
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Percona Server 5.7
- en: Way back in 2010, [Percona Server](https://oreil.ly/Gyq8J) introduced a plug-in
    to capture global response time called [Response Time Distribution](https://oreil.ly/PE5kh).
    It’s easy to install the plug-in, but it takes work to configure and use because
    it’s a histogram of response time ranges, which means you need to set `var.query_response_time_range_base`—a
    global system variable that the plug-in creates—to configure the histogram bucket
    ranges, then compute a percentile from the bucket counts. MySQL 8.0 global response
    time is also a histogram, but the bucket ranges and percentiles are preset and
    precomputed, which is why the query in [Example 6-1](#qrt-query) works out of
    the box. It’s not that difficult to set up; it only sounds complicated. The benefit
    of having global response time is well worth the effort.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 早在2010年，[Percona Server](https://oreil.ly/Gyq8J)引入了一个用于捕获全局响应时间的插件，名为[响应时间分布](https://oreil.ly/PE5kh)。安装插件很容易，但配置和使用需要一些工作，因为它是响应时间范围的直方图，这意味着你需要设置`var.query_response_time_range_base`——一个插件创建的全局系统变量，来配置直方图桶范围，然后从桶计数计算百分位数。MySQL
    8.0全局响应时间也是一个直方图，但桶范围和百分位数是预设和预计算的，这就是为什么[示例 6-1](#qrt-query)中的查询可以直接使用。设置起来并不难；听起来复杂而已。拥有全局响应时间的好处绝对值得努力。
- en: MariaDB 10.0
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB 10.0
- en: '[MariaDB](https://oreil.ly/oeGJO) uses the same plug-in from Percona but it
    has a slightly different name: [Query Response Time Plugin](https://oreil.ly/kb4gA).
    Although introduced in MariaDB 10.0, it was not marked stable until MariaDB 10.1.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[MariaDB](https://oreil.ly/oeGJO)使用与Percona相同的插件，但名称略有不同：[查询响应时间插件](https://oreil.ly/kb4gA)。虽然在MariaDB
    10.0中引入，但直到MariaDB 10.1才标记为稳定版。'
- en: Before MySQL 8.0, obtaining global query response time is not trivial, but it’s
    worth the effort if you’re running Percona Server or MariaDB. If you’re running
    MySQL in the cloud, check the cloud provider metrics because some provide a response
    time metric (which the cloud provider might call *latency*). If nothing else,
    frequently review the query profile to keep an eye on response times.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0之前，获取全局查询响应时间并不是一件简单的事情，但如果你在运行Percona Server或MariaDB，这个努力是值得的。如果你在云中运行MySQL，请检查云提供商的指标，因为一些提供了响应时间指标（云提供商可能称为*延迟*）。如果没有其他办法，经常审查查询配置文件以监控响应时间。
- en: Errors
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误
- en: Errors are one of the four [“Key Performance Indicators”](#kpi). As of MySQL
    8.0.0, it’s easy to obtain a count of *all* errors from the [Performance Schema](https://oreil.ly/glJUC)
    by executing the query in [Example 6-2](#all-errors-query).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是四个[“关键绩效指标”](#kpi)之一。从MySQL 8.0.0开始，通过在[性能模式](https://oreil.ly/glJUC)中执行[示例 6-2](#all-errors-query)中的查询，轻松获取*所有*错误的计数。
- en: Example 6-2\. Global error count
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 全局错误计数
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Error number 1287, excluded in the `WHERE` clause in [Example 6-2](#all-errors-query),
    is for deprecation warnings: when a query uses a feature that is deprecated, MySQL
    issues a warning. Including this error number is likely to make the global error
    count too noisy, which is why I exclude it.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 错误编号1287，在[示例 6-2](#all-errors-query)的`WHERE`子句中被排除，用于弃用警告：当查询使用被弃用的功能时，MySQL会发出警告。包含此错误号可能会使全局错误计数过于吵闹，这就是我排除它的原因。
- en: Since MySQL has so many errors and warnings, there’s no telling what your global
    error rate will be. Don’t expect or try to achieve a zero error rate. That’s essentially
    impossible because clients can cause errors, and there’s nothing you, the application,
    or MySQL can do to prevent that. The goal is to establish the normal error rate
    for the application. If the query in [Example 6-2](#all-errors-query) is too noisy—which
    means it produces a high rate of errors but you are certain the application is
    functioning normally—then fine tune the query by excluding additional error numbers.
    MySQL error codes are documented in the [“MySQL Error Message Reference”](https://oreil.ly/wKfnV).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MySQL有很多错误和警告，无法预测全局错误率会是多少。不要期望或试图达到零错误率。这基本上是不可能的，因为客户端可能会引发错误，你、应用程序或MySQL都无法阻止。目标是为应用程序建立正常的错误率。如果[示例 6-2](#all-errors-query)中的查询太吵闹——这意味着它产生了高错误率，但你确信应用程序正常运行——那就通过排除其他错误号码来微调查询。MySQL错误代码在[“MySQL错误消息参考”](https://oreil.ly/wKfnV)中有文档。
- en: Before MySQL 8.0, you cannot obtain a global error count from MySQL, but you
    can obtain a count of all *query* errors from the [Performance Schema](https://oreil.ly/QiHj8)
    by executing the query in [Example 6-3](#query-errors-query).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0之前，你无法从MySQL中获取全局错误计数，但可以通过执行[示例 6-3](#query-errors-query)中的查询，获取*查询*错误的计数，来自[性能模式](https://oreil.ly/QiHj8)。
- en: Example 6-3\. Query error count
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 查询错误计数
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since this works in all distributions as of MySQL 5.6, there is no reason not
    to monitor all query errors. Granted, the application should report query errors,
    too; but if it also retries on error, it might hide a certain amount of errors.
    By contrast, this will expose all query errors, potentially revealing a problem
    that application retries are masking.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 自MySQL 5.6起在所有发行版中都有效，没有理由不监控所有查询错误。当然，应用程序也应报告查询错误；但如果应用程序在错误发生时也重试，它可能会隐藏一定数量的错误。相比之下，这将暴露所有查询错误，可能会揭示应用程序重试所掩盖的问题。
- en: 'The last error metrics are client connection errors:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的错误指标是客户端连接错误：
- en: '`Aborted_clients`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aborted_clients`'
- en: '`Aborted_connects`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aborted_connects`'
- en: '`Connection_errors_%`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection_errors_%`'
- en: 'The first two metrics are commonly monitored to ensure that there are no issues
    *while connecting* or *already connected* to MySQL. That wording is precise: if
    the application cannot make a network connection to MySQL, then MySQL does not
    see the client and does not report a client connection error because, from the
    MySQL point of view, there is no client connection yet. Low-level network connection
    issues should be reported by the application. However, if the application cannot
    connect, you’re likely to see a drop in the other three KPIs (QPS, threads running,
    and response time) because the application isn’t executing queries.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个指标通常被监控，以确保连接或已连接到MySQL时没有问题。这种措辞非常精确：如果应用程序无法与MySQL建立网络连接，则MySQL不会看到客户端，也不会报告客户端连接错误，因为从MySQL的角度来看，此时还没有客户端连接。低级网络连接问题应由应用程序报告。但是，如果应用程序无法连接，则可能会看到其他三个关键绩效指标（QPS、正在运行的线程和响应时间）的下降，因为应用程序没有执行查询。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `%` character in `Connection_errors_%` is a MySQL wildcard; several metrics
    exist with the prefix `Connection_errors_`. To list them, execute `SHOW GLOBAL
    STATUS LIKE *Connection_errors_%*;`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connection_errors_%`中的`%`字符是MySQL通配符；存在几个以`Connection_errors_`为前缀的指标。要列出它们，请执行`SHOW
    GLOBAL STATUS LIKE *Connection_errors_%*;`。'
- en: Before moving on to the next spectrum, let’s address a problem that’s also not
    a problem—at least not for MySQL. If the application begins to spew errors but
    MySQL does not and the other three KPIs are normal, then the problem is with the
    application or the network. MySQL has many quirks, but lying is not one of them.
    If MySQL KPIs are thumbs up (all okay and normal), then you can trust that MySQL
    is working normally.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一个范围之前，让我们解决一个同样不是问题的问题——至少对MySQL来说不是问题。如果应用程序开始输出错误，但MySQL没有输出，并且其他三个关键绩效指标正常，那么问题可能出现在应用程序或网络上。MySQL有很多怪癖，但虚报不是其中之一。如果MySQL的关键绩效指标一切正常，那么可以相信MySQL正在正常工作。
- en: Queries
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Queries
- en: 'Metrics related to queries reveal how fast MySQL is working and what type of
    work it’s doing—at a very high level. These metrics reveal two access pattern
    traits: throughput and read/write (see [“Throughput”](ch04.html#ap-throughput)
    and [“Read/Write”](ch04.html#ap-read-write)).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询相关的指标显示了MySQL的工作速度和工作类型——在非常高的层面上。这些指标揭示了两种访问模式的特征：吞吐量和读写（参见[“吞吐量”](ch04.html#ap-throughput)和[“读/写”](ch04.html#ap-read-write)）。
- en: QPS
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QPS
- en: 'QPS is one of the four [“Key Performance Indicators”](#kpi). The underlying
    metric is aptly named:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: QPS是四个[“关键绩效指标”](#kpi)之一。底层度量标准的名称非常恰当：
- en: '`Queries`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queries`'
- en: 'That metric is a counter, but QPS is a rate, so technically QPS equals the
    difference of two `Queries` measurements divided by the number of seconds between
    the measurements: QPS = (Queries @ T1 – Queries @ T0) / (T1 – T0), where T0 is
    the time of the first measurement and T1 is the time of the second measurement.
    Metric graphing systems (like [Grafana](https://grafana.com)) convert counters
    to rates by default. As a result, you should not need to convert `Queries` or
    any other counters to rates. Just be aware that most MySQL metrics are counters,
    but they are converted to and expressed as rates.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那个指标是一个计数器，但QPS是一个速率，因此技术上QPS等于两次`Queries`测量之间的差异除以测量之间的秒数：QPS = （T1时的Queries
    - T0时的Queries）/ （T1 - T0），其中T0是第一次测量的时间，T1是第二次测量的时间。度量图系统（如[Grafana](https://grafana.com)）默认将计数器转换为速率。因此，您不需要将`Queries`或任何其他计数器转换为速率。只需注意，大多数MySQL指标都是计数器，但它们会被转换为速率并表示出来。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Metric graphing systems convert counters to rates by default.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 度量图系统默认将计数器转换为速率。
- en: QPS receives a lot of attention because it indicates overall MySQL throughput—how
    fast MySQL is executing queries—but don’t fixate on it. As mentioned in [“Less
    QPS Is Better”](ch03.html#less-qps-is-better), QPS reveals nothing qualitative
    about the queries or performance in general. If QPS is incredibly high but response
    time is also incredibly high, then QPS indicates a problem, not great performance.
    Other metrics reveal more about MySQL performance than QPS.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: QPS受到关注是因为它表示MySQL的总体吞吐量——MySQL执行查询的速度——但不要过度关注它。正如在[“少量QPS更好”](ch03.html#less-qps-is-better)中提到的，QPS对查询或性能总体质量并没有任何定性的影响。如果QPS非常高但响应时间也非常高，则QPS表明存在问题，而不是良好的性能。其他指标比QPS更多地揭示了MySQL性能。
- en: When everything is running normally, QPS fluctuates with application usage.
    When there is a problem, QPS fluctuations correlate with other metrics. To analyze
    performance or diagnose a problem, I glance at QPS to see where (in a chart) its
    value is abnormal. Then I correlate that period (time along the X axis of the
    chart) with other, more specific metrics in the spectra. As a KPI, QPS indicates
    a problem, but other metrics pinpoint the problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常运行时，QPS随应用使用情况波动。当出现问题时，QPS的波动与其他指标相关。为了分析性能或诊断问题，我会看一眼QPS，看看它在图表中的值是否异常。然后，我会将这段时间（图表X轴上的时间）与光谱中的其他更具体的指标相关联。作为关键绩效指标，QPS表明存在问题，但其他指标则能够更精确定位问题。
- en: 'All abnormal changes in QPS are suspect and worth investigating. Most, if not
    all, engineers know that a drop in QPS is bad, but an abnormal increase in QPS
    can be equally bad or worse. Also bad but more rare is flatline QPS—a nearly constant
    QPS value—because minor fluctuations are normal. When QPS changes abnormally,
    the first question is usually: what’s the cause? I address that later in this
    chapter (see [“Cause and Effect”](#cause-and-effect)).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有QPS中的异常变化都值得怀疑并值得调查。大多数工程师知道QPS下降是不好的，但QPS异常增加同样糟糕甚至更糟。同样不好但更少见的是QPS的平线化——几乎恒定的QPS值——因为轻微波动是正常的。当QPS异常变化时，通常的第一个问题是：是什么原因？我稍后在本章中解决这个问题（参见[“因果关系”](#cause-and-effect)）。
- en: 'MySQL exposes another closely related metric: `Questions`. (The term *question*
    is only used for this metric; it’s not used for anything else inside MySQL.) `Questions`
    counts only queries sent by clients, not queries executed by stored programs.
    For example, queries executed by a trigger do *not* count in `Questions` because
    a client did not send them; but they do count in `Queries`. Since `Questions`
    is a subset of `Queries`, the difference is only informational, and monitoring
    `Questions` is optional. For QPS, always use `Queries`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL还公开了另一个密切相关的度量标准：`Questions`。 （术语*question*仅用于此度量标准；在MySQL内部没有其他用途。） `Questions`仅计算客户端发送的查询，而不计算由存储程序执行的查询。例如，触发器执行的查询不会计入`Questions`，因为客户端没有发送它们；但它们会计入`Queries`。由于`Questions`是`Queries`的子集，所以二者之间的差异仅仅是信息上的区别，监控`Questions`是可选的。对于QPS，请始终使用`Queries`。
- en: TPS
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TPS
- en: If the application relies on explicit, multistatement transactions, then transactions
    per second (TPS) is as important as QPS. For some applications, a database transaction
    represents a unit of work in the application, so TPS is a better rate than QPS
    because the application unit of work is all or nothing, which is why it’s executed
    in an explicit transaction.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序依赖于显式的多语句事务，则每秒事务数（TPS）与QPS同样重要。对于一些应用程序，数据库事务代表应用程序中的一个工作单元，因此TPS比QPS更能反映出应用程序工作单元的速率，因为应用程序的工作单元是“全有或全无”，这就是为什么它在显式事务中执行。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An *implicit transaction* is a single SQL statement with [`autocommit`](https://oreil.ly/zrjQK)
    enabled, which is the default. An *explicit transaction* starts with `BEGIN` or
    `START TRANSACTION` and ends with either `COMMIT` or `ROLLBACK`, regardless of
    `autocommit`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式事务是一个启用[`autocommit`](https://oreil.ly/zrjQK)的单个SQL语句，这是默认设置。显式事务从`BEGIN`或`START
    TRANSACTION`开始，并以`COMMIT`或`ROLLBACK`结束，不论`autocommit`如何。
- en: 'In MySQL, explicit transaction throughput is revealed by three metrics:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中，显式事务吞吐量由三个度量标准揭示：
- en: '`Com_begin`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_begin`'
- en: '`Com_commit`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_commit`'
- en: '`Com_rollback`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_rollback`'
- en: Normally, the rate of `Com_begin` and `Com_commit` are the same because every
    transaction must begin and successful transactions must commit. When there’s a
    problem that causes transactions to stall (one of the [“Common Problems”](ch08.html#trx-problems)),
    the rate of `Com_begin` exceeds the other two metrics.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，`Com_begin`和`Com_commit`的速率是相同的，因为每个事务必须开始，并且成功的事务必须提交。当出现导致事务停滞的问题（[“常见问题”](ch08.html#trx-problems)之一）时，`Com_begin`的速率超过了另外两个度量标准。
- en: Use `Com_commit` to measure TPS because transaction throughput implies successful
    transactions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Com_commit`来衡量TPS，因为事务吞吐量意味着成功的事务。
- en: 'A transaction rollback is supposed to indicate an error—since transactions
    are all or nothing—but the `ROLLBACK` statement is also commonly used for cleanup:
    it ensures that the previous transaction—if any—is closed before starting the
    next transaction. Consequently, the rollback rate might not be zero. As with most
    metrics, normal and stable is the goal (see [“Normal and Stable: The Best Database
    Is a Boring Database”](#normal-and-stable)).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 事务回滚通常表示错误，因为事务要么全部成功，要么全部失败，但`ROLLBACK`语句通常用于清理：它确保在开始下一个事务之前关闭前一个（如果有）。因此，回滚率可能不为零。与大多数指标一样，正常和稳定是目标（参见[“正常和稳定：最好的数据库是无聊的数据库”](#normal-and-stable)）。
- en: Another gauge metric that indicates the current number of active transactions
    is `innodb.trx_active_transactions`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个指标是`innodb.trx_active_transactions`，指示当前活动事务的数量。
- en: '`BEGIN` starts a transaction, but a transaction is not *active* until, generally
    speaking, a query accesses a table. For example, `BEGIN; SELECT NOW();` starts
    a transaction that is not active because no query accesses a table.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`BEGIN`开始一个事务，但事务通常在查询访问表后才会*激活*。例如，`BEGIN; SELECT NOW();`开始一个事务，但没有查询访问表，因此事务不会激活。'
- en: Read/write
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读/写
- en: 'There are nine read/write metrics named according to a type of SQL statement:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有九个读/写指标，按照SQL语句类型命名：
- en: '`Com_select`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_select`'
- en: '`Com_delete`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_delete`'
- en: '`Com_delete_multi`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_delete_multi`'
- en: '`Com_insert`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_insert`'
- en: '`Com_insert_select`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_insert_select`'
- en: '`Com_replace`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_replace`'
- en: '`Com_replace_select`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_replace_select`'
- en: '`Com_update`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_update`'
- en: '`Com_update_multi`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_update_multi`'
- en: For example, `Com_select` is a counter for the number of `SELECT` statements.
    The `_multi` suffix in `Com_delete_multi` and `Com_update_multi` refers to queries
    that reference multiple tables. A multitable `DELETE` increments only `Com_delete_multi`,
    whereas a single-table `DELETE` only updates `Com_delete`. The same is true for
    `UPDATE` statements with respect to `Com_update_multi` and `Com_update`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Com_select`是`SELECT`语句数量的计数器。`Com_delete_multi`和`Com_update_multi`中的`_multi`后缀指的是涉及多个表的查询。多表`DELETE`仅增加`Com_delete_multi`，而单表`DELETE`仅更新`Com_delete`。对于`UPDATE`语句也是如此，涉及`Com_update_multi`和`Com_update`。
- en: Read/write metrics reveal the important types and throughputs of queries that
    constitute `Queries`. These metrics do not fully account for `Queries`; they are
    only the most important metrics with respect to performance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 读/写指标显示构成`Queries`的查询类型和吞吐量的重要类型。这些指标并不完全涵盖`Queries`，它们只是在性能方面最重要的指标。
- en: 'Monitor these metrics as individual rates and percentages of `Queries`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Queries`的单独速率和百分比监视这些指标：
- en: '`Com_select` indicates the read percentage of the workload:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_select`表示工作负载的读取百分比：'
- en: (Com_select / Queries) × 100.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （Com_select / Queries）× 100。
- en: The sum of the other eight metrics indicates the write percentage of the workload.^([2](ch06.html#idm45829110678032))
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他八个指标的总和表示工作负载的写入百分比。^([2](ch06.html#idm45829110678032))
- en: 'The read and write percentages will *not* equal 100% because `Queries` accounts
    for other types of SQL statements: `SHOW`, `FLUSH`, `GRANT`, and many more. If
    the remaining percentage is suspiciously high (more than 20%), it probably won’t
    affect performance, but it’s worth investigating: examine other `Com_` metrics
    to account for other types of SQL statements.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入百分比之和*不会*等于100%，因为`Queries`包括其他类型的SQL语句：`SHOW`、`FLUSH`、`GRANT`等等。如果剩余百分比异常高（超过20%），可能不会影响性能，但值得调查：检查其他`Com_`指标以考虑其他类型的SQL语句。
- en: Admin
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理
- en: 'Admin metrics refer to commands that, typically, only database administrators
    invoke:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 管理指标通常是仅由数据库管理员调用的命令：
- en: '`Com_flush`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_flush`'
- en: '`Com_kill`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_kill`'
- en: '`Com_purge`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_purge`'
- en: '`Com_admin_commands`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_admin_commands`'
- en: The first three metrics refer to [`FLUSH`](https://oreil.ly/O6j77), [`KILL`](https://oreil.ly/fMbiY),
    and [`PURGE`](https://oreil.ly/czxYb), respectively. These commands could affect
    performance, but they should be very rare. If not, ask your DBA or cloud provider
    what they’re doing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个指标分别是[`FLUSH`](https://oreil.ly/O6j77)、[`KILL`](https://oreil.ly/fMbiY)和[`PURGE`](https://oreil.ly/czxYb)。这些命令可能会影响性能，但应该非常罕见。如果不是，请询问您的DBA或云服务提供商他们在做什么。
- en: The last metric, `Com_admin_commands`, is an oddity. It refers to other admin
    commands for which there are not specific `Com_` status variables. For example,
    the MySQL protocol has a ping command that is commonly used by MySQL client drivers
    to test the connection. This is harmless in moderation, but problems can result
    from a lack of moderation. Don’t expect `Com_admin_commands` to indicate any problems,
    but monitoring it is still a best practice.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个指标 `Com_admin_commands` 有些奇怪。它指的是其他管理员命令，这些命令没有特定的 `Com_` 状态变量。例如，MySQL
    协议有一个 ping 命令，MySQL 客户端驱动程序通常用它来测试连接。适度使用是无害的，但如果使用过度可能会导致问题。不要期望 `Com_admin_commands`
    会显示任何问题，但监控它仍然是最佳实践。
- en: SHOW
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SHOW
- en: 'MySQL has over 40 [`SHOW`](https://oreil.ly/u7Xzs) statements, most of which
    have a corresponding `Com_show_` metric. `SHOW` commands never change MySQL or
    modify data, so in that sense they’re harmless. But they are queries, which means
    they use a thread, time, and resources in MySQL. `SHOW` commands can stall, too.
    `SHOW GLOBALS STATUS`, for example, can take a full second or more on a busy server.
    Consequently, it’s a best practice to monitor at least the following 10 metrics:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 有超过 40 个 [`SHOW`](https://oreil.ly/u7Xzs) 命令，其中大部分对应 `Com_show_` 指标。`SHOW`
    命令不会改变 MySQL 或修改数据，因此在这个意义上它们是无害的。但它们是查询命令，这意味着它们会使用 MySQL 中的线程、时间和资源。`SHOW` 命令也可能会造成停顿。例如，`SHOW
    GLOBALS STATUS` 在繁忙服务器上可能需要一整秒或更多时间。因此，最佳实践是至少监控以下 10 个指标：
- en: '`Com_show_databases`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_databases`'
- en: '`Com_show_engine_status`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_engine_status`'
- en: '`Com_show_errors`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_errors`'
- en: '`Com_show_processlist`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_processlist`'
- en: '`Com_show_slave_status`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_slave_status`'
- en: '`Com_show_status`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_status`'
- en: '`Com_show_table_status`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_table_status`'
- en: '`Com_show_tables`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_tables`'
- en: '`Com_show_variables`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_variables`'
- en: '`Com_show_warnings`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_show_warnings`'
- en: Note
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of MySQL 8.0.22, monitor `Com_show_replica_status` instead of `Com_show_slave_status`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MySQL 8.0.22 开始，应监控 `Com_show_replica_status` 而不是 `Com_show_slave_status`。
- en: Don’t expect `SHOW` metrics to indicate any problems, but don’t be surprised
    if one does because it wouldn’t be the first time.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不要期望 `SHOW` 指标会显示任何问题，但如果有问题，也不要感到意外，因为这并不是第一次。
- en: Threads and Connections
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和连接
- en: '`Threads_running` is one of the four [“Key Performance Indicators”](#kpi).
    It indicates how hard MySQL is working because it’s directly connected to active
    query execution (when a client connection is not executing a query, its thread
    is idle), and it’s effectively limited by the number of CPU cores. Let’s come
    back to `Threads_running` after looking at related metrics.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Threads_running` 是四个[“关键性能指标”](#kpi)之一。它显示 MySQL 正在工作的强度，因为它直接与活动查询执行相关联（当客户端连接不执行查询时，其线程处于空闲状态），并且受
    CPU 核心数量的限制。让我们在查看相关指标后再回到 `Threads_running`。'
- en: 'Threads and connections are one spectrum because they are directly related:
    MySQL runs one thread per client connection. The four most important metrics for
    threads and connections are:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 线程和连接是一个谱系，因为它们直接相关：MySQL 对每个客户端连接运行一个线程。线程和连接的四个最重要指标是：
- en: '`Connections`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connections`'
- en: '`Max_used_connections`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Max_used_connections`'
- en: '`Threads_connected`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Threads_connected`'
- en: '`Threads_running`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Threads_running`'
- en: '`Connections` is the number of connection attempts to MySQL, both successful
    and failed. It reveals the stability of the application connection pool to MySQL.
    Usually, application connections to MySQL are long-lived, where *long* is at least
    a few seconds, if not minutes or hours. Long-lived connections avoid the overhead
    of establishing a connection. When the application and MySQL are on the same local
    network, the overhead is negligible: 1 millisecond or less. But network latency
    between the application and MySQL adds up quickly when multiplied by hundreds
    of connections and multiplied again by the connection rate. (`Connections` is
    a counter but expressed as a rate: connections/second.) MySQL can easily handle
    hundreds of connections per second, but if this metric reveals an abnormally high
    rate of connections, find and fix the root cause.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Connections` 是对 MySQL 进行的连接尝试次数，包括成功和失败的。它显示应用程序连接池到 MySQL 的稳定性。通常，应用程序与 MySQL
    的连接是长期存在的，*长期* 至少是几秒，如果不是几分钟或几小时。长期存在的连接避免了建立连接的开销。当应用程序和 MySQL 在同一个本地网络上时，开销可以忽略不计：1
    毫秒或更少。但是，应用程序和 MySQL 之间的网络延迟会随连接数的增加而迅速累积，再乘以连接速率。(`Connections` 是一个计数器，但表达为速率：连接数/秒。)
    MySQL 可以轻松处理每秒数百个连接，但如果这个指标显示连接速率异常高，需要找出并修复根本原因。'
- en: '`Max_used_connections` as a percentage of [`var.max_connections`](https://oreil.ly/MVZaQ)
    reveals connection utilization. The default value for `var.max_connections` is
    151, which is probably too low for most applications but *not* because the application
    needs more connections for performance. The application needs more connections
    only because each application instance has its own connection pool. (I presume
    the application is scaled out.) If the connection pool size is 100 and there are
    3 application instances, then the application (all instances) can create 300 connections
    to MySQL. That is the main reason why 151 max connections is not sufficient.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [`var.max_connections`](https://oreil.ly/MVZaQ) 的百分比，`Max_used_connections`
    显示了连接的利用率。`var.max_connections` 的默认值是 151，对于大多数应用程序来说可能太低了，但并不是因为应用程序需要更多连接来提高性能。应用程序只需要更多连接是因为每个应用程序实例都有自己的连接池。（我假设应用程序是扩展的。）如果连接池大小是
    100，且有 3 个应用程序实例，则应用程序（所有实例）可以创建 300 个连接到 MySQL。这就是为什么 151 最大连接数不够的主要原因。
- en: A common misconception is that the application needs thousands of connections
    to MySQL for performance or to support thousands of users. This is patently not
    true. The limiting factor is threads, not connections—more on `Threads_running`
    in a moment. A single MySQL instance can easily handle thousands of connections.
    I’ve seen 4,000 connections in production and more in benchmarks. But for most
    applications, several hundred connections (total) is more than sufficient. If
    your application demonstrably requires several thousand connections, then you
    need to shard (see [Chapter 5](ch05.html#ch05)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是应用程序需要数千个连接到 MySQL 以提高性能或支持数千个用户。这是完全不正确的。限制因素是线程，而不是连接——稍后详细介绍 `Threads_running`。单个
    MySQL 实例可以轻松处理数千个连接。我曾在生产环境中见过 4000 个连接，以及更多的基准测试。但对于大多数应用程序来说，总共几百个连接已经足够了。如果您的应用程序明显需要数千个连接，那么您需要分片（参见
    [第五章](ch05.html#ch05)）。
- en: 'The real problem to monitor and avoid is 100% connection utilization. If MySQL
    runs out of available connections, an application outage is essentially guaranteed.
    If connection utilization rises suddenly, approaching 100%, the cause is always
    an external problem, or bug, or both. (MySQL cannot connect to itself, so the
    cause must be external.) In response to an external problem—like a network issue,
    for example—the application creates more connections than normal. Or, a bug causes
    the application not to close connections—commonly known as a *connection leak*.
    Or, an external problem triggers a bug in the application—I’ve seen it happen.
    Either way, the underlying cause is always external: something outside MySQL is
    connecting to MySQL and using all the connections.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和避免的真正问题是 100% 的连接利用率。如果 MySQL 的可用连接耗尽，应用程序将出现故障。如果连接利用率突然上升，接近 100%，原因总是外部问题，或者
    bug，或者两者兼有。（MySQL 无法连接到自身，因此原因必定是外部的。）在响应外部问题，比如网络问题时，应用程序会创建比正常情况更多的连接。或者，bug
    导致应用程序不关闭连接——通常被称为 *连接泄漏*。或者，外部问题触发应用程序中的 bug——我曾见过这种情况发生。不管怎样，根本原因总是外部的：外部的东西连接到
    MySQL 并使用了所有连接。
- en: As clients connect and disconnect, MySQL increments and decrements the `Threads_connected`
    gauge metric. The name of this metric is a little misleading since *clients* are
    connected, not threads, but it reflects that MySQL runs one thread per client
    connection.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接和断开连接时，MySQL 会增加和减少 `Threads_connected` 这个度量标准。这个度量标准的名称有点误导，因为连接的是*客户端*，而不是线程，但它反映了
    MySQL 每个客户端连接运行一个线程的事实。
- en: '`Threads_running` is a gauge metric and an implicit utilization relative to
    the number of CPU cores. Although `Threads_running` can spike into the hundreds
    and thousands, performance will degrade sharply at much lower values: around twice
    the number of CPU cores. The reason is simple: one CPU core runs one thread. When
    the number of threads running is greater than the number of CPU cores, it means
    that some threads are stalled—waiting for CPU time. This is analogous to rush
    hour traffic: thousands of cars in gridlock on the highway, engines running but
    barely moving. (Or, for electric cars: batteries running but barely moving.) Consequently,
    it’s normal for `Threads_running` to be quite low: less than 30. Bursts lasting
    seconds or less are possible with good hardware and an optimized workload, but
    sustained (normal and stable) `Threads_running` should be as low as possible.
    As in [“Less QPS Is Better”](ch03.html#less-qps-is-better), less `Threads_running`
    is better too.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Threads_running` 是一个度量仪表和相对于 CPU 核心数量的隐式利用率。虽然 `Threads_running` 可以突然增加到数百甚至数千，但性能在较低值时会急剧下降：大约是
    CPU 核心数量的两倍。原因很简单：一个 CPU 核心运行一个线程。当运行的线程数超过 CPU 核心数时，这意味着一些线程处于停滞状态，等待 CPU 时间。这类似于交通高峰期：成千上万辆汽车在高速公路上堵塞，发动机运行但几乎不动。（或者对于电动汽车来说：电池运行但几乎不动。）因此，`Threads_running`
    通常会非常低：少于 30。使用良好的硬件和优化的工作负载，可能会出现持续时间为秒或更短的突发情况，但持续的（正常和稳定的）`Threads_running`
    应尽可能低。就像在 [“QPS 越少越好”](ch03.html#less-qps-is-better) 中一样，`Threads_running` 越少越好。'
- en: 'High throughput (QPS) with very low threads running is a strong indication
    of efficient performance because there is only one way to achieve both: very fast
    query response time. [Table 6-2](#threads-running-qps) lists threads running and
    QPS from five real (and different) applications.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 高吞吐量（QPS），同时线程运行非常低，这是效率高的一个强烈指标，因为只有一种方式可以同时实现两者：非常快的查询响应时间。[表 6-2](#threads-running-qps)
    列出了来自五个真实（且不同）应用程序的线程运行和 QPS。
- en: Table 6-2\. Threads running and QPS
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. 运行的线程数和 QPS
- en: '| Threads running | QPS |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 线程运行 | QPS |'
- en: '| --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 4 | 8,000 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 8,000 |'
- en: '| 8 | 6,000 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 6,000 |'
- en: '| 8 | 30,000 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 30,000 |'
- en: '| 12 | 23,000 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 23,000 |'
- en: '| 15 | 33,000 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 33,000 |'
- en: 'The second and third rows highlight how profoundly the application workload
    affects performance: with one workload, 6,000 QPS needs 8 threads running; but
    another workload achieves 5x QPS (30,000) with the same number of threads. For
    the last row, 33,000 QPS is not exceptionally high, but that database is sharded:
    total QPS across all shards exceeds one million. Empirically, high throughput
    is possible with few threads running.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行和第三行突出显示应用程序工作负载对性能的深远影响：在一种工作负载下，6,000 QPS 需要 8 个运行的线程；但另一种工作负载使用相同数量的线程实现了
    5 倍 QPS（30,000）。对于最后一行，33,000 QPS 并不是异常高，但该数据库是分片的：跨所有分片的总 QPS 超过一百万。经验性地，即使线程数很少，高吞吐量也是可能的。
- en: Temporary Objects
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时对象
- en: 'Temporary objects are temporary files and tables that MySQL uses for various
    purposes: sorting rows, large joins, and so on. Three metrics count the number
    of temporary tables on disk, temporary tables in memory, and temporary files (on
    disk) created:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 临时对象是 MySQL 用于各种目的的临时文件和表：排序行，大连接等等。三个度量标准计算了在磁盘上的临时表数量，内存中的临时表数量以及创建的临时文件（在磁盘上）：
- en: '`Created_tmp_disk_tables`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created_tmp_disk_tables`'
- en: '`Created_tmp_tables`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created_tmp_tables`'
- en: '`Created_tmp_files`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created_tmp_files`'
- en: 'These metrics are rarely zero because temporary objects are common and harmless
    as long as the rates are stable. The most impactful metric is `Created_tmp_disk_tables`,
    which is the reciprocal of `Created_tmp_tables`. When MySQL needs a temporary
    table to execute a query (for `GROUP BY`, for example), it starts with an in-memory
    temporary table and increments `Created_tmp_tables`. This shouldn’t impact performance
    because it’s in memory. But if that temporary table grows larger than [`var.tmp_table_size`](https://oreil.ly/4plVm)—the
    system variable that determines the in-memory temporary table size—then MySQL
    writes the temporary table to disk and increments `Created_tmp_disk_tables`. In
    moderation, this probably won’t impact performance, but it certainly doesn’t help,
    either, because storage is significantly slower than memory. The same is true
    for `Created_tmp_files`: acceptable in moderation, but not helping performance.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标很少为零，因为临时对象很常见，只要比率稳定，就无害。最有影响力的指标是 `Created_tmp_disk_tables`，它是 `Created_tmp_tables`
    的倒数。当MySQL需要一个临时表来执行查询（例如 `GROUP BY`），它从内存中的临时表开始，并增加 `Created_tmp_tables`。这不应影响性能，因为它在内存中。但是，如果该临时表增长超过
    [`var.tmp_table_size`](https://oreil.ly/4plVm)——决定内存中临时表大小的系统变量——那么MySQL会将临时表写入磁盘，并增加
    `Created_tmp_disk_tables`。适度情况下，这可能不会影响性能，但肯定也不会帮助，因为存储显著比内存慢。对于 `Created_tmp_files`，情况也是一样：适度接受，但不利于性能。
- en: Warning
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'As of MySQL 8.0, `Created_tmp_disk_tables` does *not* count temporary tables
    created on disk. This is due to the new storage engine used for internal temporary
    tables: `TempTable`. The corresponding metric is a Performance Schema memory instrument:
    `memory/temptable/physical_disk`. (A related instrument is `memory/temptable/physical_ram`,
    which tracks `TempTable` memory allocation for in-memory temporary tables.) If
    you’re using MySQL 8.0, talk with your DBA to ensure that this metric is collected
    and reported correctly.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0中，`Created_tmp_disk_tables` *不* 计算在磁盘上创建的临时表。这是由于内部临时表 `TempTable`
    使用的新存储引擎：`TempTable`。相应的指标是Performance Schema内存仪表：`memory/temptable/physical_disk`。（一个相关的仪表是
    `memory/temptable/physical_ram`，用于跟踪内存中临时表 `TempTable` 的内存分配。）如果您正在使用MySQL 8.0，请与您的DBA确保此指标被正确收集和报告。
- en: Since temporary objects are side effects of queries, these metrics are most
    revealing when a change in one correlates to a change in KPIs. For example, a
    sudden increase in `Created_tmp_disk_tables` coupled with a sudden increase in
    response time screams “Look at me!”^([3](ch06.html#idm45829110575632))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于临时对象是查询的副作用，这些指标在一个变化与关键绩效指标（KPIs）变化相关时最具启示性。例如，`Created_tmp_disk_tables`
    突然增加并伴随着响应时间的突然增加时，会大声呼喊“看看我！”^([3](ch06.html#idm45829110575632))
- en: Prepared Statements
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备语句
- en: 'Prepared statements are a double-edged sword: used properly, they increase
    efficiency; but used improperly (or unknowingly), they increase waste. The proper
    and most efficient way to use prepared statements is to prepare once and execute
    many times, which is counted by two metrics:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 准备语句是一把双刃剑：正确使用可以提高效率；但如果错误使用（或者无意中使用），会增加浪费。使用准备语句的正确和最有效的方式是准备一次，多次执行，这由两个指标统计：
- en: '`Com_stmt_prepare`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_stmt_prepare`'
- en: '`Com_stmt_execute`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Com_stmt_execute`'
- en: '`Com_stmt_execute` should be significantly greater than `Com_stmt_prepare`.
    If it isn’t, then prepared statements are increasing waste due to extra queries
    to prepare and close the statement. The worst case is when these metrics are one-to-one,
    or close to it, because a single query incurs two wasted roundtrips to MySQL:
    one to prepare and another to close the statement. When MySQL and the application
    are on the same local network, two extra roundtrips might not be noticeable, but
    they are pure waste multiplied by QPS. For example, an extra 1 millisecond at
    1,000 QPS is a wasted second—a second during which another 1,000 queries could
    have been executed.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Com_stmt_execute` 应显著大于 `Com_stmt_prepare`。如果不是，则准备语句因额外的准备和关闭语句查询而增加了浪费。最糟糕的情况是这些指标一对一或接近一对一，因为单个查询会导致两次MySQL的多余往返：一次是准备语句，另一次是关闭语句。当MySQL和应用程序在同一个本地网络上时，两个额外的往返可能不明显，但它们纯粹是QPS倍增的浪费。例如，以1,000
    QPS为基础，额外的1毫秒就是浪费的一秒——在这一秒内本可以执行另外1,000次查询。'
- en: 'Aside from the performance implications, you should monitor these prepared
    statement metrics because the application might be using prepared statements unintentionally.
    For example, the MySQL driver for the Go programming language defaults to using
    prepared statements for security: to avoid SQL injection vulnerabilities. At first
    glance (or any number of glances), you would not think that the Go code in [Example 6-4](#hidden-ps)
    uses a prepared statement, but it does.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能影响之外，您应该监视这些预准备语句的度量，因为应用程序可能无意中使用预准备语句。例如，Go编程语言的MySQL驱动程序默认使用预准备语句以防止SQL注入漏洞。乍一看（或多次查看），您可能不认为Go代码中的[示例 6-4](#hidden-ps)使用了预准备语句，但实际上确实使用了。
- en: Example 6-4\. Hidden prepared statement
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-4\. 隐藏的预准备语句
- en: '[PRE3]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Check the documentation for the MySQL driver that the application uses. If
    it does not explicitly mention if and when it uses prepared statements, then verify
    manually: on a development instance of MySQL (your laptop, for example), enable
    the [general query log](https://oreil.ly/1Vczu) and write a test program to execute
    SQL statements using the same methods and function calls that the application
    uses. The general log indicates when prepared statements are used:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 检查应用程序使用的MySQL驱动程序的文档。如果未明确说明是否以及何时使用预准备语句，则手动验证：在MySQL的开发实例（例如您的笔记本电脑）上启用[通用查询日志](https://oreil.ly/1Vczu)，并编写一个测试程序，使用应用程序使用的相同方法和函数调用执行SQL语句。通用日志会指示何时使用预准备语句：
- en: '[PRE4]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the number of open prepared statements is limited to [`var.max_​pre⁠pared_​stmt_count`](https://oreil.ly/K2MWz),
    which is 16,382 by default. (Even 1,000 prepared statements is a lot for one application,
    unless the application is programmatically generating statements.) This gauge
    metric reports the current number of open prepared statements:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开放的预准备语句数量限制为[`var.max_​pre⁠pared_​stmt_​count`](https://oreil.ly/K2MWz)，默认为16,382。（即使对于一个应用程序而言，1,000个预准备语句也是很多，除非该应用程序是通过程序生成语句。）此计量度指标报告当前开放的预准备语句数量：
- en: '`Prepared_stmt_count`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Prepared_stmt_count`'
- en: Don’t let `Prepared_stmt_count` reach `var.max_prepared_stmt_count`, else the
    application will stop working. If this happens, it’s an application bug due to
    leaking (not closing) prepared statements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让`Prepared_stmt_count`达到`var.max_prepared_stmt_count`，否则应用程序将停止工作。如果发生这种情况，这是由于泄漏（未关闭）预准备语句导致的应用程序错误。
- en: Bad SELECT
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不良SELECT
- en: Four metrics count the occurrence of `SELECT` statements that are usually bad
    for performance:^([4](ch06.html#idm45829110547888))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 四个度量指标统计通常对性能不利的`SELECT`语句出现的次数：^([4](ch06.html#idm45829110547888))
- en: '`Select_scan`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select_scan`'
- en: '`Select_full_join`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select_full_join`'
- en: '`Select_full_range_join`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select_full_range_join`'
- en: '`Select_range_check`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select_range_check`'
- en: '`Select_scan` and `Select_full_join` are described in [Chapter 1](ch01.html#ch01):
    [“Select scan”](ch01.html#Select-scan) and [“Select full join”](ch01.html#Select-full-join),
    respectively. The only difference here is that these two metrics apply globally
    (all queries).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html#ch01)描述了`Select_scan`和`Select_full_join`：分别为[“Select scan”](ch01.html#Select-scan)和[“Select
    full join”](ch01.html#Select-full-join)。这两个度量的唯一区别在于这两个度量适用于全局（所有查询）。'
- en: '`Select_full_range_join` is the lesser evil of `Select_full_join`: instead
    of a full table scan to join a table, MySQL uses an index to do a range scan.
    It’s possible that the range is limited and response time for the `SELECT` is
    acceptable, but it’s bad enough to warrant its own metric.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select_full_range_join`是`Select_full_join`的次优选择：MySQL使用索引而不是完整表扫描来进行范围扫描。可能范围受限且`SELECT`的响应时间可接受，但已经足够糟糕以至于需要它自己的度量。'
- en: '`Select_range_check` is similar to but worse than `Select_full_range_join`.
    It’s easiest to explain with a simple query: `SELECT * FROM t1, t2 WHERE t1.id
    > t2.id`. When MySQL joins tables `t1` and `t2` (in that order), it does *range
    checks* on `t2`: for every value from `t1`, MySQL checks if it can use an index
    on `t2` to do a range scan or index merge. Rechecking every value from `t1` is
    necessary because, given the query, MySQL cannot know `t1` values ahead of time.
    But rather than do the worst possible execution plan—`Select_full_join`—MySQL
    keeps trying to use an index on `t2`. In the `EXPLAIN` output, the `Extra` field
    for `t2` lists “Range checked for each record,” and `Select_range_check` is incremented
    once for the table. The metric is *not* incremented for each range change; it’s
    incremented once to signal that a table was joined by doing range checks.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select_range_check` 类似于但比 `Select_full_range_join` 更糟。可以通过一个简单的查询来最容易地解释：`SELECT
    * FROM t1, t2 WHERE t1.id > t2.id`。当 MySQL 连接表 `t1` 和 `t2`（按此顺序）时，会对 `t2` 进行*范围检查*：对于
    `t1` 的每个值，MySQL 检查是否可以使用 `t2` 上的索引进行范围扫描或索引合并。由于查询时 MySQL 无法预先知道 `t1` 的值，因此需要重新检查每个
    `t1` 的值。但是，与执行最差执行计划 `Select_full_join` 不同，MySQL 会继续尝试使用 `t2` 上的索引。在 `EXPLAIN`
    输出中，`t2` 的 `Extra` 字段列出了“Range checked for each record”，并且对表增加了一次 `Select_range_check`。该指标*不*会在每个范围更改时增加；它只会在连接表时发出一次信号，表明进行了范围检查。'
- en: Bad `SELECT` metrics should be zero or virtually zero (if you round down). A
    few `Select_scan` or `Select_full_range_join` are inevitable, but the other two—`Select_full_join`
    and `Select_range_check`—should be found and fixed immediately if not zero.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不良的 `SELECT` 指标应该为零或接近零（四舍五入）。`Select_scan` 或 `Select_full_range_join` 有一些是不可避免的，但另外两个——`Select_full_join`
    和 `Select_range_check`——如果不是零，应立即找出并修复。
- en: Network Throughput
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络吞吐量
- en: 'The MySQL protocol is very efficient and rarely uses any noticeable amount
    of network bandwidth. Usually, it’s the network affecting MySQL rather than MySQL
    affecting the network. Nevertheless, it’s good to monitor network throughput as
    recorded by MySQL:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 协议非常高效，很少使用大量网络带宽。通常，是网络影响 MySQL 而不是 MySQL 影响网络。尽管如此，监控 MySQL 记录的网络吞吐量仍然是一件好事：
- en: '`Bytes_sent`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bytes_sent`'
- en: '`Bytes_received`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bytes_received`'
- en: 'Since these metrics count network bytes sent and received, respectively, convert
    the values to network units: Mbps or Gbps, whichever matches the link speed of
    the server running MySQL. Gigabit links are most common, even in the cloud.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些指标计算网络发送和接收的字节数，因此将值转换为网络单位：Mbps 或 Gbps，与运行 MySQL 的服务器的链路速度匹配。即使在云中，千兆位链路最为普遍。
- en: Note
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Metric graphing systems convert counters to rates by default, but you probably
    need to multiply these metrics by eight (8 bits per byte) and set the graph unit
    to bits to display as Mbps or Gbps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 指标图形系统默认将计数器转换为速率，但您可能需要将这些指标乘以八（每字节8位），并将图形单位设置为位，以显示为 Mbps 或 Gbps。
- en: 'I have seen MySQL saturate a network only once. The cause was related to a
    system variable that’s not usually a problem: [`var.binlog_row_image`](https://oreil.ly/tboxy).
    This system variable is related to replication that [Chapter 7](ch07.html#ch07)
    addresses in more detail, but the short version is: this system variable controls
    whether or not `BLOB` and `TEXT` columns are logged in the binary logs and replicated.
    The default value is `full`, which logs and replicates `BLOB` and `TEXT` columns.
    Normally, that’s not a problem, but one application created a perfect storm by
    having all of the following attributes at once:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经见过 MySQL 仅仅一次饱和了网络。原因与通常不会成为问题的系统变量有关：[`var.binlog_row_image`](https://oreil.ly/tboxy)。这个系统变量与复制有关，[第7章](ch07.html#ch07)
    更详细地介绍了这个问题，但简短的版本是：这个系统变量控制是否在二进制日志和复制中记录和复制 `BLOB` 和 `TEXT` 列。默认值为 `full`，即记录和复制
    `BLOB` 和 `TEXT` 列。通常情况下，这不是问题，但某个应用程序同时具备以下所有属性时会造成严重问题：
- en: Using MySQL as a queue
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MySQL 作为队列
- en: Huge `BLOB` values
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大 `BLOB` 值
- en: Write-heavy
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入密集型
- en: High throughput
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高吞吐量
- en: 'These access patterns combined to replicate a small flood of data, causing
    major replication lag. The solution was changing `var.binlog_row_image` to `noblob`
    to stop replicating the `BLOB` values, which didn’t need to be replicated. This
    true story leads to the next spectrum: replication.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问模式结合在一起，复制了大量数据，导致主要的复制延迟。解决方案是将 `var.binlog_row_image` 更改为 `noblob`，停止复制不需要复制的
    `BLOB` 值。这个真实的故事引出了下一个问题：复制。
- en: Replication
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: '*Lag* is the bane of replication: the delay between a write on the source MySQL
    instance and when that write is applied on a replica MySQL instance. When replication
    (and the network) is working normally, replication lag is subsecond, limited only
    by network latency.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*滞后*是复制的祸根：源MySQL实例上的写入与在副本MySQL实例上应用该写入之间的延迟。当复制（和网络）正常工作时，复制延迟是次秒级的，仅受网络延迟限制。'
- en: Note
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before MySQL 8.0.22, the replica lag metric and command were `Sec​onds_​Behind_Master`
    and `SHOW SLAVE STATUS`, respectively. As of MySQL 8.0.22, the metric and command
    are `Sec​onds_​Behind_Source` and `SHOW REPLICA STATUS`. I use the current metric
    and command in this book.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0.22之前，副本滞后度量和命令分别为`Sec​onds_​Behind_Master`和`SHOW SLAVE STATUS`。从MySQL
    8.0.22开始，度量和命令变为`Sec​onds_​Behind_Source`和`SHOW REPLICA STATUS`。本书中使用当前的度量和命令。
- en: 'MySQL has an infamous gauge metric for replication lag: `Seconds_Behind_Source`.
    This metric is infamous because it’s not wrong but it’s also not what you expect.
    It can jump between zero and a high value, which is as amusing as it is confusing.
    Consequently, the best practice is to ignore this metric and, instead, use a tool
    like [`pt-heartbeat`](https://oreil.ly/VMg4c) to measure true replication lag.
    Then you have to configure your MySQL monitor software (or service) to measure
    and report *replication lag* from `pt-heartbeat`. Since `pt-heartbeat` has been
    around for so long, some MySQL monitors support it natively; and there’s a good
    chance that the engineers who manage your MySQL instances are already using it.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有一个臭名昭著的度量标准用于复制滞后：`Seconds_Behind_Source`。这个度量标准之所以臭名昭著，是因为它并不是错的，但也不是你期望的那样。它可以在零和一个高值之间跳跃，这既令人愉悦又令人困惑。因此，最佳实践是忽略此度量标准，而是使用像[`pt-heartbeat`](https://oreil.ly/VMg4c)这样的工具来测量真正的复制延迟。然后，您必须配置您的MySQL监控软件（或服务）以从`pt-heartbeat`测量和报告*复制滞后*。由于`pt-heartbeat`已经存在很长时间，一些MySQL监视器本地支持它；而且管理您的MySQL实例的工程师很有可能已经在使用它。
- en: 'MySQL exposes one metric related to replication that is not infamous: `Binlog_cache_disk_use`.
    [Chapter 7](ch07.html#ch07) clarifies the following details; for now, a high level
    explanation is sufficient. For each client connection, a in-memory binary log
    cache buffers writes before they’re written to the binary log files—from which
    the writes replicate to replicas. If the binary log cache is too small to hold
    all the writes for a transaction, the changes are written to disk and `Binlog_cache_disk_use`
    is incremented. In moderation, this is acceptable, but it shouldn’t be frequent.
    If it becomes frequent, you can alleviate it by increasing the binary log cache
    size: [`var.binlog_cache_size`](https://oreil.ly/0TEIJ).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL公开了一个与复制相关的度量标准，这并非臭名昭著：`Binlog_cache_disk_use`。[第7章](ch07.html#ch07)详细说明了以下细节；目前，高层次的解释已经足够。对于每个客户端连接，内存中的二进制日志缓存在将写入写入二进制日志文件之前缓冲写操作——从中写操作复制到副本。如果二进制日志缓存过小而无法容纳事务的所有写入，则将更改写入磁盘并增加`Binlog_cache_disk_use`。适度情况下，这是可以接受的，但不应该频繁发生。如果频繁发生，可以通过增加二进制日志缓存大小[`var.binlog_cache_size`](https://oreil.ly/0TEIJ)来缓解。
- en: 'From the example in the previous section, we know that `var.binlog_row_image`
    affects the binary log cache, too: full row images can require a lot of space
    if the table has `BLOB` or `TEXT` columns.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一节的例子中，我们知道`var.binlog_row_image`也会影响二进制日志缓存：如果表中有`BLOB`或`TEXT`列，完整行图像可能需要大量空间。
- en: Data Size
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据大小
- en: '[Chapter 3](ch03.html#ch03) explains why less data is more performance. Monitoring
    data size is important because it’s common for databases to grow larger than expected.
    If data growth is due to application growth—the application is becoming increasingly
    popular—then it’s a good problem to have, but it’s a problem nevertheless.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html#ch03)解释了为什么数据越少性能越好。监控数据大小很重要，因为数据库通常会比预期的更大。如果数据增长是由应用程序增长导致的——应用程序变得越来越受欢迎——那么这是一个好问题，但仍然是一个问题。'
- en: It’s also easy to overlook because MySQL performance scales effortlessly as
    data grows, but not forever. A database can grow from 10 GB to 300 GB—a 30x increase—and
    not encounter performance issues if queries and access patterns are optimized
    well. But another 30x increase to 9 TB? Not possible. Even a 3x increase to 900
    GB is asking too much—it could happen if the access patterns are exceptionally
    favorable, but don’t bet on it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它也很容易被忽视，因为MySQL的性能随着数据增长而轻松扩展，但并非无限。如果查询和访问模式优化良好，数据库可以从10 GB增长到300 GB，即使不会遇到性能问题。但再增加30倍到9
    TB？不可能。即使是增加3倍到900 GB也是要求过高的——如果访问模式非常有利，这种情况可能会发生，但不要赌这种可能性。
- en: 'MySQL exposes table sizes (and other table metadata) in an Information Schema
    table: [`information_schema.tables`](https://oreil.ly/PqATu). The query in [Example 6-5](#db-size-query)
    returns the size of each database in gigabytes.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL在一个信息模式表`information_schema.tables`中公开了表的大小（和其他表的元数据）：[`information_schema.tables`](https://oreil.ly/PqATu)。在[示例 6-5](#db-size-query)中的查询返回每个数据库的大小（以GB为单位）。
- en: Example 6-5\. Database sizes (GB)
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 数据库大小（GB）
- en: '[PRE5]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The query in [Example 6-6](#tbl-size-query) returns the size of each table in
    gigabytes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 6-6](#tbl-size-query)中的查询返回每个表的大小（以GB为单位）。
- en: Example 6-6\. Table sizes (GB)
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 表大小（GB）
- en: '[PRE6]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is no standard for database and table size metrics. Query and aggregate
    values from `information_schema.tables` to suit your needs. At a bare minimum,
    collect database sizes ([Example 6-5](#db-size-query)) every hour. It’s better
    to be more precise and collect table sizes every 15 minutes.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 没有关于数据库和表大小度量的标准。根据您的需求查询和聚合`information_schema.tables`中的值。至少每小时收集数据库大小（[示例 6-5](#db-size-query)）。更精确地收集表大小，最好每15分钟进行一次。
- en: 'Be sure that, wherever you store or send MySQL metrics, you can retain data
    size metrics for at least a year. Near-term data growth trending is used to estimate
    when the disk will run out of space; or, in the cloud, when more storage will
    need to be provisioned. Long-term data growth trending is used to estimate when
    sharding ([Chapter 5](ch05.html#ch05)) becomes necessary, as covered in [“Practice:
    Four-Year Fit”](ch05.html#ch05-ai).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 确保无论您在何处存储或发送MySQL度量数据，您都能至少保留一年的数据大小度量。短期数据增长趋势用于估计磁盘何时会耗尽空间；或者在云中，用于估计何时需要更多的存储空间。长期数据增长趋势用于估计何时需要分片（[第5章](ch05.html#ch05)），如[“实践：四年合适”](ch05.html#ch05-ai)中所述。
- en: InnoDB
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: InnoDB
- en: '[InnoDB](https://oreil.ly/4b5qP) is complex.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[InnoDB](https://oreil.ly/4b5qP)是复杂的。'
- en: However, since it is the default MySQL storage engine, we must steel ourselves
    to embrace it. A deep dive is not necessary—or even possible within the limits
    of this book. Although this section is long, it barely breaks the surface of InnoDB
    internals. Nevertheless, the following InnoDB metrics reveal some of the inner
    workings of the storage engine responsible for reading and writing data.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于它是默认的MySQL存储引擎，我们必须做好接受它的准备。深入挖掘并不是必要的——甚至在这本书的限制内也不可能。尽管本节内容很长，但几乎没有深入到InnoDB内部的表面。然而，以下InnoDB度量指标揭示了负责读写数据的存储引擎的一些内部工作原理。
- en: History list length (metric)
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史列表长度（度量）
- en: 'History list length (HLL) is a curious metric because every engineer that uses
    MySQL learns what it *means*, but very few know what it *is*. When HLL increases
    significantly over a period of minutes or hours, it means that InnoDB is keeping
    a significant number of old row versions instead of purging them because one or
    more long-running transaction has not committed or was abandoned without being
    rolled back due to an undetected lost client connection. All of that, which I
    explain later in [“History List Length”](ch08.html#hll), is revealed by one gauge
    metric:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 历史列表长度（HLL）是一个奇怪的度量，因为每个使用MySQL的工程师都知道它*意味着*什么，但很少有人知道它*是*什么。当HLL在几分钟或几小时内显著增加时，意味着InnoDB保存了大量旧行版本而未清除，因为一个或多个长时间运行的事务未提交或由于未检测到的客户端连接丢失而被放弃。我在[“历史列表长度”](ch08.html#hll)后面解释的所有这些内容都由一个计量指标揭示：
- en: '`innodb.trx_rseg_history_len`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.trx_rseg_history_len`'
- en: 'A normal value for `innodb.trx_rseg_history_len` is less than 1,000. You should
    monitor and alert if HLL is greater than 100,000. Contrary to [“Wild Goose Chase
    (Thresholds)”](#thresholds) and [“Alert on User Experience and Objective Limits”](#alert-on)
    later in this chapter, this is a reliable threshold and actionable alert. The
    action: find and terminate the long-running or abandoned transaction.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.trx_rseg_history_len`的正常值应小于1,000。如果HLL大于100,000，则应监视并发出警报。与[“野鸡追”（阈值）](#thresholds)和[“用户体验和客观限制的警报”](#alert-on)相反，这是一个可靠的阈值和可操作的警报。措施是：查找并终止长时间运行或被丢弃的事务。'
- en: History list length does not directly affect performance, but it is a harbinger
    of trouble—do not ignore it. The trouble relates to the fact that, since InnoDB
    is a transactional storage engine, every query on an InnoDB table is a transaction.
    Transactions incur overhead, and the HLL metric reveals when a long-running or
    abandoned transaction is causing InnoDB to handle an unreasonable amount of overhead.
    Some overhead is necessary—even beneficial—but too much amounts to waste, and
    waste is antithetical to performance.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 历史列表长度并不直接影响性能，但它是麻烦的前兆——不要忽视它。问题与事实相关，因为 InnoDB 是一个事务性存储引擎，每个对 InnoDB 表的查询都是一个事务。事务会产生开销，而
    HLL 指标显示当一个长时间运行或被放弃的事务导致 InnoDB 处理过多开销时。一些开销是必要的——甚至是有益的——但过多会导致浪费，而浪费是与性能对立的。
- en: 'There’s so much more to say about transactions and HLL that it won its own
    chapter: [Chapter 8](ch08.html#ch08). For now, let’s stay focused on metrics because
    we’ve only begun with InnoDB.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有关事务和 HLL 的内容，这本书还有一个单独的章节：[第 8 章](ch08.html#ch08)。现在，让我们把焦点放在指标上，因为我们刚刚开始接触
    InnoDB。
- en: Deadlock
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 死锁
- en: 'A deadlock occurs when two (or more) transactions hold row locks that the other
    transaction needs. For example, transaction *A* holds a lock on row 1 and needs
    a lock on row 2, and transaction *B* holds a lock on row 2 and needs a lock on
    row 1. MySQL automatically detects and rolls back one transaction to resolve the
    deadlock, and increments one metric:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁发生在两个（或更多）事务持有另一个事务所需的行锁时。例如，事务 *A* 持有行 1 的锁并需要行 2 的锁，而事务 *B* 持有行 2 的锁并需要行
    1 的锁。MySQL 自动检测并回滚一个事务以解决死锁，并增加一个指标：
- en: '`innodb.lock_deadlocks`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.lock_deadlocks`'
- en: Deadlocks should not occur. A prevalence of deadlocks is related to the concurrency
    access pattern trait (see [“Concurrency”](ch04.html#ap-concurrency)). Highly concurrent
    data access must be designed (in the application) to avoid deadlocks by ensuring
    that different transactions accessing the same rows (or nearby rows) examine the
    rows in roughly the same order. In the earlier example of transaction *A* and
    transaction *B*, they access the same two rows in opposite order, which can lead
    to a deadlock when the transactions execute at the same time. To learn more about
    deadlocks, read [“Deadlocks in InnoDB”](https://oreil.ly/UpX0r) in the MySQL manual.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁不应该发生。死锁的普遍性与并发访问模式特征相关（参见[“并发性”](ch04.html#ap-concurrency)）。高并发数据访问必须经过设计（在应用程序中），以避免由于不同事务访问相同行（或附近行）而导致死锁，确保这些事务大致以相同的顺序检查行。在前面关于事务
    *A* 和事务 *B* 的示例中，它们以相反的顺序访问相同的两行，当事务同时执行时可能导致死锁。要了解更多关于死锁的信息，请阅读 MySQL 手册中的[“InnoDB
    中的死锁”](https://oreil.ly/UpX0r)。
- en: Row lock
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行锁
- en: 'Row lock metrics reveal *lock contention*: how quickly (or not) queries acquire
    row locks to write data. The most fundamental row lock metrics are:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 行锁指标显示*锁争用*：查询获取行锁以写入数据的速度（或不速度）。最基本的行锁指标包括：
- en: '`innodb.lock_row_lock_time`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.lock_row_lock_time`'
- en: '`innodb.lock_row_lock_current_waits`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.lock_row_lock_current_waits`'
- en: '`innodb.lock_row_lock_waits`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.lock_row_lock_waits`'
- en: '`innodb.lock_timeouts`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.lock_timeouts`'
- en: 'The first metric, `innodb.lock_row_lock_time`, is a rare type: the total number
    of milliseconds spent acquiring row locks. It’s in the class of response time
    metrics (see [“Response Time”](#field-response-time)), but unlike [“Query Response
    Time”](#metrics-qrt), it is collected as a running total rather than a histogram.
    Consequently, it’s not possible to report `innodb.lock_row_lock_time` as a percentile,
    which would be ideal. And reporting it as a rate (see [“Rate”](#field-rate)) is
    nonsensical: milliseconds per second. Instead, this metric must be reported as
    a difference: if 500 milliseconds at time T1 and 700 milliseconds at time T2,
    then report T2 value – T1 value = 200 ms. (Use maximum for the chart rollup function.
    Don’t average the data points because it’s better to see the worst case.) As a
    response time metric, lower is better. The value of `innodb.lock_row_lock_time`
    cannot be zero (unless the workload is read-only and never needs to acquire a
    single row lock) because it takes a nonzero amount of time to acquire locks. The
    goal, as always, is that the metric is normal and stable. When it’s not, the other
    row lock metrics will not be normal either.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指标 `innodb.lock_row_lock_time` 是一种罕见类型：用于获取行锁的总毫秒数。它属于响应时间指标类别（参见[“响应时间”](#field-response-time)），但不像[“查询响应时间”](#metrics-qrt)，它是作为累积总和而不是直方图进行收集的。因此，无法将
    `innodb.lock_row_lock_time` 报告为百分位数，这本应是理想的。将其作为速率报告（参见[“速率”](#field-rate)）也是荒谬的：每秒毫秒。相反，必须将此指标报告为差异：如果
    T1 时为 500 毫秒，T2 时为 700 毫秒，则报告 T2 值 - T1 值 = 200 毫秒。（在图表聚合函数中使用最大值。不要对数据点进行平均处理，因为最好看到最坏的情况。）作为响应时间指标，数值越低越好。`innodb.lock_row_lock_time`
    的值不能为零（除非工作负载是只读且从不需要获取单个行锁），因为获取锁需要一定的时间。因此，目标始终是指标正常和稳定。当它不正常时，其他行锁指标也不会正常。
- en: '`innodb.lock_row_lock_current_waits` is a gauge metric for the current number
    of queries waiting to acquire a row lock. `innodb.lock_row_lock_waits` is a count
    of the number of queries that waited to acquire a row. The two variables are essentially
    the same: the former is a current gauge, and the latter is a historical counter
    and rate. When the rate of row lock waits increases, it’s a sure sign of trouble
    because MySQL does not wait by accident: something must cause it to wait. In this
    case, the cause will be concurrent queries accessing the same (or nearby) rows.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.lock_row_lock_current_waits` 是当前等待获取行锁的查询数量的计量指标。`innodb.lock_row_lock_waits`
    是等待获取行锁的查询数量的计数器和速率。这两个变量本质上是相同的：前者是当前的计量，后者是历史计数器和速率。当行锁等待率增加时，这是一个明确的问题信号，因为
    MySQL 不会无缘无故等待：一定是有什么原因导致了等待。在这种情况下，原因将是并发查询访问相同（或附近）的行。'
- en: '`innodb.lock_timeouts` is incremented when a row lock wait times out. The default
    row lock wait timeout is 50 seconds, configured by [`var.innodb_lock_wait_timeout`](https://oreil.ly/4kCLg),
    and applies *per row lock*. This is far too long for any normal application to
    wait; I advise a much lower value: 10 seconds or less.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.lock_timeouts` 在行锁等待超时时会增加。默认的行锁等待超时是 50 秒，由 [`var.innodb_lock_wait_timeout`](https://oreil.ly/4kCLg)
    配置，并且适用于*每个*行锁。对于任何正常应用程序来说，等待时间太长了；我建议设置更低的值：10 秒或更短。'
- en: 'InnoDB locking is sophisticated and nuanced. As a result, lock contention is
    *not* a common problem unless the workload exhibits three particular access patterns:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 的锁定机制非常复杂和微妙。因此，除非工作负载展示了三种特定的访问模式，否则锁竞争并*不*是一个常见问题：
- en: Write-heavy ([“Read/Write”](ch04.html#ap-read-write))
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入密集型（[“读写”](ch04.html#ap-read-write)）
- en: High throughput ([“Throughput”](ch04.html#ap-throughput))
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高吞吐量（[“吞吐量”](ch04.html#ap-throughput)）
- en: High concurrency ([“Concurrency”](ch04.html#ap-concurrency))
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高并发性（[“并发性”](ch04.html#ap-concurrency)）
- en: That would be a very particular application and workload. But lock contention
    can become a problem for any application and workload (even with low throughput
    and concurrency), so always monitor rock lock metrics.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个非常特定的应用程序和工作负载。但是锁竞争对于任何应用程序和工作负载都可能成为问题（即使吞吐量和并发性较低），因此始终监视行锁指标。
- en: Data throughput
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据吞吐量
- en: 'Data throughput in bytes per seconds is measured by two metrics:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 数据吞吐量以每秒字节数来衡量，有两个指标：
- en: '`Innodb_data_read`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Innodb_data_read`'
- en: '`Innodb_data_written`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Innodb_data_written`'
- en: 'Data throughput is rarely an issue: SSD is fast; PCIe and NVMe made it even
    faster. Regardless, monitoring data throughput is a best practice because storage
    throughput is limited, especially in the cloud. Do not expect to achieve published
    storage throughput rates because published rates are measured under ideal conditions:
    data straight to (or from) disk. InnoDB is super fast and efficient, but it’s
    still a complex layer of software between the data and the disk that inherently
    precludes achieving published storage throughput rates.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 数据吞吐量很少成为问题：SSD 速度快；PCIe 和 NVMe 使其更快。无论如何，监控数据吞吐量是一种最佳实践，因为存储吞吐量受限，特别是在云中。不要期望实现发布的存储吞吐量速率，因为这些速率是在理想条件下测量的：直接数据到（或从）磁盘。InnoDB
    非常快速和高效，但它仍然是数据和磁盘之间的复杂软件层，从根本上阻止了实现发布的存储吞吐量速率。
- en: Warning
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Be careful about throughput in the cloud: storage is unlikely to be locally
    attached, which limits throughput to network speeds. 1 Gbps equals 125 MB/s, which
    is throughput similar to spinning disks.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意云端的吞吐量：存储通常不会是本地连接的，这会限制吞吐量为网络速度。1 Gbps 相当于 125 MB/s，这是类似于旋转硬盘的吞吐量。
- en: IOPS
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOPS
- en: 'InnoDB has a deep and sometimes complicated relationship with storage I/O capacity,
    measured in IOPS. But first, the easy part: InnoDB read and write IOPS are counted
    by two metrics, respectively:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 与存储 I/O 容量有着深入且有时复杂的关系，以 IOPS 衡量。但首先，让我们先来看简单的部分：InnoDB 的读写 IOPS 分别由两个度量标准来计算：
- en: '`innodb.os_data_reads`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.os_data_reads`'
- en: '`innodb.os_data_writes`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.os_data_writes`'
- en: These metrics are counters, so like other counters, they are converted to and
    expressed as rates by metric graphing systems. Be sure to set the graph unit to
    IOPS for each.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些度量标准是计数器，因此像其他计数器一样，它们会被度量图系统转换并表达为速率。确保为每个度量标准图设置单位为 IOPS。
- en: The performance raison d’être of InnoDB is to optimize and reduce storage I/O.
    Although high IOPS are impressive from an engineering point of view, they are
    the bane of performance because storage is slow. But storage is required for durability—persisting
    data changes to disk—so InnoDB goes to great lengths to be fast *and* durable.
    Consequently, as in [“Less QPS Is Better”](ch03.html#less-qps-is-better), fewer
    IOPS are better.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 的性能核心在于优化和减少存储 I/O。尽管从工程角度来看高 IOPS 令人印象深刻，但对性能来说却是一大难题，因为存储速度较慢。然而，存储是必须的，用于数据持久性，即将数据更改持久化到磁盘上，因此
    InnoDB 努力实现快速*和*持久性。因此，就像在 [“少量 QPS 更好”](ch03.html#less-qps-is-better) 中提到的，更少的
    IOPS 更好。
- en: 'But don’t underutilize IOPS, either. If your company runs its own hardware,
    the maximum number of storage IOPS is determined by the storage device—check the
    device specifications, or ask the engineers who manage the hardware. In the cloud,
    storage IOPS are allocated or provisioned, so it’s usually easier to tell the
    maximum because you purchase the IOPS—check the storage settings, or ask the cloud
    provider. If InnoDB never uses more than 2,000 IOPS, for example, then don’t purchase
    (or provision) 40,000 IOPS: InnoDB simply won’t use the excess IOPS. By contrast,
    if InnoDB constantly uses the maximum number of storage IOPS, then either the
    application workload needs to be optimized to reduce storage I/O (see Chapters
    [1](ch01.html#ch01)–[5](ch05.html#ch05)), or InnoDB legitimately needs more IOPS.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 但也不要低估 IOPS 的使用。如果您的公司使用自己的硬件，存储 IOPS 的最大数量由存储设备确定——请查看设备规格或询问管理硬件的工程师。在云端，存储
    IOPS 是分配或预留的，因此通常更容易知道最大值，因为您购买了这些 IOPS——请检查存储设置或询问云服务提供商。例如，如果 InnoDB 从未使用超过
    2,000 IOPS，那么不要购买（或预留）40,000 IOPS：InnoDB 简单地不会使用多余的 IOPS。相反，如果 InnoDB 不断使用最大数量的存储
    IOPS，那么要么需要优化应用工作负载以减少存储 I/O（参见第 [1](ch01.html#ch01)–[5](ch05.html#ch05) 章），要么
    InnoDB 确实需要更多的 IOPS。
- en: 'InnoDB I/O capacity for *background tasks* is largely configured by [`var​.inno​db_​io_capacity`](https://oreil.ly/zU6iW)
    and [`var.innodb_io_capacity_max`](https://oreil.ly/LiilY), two system variables
    that default to 200 and 2,000 IOPS, respectively. (There are other variables,
    but I must gloss over them to stay focused on metrics. To learn more, read [“Configuring
    InnoDB I/O Capacity”](https://oreil.ly/G9Bcw) in the MySQL manual.) Background
    tasks include page flushing, change buffer merging, and more. In this book, I
    cover only page flushing, which is arguably the single most important background
    task. Limiting background task storage I/O ensures that InnoDB does not overwhelm
    the server. It also allows InnoDB to optimize and stabilize storage I/O rather
    than bombard the storage device with erratic access. By contrast, foreground tasks
    do not have any configurable I/O capacities or limits: they use as many IOPS as
    necessary and available. The primary foreground task is executing queries, but
    this does not mean queries use high or excessive IOPS because, remember, the performance
    raison d’être of InnoDB is to optimize and reduce storage I/O. For reads, the
    buffer pool purposefully optimizes and reduces IOPS. For writes, page flushing
    algorithms and the transaction log purposefully optimize and reduce storage I/O.
    The following sections reveal how.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB *后台任务* 的I/O容量主要由[`var.inno​db_​io_capacity`](https://oreil.ly/zU6iW)和[`var.innodb_io_capacity_max`](https://oreil.ly/LiilY)两个系统变量配置，默认值分别为200和2,000
    IOPS。（还有其他变量，但我必须略过它们以便专注于度量。要了解更多，请阅读MySQL手册中的[“配置InnoDB I/O容量”](https://oreil.ly/G9Bcw)。）后台任务包括页面刷新、变更缓冲区合并等。在本书中，我仅涵盖页面刷新，这可谓是最重要的后台任务之一。限制后台任务的存储I/O确保InnoDB不会过载服务器。它还允许InnoDB优化和稳定存储I/O，而不是向存储设备发送不规律的访问。相比之下，前台任务没有任何可配置的I/O容量或限制：它们使用必要和可用的IOPS。主要的前台任务是执行查询，但这并不意味着查询使用高或过多的IOPS，因为请记住，InnoDB的性能目的是优化和减少存储I/O。对于读取操作，缓冲池有意优化和减少IOPS。对于写入操作，页面刷新算法和事务日志有意优化和减少存储I/O。接下来的几节将揭示其详细内容。
- en: 'InnoDB can achieve high IOPS, but can the application? Probably not because
    there are many layers between the application and the IOPS that preclude the former
    from achieving a high number of the latter. In my experience, applications use
    hundreds to thousands of IOPS, and exceptionally optimized applications that are
    “going viral” push around 10,000 IOPS on a single MySQL instance. Recently, I
    was benchmarking MySQL in the cloud and hit a ceiling at 40,000 IOPS. The cloud
    provider publishes 80,000 IOPS as the maximum and allows me to provision that,
    but their storage system is capped at 40,000 IOPS. Point being: InnoDB can achieve
    high IOPS, but everything around it is a different question.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB可以实现高IOPS，但应用程序呢？可能不行，因为应用程序与IOPS之间有许多层，这些层阻碍了前者实现较高的后者数量。根据我的经验，应用程序使用数百至数千个IOPS，而“热门”优化的应用程序在单个MySQL实例上推动大约10,000个IOPS。最近，我在云中进行了MySQL的基准测试，并在40,000个IOPS处达到了一个上限。云服务提供商发布的最大值为80,000个IOPS，并允许我进行配置，但他们的存储系统限制在40,000个IOPS。重点是：InnoDB可以实现高IOPS，但其周围的一切又是另一回事。
- en: 'This section is only a primer on InnoDB I/O because it underlies the final
    three InnoDB spectra that consume IOPS: [“Buffer pool efficiency”](#metrics-buff-pool),
    [“Page flushing”](#metrics-page-flushing), and [“Transaction log”](#metrics-trx-log).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅是InnoDB I/O的入门，因为它构成了消耗IOPS的最后三个InnoDB光谱的基础：[“缓冲池效率”](#metrics-buff-pool)，[“页面刷新”](#metrics-page-flushing)和[“事务日志”](#metrics-trx-log)。
- en: 'To learn more InnoDB I/O, start by reading [“Configuring InnoDB I/O Capacity”](https://oreil.ly/w9MOg)
    in the MySQL manual. To really dive into the nitty-gritty details of InnoDB I/O,
    read an illuminating three-part blog post by renowned MySQL experts Yves Trudeau
    and Francisco Bordenave: [“Give Love to Your SSDs: Reduce innodb_io_capacity_max!”](https://oreil.ly/q0L61),
    [“InnoDB Flushing in Action for Percona Server for MySQL”](https://oreil.ly/ZY2Xe),
    and [“Tuning MySQL/InnoDB Flushing for a Write-Intensive Workload”](https://oreil.ly/P03EX).
    But finish this chapter first because it’s a great foundation for those blog posts.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于InnoDB I/O的信息，请先阅读MySQL手册中的[“配置InnoDB I/O容量”](https://oreil.ly/w9MOg)。要真正深入了解InnoDB
    I/O的细枝末节，请阅读著名的MySQL专家Yves Trudeau和Francisco Bordenave撰写的启发性三部曲博客文章：[“给你的SSD多点爱：减少innodb_io_capacity_max！”](https://oreil.ly/q0L61)，[“Percona
    Server for MySQL中的InnoDB刷新实战”](https://oreil.ly/ZY2Xe)，以及[“为写入密集型工作负载调整MySQL/InnoDB刷新”](https://oreil.ly/P03EX)。但请先完成本章内容，因为它为这些博客文章奠定了良好的基础。
- en: InnoDB works with data in memory, not on disk. It reads data from disk when
    necessary, and it writes data to disk to make changes durable, but these are lower
    level operations into which the next three sections delve. At a higher level,
    InnoDB works with data in memory because storage is too slow—even with a million
    IOPS. Consequently, there is not a direct correlation between queries, rows, and
    IOPS. Writes always consume IOPS (for durability). Reads can execute without consuming
    any IOPS, but it depends on buffer pool efficiency.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 在内存中处理数据，而不是在磁盘上。必要时从磁盘读取数据，并将数据写入磁盘以使更改持久化，但这些是较低级别的操作，将在接下来的三个部分中详细探讨。在更高的层次上，InnoDB
    在内存中处理数据，因为存储速度太慢——即使有百万 IOPS。因此，查询、行和 IOPS 之间没有直接的对应关系。写入始终消耗 IOPS（用于持久性）。读取可以在不消耗任何
    IOPS 的情况下执行，但这取决于缓冲池效率。
- en: Buffer pool efficiency
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲池效率
- en: The InnoDB buffer pool is an *in-memory* cache of table data and other internal
    data structures. From [“InnoDB Tables Are Indexes”](ch02.html#tables-are-indexes),
    you know that the buffer pool contains index pages—more on pages in the next section.
    InnoDB certainly understands rows, but internally it’s far more concerned with
    pages. At this depth of MySQL performance, the focus changes from rows to pages.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 缓冲池是表数据和其他内部数据结构的*内存*缓存。来自[“InnoDB 表即索引”](ch02.html#tables-are-indexes)的信息表明，缓冲池包含索引页——更多关于页的内容将在下一节讨论。InnoDB
    确实理解行，但内部更关注页。在 MySQL 性能的这个深度上，焦点从行转向页。
- en: 'At a high level, InnoDB accesses (reads and writes) all data by pages in the
    buffer pool. (Low-level writes are more complicated and addressed in the last
    InnoDB section: [“Transaction log”](#metrics-trx-log).) If data is not in the
    buffer pool when accessed, InnoDB reads it from storage and saves it in the buffer
    pool.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，InnoDB 通过缓冲池中的页访问（读取和写入）所有数据。（低级别写入更复杂，在最后一个 InnoDB 部分中详细介绍：[“事务日志”](#metrics-trx-log)。）如果访问时数据不在缓冲池中，InnoDB
    将从存储器中读取并保存到缓冲池中。
- en: '*Buffer pool efficiency* is the percentage of data accessed from memory, calculated
    from two metrics:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓冲池效率*是从内存访问的数据百分比，由两个指标计算：'
- en: '`Innodb_buffer_pool_read_request`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Innodb_buffer_pool_read_request`'
- en: '`Innodb_buffer_pool_reads`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Innodb_buffer_pool_reads`'
- en: '`Innodb_buffer_pool_read_request` counts all requests to access data in the
    buffer pool. If the requested data is *not* in memory, InnoDB increments `Inno​db_​buf​fer_​pool_reads`
    and loads the data from disk. Buffer pool efficiency equals (`Innodb_buffer_pool_read_request`
    / `Innodb_buffer_pool_reads`) × 100.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_buffer_pool_read_request` 计算所有访问缓冲池中数据的请求。如果请求的数据*不在*内存中，InnoDB 将增加
    `Inno​db_​buf​fer_​pool_reads` 并从磁盘加载数据。缓冲池效率等于 (`Innodb_buffer_pool_read_request`
    / `Innodb_buffer_pool_reads`) × 100。'
- en: Note
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The word *read* in these metrics does not mean `SELECT`. InnoDB reads data
    from the buffer pool for all queries: `INSERT`, `UPDATE`, `DELETE`, and `SELECT`.
    For example, on `UPDATE`, InnoDB reads the row from the buffer pool. If not in
    the buffer pool, it loads the row from disk into the buffer pool.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标中的 *read* 不意味着 `SELECT`。InnoDB 为所有查询（`INSERT`、`UPDATE`、`DELETE` 和 `SELECT`）从缓冲池中读取数据。例如，在
    `UPDATE` 时，InnoDB 从缓冲池中读取行。如果不在缓冲池中，则从磁盘加载行到缓冲池中。
- en: Buffer pool efficiency will be very low when MySQL starts. This is normal; it’s
    called a *cold buffer pool*. Loading data warms the buffer pool—like throwing
    logs on a fire. It usually takes several minutes to fully warm the buffer pool,
    which is indicated when buffer pool efficiency reaches its normal and stable value.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MySQL 启动时，缓冲池效率会非常低。这是正常现象；称为*冷缓冲池*。加载数据会使缓冲池变暖——就像往火上扔木头一样。通常需要几分钟才能完全使缓冲池变暖，这在缓冲池效率达到正常稳定值时得到体现。
- en: 'Buffer pool efficiency should be extremely close to 100%—ideally 99.0% or greater—but
    don’t fixate on the value. Technically, this metric is a cache hit ratio, but
    that’s not how it’s used. A cache hit ratio reveals little beyond the metric:
    values are cached, or they’re not. On the contrary, buffer pool efficiency reveals
    how well InnoDB is able to keep frequently accessed data—the working set—in memory
    while balancing speed and durability. To put it colorfully, buffer pool efficiency
    is how well InnoDB can keep a match lit in a hurricane. The working set is the
    flame; durability is the rain (it dampens throughput);^([5](ch06.html#idm45829110227344))
    the application is the wind.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲池效率应该非常接近于100% —— 理想情况下是99.0%或更高，但不要固守于数值。从技术上讲，这个指标是一个缓存命中率，但并不是它的使用方式。缓冲池效率揭示了InnoDB在平衡速度和耐久性时，能够将频繁访问的数据——工作集——保持在内存中的能力。形象地说，缓冲池效率是InnoDB在飓风中保持火柴点燃的能力。工作集是火焰；耐久性是雨水（它减少了吞吐量）；^([5](ch06.html#idm45829110227344))
    应用程序是风。
- en: Note
  id: totrans-364
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In a bygone era, performance equated to cache hit ratios. Today, that is no
    longer true: performance is query response time. If buffer pool efficiency is
    extremely low but response time is great, then performance is great. That probably
    won’t happen, but the point is not to lose focus—recall [“North Star”](ch01.html#north-star).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，性能等同于缓存命中率。如今，情况已非如此：性能是查询响应时间。如果缓冲池效率非常低但响应时间很好，那么性能很好。这种情况可能不会发生，但重点不是失去焦点——回想[“北极星”](ch01.html#north-star)。
- en: 'If total data size is less than available memory, then all data can fit in
    the buffer pool at once. (Buffer pool size is configured by [`var.innodb_buffer_pool_size`](https://oreil.ly/N4lnI).
    Or, as of MySQL 8.0.3, enabling [`var.innodb_dedicated_server`](https://oreil.ly/I5KaC)
    automatically configures buffer pool size and other related system variables.)
    In this case, buffer pool efficiency is a nonissue and performance bottlenecks—if
    any—will occur in CPU or storage (since all data is in memory). But this case
    is the exception, not the norm. The norm is total data size being *far greater*
    than available memory. In this (normal) case, buffer pool efficiency has three
    primary influences:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果总数据大小小于可用内存，则所有数据可以一次性适应缓冲池。（缓冲池大小由[`var.innodb_buffer_pool_size`](https://oreil.ly/N4lnI)配置。或者，从MySQL
    8.0.3开始，启用[`var.innodb_dedicated_server`](https://oreil.ly/I5KaC)会自动配置缓冲池大小和其他相关系统变量。）在这种情况下，缓冲池效率不是问题，性能瓶颈（如果有的话）将出现在CPU或存储器中（因为所有数据都在内存中）。但这种情况是例外，不是常态。常态是总数据大小远远大于可用内存。在这种（正常）情况下，缓冲池效率有三个主要影响因素：
- en: Data access
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问
- en: Data access brings data into the buffer pool. The data age access pattern trait
    (see [“Data Age”](ch04.html#ap-data-age)) is the primary influence because only
    new data needs to be loaded into the buffer pool.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问将数据带入缓冲池。数据年龄访问模式特性（参见[“数据年龄”](ch04.html#ap-data-age)）是主要影响因素，因为只有新数据需要加载到缓冲池中。
- en: Page flushing
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 页面刷新
- en: Page flushing allows data to be evicted from the buffer pool. Page flushing
    is necessary for new data to be loaded into the buffer pool. The next section
    goes into more detail.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 页面刷新允许从缓冲池中驱逐数据。页面刷新对于将新数据加载到缓冲池中是必要的。下一节将详细介绍。
- en: Available memory
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 可用内存
- en: The more data that InnoDB keeps in memory, the less it needs to load or flush
    data. In the exceptional case previously mentioned, when all data fits in memory,
    buffer pool efficiency is a nonissue.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB在内存中保留的数据越多，就越不需要加载或刷新数据。在前面提到的例外情况中，当所有数据都适应内存时，缓冲池效率不是问题。
- en: 'Buffer pool efficiency reveals the combined effect of those three influences.
    As a combined effect, it cannot pinpoint one cause. If its value is lower than
    normal, the cause could be one, two, or all three influences. You must analyze
    all three to determine which is the greatest *or* the most feasible to change.
    For example, as detailed in [Chapter 4](ch04.html#ch04), changing access patterns
    is a best practice for improving performance, but if you’re page-deep in MySQL
    performance, you’ve probably already done that. In that case, more memory or faster
    storage (more IOPS) might be more feasible—and more justified since you’ve already
    optimized the workload. Although buffer pool efficiency cannot give you answers,
    it tells you where to look: access patterns (especially [“Data Age”](ch04.html#ap-data-age)),
    page flushing, and memory size.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲池效率显示了这三种影响的综合效果。作为综合效果，它不能准确指出一个原因。如果其值低于正常水平，原因可能是其中一个、两个或所有三个影响因素。您必须分析所有三个因素，以确定哪一个是最主要的或最可改变的。例如，如第4章所述，更改访问模式是改善性能的最佳实践，但如果您深入MySQL性能，可能已经做过了。在这种情况下，增加内存或更快的存储（更多的IOPS）可能更可行，并且更有理由，因为您已经优化了工作负载。尽管缓冲池效率不能给出答案，但它告诉您应该从哪里着手：访问模式（特别是[“数据年龄”](ch04.html#ap-data-age)）、页面刷新和内存大小。
- en: InnoDB buffer pool efficiency is the tip of the iceberg. Underneath, page flushing
    is the internal machinery that keeps it afloat.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB缓冲池效率只是冰山一角。在其下面，页面刷新是保持其运行的内部机制。
- en: Page flushing
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面刷新
- en: This spectrum is large and complicated, so it’s further subdivided into *Pages*
    and *Flushing*, which are inextricable.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个光谱非常广泛和复杂，因此进一步细分为*页面*和*刷新*，二者密不可分。
- en: Pages
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 页面
- en: 'As mentioned in the previous section, the buffer pool contains index pages.
    There are four types of pages:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，缓冲池包含索引页面。有四种类型的页面：
- en: Free pages
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲页面
- en: These contain no data; InnoDB can load new data into them.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不包含数据；InnoDB可以将新数据加载到其中。
- en: Data pages
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 数据页
- en: These contain data that has not been modified; also called *clean pages*.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包含尚未修改的数据；也称为*干净页*。
- en: Dirty pages
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 脏页
- en: These contain modified data that has not been flushed to disk.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包含尚未刷新到磁盘的修改数据。
- en: Misc pages
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 杂项页面
- en: These contain miscellaneous internal data not covered in this book.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包含本书未涵盖的各种内部数据。
- en: 'Since InnoDB keeps the buffer pool full of data, monitoring the number of data
    pages is not necessary. Free and dirty pages are the most revealing with respect
    to performance, especially when viewed with flushing metrics in the next section.
    Three gauges and one counter (the last metric) reveal how many free and dirty
    pages are sloshing around in the buffer pool:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 由于InnoDB保持缓冲池充满数据，监控数据页的数量并不必要。空闲和脏页在性能方面尤为重要，特别是在下一节中查看刷新指标时。三个仪表和一个计数器（最后一个指标）显示缓冲池中流动的空闲和脏页的数量：
- en: '`innodb.buffer_pool_pages_total`'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_pool_pages_total`'
- en: '`innodb.buffer_pool_pages_dirty`'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_pool_pages_dirty`'
- en: '`innodb.buffer_pool_pages_free`'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_pool_pages_free`'
- en: '`innodb.buffer_pool_wait_free`'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_pool_wait_free`'
- en: '`innodb.buffer_pool_pages_total` is the total number of pages in the buffer
    pool (total page count), which depends on the buffer pool size ([`var​.inno​db_​buffer_pool_size`](https://oreil.ly/fXHQ4)).
    (Technically, this is a gauge metric because, as of MySQL 5.7.5, the InnoDB buffer
    pool size is dynamic. But frequently changing the buffer pool size is not common
    because it’s sized according to system memory, which cannot change quickly—even
    cloud instances require a few minutes to resize.) Total page count calculates
    the percentage of free and dirty pages: `innodb.buffer_pool_pages_free` and `innodb.buffer_pool_pages_dirty`
    divided by total pages, respectively. Both percentages are gauge metrics, and
    the values change frequently due to page flushing.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.buffer_pool_pages_total`是缓冲池中页面的总数（总页面数），这取决于缓冲池的大小（[`var​.inno​db_​buffer_pool_size`](https://oreil.ly/fXHQ4)）。
    （从技术上讲，这是一个仪表指标，因为从MySQL 5.7.5开始，InnoDB缓冲池大小是动态的。但经常更改缓冲池大小并不常见，因为它根据系统内存大小调整，这种调整不能很快进行——即使云实例也需要几分钟来调整大小。）总页面数计算空闲和脏页的百分比：`innodb.buffer_pool_pages_free`和`innodb.buffer_pool_pages_dirty`分别除以总页面数。这两个百分比是仪表指标，并且由于页面刷新而频繁变化。'
- en: 'To ensure that free pages are available when needed, InnoDB maintains a nonzero
    balance of free pages that I call the *free page target*. The free page target
    is equal to the product of two system variables: the system variable [`var.innodb_lru_scan_depth`](https://oreil.ly/TG9hj)
    multiplied by [`var.innodb_buffer_pool_instances`](https://oreil.ly/srIHw). The
    name of the former system variable is somewhat misleading, but it configures the
    number of free pages that InnoDB maintains in *each* buffer pool instance; the
    default is 1024 free pages. Until now, I have written about *the buffer pool*
    as one logical part of InnoDB. Under the hood, the buffer pool is divided into
    multiple *buffer pool instances*, each with its own internal data structures to
    reduce contention under heavy load. The default for `var.innodb_buffer_pool_instances`
    is 8 (or 1 if the buffer pool size is less than 1 GB). Therefore, with defaults
    for both system variables, InnoDB maintains 1024 × 8 = 8192 free pages. Free pages
    should hover around the free page target.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保在需要时有空闲页面可用，InnoDB维护了一个非零的自由页面余额，我称之为*自由页面目标*。自由页面目标等于两个系统变量的乘积：系统变量[`var.innodb_lru_scan_depth`](https://oreil.ly/TG9hj)乘以[`var.innodb_buffer_pool_instances`](https://oreil.ly/srIHw)。前一个系统变量的名称有些误导，但它配置了InnoDB在每个缓冲池实例中维护的自由页面数量；默认为1024个自由页面。到目前为止，我已经写了关于*缓冲池*作为InnoDB的一个逻辑部分。在内部，缓冲池被分成多个*缓冲池实例*，每个实例都有自己的内部数据结构，在重负载下减少竞争。`var.innodb_buffer_pool_instances`的默认值为8（如果缓冲池大小小于1
    GB，则为1）。因此，使用两个系统变量的默认值，InnoDB维护了1024 × 8 = 8192个自由页面。自由页面应该保持在自由页面目标周围。
- en: Tip
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Reducing `var.innodb_lru_scan_depth` is a best practice because, with default
    values, it yields 134 MB of free page size: 8192 free pages × 16 KB/page = 134
    MB. That is excessive given that rows are typically hundreds of bytes. It’s more
    efficient for free pages to be as low as possible without hitting zero and incurring
    free page waits (explained in the next paragraph). It’s good to be aware of this,
    but it’s MySQL tuning, which is beyond the scope of this book. The default does
    not hinder performance; MySQL experts just abhor inefficiency.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 减少`var.innodb_lru_scan_depth`是最佳实践，因为默认值下，它会产生134 MB的自由页面大小：8192个自由页面 × 16 KB/页面
    = 134 MB。鉴于行通常是数百字节，这显然过于高效。最好尽可能降低自由页面，避免达到零并遭受自由页面等待（在下一段解释）。了解这一点很好，但这是MySQL调整，超出本书的范围。默认设置不会影响性能；MySQL专家只是讨厌低效率。
- en: 'If free pages are consistently near zero (below the free page target), that’s
    fine as long as `innodb.buffer_pool_wait_free` remains zero. When InnoDB needs
    a free page but none is available, it increments `innodb.buffer_pool_wait_free`
    and waits. This is called a *free page wait* and it should be exceptionally rare—even
    when the buffer pool is full of data—because InnoDB actively maintains the free
    page target. But under very heavy load, it might not be able to flush and free
    pages fast enough. Simply put: InnoDB is reading new data faster than it can flush
    old data. Presuming that the workload is already optimized, there are three solutions
    to free page waits:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自由页面持续接近零（低于自由页面目标），只要`innodb.buffer_pool_wait_free`保持为零，这没问题。当InnoDB需要一个空闲页面但没有可用时，它会增加`innodb.buffer_pool_wait_free`并等待。这称为*自由页面等待*，应该极其罕见——即使缓冲池充满数据——因为InnoDB积极维护自由页面目标。但在非常重载的情况下，它可能无法快速刷新和释放页面。简而言之：InnoDB读取新数据的速度比刷新旧数据的速度快。假设工作负载已经优化，解决自由页面等待有三种方法：
- en: Increase free page target
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 增加自由页面目标
- en: If your storage can provide more IOPS (or you can provision more IOPS in the
    cloud), then increasing `var.innodb_lru_scan_depth` causes InnoDB to flush and
    free more pages, which requires more IOPS (see [“IOPS”](#metrics-iops)).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的存储可以提供更多IOPS（或者您可以在云中配置更多IOPS），则增加`var.innodb_lru_scan_depth`会导致InnoDB刷新和释放更多页面，这需要更多的IOPS（参见[“IOPS”](#metrics-iops)）。
- en: Better storage system
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的存储系统
- en: If your storage cannot provide more IOPS, upgrade to better storage, then increase
    the free page target.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的存储无法提供更多IOPS，请升级到更好的存储，然后增加自由页面目标。
- en: More memory
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内存
- en: The more memory, the bigger the buffer pool, and the more pages can fit in memory
    without needing to flush and evict old pages to load new pages. There’s one more
    detail about free page waits that I clarify later when explaining LRU flushing.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 内存越多，缓冲池越大，内存中可以容纳更多页面，而无需刷新和驱逐旧页面以加载新页面。关于自由页面等待还有一个细节，在解释LRU刷新时我稍后会澄清。
- en: Note
  id: totrans-403
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember from [“Buffer pool efficiency”](#metrics-buff-pool): *read* doesn’t
    mean `SELECT`. InnoDB reads new data from the buffer pool for all queries: `INSERT`,
    `UPDATE`, `DELETE`, and `SELECT`. When data is accessed but not in the buffer
    pool (in memory), InnoDB reads it from disk.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住[“缓冲池效率”](#metrics-buff-pool)中所述：*读*并不意味着`SELECT`。InnoDB 为所有查询（`INSERT`、`UPDATE`、`DELETE`和`SELECT`）从缓冲池中读取新数据。当数据访问但不在缓冲池中（在内存中），InnoDB
    从磁盘中读取它。
- en: If free pages are consistently much higher than the free page target, or never
    decrease to the target, then the buffer pool is too large. For example, 50 GB
    of data fills only 39% of 128 GB of RAM. MySQL is optimized to use only the memory
    that it needs, so giving it an overabundance of memory will not increase performance—MySQL
    simply won’t use the excess memory. Don’t waste memory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如果空闲页持续远高于空闲页目标，或者从未降至目标值，则缓冲池过大。例如，50 GB 的数据仅填充了 128 GB RAM 的 39%。MySQL 优化为仅使用其需要的内存，因此提供过多的内存不会增加性能——MySQL
    简单地不会使用多余的内存。不要浪费内存。
- en: Dirty pages as a percentage of total pages varies between 10% and 90% by default.
    Although dirty pages contain modified data that has not been flushed to disk,
    the data changes have been flushed to disk in the transaction log—more on this
    in the next two sections. Even with 90% dirty pages, all data changes are guaranteed
    durable—persisted to disk. It’s completely normal to have a high percentage of
    dirty pages. In fact, it’s expected unless the workload is exceptionally read-heavy
    (recall access pattern trait [“Read/Write”](ch04.html#ap-read-write)) and simply
    does not modify data very often. (In this case, I would consider whether another
    data store is better suited to the workload.)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，脏页作为总页数的百分比在10%到90%之间变化。尽管脏页包含未刷新到磁盘的修改数据，但数据变更已在事务日志中刷新到磁盘——接下来的两个部分将进一步详细说明。即使有90%的脏页，所有数据变更也保证持久化到磁盘。高比例脏页是完全正常的。实际上，除非工作负载特别读重（回顾访问模式特性[“读/写”](ch04.html#ap-read-write)），且几乎不经常修改数据，否则是预期的（在这种情况下，我会考虑是否有其他数据存储更适合该工作负载）。
- en: Since a high percentage of dirty pages is expected, this metric is used to corroborate
    other metrics related to page flushing (next section), the transaction log ([“Transaction
    log”](#metrics-trx-log)), and disk I/O ([“IOPS”](#metrics-iops)). For example,
    writing data causes dirty pages, so a spike in dirty pages corroborates a spike
    in IOPS and transaction log metrics. But a spike in IOPS without a corresponding
    spike in dirty pages cannot be caused by writes; it must be another issue—maybe
    an engineer manually executed an ad hoc query that dredged up a mass of old data
    that hadn’t seen the light of day in eons, and now InnoDB is reading it from disk
    in a maelstrom of IOPS. Ultimately, dirty pages rise and fall with the gentle
    tides of page flushing.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于预期有高比例的脏页，此指标用于验证与页面刷新（下一节）、事务日志（[“事务日志”](#metrics-trx-log)）和磁盘 I/O（[“IOPS”](#metrics-iops)）相关的其他指标。例如，写入数据会导致脏页增加，因此脏页的激增与
    IOPS 和事务日志指标的激增相一致。但是，IOPS 的激增没有相应的脏页激增，则不能由写入引起；这必须是另一个问题——可能是工程师手动执行了一个检索大量旧数据的临时查询，现在
    InnoDB 在 IOPS 的旋涡中从磁盘中读取它。最终，脏页随页面刷新的温和潮汐而起伏。
- en: Page flushing
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 页面刷新
- en: '*Page flushing* cleans dirty pages by writing the data modifications to disk.
    Page flushing serves three closely related purposes: durability, checkpointing,
    and page eviction. For simplicity, this section focuses on page flushing with
    respect to page eviction. [“Transaction log”](#metrics-trx-log) clarifies how
    page flushing serves durability and checkpointing.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*页面刷新*通过将数据修改写入磁盘来清除脏页面。页面刷新有三个紧密相关的目的：持久性、检查点和页面驱逐。为简单起见，本节重点讨论与页面驱逐相关的页面刷新。[“事务日志”](#metrics-trx-log)阐明了页面刷新如何提供持久性和检查点功能。'
- en: 'From [“Buffer pool efficiency”](#metrics-buff-pool), you know that page flushing
    makes space for new data to be loaded into the buffer pool. More specifically,
    page flushing makes dirty pages clean, and clean pages can be evicted from the
    buffer pool. Thus, the circle of page life is complete:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从[“缓冲池效率”](#metrics-buff-pool)可知，页面刷新为新数据在缓冲池中加载空间。更具体地说，页面刷新将脏页变为干净页，而干净页可以从缓冲池中驱逐出去。因此，页面的生命周期循环完成：
- en: A free page becomes a clean (data) page when data is loaded
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据加载时，空闲页变为干净（数据）页
- en: A clean page becomes a dirty page when its data is modified
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据修改时，干净页变为脏页
- en: A dirty page becomes a clean page again when the data modifications are flushed
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据修改被刷新时，一个脏页面重新变成了一个干净的页面。
- en: A clean page becomes a free page again when it’s evicted from the buffer pool
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当页面从缓冲池中被驱逐时，一个干净的页面重新变成了一个空闲的页面。
- en: The implementation of page flushing is complex and varies among distributions
    (Oracle MySQL, Percona Server, and MariaDB Server), so you might want to reread
    the following information to fully absorb the many intricate details. [Figure 6-6](#page-flushing)
    depicts the high-level components and flow of InnoDB page flushing from committing
    transactions in the transaction log (at top) to flushing and evicting pages from
    the buffer pool (at bottom).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 页面刷新的实现是复杂的，并且在不同的发行版中有所不同（Oracle MySQL、Percona Server 和 MariaDB Server），因此您可能希望重新阅读以下信息，以充分吸收其中的许多复杂细节。[图 6-6](#page-flushing)
    描述了 InnoDB 页面刷新从事务日志中提交事务（顶部）到从缓冲池刷新和驱逐页面（底部）的高级组件和流程。
- en: Figuratively, InnoDB page flushing works top to bottom in [Figure 6-6](#page-flushing),
    but I’m going to explain it from the bottom up. In the buffer pool, dirty pages
    are dark, clean (data) pages are white, and free pages have a dotted outline.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 比喻地说，InnoDB 页面刷新在 [图 6-6](#page-flushing) 中自顶向下工作，但我将从底向上解释。在缓冲池中，脏页面是深色的，干净（数据）页面是白色的，而空闲页面则有虚线边框。
- en: '![emsp 0606](assets/emsp_0606.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0606](assets/emsp_0606.png)'
- en: Figure 6-6\. InnoDB page flushing
  id: totrans-418
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. InnoDB 页面刷新
- en: 'Dirty pages are recorded in two internal lists (for each buffer pool instance):'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 脏页面在两个内部列表中记录（每个缓冲池实例）：
- en: Flush list
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新列表
- en: Dirty pages from writes committed in the transaction log.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 来自事务日志中已提交写入的脏页面。
- en: LRU list
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: LRU 列表
- en: Clean and dirty pages in the buffer pool ordered by data age.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲池中根据数据年龄排序的干净和脏页面。
- en: Strictly speaking, the LRU list tracks all pages with data, and that just happens
    to include dirty pages; whereas the flush list explicitly tracks only dirty pages.
    Either way, MySQL uses both lists to find dirty pages to flush. (In [Figure 6-6](#page-flushing),
    the LRU list is connected to [tracking] only one dirty page, but this only a simplification
    to avoid a clutter of lines.)
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，LRU列表跟踪所有具有数据的页面，这些页面包括脏页面；而刷新列表显式地只跟踪脏页面。无论如何，MySQL 使用这两个列表来查找要刷新的脏页面。（在
    [图 6-6](#page-flushing) 中，LRU 列表与 [追踪] 只连接了一个脏页面，但这只是为了避免线条混乱的简化描述。）
- en: Once every second, dirty pages are flushed from both lists by background threads
    aptly named *page cleaner threads*. By default, InnoDB uses four page cleaner
    threads, configured by [`var.innodb_page_cleaners`](https://oreil.ly/ELUoy). Each
    page cleaner flushes both lists; but for simplicity, [Figure 6-6](#page-flushing)
    shows one page cleaner flushing one list.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟一次，后台线程从两个列表中刷新脏页面，这些线程被称为 *页面清理器线程*。默认情况下，InnoDB 使用四个页面清理器线程，由 [`var.innodb_page_cleaners`](https://oreil.ly/ELUoy)
    配置。每个页面清理器刷新两个列表；但为了简单起见，[图 6-6](#page-flushing) 显示一个页面清理器刷新一个列表。
- en: 'Two flushing algorithms are primarily responsible for flush list flushing and
    LRU list flushing, respectively:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 两种刷新算法主要负责刷新列表和 LRU 列表的刷新：
- en: Adaptive flushing
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应刷新
- en: Adaptive flushing determines the rate at which page cleaners flush dirty pages
    from the flush list.^([6](ch06.html#idm45829110113632)) The algorithm is *adaptive*
    because it varies the page flush rate based on the rate of transaction log writes.
    Faster writes, faster page flushing. The algorithm responds to write load, but
    it’s also finely tuned to produce a stable rate of page flushing under varying
    write loads.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应刷新确定页面清理器从刷新列表中刷新脏页面的速率。[^6] 该算法是 *自适应* 的，因为它根据事务日志写入的速率变化调整页面刷新率。写入速度越快，刷新页面也越快。该算法响应写入负载，但也经过精心调整，以在不同的写入负载下产生稳定的页面刷新速率。
- en: 'Page flushing by page cleaners is a background task, therefore the page flush
    rate is limited by the configured InnoDB I/O capacity explained in [“IOPS”](#metrics-iops),
    specifically: `var.innodb_io_capacity` and `var.innodb_io_capacity_max`. Adaptive
    flushing does a fantastic job of keeping the flush rate (in terms of IOPS) between
    these two values.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 页面清理由页面清理器执行的后台任务，因此页面刷新速率受到配置的 InnoDB I/O 容量限制的限制，具体解释请参见 [“IOPS”](#metrics-iops)，特别是：`var.innodb_io_capacity`
    和 `var.innodb_io_capacity_max`。自适应刷新出色地保持了刷新率（按 IOPS 计算）在这两个值之间。
- en: The purpose of adaptive flushing is to allow checkpointing to reclaim space
    in the transaction logs. (Actually, this is the purpose of flush list flushing
    in general; algorithms are just different methods of accomplishing it.) I explain
    checkpointing in [“Transaction log”](#metrics-trx-log), but I mention it here
    to clarify that, although flushing makes pages clean and candidates for eviction,
    that is not the purpose of adaptive flushing.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应刷新的目的是允许检查点在事务日志中回收空间。（实际上，这是刷新列表刷新的一般目的；算法只是实现它的不同方法。）我在[“事务日志”](#metrics-trx-log)中解释了检查点，但我在这里提到它是为了澄清，尽管刷新使页面变得干净并成为驱逐的候选对象，但这不是自适应刷新的目的。
- en: 'The intricate details of the adaptive flushing algorithm are beyond the scope
    of this book. The important point is: adaptive flushing flushes dirty pages from
    the flush list in response to transaction log writes.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应刷新算法的复杂细节超出了本书的范围。重要的是：自适应刷新响应事务日志写入，从刷新列表中刷新脏页。
- en: LRU flushing
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: LRU刷新
- en: 'LRU flushing flushes dirty pages from the tail of the LRU list, which contains
    the oldest pages. Simply put: LRU flushing flushes and evicts old pages from the
    buffer pool.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: LRU刷新从LRU列表的尾部刷新脏页，其中包含最老的页面。简而言之：LRU刷新从缓冲池中刷新和驱逐旧页面。
- en: LRU flushing happens in the background and the foreground. Foreground LRU flushing
    happens when a user thread (a thread executing a query) needs a free page but
    there are none. This is not good for performance because it’s a wait—it increases
    query response time. When it occurs, MySQL increments `innodb.buffer_pool_wait_free`,
    which is the “one more detail about free page waits” mentioned earlier.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: LRU刷新发生在后台和前台。当用户线程（执行查询的线程）需要空闲页，但没有空闲页时，就会发生前台LRU刷新。这对性能不利，因为它会增加查询响应时间。当它发生时，MySQL会增加`innodb.buffer_pool_wait_free`，这是前面提到的关于空闲页等待的一个更多细节。
- en: Page cleaners handle background LRU flushing (because page cleaners are background
    threads). When a page cleaner flushes a dirty page from the LRU list, it also
    frees the page by adding it to the free list. This is primarily how InnoDB maintains
    the free page target (see [“Pages”](#pg-pages)) and avoids free page waits.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 页面清理器处理后台LRU刷新（因为页面清理器是后台线程）。当页面清理器从LRU列表中刷新一个脏页时，它也通过将其添加到空闲列表来释放页面。这主要是InnoDB维护空闲页目标（参见[“页面”](#pg-pages)）并避免空闲页等待的方法。
- en: Although background LRU flushing is a background task, it is *not* limited by
    the configured InnoDB I/O capacity explained (`var.innodb_io_capacity` and `var.innodb_io_capacity_max`).^([7](ch06.html#idm45829110096368))
    It’s effectively limited (per buffer pool instance) by [`var.innodb_lru_scan_depth`](https://oreil.ly/fGGjJ).
    For various reasons beyond the scope of this book, this is not a problem in terms
    of excessive background storage I/O.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然后台LRU刷新是一个后台任务，但并未受到配置的InnoDB I/O容量（`var.innodb_io_capacity`和`var.innodb_io_capacity_max`）的限制。^([7](ch06.html#idm45829110096368))
    它的限制效果（每个缓冲池实例）由[`var.innodb_lru_scan_depth`](https://oreil.ly/fGGjJ)确定。出于本书范围之外的各种原因，这在后台存储I/O方面并非问题。
- en: The purpose of LRU flushing is to flush and free (evict) the oldest pages. *Old*,
    as detailed in [“Data Age”](ch04.html#ap-data-age), means the least recently used
    pages, hence *LRU*. The intricate details of LRU flushing, the LRU list, and how
    it all relates to the buffer pool are beyond the scope of this book; but if you’re
    curious, start by reading [“Buffer Pool”](https://oreil.ly/OyBeI) in the MySQL
    manual. The important point is that LRU flushing frees pages and its maximum rate
    is the free page target (per second), not the configured InnoDB I/O capacity.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: LRU刷新的目的是刷新并释放（驱逐）最老的页面。*老*，如[“数据年龄”](ch04.html#ap-data-age)中详细说明的那样，意味着最近最少使用的页面，因此是*LRU*。关于LRU刷新、LRU列表以及它与缓冲池的关系的复杂细节超出了本书的范围；但如果你感兴趣，可以从MySQL手册中的[“缓冲池”](https://oreil.ly/OyBeI)开始阅读。重要的是，LRU刷新释放页面，其最大速率是空闲页目标（每秒），而不是配置的InnoDB
    I/O容量。
- en: 'With that crash course on InnoDB flushing, the following four metrics are now
    intelligible:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 经过对InnoDB刷新的速成课程，以下四个指标现在可以说清楚了：
- en: '`innodb.buffer_flush_batch_total_pages`'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_flush_batch_total_pages`'
- en: '`innodb.buffer_flush_adaptive_total_pages`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_flush_adaptive_total_pages`'
- en: '`innodb.buffer_LRU_batch_flush_total_pages`'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_LRU_batch_flush_total_pages`'
- en: '`innodb.buffer_flush_background_total_pages`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.buffer_flush_background_total_pages`'
- en: 'All four metrics are counters that, when converted to rates, reveal page flush
    rates for each algorithm. `innodb.buffer_flush_batch_total_pages` is the total
    page flush rate for all algorithms. It’s a high-level rate that’s useful as a
    KPI for InnoDB: the total page flush rate should be normal and stable. If not,
    one of the metrics indicates which part of InnoDB is not flushing normally.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个指标都是计数器，当转换为速率时，会显示每个算法的页面刷新速率。`innodb.buffer_flush_batch_total_pages` 是所有算法的总页面刷新速率。作为InnoDB的关键绩效指标，这是一个高级别速率：总页面刷新速率应该是正常和稳定的。如果不是这样，其中一个指标会指出InnoDB的哪个部分没有正常刷新。
- en: '`innodb.buffer_flush_adaptive_total_pages` is the number of pages flushed by
    adaptive flushing. `innodb.buffer_LRU_batch_flush_total_pages` is the number of
    pages flushed by background LRU flushing. Given the earlier explanation of these
    flushing algorithms, you know which parts of InnoDB they reflect: the transaction
    log and free pages, respectively.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.buffer_flush_adaptive_total_pages` 是自适应刷新刷新的页数。`innodb.buffer_LRU_batch_flush_total_pages`
    是后台LRU刷新的页数。根据前面对这些刷新算法的解释，您知道它们反映了InnoDB的哪些部分：分别是事务日志和空闲页。'
- en: '`innodb.buffer_flush_background_total_pages` is included for completeness:
    it is the number of pages flushed by other algorithms described in [“Idle Flushing
    and Legacy Flushing”](#idle-flushing). If the rate of background page flushing
    is problematic, you will need to consult a MySQL expert because that’s not supposed
    to happen.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.buffer_flush_background_total_pages` 被包括是为了完整性：它是其他算法刷新的页面数，描述在[“空闲刷新和传统刷新”](#idle-flushing)中。如果后台页面刷新速率有问题，您需要咨询MySQL专家，因为这不应该发生。'
- en: Although different flushing algorithms have different rates, the storage system
    underlies all of them because flushing requires IOPS. If you’re running MySQL
    on spinning disks, for example, the storage system (both the storage bus and the
    storage device) simply do not provide many IOPS. If you run MySQL on high-end
    storage, then IOPS may never be an underlying issue. And if you’re running MySQL
    in the cloud, you can provision as many IOPS as you need, but the cloud uses network-attached
    storage, which is slow. Also remember that IOPS have latency—especially in the
    cloud—ranging from microseconds to milliseconds. This is deep knowledge verging
    on expert-level internals, but let’s keep going because it’s powerful knowledge
    worth learning.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不同的刷新算法有不同的速率，但存储系统支持所有这些，因为刷新需要IOPS。例如，如果您在旋转硬盘上运行MySQL，存储系统（包括存储总线和存储设备）根本提供不了多少IOPS。如果您在高端存储上运行MySQL，那么IOPS可能永远不是一个潜在问题。如果您在云中运行MySQL，您可以按需提供尽可能多的IOPS，但云使用网络附加存储，速度较慢。还要记住，IOPS具有延迟，特别是在云中，延迟范围从微秒到毫秒。这是接近专家级内部的深层知识，但让我们继续进行学习，因为这是值得学习的强大知识。
- en: Transaction log
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务日志
- en: 'The final and perhaps most important spectrum: the transaction log, also known
    as the redo log. For brevity, it’s called *the log* when the context is clear
    and unambiguous, as it is here.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也许是最重要的光谱：事务日志，也被称为重做日志。简称*日志*，在这里上下文清晰且无歧义。
- en: The transaction log guarantees durability. When a transaction commits, all data
    changes are recorded in the transaction log and flushed to disk—which makes the
    data changes durable—and corresponding dirty pages remain in memory. (If MySQL
    crashes with dirty pages, the data changes are not lost because they were already
    flushed to disk in the transaction log.) Transaction log flushing is *not* page
    flushing. The two processes are separate but inextricable.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 事务日志保证耐久性。当事务提交时，所有数据更改都记录在事务日志中并刷新到磁盘上，这使数据更改具有耐久性，并且相应的脏页保留在内存中。（如果MySQL崩溃并带有脏页，则数据更改不会丢失，因为它们已经在事务日志中刷新到磁盘。）事务日志刷新*不是*页面刷新。这两个过程是分开的但又不可分割的。
- en: The InnoDB transaction log is a fixed-size ring buffer on disk, as shown in
    [Figure 6-7](#trx-log). By default, it comprises two physical log files. The size
    of each is configured by [`var.innodb_log_file_size`](https://oreil.ly/ItAxz).
    Or, as of MySQL 8.0.3, enabling [`var.innodb_dedicated_server`](https://oreil.ly/gv38o)
    automatically configures the log file size and other related system variables.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB事务日志是磁盘上的固定大小环形缓冲区，如[图6-7](#trx-log)所示。默认情况下，它由两个物理日志文件组成。每个文件的大小由[`var.innodb_log_file_size`](https://oreil.ly/ItAxz)配置。或者，从MySQL
    8.0.3开始，启用[`var.innodb_dedicated_server`](https://oreil.ly/gv38o)会自动配置日志文件大小和其他相关系统变量。
- en: The transaction log contains data changes (technically, *redo logs*), not pages;
    but the data changes are linked to dirty pages in the buffer pool. When a transaction
    commits, its data changes are written to the head of the transaction log and flushed
    (synced) to disk, which advances the head clockwise, and the corresponding dirty
    pages are added to the flush list shown earlier in [Figure 6-6](#page-flushing).
    (In [Figure 6-7](#trx-log), the head and tail move clockwise, but this is only
    an illustration. Unless you have spinning disks, the transaction log does not
    literally move.) Newly written data changes overwrite old data changes for which
    the corresponding pages have been flushed.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 事务日志包含数据更改（技术上是*重做日志*），而不是页面；但数据更改与缓冲池中的脏页面相连。当事务提交时，其数据更改被写入事务日志的头部并被刷新（同步）到磁盘，这将使头部顺时针前进，并将相应的脏页面添加到之前在[图 6-6](#page-flushing)中显示的刷新列表中。在[图 6-7](#trx-log)中，头部和尾部顺时针移动，但这仅仅是一种插图。除非您使用旋转硬盘，否则事务日志不会实际移动。新写入的数据更改会覆盖已刷新相应页面的旧数据更改。
- en: '![emsp 0607](assets/emsp_0607.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0607](assets/emsp_0607.png)'
- en: Figure 6-7\. InnoDB transaction log
  id: totrans-453
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. InnoDB事务日志
- en: Note
  id: totrans-454
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A simplified illustration and explanation of the InnoDB transaction log makes
    it appear serialized. But that is only an artifact of simplifying a complex process.
    The actual low-level implementation is highly concurrent: many user threads are
    committing changes to the transaction log in parallel.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的InnoDB事务日志插图和解释使其看起来像是串行的。但这只是简化复杂过程的一个结果。实际的低级实现是高度并发的：许多用户线程并行提交更改到事务日志中。
- en: '*Checkpoint age* is the length of the transaction log (in bytes) between the
    head and the tail. *Checkpointing* reclaims space in the transaction log by flushing
    dirty pages from the buffer pool, which allows the tail to advance. Once dirty
    pages have been flushed, the corresponding data changes in the transaction log
    can be overwritten with new data changes. Adaptive flushing implements checkpointing
    in InnoDB, which is why the checkpoint age is an input to the adaptive flushing
    algorithm shown in [Figure 6-6](#page-flushing).'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '*检查点年龄*是头部和尾部之间事务日志的长度（以字节计）。*检查点*通过从缓冲池刷新脏页面来回收事务日志中的空间，从而使尾部可以前进。一旦脏页面被刷新，事务日志中的相应数据更改就可以被新的数据更改覆盖。适应性刷新在InnoDB中实现了检查点，这就是为什么检查点年龄是显示在[图 6-6](#page-flushing)中自适应刷新算法的输入。'
- en: Note
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By default, all data changes (redo logs) in the transaction log are durable
    (flushed to disk), but corresponding dirty pages in the buffer pool are not durable
    until flushed by checkpointing.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，事务日志中的所有数据更改（重做日志）是持久的（刷新到磁盘），但缓冲池中相应的脏页面直到被检查点刷新才是持久的。
- en: 'Checkpointing advances the tail to ensure that the checkpoint age does not
    become too old (which really means *too large* because it’s measured in bytes,
    but *too old* is the more common phrase). But what happens if the checkpoint age
    becomes so old that the head meets the tail? Since the transaction log is a fixed-size
    ring buffer, the head can wrap around and meet the tail if the write rate consistently
    exceeds the flush rate. InnoDB won’t let this happen. There are two safeguard
    points called *async* and *sync*, as shown in [Figure 6-7](#trx-log). *Async*
    is the point at which InnoDB begins asynchronous flushing: writes are allowed,
    but the page flushing rate is increased to near maximum. Although writes are allowed,
    flushing will use so much InnoDB I/O capacity that you can (and should) expect
    a noticeable drop in overall server performance. *Sync* is the point at which
    InnoDB begins synchronous flushing: *all writes stop*, and page flushing takes
    over. Needless to say, that’s terrible for performance.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点通过将尾部推进来确保检查点年龄不会变得太老（这实际上意味着*太大*，因为它是以字节计量的，但*太老*是更常见的说法）。但如果检查点年龄变得太老以至于头部遇到尾部会发生什么？由于事务日志是一个固定大小的环形缓冲区，如果写入速率持续超过刷新速率，头部会绕回并遇到尾部。InnoDB不会让这种情况发生。在[图 6-7](#trx-log)中显示了两个保障点称为*async*和*sync*。*Async*是InnoDB开始异步刷新的点：允许写入，但页面刷新速率增加到接近最大。虽然允许写入，但刷新将使用大量InnoDB
    I/O容量，您可以（而且应该）预期整体服务器性能显著下降。*Sync*是InnoDB开始同步刷新的点：*所有写入停止*，页面刷新接管。不用说，这对性能非常不利。
- en: 'InnoDB exposes metrics for the checkpoint age and the async flush point, respectively:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB公开了检查点年龄和异步刷新点的指标：
- en: '`innodb.log_lsn_checkpoint_age`'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.log_lsn_checkpoint_age`'
- en: '`innodb.log_max_modified_age_async`'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.log_max_modified_age_async`'
- en: '`innodb.log_lsn_checkpoint_age` is a gauge metric measured in bytes, but the
    raw value is meaningless to humans (it ranges from zero to the log file size).
    What is meaningful to humans and critical to monitor is how close the checkpoint
    age is to the async flush point, which I call *transaction log utilization*:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.log_lsn_checkpoint_age` 是以字节为单位的一个度量指标，但其原始值对人类来说毫无意义（范围从零到日志文件大小）。对人类有意义并且是监控的关键是检查点年龄接近异步刷新点的情况，我称之为*事务日志利用率*：'
- en: (innodb.log_lsn_checkpoint_age / innodb.log_max_modified_age_async) × 100
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: （`innodb.log_lsn_checkpoint_age` / `innodb.log_max_modified_age_async`）× 100
- en: 'Transaction log utilization is conservative because the async flush point is
    at 6/8 (75%) of the log file size. Therefore, at 100% transaction log utilization,
    25% of the log is free to record new writes, but remember: server performance
    drops noticeably at the async flush point. It’s important to monitor and know
    when this point is reached. If you want to live dangerously, InnoDB exposes a
    metric for the sync flush point (which is at 7/8 [87.5%] of the log file size)
    that you can substitute for the async flush point metric (or monitor both): `innodb.log_max_modified_age_sync`.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异步刷新点在日志文件大小的6/8（75％）处，事务日志利用率是保守的。因此，在100％事务日志利用率时，有25％的日志空闲以记录新的写入数据，但请记住：在异步刷新点时，服务器性能显著下降。监控并了解何时达到此点非常重要。如果你想冒险，InnoDB
    提供了同步刷新点的度量指标（在日志文件大小的7/8 [87.5％] 处），你可以替换异步刷新点的度量指标（或同时监控两者）：`innodb.log_max_modified_age_sync`。
- en: 'There’s one small but important detail about how queries log data changes to
    the transaction log: data changes are first written to an in-memory *log buffer*
    (not to be confused with the *log file* that refers to the actual on-disk transaction
    log), then the log buffer is written to the log file, and the log file is synced.
    I’m glossing over myriad details, but the point is: there’s an in-memory log buffer.
    If the log buffer is too small and a query has to wait for free space, InnoDB
    increments:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 关于查询如何记录数据变更到事务日志，有一个小但重要的细节：数据变更首先被写入到内存中的*日志缓冲区*（不要与指代实际磁盘上的事务日志的*日志文件*混淆），然后日志缓冲区被写入到日志文件，并进行同步。我略过了无数细节，但重点是：有一个内存中的日志缓冲区。如果日志缓冲区太小而查询必须等待空闲空间，InnoDB
    就会递增：
- en: '`innodb.log_waits`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.log_waits`'
- en: '`innodb.log_waits` should be zero. If it isn’t, the log buffer size is configured
    by [`var.innodb_log_buffer_size`](https://oreil.ly/2I1cq). The default 16 MB is
    usually more than sufficient.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb.log_waits` 应该为零。如果不是，则表示日志缓冲区大小由 [`var.innodb_log_buffer_size`](https://oreil.ly/2I1cq)
    配置。通常默认的16 MB 足以满足需求。'
- en: 'Since the transaction log comprises two physical files on disk (two files,
    but one logical log), writing and syncing data changes to disk are the most fundamental
    tasks. Two gauge metrics report how many of those tasks are pending—waiting to
    be completed:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事务日志在磁盘上由两个物理文件组成（两个文件，但一个逻辑日志），将数据变更写入磁盘并将其同步是最基本的任务。两个度量指标报告了有多少这些任务是待处理的，即等待完成：
- en: '`innodb.os_log_pending_writes`'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.os_log_pending_writes`'
- en: '`innodb.os_log_pending_fsyncs`'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.os_log_pending_fsyncs`'
- en: Since writes and syncs are supposed to happen extremely quickly—nearly all write
    performance depends on it—these metrics should always be zero. If not, they indicate
    a low-level problem with either InnoDB or, more likely, the storage system—presuming
    other metrics are normal or were normal before pending writes and syncs. Don’t
    expect problems at this depth, but monitor it.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 由于写入和同步应该极快地发生——几乎所有写入性能都依赖于此——这些度量指标应始终为零。如果不是，则表明 InnoDB 或更可能是存储系统存在低级问题——假设其他度量指标正常或在待处理写入和同步之前正常。不要期望在这个深度出现问题，但要监控它。
- en: 'Last but not least, a simple but important metric that counts the number of
    bytes written to the transaction log:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，一个简单但重要的度量指标，记录写入事务日志的字节数：
- en: '`innodb.os_log_bytes_written`'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`innodb.os_log_bytes_written`'
- en: It’s best practice to monitor total log bytes written per hour as a basis for
    determining log file size. Log file size is the product of system variables [`var​.inno​db_​log_file_size`](https://oreil.ly/sinUV)
    and [`var.innodb_log_files_in_group`](https://oreil.ly/0hYp1). Or, as of MySQL
    8.0.14, enabling [`var.innodb_dedicated_server`](https://oreil.ly/f2UqB) automatically
    configures both system variables. The default log file size is only 96 MB (two
    log files at 48 MB each). As an engineer using MySQL, not a DBA, I presume whoever
    is managing your MySQL has properly configured these system variables, but it’s
    wise to verify.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 监控每小时写入的总日志字节数作为确定日志文件大小的基础是最佳实践。日志文件大小是系统变量[`var.innodb_log_file_size`](https://oreil.ly/sinUV)和[`var.innodb_log_files_in_group`](https://oreil.ly/0hYp1)的乘积。或者，从MySQL
    8.0.14开始，启用[`var.innodb_dedicated_server`](https://oreil.ly/f2UqB)会自动配置这两个系统变量。默认的日志文件大小只有96
    MB（两个日志文件每个48 MB）。作为使用MySQL的工程师，而不是DBA，我假设管理你的MySQL的人已经正确配置了这些系统变量，但最好还是进行验证。
- en: 'We made it: the end of InnoDB metrics. The spectrum of InnoDB metrics is much
    wider and deeper than presented here; these are only the most essential InnoDB
    metrics for analyzing MySQL performance. Moreover, significant changes were made
    to InnoDB from MySQL 5.7 to 8.0. For example, the internal implementation of the
    transaction log was rewritten and improved as of MySQL 8.0.11. There are other
    parts of InnoDB not covered here: double-write buffer, change buffer, adaptive
    hash index, and so on. I encourage you to learn more about InnoDB, for it is a
    fascinating storage engine. You can begin that journey at [“The InnoDB Storage
    Engine”](https://oreil.ly/s0PZk) in the MySQL manual.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了：InnoDB指标的结束。InnoDB指标的范围比这里呈现的要广泛和深入得多；这些只是分析MySQL性能最关键的InnoDB指标。此外，从MySQL
    5.7到8.0，InnoDB进行了重大改动。例如，从MySQL 8.0.11开始，事务日志的内部实现进行了重写和改进。这里没有涵盖的InnoDB的其他部分包括：双写缓冲区、更改缓冲区、自适应哈希索引等等。我鼓励你深入了解InnoDB，因为它是一个引人入胜的存储引擎。你可以从MySQL手册的[“InnoDB存储引擎”](https://oreil.ly/s0PZk)开始这段旅程。
- en: Monitoring and Alerting
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和警报
- en: MySQL metrics reveal the spectrum of MySQL performance, and they’re also great
    for waking engineers in the middle of the night—otherwise known as monitoring
    and alerting.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL指标展示了MySQL性能的广谱，它们也非常适合在半夜唤醒工程师，即监控和警报。
- en: Monitoring and alerting are external to MySQL, so they cannot affect its performance,
    but I am compelled to address the following four topics because they are related
    to metrics and important to success with MySQL.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和警报是外部的MySQL功能，因此它们无法影响其性能，但我必须讨论以下四个主题，因为它们与指标相关，并且对MySQL的成功非常重要。
- en: Resolution
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分辨率
- en: '*Resolution* means the frequency at which metrics are collected and reported:
    1 second, 10 seconds, 30 seconds, 5 minutes, and so on. Higher resolution entails
    higher frequency: 1 second is higher resolution than 30 seconds. Like a television,
    the higher the resolution, the more detail you see. And since “seeing is believing,”
    let’s see three charts of the same data over 30 seconds. The first chart, [Figure 6-8](#qps-at-1s),
    shows QPS values at maximum resolution: 1 second.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '*分辨率*表示采集和报告指标的频率：1秒，10秒，30秒，5分钟等等。更高的分辨率意味着更高的频率：1秒的分辨率比30秒的分辨率更高。就像电视机一样，分辨率越高，看到的细节就越多。而且“眼见为实”，让我们来看看相同数据在30秒内的三张图表。第一张图表，[图
    6-8](#qps-at-1s)，展示了最高分辨率下的 QPS 值：1秒。'
- en: '![emsp 0608](assets/emsp_0608.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0608](assets/emsp_0608.png)'
- en: Figure 6-8\. QPS at 1-second resolution
  id: totrans-483
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-8\. 1秒分辨率下的 QPS
- en: In the first 20 seconds, QPS is normal and stable, bouncing between 100 and
    200 QPS. From 20 to 25 seconds, there is a 5-second stall (the 5 data points below
    100 QPS in the box). For the last five seconds, QPS spikes to an abnormally high
    value, which is common after a stall. This chart isn’t dramatic, but it’s realistic
    and it begins to illustrate a point that the next two charts bring into focus.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在前20秒内，QPS 正常稳定，在100到200 QPS 之间波动。从第20秒到第25秒，出现了5秒的停顿（盒子中显示的5个数据点低于100 QPS）。最后五秒，QPS
    急剧上升到异常高的数值，这在停顿后是常见的情况。这张图表不太戏剧化，但却很现实，并且开始阐明一个观点，接下来的两张图表将更加明确。
- en: The second chart, [Figure 6-9](#qps-at-5s), is the exact same data but at 5-second
    resolution.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张图表，[图 6-9](#qps-at-5s)，是相同数据，但分辨率为5秒。
- en: '![emsp 0609](assets/emsp_0609.png)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0609](assets/emsp_0609.png)'
- en: Figure 6-9\. QPS at 5-second resolution
  id: totrans-487
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-9\. 5秒分辨率下的 QPS
- en: 'At 5-second resolution, some fine detail is lost, but critical details remain:
    normal and stable QPS in the first 20 seconds; the stall around 25 seconds; and
    the spike after the stall. This chart is acceptable for daily monitoring—especially
    considering that collecting, storing, and charting metrics at 1-second resolution
    is so difficult that it’s almost never done.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在5秒分辨率下，一些细微的细节丢失了，但关键的细节保留了下来：前20秒正常和稳定的QPS；大约25秒左右的停顿；以及停顿后的波动。这种图表对日常监控是可以接受的——尤其考虑到以1秒分辨率收集、存储和绘制度量是如此困难，几乎从未完成。
- en: The third chart, [Figure 6-10](#qps-at-10s), is the exact same data but at 10-second
    resolution.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个图表，[图6-10](#qps-at-10s)，是完全相同的数据，但以10秒分辨率。
- en: 'At 10-second resolution, nearly all detail is lost. According to the chart,
    QPS is stable and normal, but it’s misleading: QPS destabilized and was not normal
    for 10 seconds (five second stall and five second spike).'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在10秒分辨率下，几乎所有的细节都丢失了。根据图表，QPS是稳定和正常的，但这是误导性的：QPS不稳定，并且在10秒内（五秒的停顿和五秒的波动）不正常。
- en: 'At the very least, collect KPIs (see [“Key Performance Indicators”](#kpi))
    at 5-second resolution or better. If possible, collect most of the metrics in
    [“Spectra”](#spectra) at 5-second resolution too, with the following exceptions:
    Admin, `SHOW`, and bad `SELECT` metrics can be collected slowly (10, 20, or 30
    seconds), and data size can be collected very slowly (5, 10, or 20 minutes).'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，以5秒的分辨率收集关键绩效指标（参见[“关键绩效指标”](#kpi)）。如果可能，也要以5秒的分辨率收集大部分[“光谱”](#spectra)中的度量，以下几个例外除外：管理、`SHOW`
    和不良的`SELECT`度量可以较慢地收集（10、20或30秒），而数据大小可以非常慢地收集（5、10或20分钟）。
- en: Strive for the highest resolution possible because, unlike query metrics that
    are logged, MySQL metrics are either collected or gone for all eternity.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 力求达到尽可能高的分辨率，因为与记录的查询度量不同，MySQL度量要么被收集，要么永远消失。
- en: '![emsp 0610](assets/emsp_0610.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![emsp 0610](assets/emsp_0610.png)'
- en: Figure 6-10\. QPS at 10-second resolution
  id: totrans-494
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-10。10秒分辨率下的QPS
- en: Wild Goose Chase (Thresholds)
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 野鸭追逐（阈值）
- en: A *threshold* is a static value past which a monitoring alert triggers, often
    times paging the engineer who’s on-call. Thresholds seem like a good and reasonable
    idea, but they don’t work. That’s a very strong claim, but it’s closer to the
    truth than the opposite—claiming that thresholds work.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '*阈值*是一个静态值，超过该值会触发监控警报，通常会呼叫值班工程师。阈值似乎是一个好主意，合理的想法，但并不起作用。这是一个非常强烈的说法，但比相反的说法——声称阈值有效——更接近真相。'
- en: 'The problem is that a threshold also needs a *duration*: how long the metric
    value must remain past the threshold until the alert triggers. Consider the chart
    in [Figure 6-8](#qps-at-1s) from the previous section (QPS at 1-second resolution).
    Without a duration, a threshold at QPS less than 100 would trigger seven times
    in 30 seconds: the five second stall, and the third and thirteenth data points.
    That’s “too noisy” in the parlance of monitoring and alerting, so what about a
    threshold at QPS less than 50? Surely, a 50% drop in QPS—from 100 QPS to 50 QPS—signals
    a problem worth alerting a human. Sorry, the alert never triggers: the lowest
    data point is 50 QPS, which is not *less than* 50 QPS.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于阈值还需要一个*持续时间*：指标值必须超过阈值多久才能触发警报。考虑前一节中（1秒分辨率的QPS）图表[图6-8](#qps-at-1s)。没有持续时间，QPS小于100的阈值在30秒内会触发七次：五秒的停顿和第三第十三数据点。这在监控和警报的术语中被称为“太嘈杂”，那么QPS小于50的阈值呢？毫无疑问，QPS从100
    QPS降至50 QPS的50%下降会向人类发出警报。抱歉，警报从未触发：最低数据点是50 QPS，不*小于*50 QPS。
- en: This example seems contrived but it’s not, and it gets worse. Suppose you add
    a 5-second duration to the alert, and reset the threshold to QPS less than 100.
    Now the alert only triggers after the five-second stall. But what if the stall
    wasn’t a stall? What if there was a network blip that caused packet loss during
    those five seconds, so the problem was neither MySQL nor the application? The
    poor on-call human who was alerted is on a wild goose chase.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子似乎是刻意构造的，但实际情况并非如此，情况比这更糟。假设您向警报添加了5秒的持续时间，并将阈值重置为QPS小于100。现在，警报仅在五秒的停顿后触发。但是如果停顿不是真正的停顿呢？如果在这五秒内有网络中断导致数据包丢失，问题既不是MySQL也不是应用程序造成的？那么被警报的值班人员就像在一场野鸭追逐中一样。
- en: 'I know it seems like I’m tailoring the example to suit my point, but all joking
    aside: thresholds are notoriously difficult to perfect, where *perfect* means
    that it alerts only on truly legitimate problems—no false-positives.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道看起来我正在量身定制这个例子以符合我的观点，但开玩笑归开玩笑：阈值很难完美，完美意味着它仅在真正的合法问题上发出警报——没有误报。
- en: Alert on User Experience and Objective Limits
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在用户体验和客观限制上发出警报
- en: 'There are two proven solutions that work in lieu of thresholds:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个经过验证的解决方案可以替代阈值：
- en: Alert on what users experience
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户体验发出警报
- en: Alert on *objective* limits
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据*客观*限制发出警报
- en: 'From [“North Star”](ch01.html#north-star) and [“Key Performance Indicators”](#kpi),
    there are only two MySQL metrics that users experience: response time and errors.
    These are reliable signals not only because users experience them, but because
    they cannot be false-positive. A change in QPS might be a legitimate change in
    user traffic. But a change in response time can only be explained by a change
    in response time. The same is true for errors.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 从[“北极星”](ch01.html#north-star)和[“关键绩效指标”](#kpi)出发，用户体验到的MySQL指标仅有响应时间和错误。这些信号之所以可靠，不仅是因为用户体验到了它们，还因为它们不可能是误报。QPS的变化可能是用户流量的合理变化。但是响应时间的变化只能用响应时间的变化来解释。错误也是如此。
- en: Note
  id: totrans-505
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: With microservices, the user might be another application. In that case, normal
    response times could be very low (tens of milliseconds), but the monitoring and
    alerting principles are the same.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务，用户可能是另一个应用程序。在这种情况下，正常的响应时间可能非常低（数十毫秒），但监控和警报原则是相同的。
- en: Thresholds and duration are simpler for response time and errors, too, because
    we can imagine the abnormal conditions past the thresholds. For example, presume
    the normal P99 response time for an application is 200 milliseconds, and the normal
    error rate is 0.5 per second. If P99 response time increased to 1 second (or more)
    for a full a minute, would that be a bad user experience? If yes, then make those
    the threshold and duration. If errors increased to 10 per second for a full 20
    seconds, would that be a bad user experience? If yes, then make those the threshold
    and duration.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应时间和错误，阈值和持续时间也更简单，因为我们可以想象超过阈值的异常条件。例如，假设一个应用程序的正常P99响应时间为200毫秒，正常的错误率为每秒0.5个。如果P99响应时间在一分钟内增加到1秒（或更长时间），这是否会导致糟糕的用户体验？如果是，则将其设为阈值和持续时间。如果错误率在20秒内增加到每秒10个，这是否会导致糟糕的用户体验？如果是，则将其设为阈值和持续时间。
- en: 'For a more concrete example, let’s clarify the implementation of the previous
    example where 200 milliseconds is the normal P99 response time. Measure and report
    P99 response time every five seconds (see [“Query Response Time”](#metrics-qrt)).
    Create a rolling one minute alert on the metric that triggers when the last 12
    values are greater than one second. (Since the metric is reported every five seconds,
    there are 60 / 5 seconds = 12 values/minute.) From a technical point of view,
    a sustained 5x increase in query response time is drastic and merits investigation—it’s
    probably an early warning that a larger problem is brewing and, if ignored, will
    cause an application outage. But the intention of the alert is more practical
    than technical: if users are used to subsecond responses from the application,
    then one-second responses are noticeably sluggish.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 举个更具体的例子，让我们澄清之前例子的实施情况，其中200毫秒是正常的P99响应时间。每五秒测量和报告P99响应时间（见[“查询响应时间”](#metrics-qrt)）。对于触发条件的度量创建一个滚动的一分钟警报，当最后12个值大于一秒时触发。（因为指标每五秒报告一次，所以每分钟有60
    / 5秒 = 12个值/分钟。）从技术角度来看，查询响应时间的持续5倍增加是激烈的，并且值得调查——这可能是一个更大问题即将到来的早期警告，如果被忽视，将导致应用程序的中断。但是警报的目的更实际而非技术性：如果用户习惯于从应用程序获得亚秒级的响应，则一秒钟的响应显然会感到迟钝。
- en: 'Objective limits are minimum or maximum values that MySQL cannot pass. These
    are common objective limits external to MySQL:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 客观限制是MySQL无法超越的最小或最大值。这些是MySQL外部常见的客观限制：
- en: Zero free disk space
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零剩余磁盘空间
- en: Zero free memory
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零空闲内存
- en: 100% CPU utilization
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100% CPU利用率
- en: 100% storage IOPS utilization
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100%存储IOPS利用率
- en: 100% network utilization
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100%网络利用率
- en: 'MySQL has many *max* system variables, but these are the most common ones that
    affect applications:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有许多*max*系统变量，但以下是最常见的几个会影响应用程序的：
- en: '[`max_connections`](https://oreil.ly/0ODxA)'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`max_connections`](https://oreil.ly/0ODxA)'
- en: '[`max_prepared_stmt_count`](https://oreil.ly/jqNuk)'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`max_prepared_stmt_count`](https://oreil.ly/jqNuk)'
- en: '[`max_allowed_packet`](https://oreil.ly/qM3R5)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`max_allowed_packet`](https://oreil.ly/qM3R5)'
- en: 'There’s one more object limit that has surprised more than one engineer: maximum
    [`AUTO_INCREMENT`](https://oreil.ly/tkXWP) value. MySQL does not have a native
    metric or method for checking if an `AUTO_INCREMENT` column is approaching its
    maximum value. Instead, common MySQL monitoring solutions create a metric by executing
    a SQL statement similar to [Example 6-7](#auto-inc-max), which was written by
    renowned MySQL expert Shlomi Noach in [“Checking for AUTO_INCREMENT capacity with
    single query”](https://oreil.ly/LJ64E).'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 有一个限制值可能会让不少工程师感到意外：[`AUTO_INCREMENT`](https://oreil.ly/tkXWP) 的最大值。MySQL
    没有本地度量或方法来检查 `AUTO_INCREMENT` 列是否接近其最大值。相反，常见的 MySQL 监控解决方案通过执行类似于[示例 6-7](#auto-inc-max)的
    SQL 语句来创建一个度量，该示例由著名的 MySQL 专家 Shlomi Noach 在 [“使用单个查询检查 AUTO_INCREMENT 容量”](https://oreil.ly/LJ64E)
    中编写。
- en: Example 6-7\. SQL statement that checks maximum `AUTO_INCREMENT`
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 检查最大 `AUTO_INCREMENT` 的 SQL 语句
- en: '[PRE7]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What about the other two key performance indicators: QPS and threads running?
    Monitoring QPS and threads running is a best practice, but alerting on them is
    not. These metrics are pivotal when investigating a legitimate problem signaled
    by response time or errors, but otherwise they fluctuate too much to be reliable
    signals.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 那么另外两个关键的性能指标如何：QPS 和正在运行的线程？监控 QPS 和正在运行的线程是最佳实践，但不建议对它们进行警报。这些度量在调查由响应时间或错误信号的真正问题时至关重要，但否则它们的波动太大，不能作为可靠的信号。
- en: 'If this approach seems radical, remember: these are alerts for engineers using
    MySQL, not DBAs.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种方法看起来很激进，请记住：这些是针对使用 MySQL 的工程师的警报，而不是 DBA。
- en: Cause and Effect
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因果关系
- en: 'I won’t mince words: when MySQL is slow to respond, the application is the
    cause the vast majority (maybe 80%) of the time—in my experience—because the application
    drives MySQL. Without it, MySQL is idle. If the application isn’t the cause, there
    are a few other common causes of slow MySQL performance. Another application—any
    application, not just MySQL—is a likely culprit maybe 10% of the time, as I discuss
    later in [“Noisy Neighbors”](ch09.html#noisy-neighbors). Hardware, which includes
    the network, causes problems a mere 5% of the time because modern hardware is
    quite reliable (especially enterprise-grade hardware, which lasts longer [and
    costs more] than consumer-grade hardware). Last and least: I estimate only a 1%
    chance that MySQL is the root cause of its own slowness.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我直言不讳：当 MySQL 响应缓慢时，应用程序在大多数情况下（也许 80%）是原因——根据我的经验——因为应用程序驱动 MySQL。没有应用程序，MySQL
    就空闲。如果应用程序不是原因，MySQL 性能缓慢的其他常见原因有几个。另一个应用程序——任何应用程序，不仅仅是 MySQL——可能有 10% 的概率成为罪魁祸首，正如我在
    [“吵闹邻居”](ch09.html#noisy-neighbors) 中讨论的那样。硬件，包括网络，在现代硬件非常可靠的情况下只占 5% 的问题，尤其是企业级硬件，它的持久性（和成本）比消费者级硬件更长。最后且最少：我估计
    MySQL 自身是其缓慢的根本原因的可能性仅为 1%。
- en: 'Once identified, the cause is presumed to be the root cause, not a side effect
    of some prior, unseen cause. For example, application causes presume something
    like a poorly written query that, once deployed in production, immediately causes
    a problem in MySQL. Or, hardware causes presume something like a degraded storage
    system that’s working but significantly slower than usual, which causes MySQL
    to respond slowly. When this presumption is false—the identified cause is *not*
    the root cause—an especially pernicious situation occurs. Consider the following
    sequence of events:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定，原因被认为是根本原因，而不是某种之前未见的副作用。例如，应用程序的原因假设类似于在生产中部署后立即在 MySQL 中引发问题的查询编写不佳。或者，硬件原因假设类似于工作但比平常慢得多的退化存储系统，这会导致
    MySQL 响应缓慢。当这种假设是错误的——确定的原因*不是*根本原因时，尤其危险。考虑以下事件序列：
- en: A network issue lasting 20 seconds causes significant packet loss or low-level
    network retries.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续 20 秒的网络问题导致严重的数据包丢失或低级别网络重试。
- en: The network issue causes query errors or timeouts (due to packet loss or retries,
    respectively).
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络问题导致查询错误或超时（分别由于数据包丢失或重试）。
- en: Both the application and MySQL log errors (query errors and client errors, respectively).
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序和 MySQL 都记录错误（查询错误和客户端错误）。
- en: The application retries queries.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序重试查询。
- en: While retrying old queries, the application continues executing new queries.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重试旧查询的同时，应用程序继续执行新查询。
- en: QPS increases due to executing new and old queries.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于执行新旧查询，QPS 增加。
- en: Utilization increases due to QPS increasing.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 QPS 增加，利用率也在增加。
- en: Waits increase due to utilization increasing.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于利用率增加，等待时间也在增加。
- en: Timeouts increase due to waits increasing.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于等待时间增加，超时也在增加。
- en: The application retries queries again, which creates a feedback loop.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序再次重试查询，从而创建一个反馈循环。
- en: 'By the time you step into this situation, the problem is apparent but the root
    cause is not. You know that everything was normal and stable before the problem:
    no application changes or deployments; MySQL key performance indicators were normal
    and stable; and DBAs confirm that no work was done on their side. That’s what
    makes this situation especially pernicious: as far as you can tell, it shouldn’t
    be happening, but there’s no denying that it is.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进入这种情况时，问题是显而易见的，但根本原因并不明确。您知道问题发生之前一切都是正常和稳定的：没有应用程序变更或部署；MySQL 的关键性能指标是正常和稳定的；DBA
    确认他们这边没有做任何工作。这使得这种情况特别具有阴险性：据您所知，事情不应该发生，但不可否认它确实发生了。
- en: 'Technically speaking, all causes are knowable because computers are finite
    and discrete. But practically speaking, causes are only as knowable as monitoring
    and logging allow. In this example, if you have exceptionally good networking
    monitoring and application logging (and access to the MySQL error log), you can
    figure out the root cause: the 20-second network blip. But that’s a lot easier
    said than done because in the midst of this situation—your application is down,
    customers are calling, and it’s 4:30 p.m. on a Friday—engineers are focused on
    fixing the problem, not elucidating its root cause. When focused on fixing the
    problem, it’s easy to see MySQL as the cause that needs to be fixed: make MySQL
    run faster and the application will be OK. But there is no way to fix MySQL in
    this sense—recall, [“MySQL Does Nothing”](ch04.html#mysql-does-nothing). Since
    everything was normal before the problem, the goal is to return to that normal,
    starting with the application because it drives MySQL. The correct solution depends
    on the application, but common tactics are: restarting the application, throttling
    incoming application requests, and disabling application features.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，所有原因都是可以知道的，因为计算机是有限且离散的。但从实际角度来看，原因只能知道到监控和日志记录的允许程度。在这个例子中，如果您拥有异常好的网络监控和应用程序日志记录（以及访问
    MySQL 错误日志的权限），您可以找出根本原因：20 秒的网络故障。但这比做起来要困难得多，因为在这种情况下——您的应用程序停止运行，客户在打电话，并且现在是星期五下午四点半——工程师们专注于解决问题，而不是阐明其根本原因。在专注于解决问题时，很容易将
    MySQL 视为需要修复的原因：让 MySQL 运行更快，应用程序就会恢复正常。但从这个意义上讲，没有办法修复 MySQL——回想一下，“MySQL 什么都不做”。因为在问题发生之前一切正常，目标是恢复到那种正常状态，从应用程序开始，因为它驱动着
    MySQL。正确的解决方案取决于应用程序，但常见的策略包括：重新启动应用程序、限制传入的应用程序请求和禁用应用程序功能。
- en: I’m not favoring MySQL. The simple reality is that MySQL is a mature database
    with more than 20 years in the field. Moreover, as an open source database, it
    has been scrutinized by engineers from all over the world. At this juncture in
    the storied life of MySQL, inherent slowness is not its weakness. Rather than
    ask why MySQL is slow, a more powerful and effective question that leads to a
    root cause or immediate fix is “What is causing MySQL to run slowly?”
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不偏袒 MySQL。简单的事实是，MySQL 是一个成熟的数据库，在这个领域已经超过 20 年了。此外，作为一个开源数据库，它已经受到来自世界各地工程师的严格审查。在
    MySQL 充满传奇色彩的生命周期的这个时刻，固有的慢不是它的弱点。与其问为什么 MySQL 慢，一个更强大有效的问题是，“是什么导致 MySQL 运行缓慢？”
- en: Summary
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'This chapter analyzed the spectra of MySQL metrics that are the most important
    for understanding the nature of the workload, which accounts for MySQL performance.
    The illuminating takeaway points are:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析了 MySQL 指标的光谱，这些指标对于理解工作负载的本质至关重要，这些指标决定了 MySQL 的性能。关键的领悟点是：
- en: 'MySQL performance has two sides: query performance and server performance.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 性能有两个方面：查询性能和服务器性能。
- en: Query performance is input; server performance is output.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询性能是输入；服务器性能是输出。
- en: Normal and stable are whatever performance MySQL exhibits for your application
    on a typical day when everything is working properly.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常和稳定是 MySQL 在您的应用程序上表现出来的一切，就像一天中的典型工作日一样，一切都正常运行。
- en: Stability does not limit performance; it ensures that performance—at any level—is
    sustainable.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定性不限制性能；它确保任何水平的性能都是可持续的。
- en: MySQL KPIs are response time, errors, QPS, and threads running.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 的关键性能指标包括响应时间、错误、QPS 和正在运行的线程。
- en: 'The field of metrics comprises six classes of metrics: response time, rate,
    utilization, wait, error, and access pattern (seven, if you count internal metrics).'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标领域包括六类指标：响应时间、速率、利用率、等待、错误和访问模式（如果计算内部指标，则为七类）。
- en: 'Metric classes are related: rate increases utilization; utilization pushes
    back to decrease rate; high (maximum) utilization incurs wait; wait timeout incurs
    error.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标类相关联：速率增加利用率；利用率推动降低速率；高（最大）利用率引发等待；等待超时引发错误。
- en: The spectra of MySQL metrics are vast; see [“Spectra”](#spectra).
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 指标的光谱是广泛的；请参阅 [“光谱”](#spectra)。
- en: '*Resolution* means the frequency at which metrics are collected and reported.'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分辨率* 意味着收集和报告指标的频率。'
- en: High resolution metrics (5 seconds or less) reveal important performance details
    that are lost in low resolution metrics.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高分辨率指标（5 秒或更短）揭示了低分辨率指标中丢失的重要性能细节。
- en: Alert on what users experience (like response time) and objective limits.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报用户体验（如响应时间）和客观限制。
- en: Application issues (your application or another) are the most likely cause of
    slow MySQL performance.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序问题（无论是您的应用程序还是其他应用程序）是导致 MySQL 性能缓慢的最可能原因。
- en: MySQL server performance is revealed through a spectrum of metrics that are
    the figurative refraction of the workload through MySQL.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 服务器性能通过一系列指标展现出来，这些指标在某种程度上反映了工作负载通过 MySQL 的折射。
- en: The next chapter investigates replication lag.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将调查复制延迟。
- en: 'Practice: Review Key Performance Indicators'
  id: totrans-556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践：审查关键性能指标
- en: The goal of this practice is to know the normal and stable values of the four
    KPIs for MySQL, as addressed in [“Key Performance Indicators”](#kpi). To make
    this practice interesting first, write down what you think the KPI values are
    for your application. You probably have a good idea about QPS; what about response
    time (P99 or P999), errors, and threads running?
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这项实践的目标是了解 MySQL 的四个关键性能指标的正常和稳定数值，如 [“关键性能指标”](#kpi) 所述。为了使这项实践更有趣，首先写下您认为的应用程序的
    KPI 值。您可能对 QPS 有一个很好的了解；那响应时间（P99 或 P999）、错误和运行中的线程呢？
- en: Start collecting the four [“Key Performance Indicators”](#kpi), if you’re not
    already. Your method depends on the software (or service) that you use to collect
    MySQL metrics. Any decent MySQL monitor should collect all four; if your current
    solution does not, seriously consider a better MySQL monitor because if it doesn’t
    collect key performance indicators, it’s unlikely to collect many of the metrics
    detailed in [“Spectra”](#spectra).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未开始，开始收集这四个 [“关键性能指标”](#kpi)。您的方法取决于您用来收集 MySQL 指标的软件（或服务）。任何像样的 MySQL 监控器应该都能收集所有四个指标；如果您当前的解决方案没有，严肃考虑更好的
    MySQL 监控器，因为如果它不能收集关键性能指标，它不太可能收集 [“光谱”](#spectra) 中详细描述的许多指标。
- en: 'Review at least one full day of KPI metrics. Are the real values close to what
    you thought? If response time is higher than you thought, then you know where
    to begin: [“Query profile”](ch01.html#query-profile). If the rate of errors is
    higher than you thought, then query table `performance_schema.events_errors_summary_global_by_error`
    to see which error numbers are occurring. Use [“MySQL Error Message Reference”](https://oreil.ly/F9z9W)
    to look up the error code. If threads running is higher than you thought, diagnosis
    is tricky because a single thread executes different queries (presuming the application
    uses a connection pool). Start with the slowest queries in the query profile.
    If your query metric tool reports query load, focus on queries with the highest
    load; otherwise, focus on queries with the highest total query time. If necessary,
    investigate using the [Performance Schema `threads` table](https://oreil.ly/ZgtGW).'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 审查至少一整天的关键性能指标。实际数值是否接近您的预期？如果响应时间高于预期，那么您知道从哪里开始：[“查询概要”](ch01.html#query-profile)。如果错误率高于预期，则查询表
    `performance_schema.events_errors_summary_global_by_error` 查看正在发生的错误编号。使用 [“MySQL
    错误消息参考”](https://oreil.ly/F9z9W) 查找错误代码。如果运行线程高于预期，则诊断较为复杂，因为单个线程执行不同的查询（假定应用程序使用连接池）。从查询概要中开始处理最慢的查询。如果您的查询指标工具报告查询负载，请关注负载最高的查询；否则，请关注总查询时间最长的查询。如有必要，使用
    [Performance Schema `threads` 表](https://oreil.ly/ZgtGW) 进行调查。
- en: Review the KPIs for different periods throughout the day. Are the values stable
    all day, or do they decrease in the middle of the night? Are there periods when
    the values are abnormal? Overall, what are the normal and stable KPI values for
    your application?
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 审查一天中不同时段的关键性能指标。数值整天稳定吗，还是在午夜时分有所下降？是否存在数值异常的时段？总体来看，您的应用程序的正常和稳定的关键性能指标是什么？
- en: 'Practice: Review Alerts and Thresholds'
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践：审查警报和阈值
- en: 'The goal of this practice is to help you sleep at night. Whereas charts for
    MySQL metrics are front and center, alerts—and configuration of those alerts—are
    usually hidden away. Consequently, engineers—especially newly hired engineers—do
    not know what alerts lurk in the darkness, waiting to page them while they sleep.
    Take a morning or afternoon to shine a light on all your alerts and how they are
    configured—their thresholds, if any. And while you’re at it: document the alerts
    (or update the current documentation). Review [“Wild Goose Chase (Thresholds)”](#thresholds)
    and [“Alert on User Experience and Objective Limits”](#alert-on), and adjust or
    remove superfluous alerts.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这项实践的目标是帮助你晚上能够安心入睡。虽然MySQL指标的图表处于前台和中心位置，但警报及其配置通常被隐藏起来。因此，工程师，特别是新入职的工程师，不知道哪些警报潜伏在黑暗中，等待他们在睡觉时呼叫。花一个早晨或下午的时间来照亮所有的警报及其配置情况——它们的阈值，如果有的话。并且，在此期间：记录警报（或更新当前的文档）。查看
    [“荒谬的追逐（阈值）”](#thresholds) 和 [“基于用户体验和目标限制的警报”](#alert-on)，并调整或移除多余的警报。
- en: 'The goal for alerting is simple: every page is legitimate and actionable. *Legitimate*
    means that something is already broken, or certain to break very soon, and it
    requires fixing right now. *Actionable* means that the engineer (who was paged)
    has the knowledge, skills, and access to fix it. This is possible with MySQL.
    Say *no* to the wild goose chase and *yes* to a good night’s sleep.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 警报的目标很简单：每一页都是合法的并且可操作的。*合法* 意味着某些东西已经损坏，或者很快会损坏，并且需要立即修复。*可操作* 意味着工程师（被呼叫的）具有修复它所需的知识、技能和访问权限。这对MySQL来说是可能的。对荒谬的追逐说“不”，对一个好的夜间睡眠说“是”。
- en: ^([1](ch06.html#idm45829110960368-marker)) The [MySQL worklog 5384](https://oreil.ly/2kFWK)
    explains how response time quantiles are implemented in the Performance Schema.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm45829110960368-marker)) [MySQL工作日志5384](https://oreil.ly/2kFWK)
    解释了性能模式中如何实现响应时间分位数。
- en: ^([2](ch06.html#idm45829110678032-marker)) `Com_insert_select` and `Com_replace_select`
    are technically both reads and writes, but for simplicity I count them as writes.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#idm45829110678032-marker)) `Com_insert_select` 和 `Com_replace_select`
    在技术上既是读操作又是写操作，但为简单起见，我将它们视为写操作。
- en: ^([3](ch06.html#idm45829110575632-marker)) “I’m Mr. Meeseeks, look at me!”
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#idm45829110575632-marker)) “我是米斯克先生，看着我！”
- en: ^([4](ch06.html#idm45829110547888-marker)) See my blog post [“MySQL Select and
    Sort Status Variables”](https://oreil.ly/OpJvS) for an in-depth explanation of
    all `Select_%` and `Sort_%` metrics.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#idm45829110547888-marker)) 查看我的博文 [“MySQL Select和Sort状态变量”](https://oreil.ly/OpJvS)
    ，详细解释了所有 `Select_%` 和 `Sort_%` 指标。
- en: ^([5](ch06.html#idm45829110227344-marker)) You can disable durability, but that’s
    a terrible idea.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.html#idm45829110227344-marker)) 你可以禁用耐久性，但那是个糟糕的主意。
- en: ^([6](ch06.html#idm45829110113632-marker)) The MySQL adaptive flushing algorithm
    was created in 2008 by renowned MySQL expert Yasufumi Kinoshita while working
    at Percona. See his blog post [“Adaptive checkpointing”](https://oreil.ly/8QG6X).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.html#idm45829110113632-marker)) MySQL自适应刷新算法是由著名的MySQL专家Yasufumi
    Kinoshita在2008年在Percona工作时创建的。查看他的博文 [“自适应检查点”](https://oreil.ly/8QG6X)。
- en: ^([7](ch06.html#idm45829110096368-marker)) For proof and a deep dive, read my
    blog post [“MySQL LRU Flushing and I/O Capacity”](https://oreil.ly/YHEcj).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.html#idm45829110096368-marker)) 想要证明并深入了解，请阅读我的博文 [“MySQL LRU刷新和I/O容量”](https://oreil.ly/YHEcj)。
- en: '^([8](ch06.html#idm45829104102032-marker)) *Legacy flushing* is also called
    *dirty pages percentage flushing*, but I prefer my term because it’s simpler and
    frames it more accurately: *legacy* implies that it’s no longer current, which
    is true.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch06.html#idm45829104102032-marker)) *遗留刷新* 也被称为*脏页百分比刷新*，但我更喜欢我的术语，因为它更简单，并且更准确地描述它：*遗留*
    暗示它不再是当前的，这是真实的。
