- en: Chapter 1\. MySQL Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 MySQL 架构
- en: MySQL’s architectural characteristics make it useful for a wide range of purposes.
    Although it is not perfect, it is flexible enough to work well in both small and
    large environments. These range from a personal website up to large-scale enterprise
    applications. To get the most from MySQL, you need to understand its design so
    that you can work with it, not against it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 的架构特点使其适用于各种用途。虽然它并非完美，但足够灵活，可以在小型和大型环境中都能很好地运行。从个人网站到大型企业应用程序都适用。要充分利用
    MySQL，您需要了解其设计，以便与之合作，而不是对抗它。
- en: This chapter provides a high-level overview of the MySQL server architecture,
    the major differences between the storage engines, and why those differences are
    important. We’ve tried to explain MySQL by simplifying the details and showing
    examples. This discussion will be useful for those new to database servers as
    well as readers who are experts with other database servers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了 MySQL 服务器架构的高层概述，存储引擎之间的主要区别以及这些区别的重要性。我们试图通过简化细节并展示示例来解释 MySQL。这个讨论对于那些对数据库服务器新手以及对其他数据库服务器是专家的读者都将有用。
- en: MySQL’s Logical Architecture
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 的逻辑架构
- en: A good mental picture of how MySQL’s components work together will help you
    understand the server. [Figure 1-1](#a_logical_view_of_the_mysql_server_arch)
    shows a logical view of MySQL’s architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对 MySQL 组件如何协同工作有一个清晰的心理图像将有助于您理解服务器。[图1-1](#a_logical_view_of_the_mysql_server_arch)展示了
    MySQL 架构的逻辑视图。
- en: 'The topmost layer, clients, contains the services that aren’t unique to MySQL.
    They’re services most network-based client/server tools or servers need: connection
    handling, authentication, security, and so forth.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最顶层的层级是客户端，包含的服务并非 MySQL 独有。这些服务是大多数基于网络的客户端/服务器工具或服务器所需的服务：连接处理、身份验证、安全等。
- en: 'The second layer is where things get interesting. Much of MySQL’s brains are
    here, including the code for query parsing, analysis, optimization, and all the
    built-in functions (e.g., dates, times, math, and encryption). Any functionality
    provided across storage engines lives at this level: stored procedures, triggers,
    and views, for example.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层是事情变得有趣的地方。MySQL 的大部分智慧都在这里，包括查询解析、分析、优化以及所有内置功能的代码（例如日期、时间、数学和加密）。在这个层面提供的任何功能都跨存储引擎：存储过程、触发器和视图，例如。
- en: The third layer contains the storage engines. They are responsible for storing
    and retrieving all data stored “in” MySQL. Like the various filesystems available
    for GNU/Linux, each storage engine has its own benefits and drawbacks. The server
    communicates with them through the storage engine API. This API hides differences
    between storage engines and makes them largely transparent at the query layer.
    It also contains a couple of dozen low-level functions that perform operations
    such as “begin a transaction” or “fetch the row that has this primary key.” The
    storage engines don’t parse SQL^([1](ch01.html#ch01fn2)) or communicate with one
    another; they simply respond to requests from the server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第三层包含存储引擎。它们负责存储和检索 MySQL 中存储的所有数据。就像 GNU/Linux 中提供的各种文件系统一样，每个存储引擎都有其自己的优点和缺点。服务器通过存储引擎
    API 与它们通信。该 API 隐藏了存储引擎之间的差异，并在查询层面上使它们基本透明。它还包含几十个低级函数，执行诸如“开始事务”或“获取具有此主键的行”等操作。存储引擎不解析
    SQL^([1](ch01.html#ch01fn2))，也不相互通信；它们只是响应服务器的请求。
- en: '![](assets/hpm4_0101.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hpm4_0101.png)'
- en: Figure 1-1\. A logical view of the MySQL server architecture
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-1 MySQL 服务器架构的逻辑视图
- en: Connection Management and Security
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接管理和安全
- en: By default, each client connection gets its own thread within the server process.
    The connection’s queries execute within that single thread, which in turn resides
    on one core or CPU. The server maintains a cache of ready-to-use threads, so they
    don’t need to be created and destroyed for each new connection.^([2](ch01.html#ch01fn3))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个客户端连接在服务器进程内部都有自己的线程。连接的查询在该单个线程内执行，该线程又位于一个核心或 CPU 上。服务器维护一个准备好使用的线程缓存，因此它们不需要为每个新连接创建和销毁。^([2](ch01.html#ch01fn3))
- en: When clients (applications) connect to the MySQL server, the server needs to
    authenticate them. Authentication is based on username, originating host, and
    password. X.509 certificates can also be used across a Transport Layer Security
    (TLS) connection. Once a client has connected, the server verifies whether the
    client has privileges for each query it issues (e.g., whether the client is allowed
    to issue a `SELECT` statement that accesses the `Country` table in the `world`
    database).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端（应用程序）连接到 MySQL 服务器时，服务器需要对其进行身份验证。身份验证基于用户名、来源主机和密码。也可以在传输层安全（TLS）连接中使用
    X.509 证书。一旦客户端连接，服务器会验证客户端是否对其发出的每个查询具有权限（例如，客户端是否被允许发出访问 `world` 数据库中 `Country`
    表的 `SELECT` 语句）。
- en: Optimization and Execution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化和执行
- en: MySQL parses queries to create an internal structure (the parse tree) and then
    applies a variety of optimizations. These can include rewriting the query, determining
    the order in which it will read tables, choosing which indexes to use, and so
    on. You can pass hints to the optimizer through special keywords in the query,
    affecting its decision-making process. You can also ask the server to explain
    various aspects of optimization. This lets you know what decisions the server
    is making and gives you a reference point for reworking queries, schemas, and
    settings to make everything run as efficiently as possible. There is more detail
    on this in [Chapter 8](ch08.html#query_performance_optimization).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 解析查询以创建内部结构（解析树），然后应用各种优化。这些优化包括重写查询、确定读取表的顺序、选择使用哪些索引等。您可以通过查询中的特殊关键字向优化器传递提示，影响其决策过程。您还可以要求服务器解释优化的各个方面。这让您了解服务器正在做出的决策，并为重新调整查询、模式和设置提供参考，使一切尽可能高效地运行。在[第8章](ch08.html#query_performance_optimization)中有更详细的内容。
- en: The optimizer does not really care what storage engine a particular table uses,
    but the storage engine does affect how the server optimizes the query. The optimizer
    asks the storage engine about some of its capabilities and the cost of certain
    operations as well as for statistics on the table data. For instance, some storage
    engines support index types that can be helpful to certain queries. You can read
    more about schema optimization and indexing in Chapters [6](ch06.html#schema_design_and_management)
    and [7](ch07.html#indexing_for_high_performance).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器并不真正关心特定表使用的存储引擎是什么，但存储引擎确实会影响服务器优化查询的方式。优化器向存储引擎询问一些能力以及某些操作的成本，还会请求表数据的统计信息。例如，某些存储引擎支持对某些查询有帮助的索引类型。您可以在第[6](ch06.html#schema_design_and_management)章和第[7](ch07.html#indexing_for_high_performance)章中了解更多关于模式优化和索引的内容。
- en: In older versions, MySQL made use of an internal query cache to see if it could
    serve the results from there. However, as concurrency increased, the query cache
    became a notorious bottleneck. As of MySQL 5.7.20, the query cache was officially
    deprecated as a MySQL feature, and in the 8.0 release, the query cache is fully
    removed. Even though the query cache is no longer a core part of the MySQL server,
    caching frequently served result sets is a good practice. While outside the scope
    of this book, a popular design pattern is to cache data in memcached or Redis.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本中，MySQL利用内部查询缓存来查看是否可以从中提供结果。然而，随着并发性的增加，查询缓存成为一个臭名昭著的瓶颈。截至MySQL 5.7.20，查询缓存正式被废弃为MySQL的一个特性，并在8.0版本中，查询缓存被完全移除。尽管查询缓存不再是MySQL服务器的核心部分，但缓存频繁提供的结果集是一个好的实践。虽然超出了本书的范围，但一个流行的设计模式是在memcached或Redis中缓存数据。
- en: Concurrency Control
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发控制
- en: 'Any time more than one query needs to change data at the same time, the problem
    of concurrency control arises. For our purposes in this chapter, MySQL has to
    do this at two levels: the server level and the storage-engine level. We will
    give you a simplified overview of how MySQL deals with concurrent readers and
    writers, so you have the context you need for the rest of this chapter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当多个查询需要同时更改数据时，就会出现并发控制问题。对于本章的目的，MySQL必须在两个级别进行并发控制：服务器级别和存储引擎级别。我们将为您简要介绍MySQL如何处理并发读取和写入，以便您在本章的其余部分中获得所需的背景知识。
- en: To illustrate how MySQL handles concurrent work on the same set of data, we
    will use a traditional spreadsheet file as an example. A spreadsheet consists
    of rows and columns, much like a database table. Assume the file is on your laptop
    and only you have access to it. There are no potential conflicts; only you can
    make changes to the file. Now, imagine you need to collaborate with a coworker
    on that spreadsheet. It is now on a shared server that both of you have access
    to. What happens when both of you need to make changes to this file at the same
    time? What if we have an entire team of people actively trying to edit, add, and
    remove cells from this spreadsheet? We can say that they should take turns making
    changes, but that is not efficient. We need an approach for allowing concurrent
    access to a high-volume spreadsheet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明MySQL如何处理对同一组数据的并发工作，我们将以传统的电子表格文件为例。电子表格由行和列组成，就像数据库表一样。假设文件在您的笔记本电脑上，并且只有您可以访问它。没有潜在的冲突；只有您可以对文件进行更改。现在，想象您需要与同事共同使用该电子表格。它现在位于您和同事都可以访问的共享服务器上。当您和同事同时需要对此文件进行更改时会发生什么？如果我们有一个整个团队的人正在积极尝试编辑、添加和删除此电子表格中的单元格，会发生什么？我们可以说他们应该轮流进行更改，但这并不高效。我们需要一种允许高容量电子表格并发访问的方法。
- en: Read/Write Locks
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读/写锁
- en: Reading from the spreadsheet isn’t as troublesome. There’s nothing wrong with
    multiple clients reading the same file simultaneously; because they aren’t making
    changes, nothing is likely to go wrong. What happens if someone tries to delete
    cell number `A25` while others are reading the spreadsheet? It depends, but a
    reader could come away with a corrupted or inconsistent view of the data. So,
    to be safe, even reading from a spreadsheet requires special care.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从电子表格中读取并不那么麻烦。多个客户端同时读取同一文件没有问题；因为他们没有进行更改，所以不太可能出错。如果有人尝试在其他人正在读取电子表格时删除`A25`单元格会发生什么？这取决于情况，但读者可能会得到损坏或不一致的数据视图。因此，即使从电���表格中读取也需要特别小心。
- en: If you think of the spreadsheet as a database table, it’s easy to see that the
    problem is the same in this context. In many ways, a spreadsheet is really just
    a simple database table. Modifying rows in a database table is very similar to
    removing or changing the content of cells in a spreadsheet file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将电子表格视为数据库表，很容易看出在这种情况下问题是相同的。在许多方面，电子表格实际上只是一个简单的数据库表。修改数据库表中的行与删除或更改电子表格文件中的单元格内容非常相似。
- en: The solution to this classic problem of concurrency control is rather simple.
    Systems that deal with concurrent read/write access typically implement a locking
    system that consists of two lock types. These locks are usually known as *shared
    locks* and *exclusive locks*, or read locks and write locks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个经典的并发控制问题相当简单。处理并发读/写访问的系统通常实现由两种锁类型组成的锁定系统。这些锁通常被称为*共享锁*和*排他锁*，或读锁和写锁。
- en: 'Without worrying about the actual locking mechanism, we can describe the concept
    as follows. *Read locks* on a resource are shared, or mutually nonblocking: many
    clients can read from a resource at the same time and not interfere with one another.
    *Write locks*, on the other hand, are exclusive—that is, they block both read
    locks and other write locks—because the only safe policy is to have a single client
    writing to the resource at a given time and to prevent all reads when a client
    is writing.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心实际的锁定机制，我们可以描述概念如下。对于资源的*读锁*是共享的，或者说是相互非阻塞的：许多客户端可以同时从资源中读取，而不会相互干扰。另一方面，*写锁*是排他的——也就是说，它们会阻止读锁和其他写锁——因为唯一安全的策略是在给定时间内只允许单个客户端向资源写入，并在客户端写入时阻止所有读取。
- en: 'In the database world, locking happens all the time: MySQL has to prevent one
    client from reading a piece of data while another is changing it. If a database
    server is performing in an acceptable manner, this management of locks is fast
    enough to not be noticeable to the clients. We will discuss in [Chapter 8](ch08.html#query_performance_optimization)
    how to tune your queries to avoid performance issues caused by locking.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库世界中，锁定一直在发生：MySQL 必须防止一个客户端在另一个客户端更改数据时读取数据。如果数据库服务器表现得符合要求，那么锁定的管理速度足够快，以至于客户端几乎察觉不到。我们将在[第8章](ch08.html#query_performance_optimization)中讨论如何调整查询以避免由锁定引起的性能问题。
- en: Lock Granularity
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定粒度
- en: One way to improve the concurrency of a shared resource is to be more selective
    about what you lock. Rather than locking the entire resource, lock only the part
    that contains the data you need to change. Better yet, lock only the exact piece
    of data you plan to change. Minimizing the amount of data that you lock at any
    one time lets changes to a given resource occur simultaneously, as long as they
    don’t conflict with each other.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 提高共享资源并发性的一种方法是更加选择性地锁定你要锁定的内容。而不是锁定整个资源，只锁定包含你需要更改的数据的部分。更好的是，只锁定你计划更改的确切数据片段。在任何给定时间最小化你锁定的数据量，让对给定资源的更改可以同时发生，只要它们不相互冲突。
- en: Unfortunately, locks are not free—they consume resources. Every lock operation—getting
    a lock, checking to see whether a lock is free, releasing a lock, and so on—has
    overhead. If the system spends too much time managing locks instead of storing
    and retrieving data, performance can suffer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，锁并不是免费的——它们会消耗资源。每个锁操作——获取锁、检查锁是否空闲、释放锁等——都有开销。如果系统花费太多时间管理锁而不是存储和检索数据，性能可能会受到影响。
- en: 'A locking strategy is a compromise between lock overhead and data safety, and
    that compromise affects performance. Most commercial database servers don’t give
    you much choice: you get what is known as row-level locking in your tables, with
    a variety of often complex ways to give good performance with many locks. Locks
    are how databases implement consistency guarantees. An expert operator of a database
    would have to go as far as reading the source code to determine the most appropriate
    set of tuning configurations to optimize this trade-off of speed versus data safety.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定策略是锁定开销和数据安全之间的一种折衷，这种折衷会影响性能。大多数商用数据库服务器并不给你太多选择：在你的表中，你得到的是所谓的行级锁定，有各种复杂的方式来提供许多锁的良好性能。锁是数据库如何实现一致性保证的方式。一个数据库的专家操作员必须深入阅读源代码，以确定最适合的一组调整配置，以优化速度与数据安全之间的这种权衡。
- en: MySQL, on the other hand, does offer choices. Its storage engines can implement
    their own locking policies and lock granularities. Lock management is a very important
    decision in storage-engine design; fixing the granularity at a certain level can
    improve performance for certain uses yet make that engine less suited for other
    purposes. Because MySQL offers multiple storage engines, it doesn’t require a
    single general-purpose solution. Let’s have a look at the two most important lock
    strategies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，MySQL 提供了选择。它的存储引擎可以实现自己的锁定策略和锁定粒度。锁管理是存储引擎设计中非常重要的决定；将粒度固定在某个级别可以提高某些用途的性能，但使该引擎不太适合其他用途。因为
    MySQL 提供了多个存储引擎，它不需要一个单一的通用解决方案。让我们看看两种最重要的锁定策略。
- en: Table locks
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表锁
- en: 'The most basic locking strategy available in MySQL, and the one with the lowest
    overhead, is table locks. A *table lock* is analogous to the spreadsheet locks
    described earlier: it locks the entire table. When a client wishes to write to
    a table (insert, delete, update, etc.), it acquires a write lock. This keeps all
    other read and write operations at bay. When nobody is writing, readers can obtain
    read locks, which don’t conflict with other read locks.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 中最基本的锁定策略，也是开销最低的策略是表锁。*表锁* 类似于前面描述的电子表格锁：它锁定整个表。当客户端希望写入表（插入、删除、更新等）时，它会获取写锁。这会阻止所有其他读取和写入操作。当没有人在写入时，读者可以获取读锁，这些读锁不会与其他读锁冲突。
- en: Table locks have variations for improved performance in specific situations.
    For example, `READ LOCAL` table locks allow some types of concurrent write operations.
    Write and read lock queues are separate with the write queue being wholly of higher
    priority than the read queue.^([3](ch01.html#ch01fn4))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表锁在特定情况下有改进性能的变体。例如，`READ LOCAL` 表锁允许某些类型的并发写操作。写锁和读锁队列是分开的，写队列完全比读队列的优先级高。^([3](ch01.html#ch01fn4))
- en: Row locks
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行锁
- en: The locking style that offers the greatest concurrency (and carries the greatest
    overhead) is the use of row locks. Going back to the spreadsheet analogy, *row
    locks* would be the same as locking just the row in the spreadsheet. This strategy
    allows multiple people to edit different rows concurrently without blocking one
    another. This enables the server to take more concurrent writes, but the cost
    is more overhead in having to keep track of who has each row lock, how long they
    have been open, and what kind of row locks they are as well as cleaning up locks
    when they are no longer needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供最大并发性（并带来最大开销）的锁定风格是使用行锁。回到电子表格的类比，*行锁* 就像只锁定电子表格中的行一样。这种策略允许多人同时编辑不同的行，而不会相互阻塞。这使服务器能够进行更多并发写入，但代价是需要跟踪谁拥有每个行锁，它们已经打开多久，以及它们是什么类型的行锁，以及在不再需要时清理锁。
- en: Row locks are implemented in the storage engine, not the server. The server
    is mostly^([4](ch01.html#ch01fn5)) unaware of locks implemented in the storage
    engines, and as you’ll see later in this chapter and throughout the book, the
    storage engines all implement locking in their own ways.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 行锁是在存储引擎中实现的，而不是在服务器中。服务器大部分时间^([4](ch01.html#ch01fn5)) 对在存储引擎中实现的锁定是不知情的，正如你将在本章和整本书中看到的，存储引擎都以自己的方式实现锁定。
- en: Transactions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: You can’t examine the more advanced features of a database system for very long
    before transactions enter the mix. A *transaction* is a group of SQL statements
    that are treated atomically, as a single unit of work. If the database engine
    can apply the entire group of statements to a database, it does so, but if any
    of them can’t be done because of a crash or other reason, none of them is applied.
    It’s all or nothing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究数据库系统的更高级功能之前，你会发现事务的存在。*事务*是一组SQL语句，被视为一个原子单元的工作。如果数据库引擎可以将整组语句应用到数据库中，它会这样做，但如果由于崩溃或其他原因无法完成其中任何一个，那么所有语句都不会被应用。要么全部成功，要么全部失败。
- en: Little of this section is specific to MySQL. If you’re already familiar with
    ACID transactions, feel free to skip ahead to [“Transactions in MySQL”](#transactions_in_mysql).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分与MySQL无关。如果你已经熟悉ACID事务，请随时跳到[“MySQL中的事务”](#transactions_in_mysql)。
- en: 'A banking application is the classic example of why transactions are necessary.^([5](ch01.html#ch01fn6))
    Imagine a bank’s database with two tables: checking and savings. To move $200
    from Jane’s checking account to her savings account, you need to perform at least
    three steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 银行应用程序是为什么需要事务的经典例子。想象一个银行的数据库有两个表：支票和储蓄。要将$200从简的支票账户转移到她的储蓄账户，你需要至少执行三个步骤：
- en: Make sure her checking account balance is greater than $200.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保她的支票账户余额大于$200。
- en: Subtract $200 from her checking account balance.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从她的支票账户余额中减去$200。
- en: Add $200 to her savings account balance.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给她的储蓄账户余额加上$200。
- en: The entire operation should be wrapped in a transaction so that if any one of
    the steps fails, any completed steps can be rolled back.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 整个操作应该包裹在一个事务中，这样如果任何一个步骤失败，已完成的步骤可以被回滚。
- en: 'You start a transaction with the `START TRANSACTION` statement and then either
    make its changes permanent with `COMMIT` or discard the changes with `ROLLBACK`.
    So the SQL for our sample transaction might look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`START TRANSACTION`语句开始一个事务，然后使用`COMMIT`使其更改永久化，或者使用`ROLLBACK`放弃更改。因此，我们示例事务的SQL可能如下所示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Transactions alone aren’t the whole story. What happens if the database server
    crashes while performing line 4? Who knows? The customer probably just lost $200\.
    What if another process comes along between lines 3 and 4 and removes the entire
    checking account balance? The bank has given the customer a $200 credit without
    even knowing it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事务本身并不是全部。如果数据库服务器在执行第4行时崩溃会发生什么？谁知道呢？客户可能刚刚损失了$200。如果另一个进程在第3行和第4行之间出现并移除整个支票账户余额会发生什么？银行已经给客户提供了$200的信用，甚至自己都不知道。
- en: 'And there are a lot more failure possibilities in this sequence of operations.
    You could see connection drops, timeouts, or even a crash of the database server
    running them midway through the operations. This is typically why highly complex
    and slow two-phase-commit systems exist: to mitigate against all sorts of failure
    scenarios.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作序列中还有很多失败的可能性。你可能会遇到连接中断、超时，甚至在操作中途数据库服务器崩溃。这通常是为什么高度复杂和缓慢的两阶段提交系统存在的原因：以减轻各种故障场景。
- en: 'Transactions aren’t enough unless the system passes the ACID test. ACID stands
    for atomicity, consistency, isolation, and durability. These are tightly related
    criteria that a data-safe transaction processing system must meet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 事务并不足够，除非系统通过ACID测试。ACID代表原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。这些是数据安全事务处理系统必须满足的紧密相关标准：
- en: Atomicity
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 原子性
- en: 'A transaction must function as a single indivisible unit of work so that the
    entire transaction is either applied or never committed. When transactions are
    atomic, there is no such thing as a partially completed transaction: it’s all
    or nothing.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事务必须作为一个单一不可分割的工作单元运行，以便整个事务要么被应用，要么永远不被提交。当事务是原子的时，不存在部分完成的事务：要么全部成功，要么全部失败。
- en: Consistency
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性
- en: The database should always move from one consistent state to the next. In our
    example, consistency ensures that a crash between lines 3 and 4 doesn’t result
    in $200 disappearing from the checking account. If the transaction is never committed,
    none of the transaction’s changes are ever reflected in the database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库应该始终从一个一致的状态转移到下一个一致的状态。在我们的示例中，一致性确保在第3行和第4行之间发生崩溃时，支票账户中不会消失$200。如果事务从未提交，事务的任何更改都不会反映在数据库中。
- en: Isolation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离性
- en: The results of a transaction are usually invisible to other transactions until
    the transaction is complete. This ensures that if a bank account summary runs
    after line 3 but before line 4 in our example, it will still see the $200 in the
    checking account. When we discuss isolation levels later in this chapter, you’ll
    understand why we said “usually invisible.”
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的结果通常对其他事务是不可见的，直到事务完成。这确保如果在我们的示例中的第3行和第4行之间运行银行账户摘要，它仍然会看到支票账户中的$200。当我们在本章后面讨论隔离级别时，你会明白为什么我们说“通常不可见”。
- en: Durability
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性
- en: Once committed, a transaction’s changes are permanent. This means the changes
    must be recorded such that data won’t be lost in a system crash. Durability is
    a slightly fuzzy concept, however, because there are actually many levels. Some
    durability strategies provide a stronger safety guarantee than others, and nothing
    is ever 100% durable (if the database itself were truly durable, then how could
    backups increase durability?).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交，事务的更改就是永久的。这意味着更改必须被记录，以防止在系统崩溃时丢失数据。然而，持久性是一个稍微模糊的概念，因为实际上有许多级别。一些持久性策略提供比其他更强的安全保证，而且没有什么是100%持久的（如果数据库本身真的是持久的，那么备份如何增加持久性呢？）。
- en: ACID transactions and the guarantees provided through them in the InnoDB engine
    specifically are one of the strongest and most mature features in MySQL. While
    they come with certain throughput trade-offs, when applied appropriately they
    can save you from implementing a lot of complex logic in the application layer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ACID事务和InnoDB引擎特别提供的保证是MySQL中最强大和最成熟的功能之一。虽然它们会带来一定的吞吐量折衷，但当适当应用时，它们可以避免在应用层实现大量复杂逻辑。
- en: Isolation Levels
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离级别
- en: Isolation is more complex than it looks. The ANSI SQL standard defines four
    isolation levels. If you are new to the world of databases, we highly recommend
    you get familiar with the general standard of ANSI SQL^([6](ch01.html#ch01fn7))
    before coming back to reading about the specific MySQL implementation. The goal
    of this standard is to define the rules for which changes are and aren’t visible
    inside and outside a transaction. Lower isolation levels typically allow higher
    concurrency and have lower overhead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离性比看起来更复杂。ANSI SQL标准定义了四个隔离级别。如果您是数据库领域的新手，我们强烈建议您在阅读有关具体MySQL实现之前熟悉ANSI SQL的一般标准^([6](ch01.html#ch01fn7))。该标准的目标是定义更改在事务内外何时可见和何时不可见的规则。较低的隔离级别通常允许更高的并发性并具有较低的开销。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Each storage engine implements isolation levels slightly differently, and they
    don’t necessarily match what you might expect if you’re used to another database
    product (thus, we won’t go into exhaustive detail in this section). You should
    read the manuals for whichever storage engines you decide to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个存储引擎对隔离级别的实现略有不同，并且不一定与您习惯于其他数据库产品时所期望的相匹配（因此，在本节中我们不会详细介绍）。您应该阅读您决定使用的任何存储引擎的手册。
- en: 'Let’s take a quick look at the four isolation levels:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下四个隔离级别：
- en: '`READ UNCOMMITTED`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`READ UNCOMMITTED`'
- en: In the `READ UNCOMMITTED` isolation level, transactions can view the results
    of uncommitted transactions. At this level, many problems can occur unless you
    really, really know what you are doing and have a good reason for doing it. This
    level is rarely used in practice because its performance isn’t much better than
    the other levels, which have many advantages. Reading uncommitted data is also
    known as a *dirty read*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`READ UNCOMMITTED`隔离级别中，事务可以查看未提交事务的结果。在这个级别，除非您真的非常了解自己在做什么并且有充分的理由这样做，否则可能会发生许多问题。这个级别在实践中很少使用，因为其性能并不比其他级别好多少，而其他级别有许多优势。读取未提交的数据也被称为*脏读*。
- en: '`READ COMMITTED`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`READ COMMITTED`'
- en: 'The default isolation level for most database systems (but not MySQL!) is `READ
    COMMITTED`. It satisfies the simple definition of isolation used earlier: a transaction
    will continue to see changes made by transactions that were committed after it
    began, and its changes won’t be visible to others until it has committed. This
    level still allows what’s known as a nonrepeatable read. This means you can run
    the same statement twice and see different data.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库系统（但不包括MySQL！）的默认隔离级别是`READ COMMITTED`。它满足先前使用的隔离的简单定义：事务将继续看到在其开始后提交的事务所做的更改，并且其更改在提交之前对其他人不可见。这个级别仍然允许所谓的不可重复读。这意味着您可以两次运行相同的语句并看到不同的数据。
- en: '`REPEATABLE READ`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPEATABLE READ`'
- en: '`REPEATABLE READ` solves the problems that `READ UNCOMMITTED` allows. It guarantees
    that any rows a transaction reads will “look the same” in subsequent reads within
    the same transaction, but in theory it still allows another tricky problem: phantom
    reads. Simply put, a phantom read can happen when you select some range of rows,
    another transaction inserts a new row into the range, and then you select the
    same range again; you will then see the new “phantom” row. InnoDB and XtraDB solve
    the phantom read problem with multiversion concurrency control, which we explain
    later in this chapter.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPEATABLE READ`解决了`READ UNCOMMITTED`允许的问题。它保证事务读取的任何行在同一事务内的后续读取中“看起来相同”，但理论上仍允许另一个棘手的问题：幻读。简而言之，当您选择某些行的范围时，另一个事务将新行插入到该范围中，然后再次选择相同范围时，您将看到新的“幻影”行。InnoDB和XtraDB通过多版本并发控制解决了幻读问题，我们稍后在本章中解释。'
- en: '`REPEATABLE READ` is MySQL’s default transaction isolation level.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPEATABLE READ`是MySQL的默认事务隔离级别。'
- en: '`SERIALIZABLE`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SERIALIZABLE`'
- en: The highest level of isolation, `SERIALIZABLE`, solves the phantom read problem
    by forcing transactions to be ordered so that they can’t possibly conflict. In
    a nutshell, `SERIALIZABLE` places a lock on every row it reads. At this level,
    a lot of timeouts and lock contention can occur. We’ve rarely seen people use
    this isolation level, but your application’s needs might force you to accept the
    decreased concurrency in favor of the data safety that results.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级别的隔离是`SERIALIZABLE`，通过强制事务按顺序排列以避免可能发生冲突来解决幻读问题。简而言之，`SERIALIZABLE`在读取每一行时都会放置一个锁。在这个级别，可能会发生很多超时和锁争用。我们很少看到人们使用这种隔离级别，但您的应用程序需求可能迫使您接受降低的并发性以换取数据安全性。
- en: '[Table 1-1](#ansi_sql_isolation_levels) summarizes the various isolation levels
    and the drawbacks associated with each one.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](#ansi_sql_isolation_levels)总结了各种隔离级别及与每个级别相关的缺点。'
- en: Table 1-1\. ANSI SQL isolation levels
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1\. ANSI SQL隔离级别
- en: '| Isolation level | Dirty reads possible | Nonrepeatable reads possible | Phantom
    reads possible | Locking reads |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 隔离级别 | 是否可能出现脏读 | 是否可能出现不可重复读 | 是否可能出现幻读 | 锁定读取 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `READ UNCOMMITTED` | Yes | Yes | Yes | No |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `READ UNCOMMITTED` | 是 | 是 | 是 | 否 |'
- en: '| `READ COMMITTED` | No | Yes | Yes | No |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `READ COMMITTED` | 否 | 是 | 是 | 否 |'
- en: '| `REPEATABLE READ` | No | No | Yes | No |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `REPEATABLE READ` | 否 | 否 | 是 | 否 |'
- en: '| `SERIALIZABLE` | No | No | No | Yes |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `SERIALIZABLE` | 否 | 否 | 否 | 是 |'
- en: Deadlocks
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: 'A *deadlock* is when two or more transactions are mutually holding and requesting
    locks on the same resources, creating a cycle of dependencies. Deadlocks occur
    when transactions try to lock resources in a different order. They can happen
    whenever multiple transactions lock the same resources. For example, consider
    these two transactions running against a `StockPrice` table, which has a primary
    key of `(stock_id, date)`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*死锁*是指两个或多个事务相互持有并请求相同资源上的锁，从而创建了依赖循环。当事务尝试以不同顺序锁定资源时，就会发生死锁。无论何时多个事务锁定相同资源，都可能发生死锁。例如，考虑这两个针对`StockPrice`表运行的事务，该表具有主键`(stock_id,
    date)`：'
- en: Transaction 1
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 事务1
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Transaction 2
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事务2
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each transaction will execute its first query and update a row of data, locking
    that row in the primary key index and any additional unique index it is part of
    in the process. Each transaction will then attempt to update its second row, only
    to find that it is already locked. The two transactions will wait forever for
    each other to complete unless something intervenes to break the deadlock. We cover
    further in [Chapter 7](ch07.html#indexing_for_high_performance) how indexing can
    make or break the performance of your queries as your schema evolves.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事务将执行其第一个查询并更新一行数据，将该行在主键索引中锁定，并在此过程中锁定其所属的任何其他唯一索引。然后，每个事务将尝试更新其第二行，只能发现它已被锁定。除非有某种干预来打破死锁，否则这两个事务将永远等待对方完成。我们在[第7章](ch07.html#indexing_for_high_performance)中进一步介绍索引如何在架构演变过程中影响查询的性能。
- en: To combat this problem, database systems implement various forms of deadlock
    detection and timeouts. The more sophisticated systems, such as the InnoDB storage
    engine, will notice circular dependencies and return an error instantly. This
    can be a good thing—otherwise, deadlocks would manifest themselves as very slow
    queries. Others will give up after the query exceeds a lock wait timeout, which
    is not always good. The way InnoDB currently handles deadlocks is to roll back
    the transaction that has the fewest exclusive row locks (an approximate metric
    for which will be the easiest to roll back).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，数据库系统实现了各种形式的死锁检测和超时。更复杂的系统，如InnoDB存储引擎，将注意到循环依赖关系并立即返回错误���这可能是一件好事——否则，死锁将表现为非常慢的查询。其他系统在查询超过锁等待超时后会放弃，这并不总是好事。InnoDB目前处理死锁的方式是回滚具有最少独占行锁的事务（这是一个近似指标，哪个事务最容易回滚）。
- en: 'Lock behavior and order are storage engine specific, so some storage engines
    might deadlock on a certain sequence of statements even though others won’t. Deadlocks
    have a dual nature: some are unavoidable because of true data conflicts, and some
    are caused by how a storage engine works.^([7](ch01.html#ch01fn8))'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 锁行为和顺序是存储引擎特定的，因此一些存储引擎可能会在某些语句序列上发生死锁，即使其他存储引擎不会。死锁具有双重性质：一些是由于真实数据冲突而不可避免的，一些是由存储引擎的工作方式引起的。^([7](ch01.html#ch01fn8))
- en: Once they occur, deadlocks cannot be broken without rolling back one of the
    transactions, either partially or wholly. They are a fact of life in transactional
    systems, and your applications should be designed to handle them. Many applications
    can simply retry their transactions from the beginning, and unless they encounter
    another deadlock, they should be successful.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生死锁，就无法在不部分或完全回滚其中一个事务的情况下解除死锁。在事务系统中，死锁是生活中的一个事实，您的应用程序应设计为处理它们。许多应用程序可以简单地从头开始重试它们的事务，除非遇到另一个死锁，否则它们应该成功。
- en: Transaction Logging
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务日志
- en: Transaction logging helps make transactions more efficient. Instead of updating
    the tables on disk each time a change occurs, the storage engine can change its
    in-memory copy of the data. This is very fast. The storage engine can then write
    a record of the change to the transaction log, which is on disk and therefore
    durable. This is also a relatively fast operation, because appending log events
    involves sequential I/O in one small area of the disk instead of random I/O in
    many places. Then, at some later time, a process can update the table on disk.
    Thus, most storage engines that use this technique (known as *write-ahead logging*)
    end up writing the changes to disk twice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 事务日志有助于使事务更高效。存储引擎可以在每次更改发生时更新磁盘上的表之前更改其内存中的数据副本。这是非常快的。然后，存储引擎可以将更改记录写入事务日志，该日志位于磁盘上，因此是持久的。这也是一个相对快速的操作，因为追加日志事件涉及磁盘上一个小区域的顺序I/O，而不是在许多地方进行随机I/O。然后，在以后的某个时间，一个进程可以更新磁盘上的表。因此，大多数使用这种技术（称为*预写式日志记录*）的存储引擎最终会将更改写入磁盘两次。
- en: If there’s a crash after the update is written to the transaction log but before
    the changes are made to the data itself, the storage engine can still recover
    the changes upon restart. The recovery method varies between storage engines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在更新写入事务日志后但在更改数据本身之前发生崩溃，则存储引擎仍然可以在重新启动时恢复更改。恢复方法因存储引擎而异。
- en: Transactions in MySQL
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL中的事务
- en: Storage engines are the software that drives how data will be stored and retrieved
    from disk. While MySQL has traditionally offered a number of storage engines that
    support transactions, InnoDB is now the gold standard and the recommended engine
    to use. Transaction primitives described here will be based on transactions in
    the InnoDB engine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 存储引擎是驱动数据如何存储和从磁盘检索的软件。虽然MySQL传统上提供了许多支持事务的存储引擎，但InnoDB现在是金标准和推荐使用的引擎。这里描述的事务基元将基于InnoDB引擎中的事务。
- en: Understanding AUTOCOMMIT
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解AUTOCOMMIT
- en: By default, a single `INSERT`, `UPDATE`, or `DELETE` statement is implicitly
    wrapped in a transaction and committed immediately. This is known as `AUTOCOMMIT`
    mode. By disabling this mode, you can execute a series of statements within a
    transaction and, at conclusion, `COMMIT` or `ROLLBACK`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，单个`INSERT`、`UPDATE`或`DELETE`语句会隐式包装在一个事务中并立即提交。这被称为`AUTOCOMMIT`模式。通过禁用此模式，您可以在事务中执行一系列语句，并在结束时`COMMIT`或`ROLLBACK`。
- en: You can enable or disable the `AUTOCOMMIT` variable for the current connection
    by using a `SET` command. The values `1` and `ON` are equivalent, as are `0` and
    `OFF`. When you run with `AUTOCOMMIT=0`, you are always in a transaction until
    you issue a `COMMIT` or `ROLLBACK`. MySQL then starts a new transaction immediately.
    Additionally, with `AUTOCOMMIT` enabled, you can begin a multistatement transaction
    by using the keyword `BEGIN` or `START TRANSACTION`. Changing the value of `AUTOCOMMIT`
    has no effect on nontransactional tables, which have no notion of committing or
    rolling back changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`SET`命令为当前连接启用或禁用`AUTOCOMMIT`变量。值`1`和`ON`是等效的，`0`和`OFF`也是如此。当你运行时`AUTOCOMMIT=0`，你总是处于一个事务中，直到你发出`COMMIT`或`ROLLBACK`。然后MySQL立即开始一个新的事务。此外，启用`AUTOCOMMIT`后，你可以使用关键字`BEGIN`或`START
    TRANSACTION`开始一个多语句事务。改变`AUTOCOMMIT`的值对非事务表没有影响，这些表没有提交或回滚更改的概念。
- en: Certain commands, when issued during an open transaction, cause MySQL to commit
    the transaction before they execute. These are typically DDL commands that make
    significant changes, such as `ALTER TABLE`, but `LOCK TABLES` and some other statements
    also have this effect. Check your version’s documentation for the full list of
    commands that automatically commit a transaction.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开事务期间发出某些命令会导致MySQL在执行之前提交事务。这些通常是进行重大更改的DDL命令，如`ALTER TABLE`，但`LOCK TABLES`和其他一些语句也有这种效果。查看你版本的文档以获取自动提交事务的完整命令列表。
- en: 'MySQLlets you set the isolation level using the `SET TRANSACTION ISOLATION
    LEVEL` command, which takes effect when the next transaction starts. You can set
    the isolation level for the whole server in the configuration file or just for
    your session:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL允许你使用`SET TRANSACTION ISOLATION LEVEL`命令设置隔离级别，该命令在下一个事务开始时生效。你可以在配置文件中为整个服务器设置隔离级别，也可以仅为你的会话设置：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is preferable to set the isolation you use most at the server level and only
    change it in explicit cases. MySQL recognizes all four ANSI standard isolation
    levels, and InnoDB supports all of them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在服务器级别设置你最常用的隔离级别，并仅在明确的情况下更改它。MySQL识别所有四个ANSI标准隔离级别，而InnoDB支持它们全部。
- en: Mixing storage engines in transactions
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在事务中混合存储引擎
- en: MySQL doesn’t manage transactions at the server level. Instead, the underlying
    storage engines implement transactions themselves. This means you can’t reliably
    mix different engines in a single transaction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL不会在服务器级别管理事务。相反，底层存储引擎自己实现事务。这意味着你不能可靠地在单个事务中混合不同的引擎。
- en: If you mix transactional and nontransactional tables (for instance, InnoDB and
    MyISAM tables) in a transaction, the transaction will work properly if all goes
    well. However, if a rollback is required, the changes to the nontransactional
    table can’t be undone. This leaves the database in an inconsistent state from
    which it might be difficult to recover and renders the entire point of transactions
    moot. This is why it is really important to pick the right storage engine for
    each table and to avoid mixing storage engines in your application logic at all
    costs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个事务中混合使用事务表和非事务表（例如，InnoDB和MyISAM表），如果一切顺利，事务将正常工作。然而，如果需要回滚，对非事务表的更改无法撤消。这将使数据库处于一个不一致的状态，可能很难恢复，并使事务的整个目的变得无意义。这就是为什么非常重要为每个表选择正确的存储引擎，并尽量避免在应用逻辑中混合存储引擎。
- en: MySQL will usually not warn you or raise errors if you do transactional operations
    on a nontransactional table. Sometimes rolling back a transaction will generate
    the warning, “Some nontransactional changed tables couldn’t be rolled back,” but
    most of the time, you’ll have no indication you’re working with nontransactional
    tables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在非事务表上执行事务操作，MySQL通常不会警告你或引发错误。有时回滚事务会生成警告：“一些非事务更改的表无法回滚”，但大多数情况下，你不会得到任何指示你正在使用非事务表。
- en: Warning
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It is best practice to not mix storage engines in your application. Failed transactions
    can lead to inconsistent results as some parts can roll back and others cannot.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是不要在应用程序中混合存储引擎。失败的事务可能导致不一致的结果，因为某些部分可以回滚，而其他部分则无法回滚。
- en: Implicit and explicit locking
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式和显式锁定
- en: InnoDB uses a two-phase locking protocol. It can acquire locks at any time during
    a transaction, but it does not release them until a `COMMIT` or `ROLLBACK`. It
    releases all the locks at the same time. The locking mechanisms described earlier
    are all implicit. InnoDB handles locks automatically, according to your isolation
    level.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB使用两阶段锁定协议。它可以在事务期间的任何时候获取锁，但直到`COMMIT`或`ROLLBACK`才会释放锁。它同时释放所有锁。前面描述的锁定机制都是隐式的。InnoDB根据你的隔离级别自动处理锁。
- en: However, InnoDB also supports explicit locking, which the SQL standard does
    not mention at all:^([8](ch01.html#ch01fn9))^, ^([9](ch01.html#ch01fn10))
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，InnoDB也支持显式锁定，SQL标准根本没有提到：^([8](ch01.html#ch01fn9))^，^([9](ch01.html#ch01fn10))
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: MySQL also supports the `LOCK TABLES` and `UNLOCK TABLES` commands, which are
    implemented in the server, not in the storage engines. If you need transactions,
    use a transactional storage engine. `LOCK TABLES` is unnecessary because InnoDB
    supports row-level locking.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL还支持`LOCK TABLES`和`UNLOCK TABLES`命令，这些命令在服务器中实现，而不是在存储引擎中。如果你需要事务，请使用事务性存储引擎。`LOCK
    TABLES`是不必要的，因为InnoDB支持行级锁定。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The interaction between `LOCK TABLES` and transactions is complex, and there
    are unexpected behaviors in some server versions. Therefore, we recommend that
    you never use `LOCK TABLES` unless you are in a transaction and `AUTOCOMMIT` is
    disabled, no matter what storage engine you are using.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOCK TABLES`和事务之间的交互是复杂的，在某些服务器版本中存在意外行为。因此，我们建议无论使用哪种存储引擎，都不要在事务中使用`LOCK
    TABLES`。'
- en: Multiversion Concurrency Control
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多版本并发控制
- en: 'Most of MySQL’s transactional storage engines don’t use a simple row-locking
    mechanism. Instead, they use row-level locking in conjunction with a technique
    for increasing concurrency known as *multiversion concurrency control (MVCC)*.
    MVCC is not unique to MySQL: Oracle, PostgreSQL, and some other database systems
    use it too, although there are significant differences because there is no standard
    for how MVCC should work.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的大多数事务性存储引擎不使用简单的行级锁定机制。相反，它们与一种称为*多版本并发控制（MVCC）*的增加并发性技术结合使用行级锁定。MVCC并不是MySQL独有的：Oracle、PostgreSQL和一些其他数据库系统也使用它，尽管存在重大差异，因为MVCC应如何工作没有标准。
- en: You can think of MVCC as a twist on row-level locking; it avoids the need for
    locking at all in many cases and can have much lower overhead. Depending on how
    it is implemented, it can allow nonlocking reads while locking only the necessary
    rows during write operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将MVCC视为对行级锁定的一种变通方法；在许多情况下，它避免了锁定的需要，并且开销要低得多。根据实现方式，它可以允许非锁定读取，同时仅在写入操作期间锁定必要的行。
- en: MVCC works by using snapshots of the data as it existed at some point in time.
    This means transactions can see a consistent view of the data, no matter how long
    they run. It also means different transactions can see different data in the same
    tables at the same time! If you’ve never experienced this before, it might be
    confusing, but it will become easier to understand with familiarity.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: MVCC通过使用数据在某个时间点存在的快照来工作。这意味着事务可以看到数据的一致视图，无论它们运行多长时间。这也意味着不同的事务可以同时在相同的表中看到不同的数据！如果您以前从未经历过这种情况，可能会感到困惑，但随着熟悉度的增加，您会更容易理解。
- en: Each storage engine implements MVCC differently. Some of the variations include
    optimistic and pessimistic concurrency control. We illustrate one way MVCC works
    by explaining InnoDB’s behavior^([10](ch01.html#ch01fn11)) in the form of a sequence
    diagram in [Figure 1-2](#a_sequence_diagram_of_handling_multiple).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个存储引擎都以不同方式实现MVCC。一些变体包括乐观和悲观并发控制。我们通过解释InnoDB的行为来说明MVCC的一种工作方式，形式为[图1-2](#a_sequence_diagram_of_handling_multiple)中的序列图。
- en: InnoDB implements MVCC by assigning a transaction ID for each transaction that
    starts. That ID is assigned the first time the transaction reads any data. When
    a record is modified within that transaction, an undo record that explains how
    to revert that change is written to the undo log, and the rollback pointer of
    the transaction is pointed at that undo log record. This is how the transaction
    can find the way to roll back if needed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB通过为每个启动的事务分配事务ID来实现MVCC。该ID是在事务第一次读取任何数据时分配的。当在该事务内修改记录时，将向撤销日志写入解释如何撤消该更改的撤销记录，并且事务的回滚指针指向该撤销日志记录。这就是事务可以找到回滚的方法的方式。
- en: '![](assets/hpm4_0102.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hpm4_0102.png)'
- en: Figure 1-2\. A sequence diagram of handling multiple versions of a row across
    different transactions
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2。处理不同事务中一行的多个版本的序列图
- en: When a different session reads a cluster key index record, InnoDB compares the
    record’s transaction ID versus the read view of that session. If the record in
    its current state should not be visible (the transaction that altered it has not
    yet committed), the undo log record is followed and applied until the session
    reaches a transaction ID that is eligible to be visible. This process can loop
    all the way to an undo record that deletes this row entirely, signaling to the
    read view that this row does not exist.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同会话读取群集键索引记录时，InnoDB会比较记录的事务ID与该会话的读取视图。如果记录在当前状态下不应可见（更改它的事务尚未提交），则会跟随并应用撤销日志记录，直到会话达到可以可见的事务ID。这个过程可以一直循环到一个完全删除此行的撤销记录，向读取视图发出此行不存在的信号。
- en: Records in a transaction are deleted by setting a “deleted” bit in the “info
    flags” of the record. This is also tracked in the undo log as a “remove delete
    mark.”
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在记录的“信息标志”中设置“删除”位来删除事务中的记录。这也在撤销日志中跟踪为“删除标记”。
- en: It is also worth noting that all undo log writes are also redo logged because
    the undo log writes are part of the server crash recovery process and are transactional.^([11](ch01.html#ch01fn12))
    The size of these redo and undo logs also plays a large part in how transactions
    at high concurrency perform. We cover their configuration in more detail in [Chapter 5](ch05.html#optimizing_server_settings).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有撤销日志写入也都会被重做记录，因为撤销日志写入是服务器崩溃恢复过程的一部分，并且是事务性的。[^11] 这些重做和撤销日志的大小也在高并发事务执行中扮演着重要角色。我们将在[第5章](ch05.html#optimizing_server_settings)中更详细地介绍它们的配置。
- en: The result of all this extra record keeping is that most read queries never
    acquire locks. They simply read data as fast as they can, making sure to select
    only rows that meet the criteria. The drawbacks are that the storage engine has
    to store more data with each row, do more work when examining rows, and handle
    some additional housekeeping operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些额外的记录保留的结果是，大多数读取查询从不获取锁。它们只是尽可能快地读取数据，确保只选择符合条件的行。缺点是存储引擎必须在每行存储更多数据，在检查行时做更多工作，并处理一些额外的管理操作。
- en: MVCC works only with the `REPEATABLE READ` and `READ COMMITTED` isolation levels.
    `READ UNCOMMITTED` isn’t MVCC compatible^([12](ch01.html#ch01fn13)) because queries
    don’t read the row version that’s appropriate for their transaction version; they
    read the newest version, no matter what. `SERIALIZABLE` isn’t MVCC compatible
    because reads lock every row they return.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: MVCC仅适用于`REPEATABLE READ`和`READ COMMITTED`隔离级别。`READ UNCOMMITTED`不兼容MVCC，因为查询不会读取适合其事务版本的行版本；无论如何，它们都会读取最新版本。`SERIALIZABLE`不兼容MVCC，因为读取会锁定它们返回的每一行。
- en: Replication
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: MySQL is designed for accepting writes on one node at any given time. This has
    advantages in managing consistency but leads to trade-offs when you need the data
    written in multiple servers or multiple locations. MySQL offers a native way to
    distribute writes that one node takes to additional nodes. This is referred to
    as *replication*. In MySQL, the source node has a thread per replica that is logged
    in as a replication client that wakes up when a write occurs, sending new data.
    In [Figure 1-3](#a_simplified_view_of_a_mysql_server_rep), we show a simple example
    of this setup, which is usually called a *topology tree* of multiple MySQL servers
    in a source and replica setup.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 设计用于在任何给定时间接受一个节点上的写入。这在管理一致性方面具有优势，但在需要将数据写入多个服务器或多个位置时会产生折衷。MySQL 提供了一种本地方法来将一个节点接受的写入分发到其他节点。这被称为*复制*。在
    MySQL 中，源节点每个副本都有一个线程作为复制客户端登录，当发生写入时会唤醒，发送新数据。在[图 1-3](#a_simplified_view_of_a_mysql_server_rep)中，我们展示了这种设置的简单示例，通常称为源和副本设置中的多个
    MySQL 服务器的*拓扑树*。
- en: '![](assets/hpm4_0103.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hpm4_0103.png)'
- en: Figure 1-3\. A simplified view of a MySQL server replication topology
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. MySQL 服务器复制拓扑的简化视图
- en: For any data you run in production, you should use replication and have at least
    three more replicas, ideally distributed in different locations (in cloud-hosted
    environments, known as *regions*) for disaster-recovery planning.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在生产环境中运行的任何数据，您应该使用复制，并至少有三个以上的副本，最好分布在不同位置（在云托管环境中称为*区域*）以进行灾难恢复规划。
- en: Over the years, replication in MySQL gained more sophistication. Global transaction
    identifiers, multisource replication, parallel replication on replicas, and semisync
    replication are some of the major updates. We cover replication in great detail
    in [Chapter 9](ch09.html#replication-id000008).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，MySQL 中的复制变得更加复杂。全局事务标识符、多源复制、副本上的并行复制和半同步复制是一些主要更新。我们在[第 9 章](ch09.html#replication-id000008)中详细介绍了复制。
- en: Datafiles Structure
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据文件结构
- en: In version 8.0, MySQL redesigned table metadata into a data dictionary that
    is included with a table’s *.ibd* file. This makes information on the table structure
    support transactions and atomic data definition changes. Instead of relying only
    on `information_schema` for retrieving table definition and metadata during operations,
    we are introduced to the dictionary object cache, which is a least recently used
    (LRU)-based in-memory cache of partition definitions, table definitions, stored
    program definitions, charset, and collation information. This major change in
    how the server accesses metadata about tables reduces I/O and is efficient, especially
    if a subset of tables is what sees the most activity and therefore is in the cache
    most often. The *.ibd* and *.frm* files are replaced with serialized dictionary
    information (*.sdi*) per table.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.0 版本中，MySQL 将表元数据重新设计为包含在表的*.ibd*文件中的数据字典。这使得关于表结构的信息支持事务和原子数据定义更改。在操作期间检索表定义和元数据不再仅依赖于`information_schema`，我们引入了字典对象缓存，这是一个基于最近最少使用（LRU）的内存缓存，其中包含分区定义、表定义、存储程序定义、字符集和校对信息。服务器访问表的元数据的这一重大变化减少了
    I/O，尤其是如果一部分表是最活跃的并且因此最常见于缓存中的话，这是有效的。*.ibd* 和 *.frm* 文件被替换为每个表的序列化字典信息（*.sdi*）。
- en: The InnoDB Engine
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InnoDB 引擎
- en: InnoDB is the default transactional storage engine for MySQL and the most important
    and broadly useful engine overall. It was designed for processing many short-lived
    transactions that usually complete rather than being rolled back. Its performance
    and automatic crash recovery make it popular for nontransactional storage needs
    too. If you want to study storage engines, it is well worth your time to study
    InnoDB in depth to learn as much as you can about it, rather than studying all
    storage engines equally.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 是 MySQL 的默认事务存储引擎，也是最重要和最广泛使用的引擎。它设计用于处理许多短暂事务，这些事务通常会完成而不是回滚。其性能和自动崩溃恢复使其在非事务性存储需求中也很受欢迎。如果您想研究存储引擎，深入学习
    InnoDB 是值得的，以尽可能多地了解它，而不是平等地研究所有存储引擎。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is best practice to use the InnoDB storage engine as the default engine for
    any application. MySQL made that easy by making InnoDB the default engine a few
    major versions ago.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将 InnoDB 存储引擎作为任何应用程序的默认引擎。MySQL 通过几个主要版本之前将 InnoDB 设为默认引擎，使这一点变得容易。
- en: InnoDB is the default MySQL general-purpose storage engine. By default, InnoDB
    stores its data in a series of datafiles that are collectively known as a *tablespace*.
    A tablespace is essentially a black box that InnoDB manages all by itself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 是默认的 MySQL 通用存储引擎。默认情况下，InnoDB 将其数据存储在一系列数据文件中，这些文件统称为*表空间*。表空间本质上是 InnoDB
    自行管理的一个黑盒。
- en: 'InnoDB uses MVCC to achieve high concurrency, and it implements all four SQL
    standard isolation levels. It defaults to the `REPEATABLE READ` isolation level,
    and it has a next-key locking strategy that prevents phantom reads in this isolation
    level: rather than locking only the rows you’ve touched in a query, InnoDB locks
    gaps in the index structure as well, preventing phantoms from being inserted.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 使用 MVCC 实现高并发，并实现了所有四个 SQL 标准隔离级别。它默认使用`REPEATABLE READ`隔离级别，并具有防止在此隔离级别中出现幻读的
    next-key 锁定策略：InnoDB 不仅锁定您在查询中触及的行，还锁定索引结��中的间隙，防止插入幻影。
- en: InnoDB tables are built on a clustered index, which we will cover in detail
    in [Chapter 8](ch08.html#query_performance_optimization) when we discuss schema
    design. InnoDB’s index structures are very different from those of most other
    MySQL storage engines. As a result, it provides very fast primary key lookups.
    However, secondary indexes (indexes that aren’t the primary key) contain the primary
    key columns, so if your primary key is large, other indexes will also be large.
    You should strive for a small primary key if you’ll have many indexes on a table.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB表是建立在聚簇索引上的，我们将在[第8章](ch08.html#query_performance_optimization)中详细讨论架构设计时进行介绍。InnoDB的索引结构与大多数其他MySQL存储引擎非常不同。因此，它提供非常快速的主键查找。但是，次要索引（非主键的索引）包含主键列，因此如果您的主键很大，其他索引也会很大。如果您将在表上有许多索引，应该努力使主键尽可能小。
- en: InnoDB has a variety of internal optimizations. These include predictive read-ahead
    for prefetching data from disk, an adaptive hash index that automatically builds
    hash indexes in memory for very fast lookups, and an insert buffer to speed inserts.
    We cover these in [Chapter 4](ch04.html#operating_system_and_hardware_optimizat)
    of this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB具有各种内部优化。这些包括从磁盘���取数据的预测性读取，自适应哈希索引自动在内存中构建哈希索引以进行非常快速的查找，以及插入缓冲区以加快插入速度。我们将在本书的[第4章](ch04.html#operating_system_and_hardware_optimizat)中介绍这些内容。
- en: InnoDB’s behavior is very intricate, and we highly recommend reading the [“InnoDB
    Locking and Transaction Model”](https://oreil.ly/AfuTi) section of the MySQL manual
    if you’re using InnoDB. Because of its MVCC architecture, there are many subtleties
    you should be aware of before building an application with InnoDB. Working with
    a storage engine that maintains consistent views of the data for all users, even
    when some users are changing data, can be complex.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB的行为非常复杂，如果你正在使用InnoDB，我们强烈建议阅读MySQL手册中的[“InnoDB锁定和事务模型”](https://oreil.ly/AfuTi)部分。由于其MVCC架构，建议在使用InnoDB构建应用程序之前，您应该了解许多微妙之处。
- en: As a transactional storage engine, InnoDB supports truly “hot” online backups
    through a variety of mechanisms, including Oracle’s proprietary MySQL Enterprise
    Backup and the open source Percona XtraBackup. We’ll dive into backup and restore
    in detail in [Chapter 10](ch10.html#backup_and_recovery).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事务性存储引擎，InnoDB通过各种机制支持真正的“热”在线备份，包括Oracle的专有MySQL企业备份和开源Percona XtraBackup。我们将在[第10章](ch10.html#backup_and_recovery)中详细讨论备份和恢复。
- en: Beginning with MySQL 5.6, InnoDB introduced online DDL, which at first had limited
    use cases that expanded in the 5.7 and 8.0 releases. In-place schema changes allow
    for specific table changes without a full table lock and without using external
    tools, which greatly improve the operationality of MySQL InnoDB tables. We will
    be covering options for online schema changes, both native and external tools,
    in [Chapter 6](ch06.html#schema_design_and_management).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从MySQL 5.6开始，InnoDB引入了在线DDL，在最初的版本中有限的用例在5.7和8.0版本中得到扩展。原地模式更改允许进行特定表更改而无需完全锁定表，也无需使用外部工具，这极大地提高了MySQL
    InnoDB表的操作性。我们将在[第6章](ch06.html#schema_design_and_management)中涵盖在线模式更改的选项，包括本机和外部工具。
- en: JSON Document Support
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON文档支持
- en: First introduced to InnoDB as part of the 5.7 release, the JSON type arrived
    with automatic validation of JSON documents as well as optimized storage that
    allows for quick read access, a significant improvement to the trade-offs of old-style
    binary large object (BLOB) storage engineers used to resort to for JSON documents.
    Along with the new data type support, InnoDB also introduced SQL functions to
    support rich operations on JSON documents. A further improvement in MySQL 8.0.7
    adds the ability to define multivalued indexes on JSON arrays. This feature can
    be a powerful way to even further speed up read-access queries to JSON types by
    matching the common access patterns to functions that can map the JSON document
    values. We go over the use and performance implications of the JSON data type
    in [“JSON Data”](ch06.html#json_data) in [Chapter 6](ch06.html#schema_design_and_management).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JSON类型是作为5.7版本的一部分首次引入InnoDB的，它具有JSON文档的自动验证以及优化的存储，可以快速读取访问，这对于旧式二进制大对象（BLOB）存储工程师过去常常使用的权衡来说是一个重大改进。除了新的数据类型支持外，InnoDB还引入了支持JSON文档的SQL函数。MySQL
    8.0.7中的进一步改进增加了在JSON数组上定义多值索引的能力。这个功能可以通过将常见访问模式与能够映射JSON文档值的函数匹配，进一步加快对JSON类型的读取访问查询。我们将在[第6章](ch06.html#schema_design_and_management)中的[“JSON数据”](ch06.html#json_data)中讨论JSON数据类型的使用和性能影响。
- en: Data Dictionary Changes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据字典更改
- en: Another major change in MySQL 8.0 is removing file-based table metadata storage
    and moving to a data dictionary using InnoDB table storage. This change brings
    all of InnoDB’s crash-recovery transactional benefits to operations like changes
    to tables. This change, while much improving the management of data definitions
    in MySQL, does also require major changes in operating a MySQL server. Most notably,
    back-up processes that used to rely on the table metadata files now have to query
    the new data dictionary to extract table definitions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8.0的另一个重大变化是删除基于文件的表元数据存储，并转而使用InnoDB表存储的数据字典。这一变化将InnoDB的所有崩溃恢复事务性优势带到了表更改等操作中。这一变化虽然极大地改进了MySQL中数据定义的管理，但也需要对MySQL服务器的操作进行重大更改。特别值得注意的是，以前依赖表元数据文件的备份过程现在必须查询新数据字典以提取表定义。
- en: Atomic DDL
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子DDL
- en: Finally, MySQL 8.0 introduced atomic data definition changes. This means that
    data definition statements now can either wholly finish successfully or be wholly
    rolled back. This becomes possible through creating a DDL-specific undo and redo
    log that InnoDB relies on to track the change—another place where InnoDB’s proven
    design has been expanded to the operations of MySQL server.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，MySQL 8.0 引入了原子数据定义更改。这意味着数据定义语句现在要么完全成功完成，要么完全回滚。这通过创建一个专门用于 DDL 的撤销和重做日志成为可能，InnoDB
    依赖于此来跟踪变化——这是 InnoDB 成熟设计被扩展到 MySQL 服务器操作的另一个地方。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: MySQL has a layered architecture, with server-wide services and query execution
    on top and storage engines underneath. Although there are many different plug-in
    APIs, the storage engine API is the most important. If you understand that MySQL
    executes queries by handing rows back and forth across the storage engine API,
    you’ve grasped the fundamentals of the server’s architecture.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 有分层架构，顶部是服务器范围的服务和查询执行，底部是存储引擎。尽管有许多不同的插件 API，但存储引擎 API 是最重要的。如果您理解 MySQL
    通过在存储引擎 API 上来回传递行来执行查询，那么您已经掌握了服务器架构的基本原理。
- en: In the past few major releases, MySQL has settled on InnoDB as its primary development
    focus and has even moved its internal bookkeeping around table metadata, authentication,
    and authorization after years in MyISAM. This increased investment from Oracle
    in the InnoDB engine has led to major improvements such as atomic DDLs, more robust
    online DDLs, better resilience to crashes, and better operability for security-minded
    deployments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几个主要版本中，MySQL 已将 InnoDB 定为其主要开发重点，并在多年后将其内部账务处理、身份验证和授权移至 MyISAM。Oracle 对
    InnoDB 引擎的增加投资导致了诸如原子 DDL、更强大的在线 DDL、更好的抗崩溃能力以及更适合安全部署的操作性等重大改进。
- en: InnoDB is the default storage engine and the one that should cover nearly every
    use case. As such, the following chapters focus heavily on the InnoDB storage
    engine when talking about features, performance, and limitations, and only rarely
    will we touch on any other storage engine from here on out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 是默认存储引擎，几乎可以覆盖所有用例。因此，在谈论功能、性能和限制时，以下章节将重点关注 InnoDB 存储引擎，很少会涉及其他存储引擎。
- en: ^([1](ch01.html#ch01fn2-marker)) One exception is InnoDB, which does parse foreign
    key definitions because the MySQL server doesn’t yet implement them itself.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#ch01fn2-marker)) 唯一的例外是 InnoDB，因为 MySQL 服务器尚未实现外键定义，所以 InnoDB
    解析外键定义。
- en: ^([2](ch01.html#ch01fn3-marker)) MySQL 5.5 and newer versions support an API
    that can accept thread-pooling plug-ins, though not commonly used. The common
    practice for thread pooling is done at access layers, which we discuss in [Chapter 5](ch05.html#optimizing_server_settings).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch01.html#ch01fn3-marker)) MySQL 5.5 及更新版本支持一个可以接受线程池插件的 API，尽管并不常用。线程池的常见做法是在访问层完成的，我们在[第5章](ch05.html#optimizing_server_settings)中讨论过。
- en: ^([3](ch01.html#ch01fn4-marker)) We definitely recommend you read [the documentation
    on exclusive versus shared locks, intention locking, and record locks](https://oreil.ly/EPfwc).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch01.html#ch01fn4-marker)) 我们强烈建议阅读[关于独占锁与共享锁、意向锁和记录锁的文档](https://oreil.ly/EPfwc)。
- en: ^([4](ch01.html#ch01fn5-marker)) There are metadata locks, which are used when
    dealing with table name changes or changing schemas, and in 8.0 we are introduced
    to “application level locking functions.” In the course of run-of-the-mill data
    changes, internal locking is left to the InnoDB engine.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch01.html#ch01fn5-marker)) 在处理表名更改或模式更改时会使用元数据锁，而在 8.0 中我们引入了“应用级锁定功能”。在日常数据更改过程中，内部锁定留给了
    InnoDB 引擎。
- en: ^([5](ch01.html#ch01fn6-marker)) Although this is a common academic exercise,
    most banks actually rely on daily reconciliation and not on strict transactional
    operations during the day.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch01.html#ch01fn6-marker)) 尽管这是一个常见的学术练习，但大多��银行实际上依赖每日对账，而不是在白天依赖严格的事务操作。
- en: ^([6](ch01.html#ch01fn7-marker)) For more information, read [a summary of ANSI
    SQL](https://oreil.ly/joikF) by Adrian Coyler and [an explanation of consistency
    models](http://jepsen.io/consistency) by Kyle Kingsbury.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch01.html#ch01fn7-marker)) 欲了解更多信息，请阅读 Adrian Coyler 撰写的[ ANSI SQL 摘要](https://oreil.ly/joikF)和
    Kyle Kingsbury 撰写的[一篇关于一致性模型的解释](http://jepsen.io/consistency)。
- en: ^([7](ch01.html#ch01fn8-marker)) As you will see later in this chapter, some
    storage engines lock entire tables, and others implement more complex row-based
    locking. All that logic lives for the most part in the storage engine layer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch01.html#ch01fn8-marker)) 正如您将在本章后面看到的，一些存储引擎锁定整个表，而其他一些实现更复杂的基于行的锁定。所有这些逻辑在很大程度上存在于存储引擎层。
- en: ^([8](ch01.html#ch01fn9-marker)) These locking hints are frequently abused and
    should usually be avoided.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch01.html#ch01fn9-marker)) 这些锁定提示经常被滥用，通常应该避免使用。
- en: ^([9](ch01.html#ch01fn10-marker)) `SELECT`…`FOR SHARE` is a MySQL 8.0 feature
    that replaces `SELECT`…`LOCK IN SHARE MODE` of previous versions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch01.html#ch01fn10-marker)) `SELECT`…`FOR SHARE` 是 MySQL 8.0 的一个新特性，取代了之前版本中的
    `SELECT`…`LOCK IN SHARE MODE`。
- en: ^([10](ch01.html#ch01fn11-marker)) We recommend reading [this blog post](https://oreil.ly/jbljq)
    by Jeremy Cole to get a deeper understanding of records structure in InnoDB.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch01.html#ch01fn11-marker)) 我们建议阅读 Jeremy Cole 的[这篇博文](https://oreil.ly/jbljq)，以更深入地了解
    InnoDB 中的记录结构。
- en: ^([11](ch01.html#ch01fn12-marker)) For a lot more detail on how InnoDB handles
    multiple versions of its records, see [this blog post](https://oreil.ly/exaaL)
    by Jeremy Cole.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch01.html#ch01fn12-marker)) 想要了解 InnoDB 如何处理其记录的多个版本，建议阅读 Jeremy Cole
    的[这篇博文](https://oreil.ly/exaaL)。
- en: ^([12](ch01.html#ch01fn13-marker)) There is no formal standard that defines
    MVCC, so different engines and databases implement it very differently, and no
    one can say any of them is wrong.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch01.html#ch01fn13-marker)) 没有正式的标准定义 MVCC，因此不同的引擎和数据库实现方式大不相同，没有人能说其中任何一种是错误的。
