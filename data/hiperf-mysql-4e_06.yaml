- en: Chapter 6\. Schema Design and Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 模式设计与管理
- en: Good logical and physical design is the cornerstone of high performance, and
    you must design your schema for the specific queries you will run. This often
    involves trade-offs. For example, a denormalized schema can speed up some types
    of queries but slow down others. Adding counter and summary tables is a great
    way to optimize queries, but they can be expensive to maintain. MySQL’s particular
    features and implementation details influence this quite a bit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的逻辑和物理设计是高性能的基石，您必须为您将运行的特定查询设计模式。这通常涉及权衡。例如，反规范化的模式可以加快某些类型的查询，但会减慢其他查询。添加计数器和汇总表是优化查询的好方法，但维护它们可能很昂贵。MySQL的特定功能和实现细节在很大程度上影响这一点。
- en: Likewise, your schema will evolve over time—as a result of what you learn about
    how you store and access data as well as how your business requirements change
    over time. This means that you should plan for schema changes as a frequent event.
    Later in this chapter, we help guide you through how to keep this activity from
    becoming an operational bottleneck for your organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您的模式将随着时间的推移而发展—这是由于您了解如何存储和访问数据以及您的业务需求随时间变化的结果。这意味着您应该计划模式更改作为频繁事件。在本章后面，我们将指导您如何避免这一活动成为组织的运营瓶颈。
- en: This chapter—and the following one, which focuses on indexing—cover the MySQL-specific
    bits of schema design. We assume that you know how to design databases, so this
    is not an introductory chapter, or even an advanced chapter, on database design.
    As a chapter on MySQL database design, it’s about what is different when designing
    databases with MySQL rather than other RDBMSs. If you need to study the basics
    of database design, we suggest Clare Churcher’s book *Beginning Database Design*
    (Apress).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节以及接下来专注于索引的章节，涵盖了MySQL特定的模式设计部分。我们假设您知道如何设计数据库，因此这不是一个介绍性的章节，甚至不是一个关于数据库设计的高级章节。作为一章关于MySQL数据库设计的章节，它关于在使用MySQL而不是其他关系数据库管理系统（RDBMS）设计数据库时有何不同。如果您需要学习数据库设计的基础知识，我们建议阅读Clare
    Churcher的书籍*Beginning Database Design*（Apress）。
- en: This chapter is preparation for the two that follow. In these three chapters,
    we will explore the interaction of logical design, physical design, and query
    execution. This requires a big-picture approach as well as attention to details.
    You need to understand the whole system to understand how each piece will affect
    others. You might find it useful to review this chapter after reading [Chapter 7](ch07.html#indexing_for_high_performance)
    on indexing and [Chapter 8](ch08.html#query_performance_optimization) on query
    optimization. Many of the topics discussed can’t be considered in isolation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是接下来两章的准备。在这三章中��我们将探讨逻辑设计、物理设计和查询执行的互动。这需要一个全局的方法以及对细节的关注。您需要了解整个系统，以了解每个部分如何影响其他部分。在阅读关于索引的[第7章](ch07.html#indexing_for_high_performance)和关于查询优化的[第8章](ch08.html#query_performance_optimization)之后，您可能会发现重新阅读本章很有用。许多讨论的主题不能孤立考虑。
- en: Choosing Optimal Data Types
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择最佳数据类型
- en: 'MySQL supports a large variety of data types, and choosing the correct type
    to store your data is crucial to getting good performance. The following simple
    guidelines can help you make better choices, no matter what type of data you are
    storing:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持各种各样的数据类型，选择正确的类型来存储您的数据对于获得良好的性能至关重要。以下简单的准则可以帮助您做出更好的选择，无论您存储的是什么类型的数据：
- en: Smaller is usually better
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，较小的通常更好
- en: In general, try to use the smallest data type that can correctly store and represent
    your data. Smaller data types are usually faster because they use less space on
    the disk, in memory, and in the CPU cache. They also generally require fewer CPU
    cycles to process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽量使用可以正确存储和表示您的数据的最小数据类型。较小的数据类型通常更快，因为它们在磁盘、内存和CPU缓存中占用的空间更少。它们通常也需要更少的CPU周期来处理。
- en: Make sure you don’t underestimate the range of values you need to store, though,
    because increasing the data type range in multiple places in your schema can be
    a painful and time-consuming operation. If you’re in doubt as to which is the
    best data type to use, choose the smallest one that you don’t think you’ll exceed.
    (If the system is not very busy or doesn’t store much data, or if you’re at an
    early phase in the design process, you can easily change it later.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请确保不要低估您需要存储的值的范围，因为在模式的多个位置增加数据类型范围可能是一个痛苦且耗时的操作。如果您对使用哪种数据类型最好感到犹豫，请选择您认为不会超出的最小数据类型。（如果系统不是非常繁忙或存储的数据不多，或者如果您处于设计过程的早期阶段，您可以稍后轻松更改。）
- en: Simple is good
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单就是好
- en: 'Fewer CPU cycles are typically required to process operations on simpler data
    types. For example, integers are cheaper to compare than characters because character
    sets and collations (sorting rules) make character comparisons complicated. Here
    are two examples: you should store dates and times in MySQL’s built-in types instead
    of as strings, and you should use integers for IP addresses. We discuss these
    topics further later.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 处理简单数据类型通常需要较少的CPU周期。例如，整数比字符更便宜，因为字符集和排序规则使字符比较复杂。以下是两个例子：您应该将日期和时间存储在MySQL的内置类型中，而不是作为字符串，您应该使用整数存储IP地址。我们稍后会进一步讨论这些主题。
- en: Avoid `NULL` if possible
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量避免`NULL`
- en: A lot of tables include nullable columns even when the application does not
    need to store `NULL` (the absence of a value), merely because it’s the default.
    It’s usually best to specify columns as `NOT NULL` unless you intend to store
    `NULL` in them. It’s harder for MySQL to optimize queries that refer to nullable
    columns because they make indexes, index statistics, and value comparisons more
    complicated. A nullable column uses more storage space and requires special processing
    inside MySQL. The performance improvement from changing `NULL` columns to `NOT
    NULL` is usually small, so don’t make it a priority to find and change them on
    an existing schema unless you know they are causing problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多表包括可空列，即使应用程序不需要存储`NULL`（值的缺失），仅仅因为这是默认值。通常最好将列指定为`NOT NULL`，除非您打算在其中存储`NULL`。对于引用可空列的查询，MySQL更难优化，因为它们使索引、索引统计信息和值比较变得更加复杂。可空列使用更多的存储空间，并且需要MySQL内部的特殊处理。将`NULL`列更改为`NOT
    NULL`的性能改进通常很小，因此除非知道它们会引起问题，否则不要将其视为现有模式中要查找和更改的优先事项。
- en: 'The first step in deciding what data type to use for a given column is to determine
    what general class of types is appropriate: numeric, string, temporal, and so
    on. This is usually pretty straightforward, but we mention some special cases
    where the choice is unintuitive.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 决定为给定列使用什么数据类型的第一步是确定适当的一般类型类别：数字、字符串、时间���。这通常很简单，但我们提到了一些选择不直观的特殊情况。
- en: The next step is to choose the specific type. Many of MySQL’s data types can
    store the same kind of data but vary in the range of values they can store, the
    precision they permit, or the physical space (on disk and in memory) they require.
    Some data types also have special behaviors or properties.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择具体类型。MySQL的许多数据类型可以存储相同类型的数据，但在它们可以存储的值范围、允许的精度或所需的物理空间（在磁盘和内存中）方面有所不同。一些数据类型还具有特殊的行为或属性。
- en: 'For example, a `DATETIME` and a `TIMESTAMP` column can store the same kind
    of data: date and time, to a precision of one second. However, `TIMESTAMP` uses
    only half as much storage space, is time zone aware, and has special auto-updating
    capabilities. On the other hand, it has a much smaller range of allowable values,
    and sometimes its special capabilities can be a handicap.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`DATETIME`和`TIMESTAMP`列可以存储相同类型的数据：日期和时间，精确到一秒。然而，`TIMESTAMP`仅使用一半的存储空间，具有时区感知能力，并具有特殊的自动更新功能。另一方面，它的可允许值范围要小得多，有时其特殊功能可能成为一种障碍。
- en: We discuss base data types here. MySQL supports many aliases for compatibility,
    such as `INTEGER` (maps to `INT`), `BOOL` (maps to `TINYINT`), and `NUMERIC` (maps
    to `DECIMAL`). These are only aliases. They can be confusing, but they don’t affect
    performance. If you create a table with an aliased data type and then examine
    `SHOW CREATE TABLE`, you’ll see that MySQL reports the base type, not the alias
    you used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里讨论基本数据类型。MySQL支持许多别名以实现兼容性，例如`INTEGER`（映射到`INT`）、`BOOL`（映射到`TINYINT`）和`NUMERIC`（映射到`DECIMAL`）。这些只是别名。它们可能会让人困惑，但不会影响性能。如果您使用别名数据类型创建表，然后检查`SHOW
    CREATE TABLE`，您会看到MySQL报告基本类型，而不是您使用的别名。
- en: Whole Numbers
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'There are two kinds of numbers: whole numbers and real numbers (numbers with
    a fractional part). If you’re storing whole numbers, use one of the integer types:
    `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, or `BIGINT`. These require 8, 16, 24,
    32, and 64 bits of storage space, respectively. They can store values from −2^(`(N
    – 1)`) to 2^(`(N – 1)`) `−` 1, where *N* is the number of bits of storage space
    they use.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种数字：整数和实数（带有小数部分的数字）。如果您要存储整数，请使用整数类型之一：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`或`BIGINT`。它们分别需要8、16、24、32和64位的存储空间。它们可以存储从−2^(`(N
    – 1)`)到2^(`(N – 1)`) `−` 1的值，其中*N*是它们使用的存储空间的位数。
- en: Integer types can optionally have the `UNSIGNED` attribute, which disallows
    negative values and approximately doubles the upper limit of positive values you
    can store. For example, a `TINYINT UNSIGNED` can store values ranging from 0 to
    255 instead of from −128 to 127.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型可以选择具有`UNSIGNED`属性，该属性不允许负值，并且可以将您可以存储的正值的上限大约加倍。例如，`TINYINT UNSIGNED`可以存储范围从0到255的值，而不是从−128到127。
- en: Signed and unsigned types use the same amount of storage space and have the
    same performance, so use whatever’s best for your data range.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号和无符号类型使用相同的存储空间并具有相同的性能，因此使用适合您数据范围的类型。
- en: Your choice determines how MySQL *stores* the data, in memory and on disk. However,
    integer computations generally use 64-bit `BIGINT` integers. (The exceptions are
    some aggregate functions, which use `DECIMAL` or `DOUBLE` to perform computations.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您的选择决定了MySQL如何*存储*数据，无论是在内存中还是在磁盘上。然而，整数计算通常使用64位的`BIGINT`整数。（有一些聚合函数的例外，它们使用`DECIMAL`或`DOUBLE`执行计算。）
- en: 'MySQL lets you specify a “width” for integer types, such as `INT(11)`. This
    is meaningless for most applications: it does not restrict the legal range of
    values but simply specifies the number of characters MySQL’s interactive tools
    (such as the command-line client) will reserve for display purposes. For storage
    and computational purposes, `INT(1)` is identical to `INT(20)`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL允许您为整数类型指定“宽度”，例如`INT(11)`。对于大多数应用程序来说，这是没有意义的：它不限制合法值的范围，而只是指定MySQL交互工具（如命令行客户端）为显示目的保留的字符数。对于存储和计算目的，`INT(1)`与`INT(20)`是相同的。
- en: Real Numbers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数
- en: Real numbers are numbers that have a fractional part. However, they aren’t just
    for fractional numbers; you can also use `DECIMAL` to store integers that are
    so large they don’t fit in `BIGINT`. MySQL supports both exact and inexact types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实数是具有小数部分的数字。但它们不仅仅适用于小数；您还可以使用`DECIMAL`存储太大以至于不适合`BIGINT`的整数。MySQL支持精确和不精确类型。
- en: The `FLOAT` and `DOUBLE` types support approximate calculations with standard
    floating-point math. If you need to know exactly how floating-point results are
    calculated, you will need to research your platform’s floating-point implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLOAT` 和 `DOUBLE` 类型支持使用标准浮点数运算进行近似计算。如果您需要准确了解浮点数结果是如何计算的，您需要研究您平台的浮点数实现。'
- en: You can specify a floating-point column’s desired precision in a couple of ways,
    which can cause MySQL to silently choose a different data type or to round values
    when you store them. These precision specifiers are nonstandard, so we suggest
    that you specify the type you want but not the precision.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过几种方式指定浮点列的所需精度，这可能会导致MySQL在存储值时选择不同的数据类型或在存储值时对其进行四舍五入。这些精度限定符是非标准的，因此我们建议您指定您想要的类型，但不指定精度。
- en: Floating-point types typically use less space than `DECIMAL` to store the same
    range of values. A `FLOAT` column uses 4 bytes of storage. `DOUBLE` consumes 8
    bytes and has greater precision and a larger range of values than `FLOAT`. As
    with integers, you’re choosing only the storage type; MySQL uses `DOUBLE` for
    its internal calculations on floating-point types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型通常使用比`DECIMAL`更少的空间来存储相同范围的值。`FLOAT`列使用4个字节的存储空间。`DOUBLE`使用8个字节，具有比`FLOAT`更高的精度和更大的值范围。与整数一样，您只是选择存储类型；MySQL在浮点类型的内部计算中使用`DOUBLE`。
- en: Because of the additional space requirements and computational cost, you should
    use `DECIMAL` only when you need exact results for fractional numbers—for example,
    when storing financial data. But in some high-volume cases, it actually makes
    sense to use a `BIGINT` instead and store the data as some multiple of the smallest
    fraction of currency you need to handle. Suppose you are required to store financial
    data to the ten-thousandth of a cent. You can multiply all dollar amounts by a
    million and store the result in a `BIGINT`, avoiding both the imprecision of floating-point
    storage and the cost of the precise `DECIMAL` math.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于额外的空间要求和计算成本，仅当您需要对分数进行精确计算时才应使用`DECIMAL`，例如，当存储财务数据时。但在某些高交易量情况下，实际上更合理的是使用`BIGINT`，并将数据存储为您需要处理的最小货币分数的某个倍数。假设您需要将财务数据存储到千分之一美分。您可以将所有美元金额乘以一百万，并将结果存储在`BIGINT`中，避免浮点存储的不精确性和精确`DECIMAL`数学的成本。
- en: String Types
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类型
- en: MySQL supports quite a few string data types, with many variations on each.
    Each string column can have its own character set and set of sorting rules for
    that character set, or collation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持多种字符串数据类型，每种类型都有许多变体。每个字符串列都可以有自己的字符集和该字符集的排序规则，或者排序规则。
- en: VARCHAR and CHAR types
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`VARCHAR` 和 `CHAR` 类型'
- en: The two major string types are `VARCHAR` and `CHAR`, which store character values.
    Unfortunately, it’s hard to explain exactly how these values are stored on disk
    and in memory because the implementations depend on the storage engine. We assume
    you are using InnoDB; if not, you should read the documentation for your storage
    engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两种主要的字符串类型是`VARCHAR`和`CHAR`，它们存储字符值。不幸的是，很难准确解释这些值在磁盘和内存中是如何存储的，因为实现取决于存储引擎。我们假设您正在使用InnoDB；如果不是，请阅读您存储引擎的文档。
- en: 'Let’s take a look at how `VARCHAR` and `CHAR` values are typically stored on
    disk. Be aware that a storage engine may store a `CHAR` or `VARCHAR` value differently
    in memory from how it stores that value on disk, and the server may translate
    the value into yet another storage format when it retrieves it from the storage
    engine. Here’s a general comparison of the two types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`VARCHAR`和`CHAR`值通常是如何存储在磁盘上的。请注意，存储引擎可能会以不同于内存中存储`CHAR`或`VARCHAR`值的方式来存储该值在磁盘上的方式，并且服务器在从存储引擎检索值时可能会将该值转换为另一种存储格式。以下是这两种类型的一般比较：
- en: '`VARCHAR`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARCHAR`'
- en: '`VARCHAR` stores variable-length character strings and is the most common string
    data type. It can require less storage space than fixed-length types because it
    uses only as much space as it needs (i.e., less space is used to store shorter
    values).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARCHAR` 存储可变长度的字符字符串，是最常见的字符串数据类型。它可能需要比固定长度类型更少的存储空间，因为它只使用所需的空间（即，存储较短值时使用的空间较少）。'
- en: '`VARCHAR` uses 1 or 2 extra bytes to record the value’s length: 1 byte if the
    column’s maximum length is 255 bytes or less, and 2 bytes if it’s more. Assuming
    the `latin1` character set, a `VARCHAR(10)` will use up to 11 bytes of storage
    space. A `VARCHAR(1000)` can use up to 1,002 bytes, because it needs 2 bytes to
    store length information.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARCHAR` 使用1或2个额外字节来记录值的长度：如果列的最大长度为255字节或更少，则使用1个字节，如果超过255字节，则使用2个字节。假设使用`latin1`字符集，`VARCHAR(10)`将使用最多11个字节的存储空间。`VARCHAR(1000)`最多可以使用1,002个字节，因为它需要2个字节来存储长度信息。'
- en: '`VARCHAR` helps performance because it saves space. However, because the rows
    are variable length, they can grow when you update them, which can cause extra
    work. If a row grows and no longer fits in its original location, the behavior
    is storage engine dependent. For example, InnoDB may need to split the page to
    fit the row into it. Other storage engines may never update data in place at all.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`VARCHAR` 有助于性能，因为它节省空间。但是，由于行是可变长度的，当您更新它们时，它们可能会增长，这可能会导致额外的工作。如果一行增长并且不再适合其原始位置，则行为取决于存储引擎。例如，InnoDB可能需要拆分页面以将行放入其中。其他存储引擎可能根本不会在原地更新数据。'
- en: It’s usually worth using `VARCHAR` when the maximum column length is much larger
    than the average length; when updates to the field are rare, so fragmentation
    is not a problem; and when you’re using a complex character set such as UTF-8,
    where each character uses a variable number of bytes of storage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当最大列长度远大于平均长度时，很少更新字段，因此碎片化不是问题时，以及使用复杂字符集（如UTF-8）时，通常值得使用`VARCHAR`。
- en: It’s trickier with InnoDB, which can store long `VARCHAR` values as BLOBs. We
    will discuss this later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于InnoDB来说情况就比较棘手了，它可以将长`VARCHAR`值存储为BLOB。我们稍后会讨论这个问题。
- en: '`CHAR`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR`'
- en: '`CHAR` is fixed-length: MySQL always allocates enough space for the specified
    number of characters. When storing a `CHAR` value, MySQL removes any trailing
    spaces. Values are padded with spaces as needed for comparisons.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR` 是固定长度的：MySQL 总是为指定数量的字符分配足够的空间。在存储 `CHAR` 值时，MySQL 会移除任何尾随空格。根据需要填充值以进行比较。'
- en: '`CHAR` is useful if you want to store very short strings or if all the values
    are nearly the same length. For example, `CHAR` is a good choice for `MD5` values
    for user passwords, which are always the same length. `CHAR` is also better than
    `VARCHAR` for data that’s changed frequently because a fixed-length row is not
    prone to fragmentation. For very short columns, `CHAR` is also more efficient
    than `VARCHAR`; a `CHAR(1)` designed to hold only `Y` and `N` values will use
    only 1 byte in a single-byte character set,^([1](ch06.html#ch01fn24)) but a `VARCHAR(1)`
    would use 2 bytes because of the length byte.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望存储非常短的字符串或所有值几乎相同长度，则 `CHAR` 是一个不错的选择。例如，对于用户密码的 `MD5` 值，它们始终是相同长度，`CHAR`
    是一个不错的选择。对于经常更改的数据，`CHAR` 也比 `VARCHAR` 更好，因为固定长度的行不容易出现碎片化。对于非常短的列，`CHAR` 也比 `VARCHAR`
    更有效率；一个设计为仅容纳 `Y` 和 `N` 值的 `CHAR(1)` 在单字节字符集中只会使用 1 个字节，但 `VARCHAR(1)` 会使用 2 个字节，因为长度字节。
- en: 'This behavior can be a little confusing, so we’ll illustrate with an example.
    First, we create a table with a single `CHAR(10)` column and store some values
    in it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可能有点令人困惑，因此我们将通过一个示例来说明。首先，我们创建一个具有单个 `CHAR(10)` 列的表，并将一些值存储在其中：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we retrieve the values, the trailing spaces have been stripped away:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索这些值时，尾随空格已被去除：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we store the same values in a `VARCHAR(10)` column, we get the following
    result upon retrieval, where the trailing space on `string3` has not been removed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将相同的值存储在 `VARCHAR(10)` 列中，我们在检索时会得到以下结果，其中 `string3` 上的尾随空格未被移除：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The sibling types for `CHAR` and `VARCHAR` are `BINARY` and `VARBINARY`, which
    store binary strings. Binary strings are very similar to conventional strings,
    but they store bytes instead of characters. Padding is also different: MySQL pads
    `BINARY` values with `\0` (the zero byte) instead of spaces and doesn’t strip
    the pad value on retrieval.^([2](ch06.html#ch01fn25))'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR` 和 `VARCHAR` 的兄弟类型是 `BINARY` 和 `VARBINARY`，它们存储二进制字符串。二进制字符串与传统字符串非常相似，但它们存储的是字节而不是字符。填充也不同：MySQL
    使用 `\0`（零字节）而不是空格填充 `BINARY` 值，并且在检索时不会去除填充值。'
- en: These types are useful when you need to store binary data and want MySQL to
    compare the values as bytes instead of characters. The advantage of byte-wise
    comparisons is more than just a matter of case insensitivity. MySQL literally
    compares `BINARY` strings one byte at a time, according to the numeric value of
    each byte. As a result, binary comparisons can be much simpler than character
    comparisons, so they are faster.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要存储二进制数据并希望 MySQL 将值作为字节而不是字符进行比较时，这些类型非常有用。按字节进行比较的优势不仅仅是大小写不敏感的问题。MySQL
    实际上是逐个字节比较 `BINARY` 字符串，根据每个字节的数值进行比较。因此，二进制比较比字符比较要简单得多，因此更快。
- en: BLOB and TEXT types
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BLOB 和 TEXT 类型
- en: '`BLOB` and `TEXT` are string data types designed to store large amounts of
    data as either binary or character strings, respectively.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOB` 和 `TEXT` 是设计用于分别存储大量数据的字符串数据类型，作为二进制或字符字符串。'
- en: 'In fact, they are each families of data types: the character types are `TINYTEXT`,
    `SMALLTEXT`, `TEXT`, `MEDIUMTEXT`, and `LONGTEXT`, and the binary types are `TINYBLOB`,
    `SMALLBLOB`, `BLOB`, `MEDIUMBLOB`, and `LONGBLOB`. `BLOB` is a synonym for `SMALLBLOB`,
    and `TEXT` is a synonym for `SMALLTEXT`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它们各自是数据类型系列：字符类型有 `TINYTEXT`、`SMALLTEXT`、`TEXT`、`MEDIUMTEXT` 和 `LONGTEXT`，而二进制类���有
    `TINYBLOB`、`SMALLBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB`。`BLOB` 是 `SMALLBLOB` 的同义词，`TEXT`
    是 `SMALLTEXT` 的同义词。
- en: Unlike all other data types, MySQL handles each `BLOB` and `TEXT` value as an
    object with its own identity. Storage engines often store them specially; InnoDB
    may use a separate “external” storage area for them when they’re large. Each value
    requires from 1 to 4 bytes of storage space in the row and enough space in external
    storage to actually hold the value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他数据类型不同，MySQL 将每个 `BLOB` 和 `TEXT` 值视为具有自己身份的对象。存储引擎通常会对它们进行特殊存储；当它们很大时，InnoDB
    可能会为它们使用单独的“外部”存储区域。每个值在行中需要占用 1 到 4 个字节的存储空间，并且在外部存储中需要足够的空间来实际保存该值。
- en: The only difference between the `BLOB` and `TEXT` families is that `BLOB` types
    store binary data with no collation or character set, but `TEXT` types have a
    character set and collation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`BLOB` 和 `TEXT` 族之间唯一的区别是，`BLOB` 类型存储没有排序规则或字符集的二进制数据，而 `TEXT` 类型具有字符集和排序规则。'
- en: 'MySQL sorts `BLOB` and `TEXT` columns differently from other types: instead
    of sorting the full length of the string, it sorts only the first `max_sort_length`
    bytes of such columns. If you need to sort by only the first few characters, you
    can decrease the `max_sort_length` server variable.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 对 `BLOB` 和 `TEXT` 列的排序与其他类型不同：它只对这些列的前 `max_sort_length` 字节进行排序，而不是对整个字符串进行排序。如果需要按照前几个字符进行排序，可以减少
    `max_sort_length` 服务器变量。
- en: MySQL can’t index the full length of these data types and can’t use the indexes
    for sorting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 无法对这些数据类型的完整长度进行索引，也无法使用索引进行排序。
- en: Using ENUM instead of a string type
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ENUM 而不是字符串类型
- en: 'Sometimes you can use an `ENUM` column instead of conventional string types.
    An `ENUM` column can store a predefined set of distinct string values. MySQL stores
    them very compactly, packed into 1 or 2 bytes depending on the number of values
    in the list. It stores each value internally as an integer representing its position
    in the field definition list. Here’s an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可以使用 `ENUM` 列代替传统的字符串类型。`ENUM` 列可以存储一组预定义的不同字符串值。MySQL 将它们非常紧凑地存储在 1 或 2
    个字节中，具体取决于列表中值的数量。它将每个值内部存储为表示其在字段定义列表中位置的整数。以下是一个示例：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The three rows actually store integers, not strings. You can see the dual nature
    of the values by retrieving them in a numeric context:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这三行实际上存储的是整数，而不是字符串。您可以在数字上下文中检索它们，看到值的双重性质：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This duality can be terribly confusing if you specify numbers for your `ENUM`
    constants, as in `ENUM('1', '2', '3')`. We suggest you don’t do this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为 `ENUM` 常量指定数字，例如 `ENUM('1', '2', '3')`，这种二义性可能会让人困惑。我们建议您不要这样做。
- en: 'Another surprise is that an `ENUM` field sorts by the internal integer values,
    not by the strings themselves:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个令人惊讶的是，`ENUM` 字段按内部整数值排序，而不是按字符串本身排序：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can work around this by specifying `ENUM` members in the order in which
    you want them to sort. You can also use `FIELD()` to specify a sort order explicitly
    in your queries, but this prevents MySQL from using the index for sorting:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按照希望排序的顺序指定 `ENUM` 成员来解决此问题。您还可以在查询中明确指定排序顺序使用 `FIELD()`，但这会阻止 MySQL 使用索引进行排序：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we’d defined the values in alphabetical order, we wouldn’t have needed to
    do that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按字母顺序定义值，我们就不需要这样做了。
- en: Because MySQL stores each value as an integer and has to do a lookup to convert
    it to its string representation, `ENUM` columns have some overhead. This is usually
    offset by their smaller size, but not always. In particular, it can be slower
    to join a `CHAR` or `VARCHAR` column to an `ENUM` column than to another `CHAR`
    or `VARCHAR` column.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 MySQL 将每个值存储为整数并必须进行查找以将其转换为其字符串表示形式，所以 `ENUM` 列具有一些开销。通常，它们的较小大小可以抵消这种开销，但并非总是如此。特别是，将
    `CHAR` 或 `VARCHAR` 列连接到 `ENUM` 列可能比连接到另一个 `CHAR` 或 `VARCHAR` 列慢。
- en: 'To illustrate, we benchmarked how quickly MySQL performs such a join on a table
    in one of our applications. The table has a fairly wide primary key:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，我们对我们的一个应用程序中的表执行了 MySQL 执行此类连接的速度基准测试。该表具有相当宽的主键：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The table contains about 110,000 rows and is only about 10 MB, so it fits entirely
    in memory. The `service` column contains 5 distinct values with an average length
    of 4 characters, and the `method` column contains 71 values with an average length
    of 20 characters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该表包含约 110,000 行，仅约 10 MB，因此完全适合内存。`service` 列包含 5 个不同的值，平均长度为 4 个字符，而 `method`
    列包含 71 个值，平均长度为 20 个字符。
- en: 'We made a copy of this table and converted the `service` and `method` columns
    to `ENUM`, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们复制了此表，并将 `service` 和 `method` 列转换为 `ENUM`，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then measured the performance of joining the tables by the primary key columns.
    Here is the query we used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过主键列测量了连接表的性能。以下是我们使用的查询：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We varied this query to join the `VARCHAR` and `ENUM` columns in different combinations.
    [Table 6-1](#speed_of_joining_varchar_and_enum_colum) shows the results.^([3](ch06.html#ch01fn26))
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了此查询以连接不同组合的 `VARCHAR` 和 `ENUM` 列。[表 6-1](#speed_of_joining_varchar_and_enum_colum)
    显示了结果。^([3](ch06.html#ch01fn26))
- en: Table 6-1\. Speed of joining `VARCHAR` and `ENUM` columns
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. 连接 `VARCHAR` 和 `ENUM` 列的速度
- en: '| Test | Queries per second |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 测试 | 每秒查询数 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `VARCHAR` joined to `VARCHAR` | 2.6 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `VARCHAR` 连接到 `VARCHAR` | 2.6 |'
- en: '| `VARCHAR` joined to `ENUM` | 1.7 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `VARCHAR` 连接到 `ENUM` | 1.7 |'
- en: '| `ENUM` joined to `VARCHAR` | 1.8 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ENUM` 连接到 `VARCHAR` | 1.8 |'
- en: '| `ENUM` joined to `ENUM` | 3.5 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `ENUM` 连接到 `ENUM` | 3.5 |'
- en: The join is faster after converting the columns to `ENUM`, but joining the `ENUM`
    columns to `VARCHAR` columns is slower. In this case, it looks like a good idea
    to convert these columns, as long as they don’t have to be joined to `VARCHAR`
    columns. It’s a common design practice to use “lookup tables” with integer primary
    keys to avoid using character-based values in joins.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在将列转换为 `ENUM` 后，连接速度更快，但将 `ENUM` 列连接到 `VARCHAR` 列则较慢。在这种情况下，转换这些列看起来是一个好主意，只要它们不必连接到
    `VARCHAR` 列。在设计中，通常使用“查找表”与整数主键来避免在连接中使用基于字符的值。
- en: 'However, there’s another benefit to converting the columns: according to the
    `Data_length` column from `SHOW TABLE STATUS`, converting these two columns to
    `ENUM` made the table about one-third smaller. In some cases, this might be beneficial
    even if the `ENUM` columns have to be joined to `VARCHAR` columns. Also, the primary
    key itself is only about half the size after the conversion. Because this is an
    InnoDB table, if there are any other indexes on this table, reducing the primary
    key size will make them much smaller, too.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将列转换为 `ENUM` 还有另一个好处：根据 `SHOW TABLE STATUS` 中的 `Data_length` 列，将这两列转换为 `ENUM`
    使表的大小减小了约三分之一。在某些情况下，即使 `ENUM` 列必须连接到 `VARCHAR` 列，这也可能是有益的。此外，转换后的主键本身大小仅为转换前的一半。由于这是一个
    InnoDB 表，如果此表上有其他索引，减小主键大小也会使它们变得更小。
- en: Warning
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While `ENUM` types are very efficient in how they store values, changes to the
    valid values that can be in an `ENUM` always require a schema change. If you do
    not yet have a robust system that automates schema changes as we describe later
    in this chapter, this operational need can be a major inconvenience if your `ENUM`
    changes often. We also refer to an antipattern of “too many `ENUM`s” in schema
    design later.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ENUM` 类型在存储值方面非常高效，但更改可以在 `ENUM` 中的有效值总是需要模式更改。如果您尚未拥有像我们稍后在本章中描述的自���化模式更改的强大系统，这种操作需求可能会成为一个主要不便，如果您的
    `ENUM` 经常更改。我们稍后还会提到模式设计中的“太多 `ENUM`”反模式。
- en: Date and Time Types
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期和时间类型
- en: 'MySQL has many types for various kinds of date and time values, such as `YEAR`
    and `DATE`. The finest granularity of time MySQL can store is microsecond. Most
    of the temporal types have no alternatives, so there is no question of which one
    is the best choice. The only question is what to do when you need to store both
    the date and the time. MySQL offers two very similar data types for this purpose:
    `DATETIME` and `TIMESTAMP`. For many applications, either will work, but in some
    cases, one works better than the other. Let’s take a look:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 有许多类型用于各种日期和时间值，例如 `YEAR` 和 `DATE`。MySQL 可以存储的时间的最细粒度是微秒。大多数时间类型没有替代方案，因此没有哪一个是最佳选择的问题。唯一的问题是当您需要同时存储日期和时间时该怎么办。MySQL
    为此目的提供了两种非常相似的数据类型：`DATETIME` 和 `TIMESTAMP`。对于许多应用程序，任何一个都可以工作，但在某些情况下，一个比另一个更好。让我们来看一下：
- en: '`DATETIME`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATETIME`'
- en: This type can hold a large range of values, from the year 1000 to the year 9999,
    with a precision of one microsecond. It stores the date and time packed into an
    integer in YYYYMMDDHHMMSS format, independent of time zone. This uses 8 bytes
    of storage space.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型可以存储大范围的值，从公元1000年到公元9999年，精度为一微秒。它将日期和时间打包成一个整数，格式为YYYYMMDDHHMMSS，与时区无关。这使用了8个字节的存储空间。
- en: By default, MySQL displays `DATETIME` values in a sortable, unambiguous format,
    such as 2008-01-16 22:37:08\. This is the ANSI standard way to represent dates
    and times.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MySQL以可排序、明确的格式显示`DATETIME`值，例如2008-01-16 22:37:08。这是表示日期和时间的ANSI标准方式。
- en: '`TIMESTAMP`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMESTAMP`'
- en: 'As its name implies, the `TIMESTAMP` type stores the number of seconds elapsed
    since midnight, January 1, 1970, Greenwich Mean Time (GMT)—the same as a Unix
    timestamp. `TIMESTAMP` uses only 4 bytes of storage, so it has a much smaller
    range than `DATETIME`: from the year 1970 to January 19, 2038\. MySQL provides
    the `FROM_UNIXTIME()` and `UNIX_TIMESTAMP()` functions to convert a Unix timestamp
    to a date and vice versa.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`TIMESTAMP`类型存储了自1970年1月1日格林尼治时间（GMT）午夜以来经过的秒数，与Unix时间戳相同。`TIMESTAMP`只使用4个字节的存储空间，因此其范围比`DATETIME`要小得多：从1970年到2038年1月19日。MySQL提供了`FROM_UNIXTIME()`和`UNIX_TIMESTAMP()`函数来将Unix时间戳转换为日期，反之亦然。
- en: The value a `TIMESTAMP` displays also depends on the time zone. The MySQL server,
    operating system, and client connections all have time zone settings.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMESTAMP`显示的值也取决于时区。MySQL服务器、操作系统和客户端连接都有时区设置。'
- en: 'Thus, a `TIMESTAMP` that stores the value `0` actually displays it as 1969-12-31
    19:00:00 in Eastern Standard Time (EST), which has a five-hour offset from GMT.
    It’s worth emphasizing this difference: if you store or access data from multiple
    time zones, the behavior of `TIMESTAMP` and `DATETIME` will be very different.
    The former preserves values relative to the time zone in use, while the latter
    preserves the textual representation of the date and time.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存储值`0`的`TIMESTAMP`实际上显示为1969-12-31 19:00:00在东部标准时间（EST），它与GMT相差五个小时。值得强调的是：如果你从多个时区存储或访问数据，`TIMESTAMP`和`DATETIME`的行为将会有很大的不同。前者保留相对于使用的时区的值，而后者保留日期和时间的文本表示。
- en: '`TIMESTAMP` also has special properties that `DATETIME` doesn’t have. By default,
    MySQL will set the first `TIMESTAMP` column to the current time when you insert
    a row without specifying a value for the column.^([4](ch06.html#ch01fn27)) MySQL
    also updates the first `TIMESTAMP` column’s value by default when you update the
    row unless you assign a value explicitly in the `UPDATE` statement. You can configure
    the insertion and update behaviors for any `TIMESTAMP` column. Finally, `TIMESTAMP`
    columns are `NOT NULL` by default, which is different from every other data type.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMESTAMP`还具有`DATETIME`没有的特殊属性。默认情况下，当你插入一行而没有为第一个`TIMESTAMP`列指定值时，MySQL会将第一个`TIMESTAMP`列设置为当前时间。MySQL还默认情况下在更新行时更新第一个`TIMESTAMP`列的值，除非你在`UPDATE`语句中明确赋值。你可以为任何`TIMESTAMP`列配置插入和更新行为。最后，`TIMESTAMP`列默认为`NOT
    NULL`，这与其他每种数据类型都不同。'
- en: Bit-Packed Data Types
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位压缩数据类型
- en: 'MySQL has a few storage types that use individual bits within a value to store
    data compactly. All of these types are technically string types, regardless of
    the underlying storage format and manipulations:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有一些存储类型，使用值内的单个位来紧凑存储数据。所有这些类型在技术上都是字符串类型，无论底层存储格式和操作如何：
- en: '`BIT`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`BIT`'
- en: You can use a `BIT` column to store one or many true/false values in a single
    column. `BIT(1)` defines a field that contains a single bit, `BIT(2)` stores 2
    bits, and so on; the maximum length of a `BIT` column is 64 bits. InnoDB stores
    each column as the smallest integer type large enough to contain the bits, so
    you don’t save any storage space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`BIT`列在单个列中存储一个或多个真/假值。`BIT(1)`定义一个包含单个位的字段，`BIT(2)`存储2位，依此类推；`BIT`列的最大长度为64位。InnoDB将每个列存储为足以包含位的最小整数类型，因此你不会节省任何存储空间。
- en: 'MySQL treats `BIT` as a string type, not a numeric type. When you retrieve
    a `BIT(1)` value, the result is a string, but the contents are the binary value
    0 or 1, not the ASCII value “0” or “1”. However, if you retrieve the value in
    a numeric context, the result is the number to which the bit string converts.
    Keep this in mind if you need to compare the result to another value. For example,
    if you store the value `b''00111001''` (which is the binary equivalent of 57)
    into a `BIT(8)` column and retrieve it, you will get the string containing the
    character code 57\. This happens to be the ASCII character code for “9”. But in
    a numeric context, you’ll get the value `57`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL将`BIT`视为字符串类型，而不是数值类型。当你检索一个`BIT(1)`值时，结果是一个字符串，但内容是二进制值0或1，而不是ASCII值“0”或“1”。但是，如果你在数值上下文中检索值，结果将是位字符串转换为的数字。如果你将值`b'00111001'`（这是57的二进制等价值）存储到一个`BIT(8)`列中并检索它，你将得到包含字符代码57的字符串。这恰好是ASCII字符代码“9”。但在数值上下文中，你将得到值`57`：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can be very confusing, so we recommend that you use `BIT` with caution.
    For most applications, we think it is a better idea to avoid this type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会非常令人困惑，因此我们建议您谨慎使用`BIT`。对于大多数应用程序，我们认为最好避免使用这种类型。
- en: If you want to store a true/false value in a single bit of storage space, another
    option is to create a nullable `CHAR(0)` column. This column is capable of storing
    either the absence of a value (`NULL`) or a zero-length value (the empty string).
    This works in practice, but it can be obtuse to others using data in the database
    and make it difficult to write queries. Unless you’re hyper-focused on saving
    space, we still recommend using `TINYINT`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在一个存储空间中存储一个真/假值，另一个选项是创建一个可空的`CHAR(0)`列。这个列可以存储值的缺失（`NULL`）或零长度值（空字符串）。这在实践中是可行的，但可能会让其他人在使用数据库中的数据时感到晦涩，使编写查询变得困难。除非你非常专注于节省空间，否则我们仍建议使用`TINYINT`。
- en: '`SET`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`'
- en: If you need to store many true/false values, consider combining many columns
    into one with MySQL’s native `SET` data type, which MySQL represents internally
    as a packed set of bits. It uses storage efficiently, and MySQL has functions
    such as `FIND_IN_SET()` and `FIELD()` that make it easy to use in queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要存储许多真/假值，请考虑将许多列合并为一个列，使用 MySQL 的原生`SET`数据类型，MySQL 在内部表示为一组位的紧凑集合。它使用存储效率高，MySQL
    有函数如`FIND_IN_SET()`和`FIELD()`，使其在查询中易于使用。
- en: Bitwise operations on integer columns
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 整数列上的位运算
- en: An alternative to `SET` is to use an integer as a packed set of bits. For example,
    you can pack 8 bits in a `TINYINT` and manipulate them with bitwise operators.
    You can make this easier by defining named constants for each bit in your application
    code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代`SET`的方法是使用整数作为一组位的紧凑集合。例如，您可以在`TINYINT`中打包 8 位，并使用位运算符进行操作。您可以通过在应用程序代码中为每个位定义命名常量来简化此过程。
- en: The major advantage of this approach over `SET` is that you can change the “enumeration”
    the field represents without an `ALTER TABLE`. The drawback is that your queries
    are harder to write and understand (what does it mean when bit 5 is set?). Some
    people are comfortable with bitwise manipulations and some aren’t, so whether
    you’ll want to try this technique is largely a matter of taste.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SET`相比，这种方法的主要优势在于您可以在不使用`ALTER TABLE`的情况下更改字段表示的“枚举”。缺点是您的查询更难编写和理解（当第 5
    位设置时意味着什么？）。有些人习惯于位操作，有些人则不习惯，因此您是否想尝试这种技术在很大程度上取决于个人口味。
- en: 'An example application for packed bits is an access control list (ACL) that
    stores permissions. Each bit or `SET` element represents a value such as `CAN_READ`,
    `CAN_WRITE`, or `CAN_DELETE`. If you use a `SET` column, you’ll let MySQL store
    the bit-to-value mapping in the column definition; if you use an integer column,
    you’ll store the mapping in your application code. Here’s what the queries would
    look like with a `SET` column:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个紧凑位的示例应用是存储权限的访问控制列表（ACL）。每个位或`SET`元素代表一个值，例如`CAN_READ`、`CAN_WRITE`或`CAN_DELETE`。如果您使用`SET`列，您将让
    MySQL 在列定义中存储位到值的映射；如果您使用整数列，您将在应用程序代码中存储映射。以下是使用`SET`列的查询示例：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you used an integer, you could write that example as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用整数，可以将该示例写成如下形式：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We’ve used variables to define the values, but you can use constants in your
    code instead.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用变量来定义值，但您可以在代码中使用常量代替。
- en: JSON Data
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 数据
- en: It is becoming increasingly common to use JSON as a format for interchanging
    data between systems. MySQL has a native JSON data type that makes it easy to
    operate on parts of the JSON structure directly within the table. Purists may
    suggest that storing raw JSON in a database is an antipattern because ideally,
    schemas are a representation of the fields in JSON. Newcomers may look at the
    JSON data type and see a short path by avoiding creating and managing independent
    fields. Which method is better is largely subjective, but we’ll be objective by
    presenting a sample use case and comparing both query speed and data size.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越普遍地使用 JSON 作为系统之间交换数据的格式。MySQL 有一个原生的 JSON 数据类型，使得直接在表内部操作 JSON 结构的部分变得容易。纯粹主义者可能会建议在数据库中存储原始
    JSON 是一种反模式，因为理想情况下，模式是 JSON 中字段的表示。新手可能会看到 JSON 数据类型，并通过避免创建和管理独立字段来看到一条捷径。哪种方法更好在很大程度上是主观的，但我们将客观地通过呈现一个示例用例并比较查询速度和数据大小来进行比较。
- en: 'Our sample data was [a list of 202 near-Earth asteroids and comets discovered,
    courtesy of NASA](https://oreil.ly/2oZX9). Tests were performed under MySQL 8.0.22
    on a four-core, 16 GB RAM virtual machine. An example of the data:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例数据是[由 NASA 提供的发现的 202 个近地小行星和彗��的列表](https://oreil.ly/2oZX9)。测试是在一个四核、16
    GB RAM 虚拟机上的 MySQL 8.0.22 上进行的。数据示例：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This data represents a designation, date it was discovered, and data collected
    about the entity, including numeric and text fields.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据代表了一个指定，发现日期，以及关于实体的收集的数据，包括数字和文本字段。
- en: 'First, we took the data set in JSON and converted it to be one row per entry.
    This resulted in a schema that looks relatively simple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 JSON 中的数据集转换为每个条目一行。这导致了一个看起来相对简单的模式：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Second, we took this JSON and converted the fields to columns using a suitable
    data type for the data. This resulted in the following schema:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将此 JSON 数据转换为列，使用适当的数据类型进行转换。这导致了以下模式：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first comparison is on data size:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个比较是数据大小：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our SQL version uses three 16 KB pages, and our JSON version uses five 16 KB
    pages. This doesn’t come as much of a surprise. A JSON data type will use more
    space to store the additional characters for defining JSON (braces, brackets,
    colons, etc.) as well as the whitespace. In this small example, the size of data
    storage can be improved by converting JSON to specific data types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 SQL 版本使用了三个 16 KB 页面，而我们的 JSON 版本使用了五个 16 KB 页面。这并不令人感到意外。JSON 数据类型将使用更多空间来存储用于定义
    JSON 的额外字符（大括号、方括号、冒号等）以及空格。在这个小例子中，通过将 JSON 转换为特定数据类型，数据存储的大小可以得到改善。
- en: There may be valid use cases where the data size is not that important. How
    does query latency measure up between the two?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在数据大小不那么重要的有效用例。这两者之间的查询延迟如何？
- en: 'To select all of a single column in SQL, our syntax is straightforward:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 SQL 中选择单个列的所有内容，我们的语法很简单：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On our first run of this query, uncached by InnoDB’s buffer pool, we got a result
    of 1.14 milliseconds (ms). The second execution, with it in memory, we got 0.44
    ms.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次运行此查询时，未被 InnoDB 缓冲池缓存，我们得到了 1.14 毫秒（ms）的结果。第二次执行，将其放入内存中，我们得到了 0.44 毫秒。
- en: 'For JSON, we are able to access a field inside of the JSON structure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSON，我们能够访问 JSON 结构内的字段：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similarly, our first execution, uncached, executed in 1.13 ms. Subsequent executions
    were at around 0.80 ms. At this execution speed, we expect that there will be
    a reasonable variation—we’re talking about a difference of hundreds of microseconds
    in a VM environment. In our opinion, both queries executed reasonably quickly,
    although it’s worth noting that the JSON query is still about twice as long.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的第一次执行，未缓存，执行时间为1.13毫秒。后续执行时间约为0.80毫秒。在这个执行速度下，我们预计会有一定的变化——我们在一个虚拟机环境中谈论数百微秒的差异。在我们看来，这两个查询都执行得相当快，尽管值得注意的是JSON查询仍然比SQL查询长大约两倍。
- en: 'What about accessing specific rows, though? For the single-row lookup, we take
    advantage of using indexes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 针对特定行的访问呢？对于单行查找，我们利用使用索引：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we do a single-row lookup, our SQL version runs in 0.33 ms, and our JSON
    version runs in 0.58 ms, giving an edge to the SQL version. This is easily explained:
    our index is allowing InnoDB to return 1 row instead of 202 rows.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行单行查找时，我们的SQL版本运行时间为0.33毫秒，而我们的JSON版本运行时间为0.58毫秒，给予SQL版本优势。这很容易解释：我们的索引允许InnoDB返回1行而不是202行。
- en: 'Comparing an indexed query to a full table scan is unfair, though. To level
    the playing field, we need to use the *generated columns* feature to extract the
    designation and then create an index against that virtual generated column:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引查询与全表扫描进行比较是不公平的。为了公平竞争，我们需要使用*生成列*功能提取指定，并创建针对该虚拟生成列的索引：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This gives us a schema on our JSON table that looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们的JSON表上的模式看起来像这样：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our schema now generates a virtual column for the designation from the `json_data`
    column and indexes it. Now, we rerun our single-row lookup to use the indexed
    column instead of the JSON column path operator (`->`). Since the field data is
    quoted in the JSON, we need to search for it quoted in our SQL as well:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式现在从`json_data`列生成一个虚拟列用于指定，并对其进行索引。现在，我们重新运行我们的单行查找，使用索引列而不是JSON列路径运算符(`->`)。由于字段数据在JSON中被引用，我们需要在SQL中也引用它：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This query executed in 0.4 ms, fairly close to our SQL version of 0.33 ms.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询在0.4毫秒内执行，与我们的SQL版本0.33毫秒相当接近。
- en: From our preceding simple test case, the amount of used tablespace seems to
    be the primary driver for why you would use SQL columns rather than storing a
    raw JSON document. Speed is still better with SQL columns. Overall, the decision
    to use native SQL versus JSON comes down to whether the ease of storing JSON in
    the database outweighs the performance. If you’re accessing this data millions
    or billions of times per day, the speed difference is going to add up.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的简单测试案例中，使用的表空间量似乎是为什么你会使用SQL列而不是存储原始JSON文档的主要原因。速度仍然比SQL列更快。总的来说，选择使用本机SQL还是JSON取决于在数据库中存储JSON的便利性是否超过性能。如果你每天访问这些数据数百万次或数十亿次，速度差异将会累积。
- en: Choosing Identifiers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择标识符
- en: In general, an *identifier* is the way you refer to a row and often what makes
    it unique. For example, if you have a table about users, you might want to assign
    each user a numerical ID or a unique username. This field may be some or all of
    your `PRIMARY KEY`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，*标识符*是指引用行的方式，通常也是使其唯一的方式。例如，如果你有一个关于用户的表，你可能想为每个用户分配一个数字ID或一个唯一的用户名。这个字段可能是你的`PRIMARY
    KEY`的一部分或全部。
- en: Choosing a good data type for an identifier column is very important. You’re
    more likely to compare these columns to other values (for example, in joins) and
    to use them for lookups than other columns. You’re also likely to use them in
    other tables as foreign keys, so when you choose a data type for an identifier
    column, you’re probably choosing the type in related tables as well. (As we demonstrated
    earlier in this chapter, it’s a good idea to use the same data types in related
    tables because you’re likely to use them for joins.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 选择标识符列的良好数据类型非常重要。你更有可能将这些列与其他值进行比较（例如，在连接中），并将它们用于查找而不是其他列。你还可能在其他表中将它们用作外键，因此当你为标识符列选择数据类型时，你可能也在相关表中选择该类型。（正如我们在本章前面演示的那样，最好在相关表中使用相同的数据类型，因为你可能会用它们进行连接。）
- en: When choosing a type for an identifier column, you need to consider not only
    the storage type but also how MySQL performs computations and comparisons on that
    type. For example, MySQL stores `ENUM` and `SET` types internally as integers
    but converts them to strings when doing comparisons in a string context.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择标识符列的类型时，你需要考虑的不仅是存储类型，还有MySQL如何在该类型上执行计算和比较。例如，MySQL在内部将`ENUM`和`SET`类型存储为整数，但在字符串上下文中进行比较时将它们转换为字符串。
- en: Once you choose a type, make sure you use the same type in all related tables.
    The types should match exactly, including properties such as `UNSIGNED`.^([5](ch06.html#ch01fn28))
    Mixing different data types can cause performance problems, and even if it doesn’t,
    implicit type conversions during comparisons can create hard-to-find errors. These
    may even crop up much later, after you’ve forgotten that you’re comparing different
    data types.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了类型，请确保在所有相关表中使用相同的类型。类型应完全匹配，包括`UNSIGNED`等属性。^([5](ch06.html#ch01fn28))混合不同的数据类型可能会导致性能问题��即使没有问题，隐式类型转换在比较过程中也可能导致难以发现的错误。这些错误甚至可能在很久之后才出现，当你忘记你正在比较不同的数据类型时。
- en: Choose the smallest size that can hold your required range of values, and leave
    room for future growth if necessary. For example, if you have a `state_id` column
    that stores US state names, you don’t need thousands or millions of values, so
    don’t use an `INT`. A `TINYINT` should be sufficient and is 3 bytes smaller. If
    you use this value as a foreign key in other tables, 3 bytes can make a big difference.
    Here we give a few tips.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择可以容纳所需值范围的最小大小，并在必要时留出未来增长的空间。例如，如果你有一个存储美国州名的`state_id`列，你不需要成千上万或数百万的值，所以不要使用`INT`。一个`TINYINT`应该足够，而且比较小3个字节。如果你在其他表中将这个值用作外键，3个字节可能会产生很大的差异。这里我们给出一些建议。
- en: Integer types
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数类型
- en: Integers are usually the best choice for identifiers because they’re fast and
    they work with `AUTO_INCREMENT`. `AUTO_INCREMENT` is a column attribute that generates
    a new integer type for each new row. For example, a billing system may need to
    generate a new invoice for each customer. Using `AUTO_INCREMENT` means that the
    first invoice generated would be 1, the second 2, and so on. Be aware that you
    should make sure you have the right integer size for the growth of the data you
    expect. There has been more than one story of system downtime associated with
    unexpectedly running out of integers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 整数通常是标识符的最佳选择，因为它们快速且可以与`AUTO_INCREMENT`一起使用。`AUTO_INCREMENT`是一个为每一行生成新整数类型的列属性。例如，一个计费系统可能需要为每个客户生成一个新的发票。使用`AUTO_INCREMENT`意味着生成的第一张发票是1，第二张是2，依此类推。请注意，你应该确保为你预期的数据增长选择正确的整数大小。有不止一个关于由于意外耗尽整数而导致系统停机的故事。
- en: ENUM and SET
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ENUM和SET
- en: The `ENUM` and `SET` types are generally a poor choice for identifiers, although
    they can be okay for static “definition tables” that contain status or “type”
    values. `ENUM` and `SET` columns are appropriate for holding information like
    an order’s status or a product’s type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENUM`和`SET`类型通常不适合作为标识符的选择，尽管它们可以用于包含状态或“类型”值的静态“定义表”。`ENUM`和`SET`列适合保存像订单状态或产品类型这样的信息。'
- en: As an example, if you use an `ENUM` field to define a product’s type, you might
    want a lookup table primary keyed on an identical `ENUM` field. (You could add
    columns to the lookup table for descriptive text, to generate a glossary, or to
    provide meaningful labels in a pull-down menu on a website.) In this case, you’ll
    want to use the `ENUM` as an identifier, but for most purposes, you should avoid
    doing so.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，如果你使用`ENUM`字段来定义产品的类型，你可能希望有一个主键为相同`ENUM`字段的查找表。在这种情况下，你会想要将`ENUM`用作标识符，但对于大多数情况，你应该避免这样做。
- en: String types
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串类型
- en: Avoid string types for identifiers if possible, because they take up a lot of
    space and are generally slower than integer types.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，避免使用字符串类型作为标识符，因为它们占用大量空间，通常比整数类型慢。
- en: You should also be very careful with completely “random” strings, such as those
    produced by `MD5()`, `SHA1()`, or `UUID()`. Each new value you generate with them
    will be distributed in arbitrary ways over a large space, which can slow `INSERT`
    and some types of `SELECT` queries:^([6](ch06.html#ch01fn29))
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该非常小心完全“随机”的字符串，比如由`MD5()`、`SHA1()`或`UUID()`生成的字符串。你用它们生成的每个新值都会以任意方式分布在一个大空间中，这可能会减慢`INSERT`和某些类型的`SELECT`查询：^([6](ch06.html#ch01fn29))
- en: They slow `INSERT` queries because the inserted value has to go in a random
    location in indexes. This causes page splits, random disk accesses, and clustered
    index fragmentation for clustered storage engines.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会减慢`INSERT`查询，因为插入的值必须放在索引中的随机位置。这会导致页面分裂、随机磁盘访问以及聚集索引碎片化对于聚集存储引擎。
- en: They slow `SELECT` queries because logically adjacent rows will be widely dispersed
    on disk and in memory.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会减慢`SELECT`查询，因为逻辑上相邻的行在磁盘和内存中会被广泛分散。
- en: Random values cause caches to perform poorly for all types of queries because
    they defeat locality of reference, which is how caching works. If the entire data
    set is equally “hot,” there is no advantage to having any particular part of the
    data cached in memory, and if the working set does not fit in memory, the cache
    will have a lot of flushes and misses.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机值会导致缓存在所有类型的查询中表现不佳，因为它们破坏了引用局部性，这是缓存工作的方式。如果整个数据集都是“热点”，那么在内存中缓存任何特定部分的数据都没有优势，如果工作集不适合内存，缓存将有很多刷新和未命中。
- en: If you do store universally unique identifier (UUID) values, you should remove
    the dashes or, even better, convert the UUID values to 16-byte numbers with `UNHEX()`
    and store them in a `BINARY(16)` column. You can retrieve the values in hexadecimal
    format with the `HEX()` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你存储通用唯一标识符（UUID）值，你应该去掉破折号，或者更好的是，使用`UNHEX()`将UUID值转换为16字节数字，并将其存储在`BINARY(16)`列中。你可以使用`HEX()`函数以十六进制格式检索值。
- en: Special Types of Data
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊数据类型
- en: Some kinds of data don’t correspond directly to the available built-in types.
    A good example is an IPv4 address. People often use `VARCHAR(15)` columns to store
    IP addresses. However, they are really unsigned 32-bit integers, not strings.
    The dotted-quad notation is just a way of writing it out so that humans can read
    it more easily. You should store IP addresses as unsigned integers. MySQL provides
    the `INET_ATON()` and `INET_NTOA()` functions to convert between the two representations.
    The space used shrinks from ~16 bytes for a `VARCHAR(15)` down to 4 bytes for
    an unsigned 32-bit integer. If you’re concerned about readability in the database
    and don’t want to keep using functions to view row data, remember that MySQL has
    views and you can use them to see your data easier.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有些数据类型与可用的内置类型不直接对应。一个很好的例子是IPv4地址。人们经常使用`VARCHAR(15)`列来存储IP地址。然而，它们实际上是无符号32位整数，而不是字符串。点分四进制表示法只是一种让人类更容易阅读的写法。你应该将IP地址存储为无符号整数。MySQL提供了`INET_ATON()`和`INET_NTOA()`函数来在这两种表示法之间转换。使用无符号32位整数，空间使用量从`VARCHAR(15)`的约16字节缩减到4字节。如果你担心数据库中的可读性，并且不想继续使用函数查看行数据，记住MySQL有视图，你可以使用它们更轻松地查看数据。
- en: Schema Design Gotchas in MySQL
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL中的模式设计陷阱
- en: Although there are universally bad and good design principles, there are also
    issues that arise from how MySQL is implemented, and that means you can make MySQL-specific
    mistakes, too. This section discusses problems that we’ve observed in schema designs
    with MySQL. It might help you avoid those mistakes and choose alternatives that
    work better with MySQL’s specific implementation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有普遍的好坏设计原则，但也存在由于MySQL的实现方式而引起的问题，这意味着你也可能犯MySQL特定的错误。本节讨论了我们在MySQL模式设计中观察到的问题。这可能有助于你避免这些错误，并选择与MySQL特定实现更好配合的替代方案。
- en: Too Many Columns
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 太多列
- en: MySQL’s storage engine API works by copying rows between the server and the
    storage engine in a row buffer format; the server then decodes the buffer into
    columns. It can be costly to turn the row buffer into the row data structure with
    the decoded columns. InnoDB’s row format always requires conversion. The cost
    of this conversion depends on the number of columns. We discovered that this can
    become expensive when we investigated an issue with high CPU consumption for a
    customer with extremely wide tables (hundreds of columns), even though only a
    few columns were actually used. If you’re planning for hundreds of columns, be
    aware that the server’s performance characteristics will be a bit different.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL的存储引擎API通过在行缓冲格式中在服务器和存储引擎之间复制行；然后服务器将缓冲区解码为列。将行缓冲区转换为具有解码列的行数据结构可能是昂贵的。InnoDB的行格式总是需要转换的。这种转换的成本取决于列的数量。当我们调查一个具有极宽表（数百列）的客户的高CPU消耗问题时，我们发现这可能会变得昂贵，尽管实际上只使用了少数列。如果您计划使用数百列，请注意服务器的性能特性将有所不同。
- en: Too Many Joins
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 太多的连接
- en: The so-called entity-attribute-value (EAV) design pattern is a classic case
    of a universally bad design pattern that especially doesn’t work well in MySQL.
    MySQL has a limitation of 61 tables per join, and EAV databases require many self-joins.
    We’ve seen more than a few EAV databases eventually exceed this limit. Even at
    many fewer joins than 61, however, the cost of planning and optimizing the query
    can become problematic for MySQL. As a rough rule of thumb, it’s better to have
    a dozen or fewer tables per query if you need queries to execute very fast with
    high concurrency.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的实体-属性-值（EAV）设计模式是一个经典的普遍糟糕的设计模式，特别在MySQL中效果不佳。MySQL对于每个连接有61个表的限制，而EAV数据库需要许多自连接。我们看到许多EAV数据库最终超过了这个限制。然而，即使比61少得多的连接，规划和优化查询的成本对于MySQL来说可能会成为问题。作为一个粗略的经验法则，如果您需要查询以非常快的速度和高并发性执行，最好每个查询有十几个或更少的表。
- en: The All-Powerful ENUM
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 万能的ENUM
- en: 'Beware of overusing `ENUM`. Here’s an example we saw:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 谨防过度使用`ENUM`。这是我们看到的一个例子：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The schema was sprinkled liberally with this pattern. This would probably be
    a questionable design decision in any database with an enumerated value type because
    it really should be an integer that is foreign-keyed to a “dictionary” or “lookup”
    table anyway.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 模式中大量使用了这种模式。在任何具有枚举值类型的数据库中，这可能是一个值得怀疑的设计决定，因为它实际上应该是一个整数，可以作为“字典”或“查找”表的外键。
- en: The ENUM in Disguise
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪装的ENUM
- en: 'An `ENUM` permits the column to hold one value from a set of defined values.
    A `SET` permits the column to hold one or more values from a set of defined values.
    Sometimes these can be easy to confuse. Here’s an example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENUM`允许列保存来自一组定义值中的一个值。`SET`允许列保存来自一组定义值中的一个或多个值。有时这些可能很容易混淆。这里有一个例子：'
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That almost surely ought to be an `ENUM` instead of a `SET`, assuming that it
    can’t be both true and false at the same time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那几乎肯定应该是一个`ENUM`而不是一个`SET`，假设它不能同时为真和假。
- en: NULL Not Invented Here
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NULL并非在这里发明
- en: We wrote earlier about the benefits of avoiding `NULL`, and indeed, we suggest
    considering alternatives when possible. Even when you do need to store a “no value”
    fact in a table, you might not need to use `NULL`. Perhaps you can use zero, a
    special value, or an empty string instead.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到避免使用`NULL`的好处，确实，我们建议在可能的情况下考虑替代方案。即使您需要在表中存储“无值”事实时，也许您并不需要使用`NULL`。也许您可以使用零、一个特殊值或空字符串代替。
- en: However, you can take this to extremes. Don’t be too afraid of using `NULL`
    when you need to represent an unknown value. In some cases, it’s better to use
    `NULL` than a magical constant. Selecting one value from the domain of a constrained
    type, such as using −1 to represent an unknown integer, can complicate your code
    a lot, introduce bugs, and just generally make a total mess out of things. Handling
    `NULL` isn’t always easy, but it’s often better than the alternative.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您也可以走向极端。当您需要表示未知值时，不要太害怕使用`NULL`。在某些情况下，使用`NULL`比使用神奇的常量更好。从受限类型的域中选择一个值，比如使用−1表示未知整数，可能会使您的代码变得复杂，引入错误，并且总体上会搞得一团糟。处理`NULL`并不总是容易的，但通常比其他替代方案更好。
- en: 'Here’s one example we’ve seen pretty frequently:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们经常看到的一个例子：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That bogus all-zeros value can cause lots of problems. (You can configure MySQL’s
    `SQL_MODE` to disallow nonsense dates, which is an especially good practice for
    a new application that hasn’t yet created a database full of bad data.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那个虚假的全零值可能会引起很多问题。（您可以配置MySQL的`SQL_MODE`来禁止无意义的日期，这对于尚未创建满是错误数据的新应用程序来说是一个特别好的做法。）
- en: On a related topic, MySQL does index `NULL`s, unlike Oracle, which doesn’t include
    nonvalues in indexes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关主题上，MySQL确实对`NULL`进行索引，而Oracle不会在索引中包含非值。
- en: 'Now that we have covered a lot of practical advice around data types, how to
    choose them, and what not to do, let’s move on to the other piece of good, iterative
    schema design: schema management.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了很多关于数据类型、如何选择它们以及不应该做什么的实用建议，让我们继续讨论另一个好的、迭代的模式设计：模式管理。
- en: Schema Management
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式管理
- en: Running schema changes is one of the most common tasks a database engineer has
    to undertake. When you get to the stage of running dozens or hundreds of database
    instances with varying business contexts and evolving features, you want to be
    careful that applying these schema changes is not a bottleneck for the entire
    organization but is still being done safely and without disrupting operations.
    This section will cover how to think about schema change management as part of
    a “data store platform,” what core values should guide this strategy, what tools
    you can introduce to enable this strategy, and how it all fits together in your
    larger software-delivery life cycle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模式更改是数据库工程师必须承担的最常见任务之一。当你开始运行数十甚至数百个具有不同业务背景和不断发展功能的数据库实例时，你希望小心处理这些模式更改不会成为整个组织的瓶颈，但仍然安全地进行，并且不会干扰运营。本节将介绍如何将模式更改管理视为“数据存储平台”的一部分，应该指导这一策略的核心价值观，你可以引入哪些工具来实现这一策略，以及如何将其与更大的软件交付生命周期结合起来。
- en: Schema Management as Part of the Data Store Platform
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式管理作为数据存储平台的一部分
- en: If you speak with any engineering leader of a fast-growing organization, you
    will find that engineer velocity and the time from feature design to running in
    production are top of their list of things to optimize. In that context, your
    task as you plan managing schemas at scale is to not allow schema management to
    become a manual process that bottlenecks progress for the entire engineering organization
    on one or a few people.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与任何快速增长组织的工程领导人交谈，你会发现工程师速度和从特性设计到在生产环境中运行的时间是他们优化事项的首要任务。在这种情况下，你在规划规模化管理模式时的任务是不允许模式管理成为一个手动过程，这会成为整个工程组织进展的瓶颈，只有一个或几个人。
- en: Set up your partner teams for success
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为成功设置合作团队
- en: As the number of teams that rely on MySQL instances in the organization grows,
    you want to always be the enabler of these teams’ success, not the gate they need
    to pass through to get their work done. This applies to schema changes, too, which
    means you want to create a path to deploying schema changes that does not hinge
    on “only the database team does it.”
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组���中依赖MySQL实例的团队数量增加，你希望始终成为这些团队成功的推动者，而不是他们需要通过才能完成工作的门槛。这也适用于模式更改，这意味着你希望创建一条路径来部署模式更改，而不是“只有数据库团队才能做到”。
- en: Integrate schema management with continuous integration
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成模式管理与持续集成
- en: After we cover a number of tools that enable schema management at scale, we
    will talk about how to integrate them with CI pipelines. But right now we would
    like to emphasize that if you start with the premise that schema changes are going
    to be managed by feature teams and not just the database team, then you need to
    get as close in workflow as you can to how these teams already deploy code changes.
    [Science has shown](https://oreil.ly/hozRf) that teams that treat schema management
    the same way they treat code deploys experience a more positive feature-delivery
    process and see improvement in the teams’ velocity. We’ll discuss the tools that
    enable that iteration with software-delivery practices in mind.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论了一些能够实现规模化模式管理的工具之后，我们将谈论如何将它们与CI管道集成。但现在我们想强调的是，如果你从这样一个前提开始，即模式更改将由特性团队而不仅仅是数据库团队来管理，那么你需要尽可能接近这些团队已经部署代码更改的工作流程。[科学已经证明](https://oreil.ly/hozRf)，将模式管理视为代码部署的团队经历了更积极的特性交付过程，并看到团队速度的提高。我们将讨论能够支持这种迭代的工具，考虑到软件交付实践。
- en: Source control for schema changes
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式更改的源代码控制
- en: We all use source control for the code we deploy, right? Then why not also for
    what the database schema is supposed to look like? One of the very first steps
    to schema management at scale is making sure you have source control underpinning
    and tracking the changes being done. It is not only A Good Thing To Do™, but in
    many cases, it’s required by your friendly compliance team, as you will see in
    [Chapter 13](ch13.html#compliance_with_mysql). Let’s cover some tools that enable
    iterating over database schemas.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都在部署代码时使用源代码控制，对吧？那么为什么不也用于数据库模式应该是什么样子呢？在规模化模式管理的第一步是确保你有支持和跟踪所做更改的源代码控制。这不仅仅是一件好事™，而且在许多情况下，你的合规团队要求这样做，正如你将在[第13章](ch13.html#compliance_with_mysql)中看到的。让我们来看看一些能够迭代数据库模式的工具。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For maximum value for your organization, use the same CI tool engineering uses
    for code deploys.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的组织最大的价值，使用工程团队用于代码部署的相同CI工具。
- en: Paid options
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 付费选项
- en: 'The landscape for database schema management as an enterprise tool has grown
    dramatically in the past few years, especially in increased support for MySQL
    installations. If you are looking for an off-the-shelf solution to help your organization
    manage schema changes, here are some things you should consider:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年，作为企业工具的数据库模式管理领域发展迅速，特别是对于MySQL安装的支持增加。如果你正在寻找一个现成的解决方案来帮助你的组织管理模式更改，这里有一些你应该考虑的事项：
- en: Cost
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 成本
- en: Cost models vary, so you should be careful if the solution you choose will charge
    per target (schema to manage) as that can add up quickly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 成本模型各不相同，因此如果你选择的解决方案会按目标（要管理的模式）收费，那么你应该小心，因为这可能会很快累积起来。
- en: Online schema management
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在线模式管理
- en: As of this writing, paid solutions such as [Flyway](https://flywaydb.org) do
    not have a clear path to running schema changes for you in a nonblocking manner,
    although its competitor [Liquibase](https://www.liquibase.org) has a well-supported
    plug-in for Percona’s online schema change. You need to be aware of the trade-offs
    each vendor is deciding on your behalf and what these trade-offs mean to your
    availability, especially if you plan to use these vendors to manage schema changes
    for databases that are large in size (multiple terabytes on disk).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，付费解决方案（如[Flyway](https://flywaydb.org)）尚无明确的路径以非阻塞方式为您运行模式更改，尽管其竞争对手[Liquibase](https://www.liquibase.org)为Percona的在线模式更改提供了一个得到良好支持的插件。您需要了解每个供应商为您做出的权衡，并了解这些权衡对您的可用性意味着什么，特别是如果您计划使用这些供应商来管理大型数据库（磁盘上有多个TB）的模式更改。
- en: Out-of-the-box integrations
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 开箱即用的集成
- en: Most of these tools come with assumptions about what languages your in-house
    software is written in and therefore what hooks to provide for integration with
    your existing software-delivery process. If your shop is highly polyglot or in
    the process of changing major software languages, this could exclude some of these
    vendors. We will cover in the next section what to do if you need to “do it yourself”
    when implementing schema source control management.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些工具都对您公司内部软件使用的语言以及为与现有软件交付流程集成提供的挂钩做出了假设。如果您的公司是高度多语言的，或者正在更改主要软件语言，这可能会排除一些供应商。我们将在下一节中介绍在实施模式源控制管理时需要“自己动手”时该怎么做。
- en: Using open source
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用开源
- en: If procuring a paid tool is out of reach or if you have valid reasons why none
    of the current solutions is a good fit for your organization, you can achieve
    the same outcomes using existing open source tooling and your organization’s CI
    pipeline.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购买付费工具超出了您的能力范围，或者如果您有正当理由认为当前的解决方案都不适合您的组织，您可以使用现有的开源工具和您组织的CI管道来实现相同的结果。
- en: A prominent open source solution for managing schema changes in version control
    across multiple environments is [Skeema](https://www.skeema.io). Skeema itself
    does not run the schema changes for you in production—we will cover how to do
    that shortly—but it is a great tool for tracking changes in a source control repository
    per database cluster and across multiple environments. Its CLI implementation
    provides a lot of flexibility when integrating with your CI solution of choice.
    How you integrate Skeema directly with your CI solution will require some consideration
    of the capabilities that CI solution has. [This blog post by the team at Twilio
    Sendgrid](https://oreil.ly/8YhBS) explains how they integrated Skeema with Buildkite
    to achieve autonomy for feature teams looking to manage changes to their databases.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的开源解决方案，用于在多个环境中通过版本控制管理模式更改的是[Skeema](https://www.skeema.io)。Skeema本身不会在生产环境中为您运行模式更改——我们将很快介绍如何做到这一点——但它是一个很好的工具，用于跟踪每个数据库集群中的源代码控制存储库中的更改以及跨多个环境。其CLI实现在与您选择的CI解决方案集成时提供了很大的灵活性。如何直接将Skeema与您的CI解决方案集成将需要考虑CI解决方案具有的功能。[Twilio
    Sendgrid团队的这篇博客文章](https://oreil.ly/8YhBS)解释了他们如何将Skeema与Buildkite集成，以实现寻求管理其数据库更改的功能团队的自主权。
- en: Note that however this solution integrates with your CI, it also needs access
    to run schema changes to all your environments, including production. This means
    also collaborating with your security team to make sure you are creating the correct
    access controls to reap the benefits of automating schema deployments using continuous
    integration.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论这个解决方案如何与您的CI集成，它还需要访问所有环境（包括生产环境）来运行模式更改。这也意味着与您的安全团队合作，以确保您正在创建正确的访问控制，以实现使用持续集成自动化模式部署模式的好处。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are already on the path of scaling your database infrastructure using
    Vitess, you should be aware that Vitess also manages schema changes for you. Make
    sure to check that specific section of the documentation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在使用Vitess扩展您的数据库基础设施的道路上，您应该知道Vitess也会为您管理模式更改。确保检查文档的特定部分。
- en: 'The field for managing schema changes across environments with both an automation
    and compliance mindset has grown dramatically in the past few years. Here are
    some final takeaways for you as you make your choice:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，具有自动化和合规性思维的跨环境管理模式更改领域已经显著增长。以下是您在做出选择时的一些最终收获：
- en: Stay as close as possible to the existing software-deploy tooling and workflow.
    You want this to be familiar to your larger engineering organization.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能接近现有的软件部署工具和工作流程。您希望这对您更大的工程组织来说是熟悉的。
- en: Use a tool that can integrate basic linting checks against schema changes to
    ensure some baseline requirements are met. Your solution should automatically
    fail a pull request if the new table does not use the right charset or there are
    foreign keys if you decided you do not want to allow them.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个可以集成基本模式更改的基本检查的工具，以确保满足一些基本要求。如果新表不使用正确的字符集或者如果您决定不允许外键，则您的解决方案应自动失败拉取请求。
- en: If you are in an organization that is polyglot and growing rapidly, make sure
    you are not accidentally introducing artificial bottlenecks such as one repository
    for all the databases and all the schema changes. Remember that the goal here
    is engineering team velocity.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您所在的组织是多语言并且正在快速增长，请确保您不会意外引入人为瓶颈，例如一个存储库用于所有数据库和所有模式更改。请记住这里的目标是工程团队速度。
- en: Running schema changes in production
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在生产环境中运行模式更改
- en: Now that we have covered options to track and manage deploying schema changes
    for your organization, let’s discuss *how* to run these changes in production
    without affecting the uptime of your databases or the services that rely on them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已���介绍了跟踪和管理为您的组织部署模式更改的选项，让我们讨论*如何*在生产环境中运行这些更改，而不会影响您的数据库的正常运行时间或依赖于它们的服务。
- en: Native DDL statements
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 本地DDL语句
- en: MySQL introduced nonblocking schema changes in version 5.6, but in that major
    version, the feature came with a number of caveats that made actually using them
    limited to very specific schema-change types.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL在5.6版本中引入了非阻塞模式的模式更改，但在该主要版本中，该功能带有一些注意事项，实际上只能用于非常特定的模式更改类型。
- en: By the time version 8.0 became GA, support for native DDL in MySQL expanded
    greatly, although it is still not universal. Changes to your primary key, changes
    to charsets, turning on per-table encryption, and adding or removing foreign keys
    are all examples of schema changes you still cannot do natively with an `INPLACE`
    alter.^([7](ch06.html#ch01fn30)) We highly recommend you get familiar through
    the documentation with what changes are allowed using either `INPLACE` or `INSTANT`
    algorithms as the preferred, native way to make schema changes in MySQL without
    downtime.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到8.0版本成为GA时，MySQL中对本机DDL的支持大大扩展，尽管仍不是普遍的。更改主键、更改字符集、打开逐表加密以及添加或删除外键都是您仍然无法使用`INPLACE`
    alter本地进行的模式更改的示例。^([7](ch06.html#ch01fn30))我们强烈建议您通过文档熟悉使用`INPLACE`或`INSTANT`算法所允许的更改，这是在MySQL中进行模式更改而无需停机的首选本地方式。
- en: However, even if the change you need is technically supported by native DDL
    in 8.0 and beyond, if the table being changed is very large in size, you can run
    into rollbacks if the logfile of table changes InnoDB is internally keeping gets
    too large, undoing hours or days of work. Another reason you may need to use an
    external tool is if you have a strong desire to control the speed at which the
    table change happens using a throttling mechanism. This is something you can manage
    with the external tools we are about to discuss.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使您需要的更改在8.0及更高版本中得到了技术上的支持，如果正在更改的表非常庞大，如果InnoDB内部保留的表更改日志文件太大，您可能会遇到回滚，从而撤销数小时或数天的工作。您可能需要使用外部工具的另一个原因是，如果您强烈希望使用节流机制控制表更改发生的速度。这是您可以通过即将讨论的外部工具来管理的事项。
- en: Using external tools to run your schema change
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用外部工具运行模式更改
- en: If you are not yet able to run the latest and greatest MySQL version with all
    the flexibility of the schema changes in place, you can still combine CI tooling
    with available open source tooling to run your schema changes in production automatically
    without affecting your service. Two prominent options for achieving this are Percona’s
    `pt-online-schema-change` and GitHub’s `gh-ost`. The documentation for both has
    all the information you need to learn how to install and use the tools, so we
    will focus here on how to choose which of them to use, what the major trade-offs
    are that you should consider, and how to improve the safety of using either tool
    as part of an automated schema-deploy pipeline in production.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚无法运行最新且最强大的MySQL版本，并且具有所有模式更改的灵活性，您仍然可以将CI工具与可用的开源工具结合使用，在不影响服务的情况下自动在生产环境中运行模式更改。实现此目标的两个主要选项是Percona的`pt-online-schema-change`和GitHub的`gh-ost`。两者的文档都包含了您学习如何安装和使用工具所需的所有信息，因此我们将重点讨论如何选择使用哪种工具，应该考虑的主要权衡以及如何提高在生产中作为自动化模式部署流程的一部分使用任一工具的安全性。
- en: Warning
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'One thing to note: any external tool running your schema changes for you will
    need to make entire copies of the table you are changing. The tool merely makes
    the process less impactful and does not require disruptive write locks, but only
    native DDL in MySQL can alter table schemas without a full table copy.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是：任何运行模式更改的外部工具都需要制作您正在更改的表的完整副本。该工具仅使该过程影响较小，不需要破坏性写锁定，但只有MySQL中的本机DDL才能在不进行完整表复制的情况下更改表模式。
- en: 'The major draw for `pt-online-schema-change` has been its stability and how
    long it’s been in use in the MySQL community. It primarily leverages triggers
    to enable changing schemas for tables of all sizes with very little impact to
    the database availability when switching to the new table version. But its core
    design also comes with trade-offs. Keep these things in mind when learning to
    use `pt-online-schema-change` to power your schema-deploy pipeline:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-online-schema-change`的主要吸引力在于其稳定性以及在MySQL社区中的长期使用。它主要利用触发器来实现对各种大小的表进行模式更改，对数据库可用性的影响非常小，当切换到新表版本时。但其核心设计也伴随着权衡。在学习如何使用`pt-online-schema-change`来支持您的模式部署流程时，请记住以下几点：'
- en: Triggers have limitations
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器有限制
- en: Before MySQL 8.0, you could not have more than one trigger with the same action
    on the same table. What does that mean? If you have a table named `sales`, and
    you already need to maintain an insert time trigger on it, MySQL before 8.0 does
    not allow another insert trigger on that table. If you try to run a `pt-online-schema-change`
    schema change against it, the tool will produce an error when it attempts to add
    the triggers it needs to function. Although we generally highly discourage using
    table triggers as part of your business logic, there will still be cases where
    legacy choices create a constraint and this becomes part of your trade-off calculation
    when choosing a schema-change mechanism.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0之前，您不能在同一表上有多个具有相同操作的触发器。这意味着什么？如果您有一个名为`sales`的表，并且您已经需要在其上维护一个插入时间触发器，MySQL在8.0之前不允许在该表上添加另一个插入触发器。如果尝试对其运行`pt-online-schema-change`模式更改，则当尝试添加所需的触发器时，该工具将产生错误。尽管我们通常强烈反对将表触发器作为业务逻辑的一部分，但仍会有情况下，遗留选择会创建约束，并且这将成为您选择模式更改机制时的权衡计算的一部分。
- en: Triggers have performance implications
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器会影响性能
- en: There are [some excellent benchmarks by Percona](https://oreil.ly/aGdKk) showing
    the performance impact of even having triggers defined on a table. This performance
    penalty may be invisible to most installations, but if you happen to be running
    your database instances at a very high transaction-per-second throughput rate,
    you may need to watch the impact of the triggers introduced by `pt-online-schema-change`
    more closely and tune it to abort more conservatively.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Percona 进行了[一些优秀的基准测试](https://oreil.ly/aGdKk)，显示即使在表上定义触发器也会产生性能影响。对于大多数安装来说，这种性能惩罚可能是看不见的，但如果您恰好在非常高的每秒事务吞吐率下运行数据库实例，您可能需要更仔细地观察
    `pt-online-schema-change` 引入的触发器的影响，并调整以更保守地中止。
- en: Running concurrent migrations
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行并发迁移
- en: Because of its use of triggers and the limitations of triggers in pre-8.0 MySQL,
    you will find that you cannot run multiple schema changes on the same table using
    `pt-online-schema-change`. This can be a minor inconvenience initially, but if
    you integrate the tool into a full schema-migration pipeline that’s automated,
    it can become a bottleneck for your teams.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其使用触发器以及在 MySQL 8.0 之前触发器的限制，您会发现无法使用 `pt-online-schema-change` 在同一张表上运行多个模式更改。这可能最初是一个小小的不便，但如果将该工具整合到一个完全自动化的模式迁移流水线中，它可能会成为团队的瓶颈。
- en: Constraints around foreign keys
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 外键约束
- en: Although the tool does have some level of support for schema changes with foreign
    keys in place, you will need to read the documentation carefully and determine
    which trade-off is the least impactful for your data and your transaction throughput.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该工具在存在外键的情况下对模式更改有一定程度的支持，但您需要仔细阅读文档，并确定哪种权衡对您的数据和事务吞吐量影响最小。
- en: '`gh-ost` was created by the data engineering team at GitHub specifically as
    a solution for managing the schema-change process without service impact but also
    without using triggers at all. Instead of using triggers to track changes during
    the table-copy phase, it connects as a replica to one of your cluster replicas
    and consumes row-based replication logs as a changelog.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`gh-ost` 是 GitHub 的数据工程团队专门为管理模式更改过程而创建的解决方案，旨在在不使用触发器的情况下管理模式更改过程，同时也不会对服务产生影响。在表复制阶段不使用触发器跟踪更改，而是作为副本连接到您的集群副本之一，并将基于行的复制日志作为更改日志消耗。'
- en: One thing you need to consider carefully about using `gh-ost` for schema changes
    is whether or not your existing database uses foreign keys. While `pt-online-schema-change`
    makes a solid attempt to support schema changes for tables that are the parent
    or child in a foreign-key relationship, it is a complex choice and full of trade-offs.
    (Do we sacrifice uptime for consistency? Or risk some window of possible inconsistency?)
    On the other hand, `gh-ost` mostly makes that choice for you and bails entirely
    if foreign keys exist in the table you are looking to alter. As the primary contributor
    on `gh-ost`, Shlomi Noach, explains in a long but very useful [blog post](https://oreil.ly/6A10o),
    the use of foreign keys and online schema change tools that are ultimately still
    external to the database engine create an environment where trade-offs are difficult
    to reason about, and he proposes not using foreign keys at all if you also require
    online schema changes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gh-ost` 进行模式更改时需要仔细考虑的一件事是您的现有数据库是否使用外键。虽然 `pt-online-schema-change` 试图支持父表或子表在外键关系中的模式更改，但这是一个复杂的选择，充满了权衡。
    （我们牺牲一致性来保证运行时间吗？还是冒一些可能不一致的风险？）另一方面，如果您要修改的表中存在外键，`gh-ost` 大多数情况下会为您做出选择并完全退出。作为
    `gh-ost` 的主要贡献者，Shlomi Noach 在一篇长篇但非常有用的[博文](https://oreil.ly/6A10o)中解释了使用外键和在线模式更改工具的环境，这些工具最终仍然是外部于数据库引擎，这种权衡很难理解，他建议如果您还需要在线模式更改，则根本不要使用外键。
- en: If you and your team are new to this task and are paving the way for CI of schema
    changes in your organization, we believe `gh-ost` is the better solution as long
    as you are also disciplined around not introducing foreign keys. Given its use
    of binary logs instead of triggers to track changes, we consider it the safer
    option where you don’t have to worry about triggers’ performance hit, it is far
    more agnostic to which version of MySQL you run (it can even work with statement-based
    replication with some caveats), and it has already been proven on large-scale
    deployments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您和您的团队对此任务还很陌生，并且正在为组织的模式更改 CI 铺平道路，我们认为 `gh-ost` 是更好的解决方案，只要您也有纪律不引入外键。考虑到它使用二进制日志而不是触发器来跟踪更改，我们认为它是更安全的选择，您不必担心触发器的性能损失，它更加不受您运行的
    MySQL 版本的影响（即使在某些情况下它甚至可以与基于语句的复制一起工作），并且它已经在大规模部署中得到验证。
- en: When is `pt-online-schema-change` the preferred option? If you are running a
    number of older databases where foreign keys already exist and removing them is
    a difficult proposal, you will find that `pt-online-schema-change` attempts a
    more expansive support for foreign keys, but you will have to carry the cognitive
    load of choosing the safest option for your data integrity and your uptime. Also,
    `gh-ost` leverages binary logs to do its work, so if those are inaccessible to
    the tool for some reason, `pt-online-schema-change` remains a viable option.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候 `pt-online-schema-change` 是首选选项？如果您运行一些旧数据库，其中已经存在外键并且删除它们是一个困难的提议，您会发现
    `pt-online-schema-change` 尝试更广泛地支持外键，但您必须承担选择对数据完整性和运行时间最安全的选项的认知负担。此外，`gh-ost`
    利用二进制日志来执行其工作，因此如果由于某种原因该工具无法访问这些日志，则 `pt-online-schema-change` 仍然是一个可行的选择。
- en: Ideally, someday we can all do online schema changes natively in MySQL, but
    that day is not here yet. Until then, the open source ecosystem has come a long
    way toward making schema changes a more easily automated process. Let’s talk about
    how to put all of these tools together for a fully fleshed CI/CD pipeline for
    schema changes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，总有一天我们都可以在 MySQL 中本地执行在线模式更改，但那一天还没有到来。在那之前，开源生态系统在使模式更改变得更容易自动化方面已经取得了长足的进步。让我们讨论如何将所有这些工具组合在一起，为模式更改的完全成熟的
    CI/CD 流水线。
- en: A CI/CD pipeline for schema changes
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于模式更改的 CI/CD 流水线
- en: 'Now that we have covered a number of tools, from tools that help manage schema
    definition versioning to tools for making the changes for you in production with
    minimal downtime, you can see that we have the pieces for a full continuous integration
    and deployment of schema changes that can remove a huge bottleneck for engineer
    productivity in your organization. Let’s put it all together:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了许多工具，从帮助管理模式定义版本控制的工具到在生产中进行更改并最小化停机时间的工具，您可以看到我们拥有完整的模式更改持续集成和部署的部件，这可以消除您组织中工程师生产力的一个巨大瓶颈。让我们把它整合起来：
- en: Organizing your schema source control
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 组织您的模式源控制
- en: First things first, you must start by separating each of your database clusters’
    schema definitions in a repository by itself. If the goal here is to provide flexibility
    for different teams to run their changes at different speeds, then it does not
    make sense to combine all the schema definitions of all your databases in one
    repository. This separation also allows each team to define different linting
    checks in the repository. Some teams may require a very specific character set
    and collation, and others are probably OK with the default. Flexibility for your
    partner teams here is key.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须通过将每个数据库集群的模式定义分开存储在一个存储库中���开始。如果这里的目标是为不同团队以不同速度运行其更改提供灵活性，那么将所有数据库的所有模式定义合并到一个存储库中是没有意义的。这种分离还允许每个团队在存储库中定义不同的linting检查。一些团队可能需要非常特定的字符集和排序规则，而其他团队可能对默认设置感到满意。这里合作伙伴团队的灵活性至关重要。
- en: Make sure to document the workflow of how an engineer in a feature team can
    go from a schema change on their laptop to one that is run on all environments
    and runs tests before going to production. A pull-request model here can be very
    useful for helping each team to define what tests to run when a schema change
    is requested, in an automated manner, before promoting and running the change
    in more environments or production.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 确保记录工程团队成员如何从他们的笔记本电脑上的模式更改到在所有环境上运行并在进入生产之前运行测试的工作流程。在这里，拉取请求模型可以非常有用，帮助每个团队定义请求模式更改时要运行的测试，以自动化方式在推广并在更多环境或生产中运行更改之前。
- en: A baseline configuration for safety
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性的基线配置
- en: Define a baseline configuration for your online schema change tool of choice.
    You are the team providing the tooling for partner teams that rely on you to give
    flexible, scalable, but also safe solutions. As you consider how you will implement
    the online schema change tool, it may be time to get opinionated about schema-design
    considerations that need to be part of testing schema change pull requests overall.
    For example, if you decide you prefer the safety of `gh-ost` and its trigger-free
    design, this will mean that you have to become a database platform free of foreign
    keys. Without going into the trade-offs of such a choice, if you do end up deciding
    “death to foreign keys,” then you should make sure that is encoded in how you
    test your schema changes in precommit hooks or in your Skeema repository, so you
    can avoid accidentally introducing undesirable schema changes too far into the
    environment hierarchy. Similarly, you should decide on a basic configuration for
    your online schema change tool that provides a basic safety net for how a change
    runs in production. Examples of what you may want to introduce in such a configuration
    include maximum MySQL threads running or maximum allowed system load. Repository
    templates can be a powerful tool to make the right thing the easy thing when any
    feature team is creating a new database and wants a repository to track and manage
    schema changes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为您选择的在线模式更改工具定义基线配置。您是为依赖您提供灵活、可扩展但也安全解决方案的合作伙伴团队提供工具的团队。在考虑如何实现在线模式更改工具时，可能是时候对需要成为测试模式更改拉取请求的模式设计考虑发表意见了。例如，如果您决定更喜欢`gh-ost`的安全性和无触发器设计，这意味着您必须成为一个不包含外键的数据库平台。不去讨论这种选择的权衡，如果最终决定“消灭外键”，那么您应该确保这一点被编码到您如何在预提交挂钩或您的Skeema存储库中测试模式更改的方式中，以便避免在环境层次结构中引入不良模式更改。同样，您应该为您的在线模式更改工具决定一个基本配置，为生产中的更改提供基本安全网。您可能希望在这种配置中引入的示例包括最大的MySQL线程运行或最大允许的系统负载。存储库模板可以是一个强大的工具，使正确的事情成为任何功能团队创建新数据库并希望跟踪和管理模式更改的存储库时的简单事情。
- en: Pipeline flexibility per team
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队的管道灵活性
- en: When you organize your schema definitions in a repository per database, you
    allow for maximum flexibility for each team that owns that database to decide
    how automated or person-managed its pipeline should be. One team could be still
    in the iteration phase for a new product, and they are OK with a schema pull request
    automatically promoting as long as the defined tests pass. Another team might
    own a more mission-critical database and require a more cautious approach, preferring
    an operator to approve the pull request before the CI system can promote it to
    the next environment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在存储库中为每个数据库组织模式定义时，您允许每个拥有该数据库的团队决定其管道应该是自动化还是人为管理的最大灵活性。一个团队可能仍处于新产品迭代阶段，只要定义的测试通过，他们就可以自动推广模式拉取请求。另一个团队可能拥有更加关键的数据库，并需要更加谨慎的方法，更倾向于在CI系统可以将其推广到下一个环境之前，要求操作员批准拉取请求。
- en: 'As you design how your organization achieves scalable schema-change deployments,
    keep your eye on the end goal: velocity that is coupled with safety for your growing
    engineering organization without the database engineering team being a bottleneck
    to how the company moves from ideas to features in production.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设计组织如何实现可扩展的模式更改部署时，保持目标在眼前：速度与安全性相结合，使您不断增长的工程组织在从想法到生产功能的公司移动中，数据库工程团队不成为瓶颈。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Good schema design is pretty universal, but of course MySQL has special implementation
    details to consider. In a nutshell, it’s a good idea to keep things as small and
    simple as you can. MySQL likes simplicity, and so will the people who have to
    work with your database. Keep these guidelines in mind:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的模式设计是相当普遍的，但当然MySQL有特殊的实现细节需要考虑。简而言之，尽可能保持事物简单和小型是个好主意。MySQL喜欢简单，与您的数据库一起工作的人也会喜欢。请记住以下准则：
- en: Try to avoid extremes in your design, such as a schema that will force enormously
    complex queries or tables with oodles and oodles of columns. (An oodle is somewhere
    between a scad and a gazillion.)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计时避免极端情况，比如会导致查询非常复杂或表格有大量列的模式。（一个“oodles”介于scad和gazillion之间。）
- en: Use small, simple, appropriate data types, and avoid `NULL` unless it’s actually
    the right way to model your data’s reality.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小型、简单、适当的数据类型，并避免使用`NULL`，除非它实际上是模拟数据现实的正确方式。
- en: Try to use the same data types to store similar or related values, especially
    if they’ll be used in a join condition.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用相同的数据类型来存储相似或相关的值，特别是如果它们将用于连接条件。
- en: Watch out for variable-length strings, which might cause pessimistic full-length
    memory allocation for temporary tables and sorting.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意变长字符串，可能会导致对临时表和排序进行悲观的全长内存分配。
- en: Try to use integers for identifiers if you can.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以的话，尽量使用整数作为标识符。
- en: Avoid the legacy MySQL-isms, such as specifying precisions for floating-point
    numbers or display widths for integers.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用传统的MySQL特性，比如为浮点数指定精度或为整数指定显示宽度。
- en: Be careful with `ENUM` and `SET`. They’re handy, but they can be abused, and
    they’re tricky sometimes. `BIT` is best avoided.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`ENUM`和`SET`要小心。它们很方便，但有时可能会被滥用，而且有时会很棘手。最好避免使用`BIT`。
- en: Database design is a science. If you’re strongly concerned with database design,
    consider using dedicated source material.^([8](ch06.html#ch01fn31))
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计是一门科学。如果您非常关注数据库设计，请考虑使用专门的源材料。^([8](ch06.html#ch01fn31))
- en: Also remember that your schema will evolve with both your business needs and
    what you learn from your users, and that means that having a robust software life
    cycle managing schema changes is a crucial part of making this evolution safe
    and scalable with your organization.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，您的模式将随着业务需求和从用户那里学到的东西而发展，这意味着具有管理模式更改的健壮软件生命周期是使这种演变对您的组织安全和可扩展的关键部分。
- en: ^([1](ch06.html#ch01fn24-marker)) Remember that the length is specified in characters,
    not bytes. A multibyte character set can require more than 1 byte to store each
    character.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#ch01fn24-marker)) 记住长度是以字符为单位指定的，而不是字节。多字节字符集可能需要超过1个字节来存储每个字符。
- en: ^([2](ch06.html#ch01fn25-marker)) Be careful with the `BINARY` type if the value
    must remain unchanged after retrieval. MySQL will pad it to the required length
    with `\0`s.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#ch01fn25-marker)) 如果值在检索后必须保持不变，请小心处理`BINARY`类型。MySQL会用`\0`填充到所需长度。
- en: ^([3](ch06.html#ch01fn26-marker)) Times are for relative comparison, as the
    speed of CPUs, memory, and other hardware changes over time.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#ch01fn26-marker)) 时间是用于相对比较的，因为CPU、内存和其他硬件的速度随时间变化。
- en: ^([4](ch06.html#ch01fn27-marker)) The rules for `TIMESTAMP` behavior are complex
    and have changed in various MySQL versions, so you should verify that you are
    getting the behavior you want. It’s usually a good idea to examine the output
    of `SHOW CREATE TABLE` after making changes to `TIMESTAMP` columns.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#ch01fn27-marker)) `TIMESTAMP`行为的规则复杂，并且在各个MySQL版本中有所更改，因此您应该验证您得到的行为是否符合您的要求。通常在对`TIMESTAMP`列进行更改后，检查`SHOW
    CREATE TABLE`的输出是个好主意。
- en: '^([5](ch06.html#ch01fn28-marker)) If you’re using the InnoDB storage engine,
    you may not be able to create foreign keys unless the data types match exactly.
    The resulting error message, “ERROR 1005 (HY000): Can’t create table,” can be
    confusing depending on the context, and questions about it come up often on MySQL
    mailing lists. (Oddly, you can create foreign keys between `VARCHAR` columns of
    different lengths.)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '^([5](ch06.html#ch01fn28-marker)) 如果使用InnoDB存储引擎，除非数据类型完全匹配，否则可能无法创建外键。由此产生的错误消息“ERROR
    1005 (HY000): Can’t create table”可能会令人困惑，具体情况取决于上下文，关于此问题的问题经常出现在MySQL邮件列表上。（奇怪的是，你可以在长度不同的`VARCHAR`列之间创建外键。）'
- en: ^([6](ch06.html#ch01fn29-marker)) On the other hand, for some very large tables
    with many writers, such pseudorandom values can actually help eliminate “hot spots.”
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.html#ch01fn29-marker)) 另一方面，对于一些有很多写入者的非常大的表，这种伪随机值实际上可以帮助消除“热点”。
- en: ^([7](ch06.html#ch01fn30-marker)) See the [MySQL documentation](https://oreil.ly/nFMKg)
    for more on this.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.html#ch01fn30-marker)) 查看[MySQL文档](https://oreil.ly/nFMKg)以获取更多信息。
- en: ^([8](ch06.html#ch01fn31-marker)) For another in-depth read, consider *Database
    Design for Mere Mortals* by Michael J. Hernandez (Pearson).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '^([8](ch06.html#ch01fn31-marker)) 想要深入阅读的话，可以考虑阅读迈克尔·J·赫尔南德斯（Pearson）的*Database
    Design for Mere Mortals*。 '
