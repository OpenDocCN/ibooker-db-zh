- en: Chapter 2\. Modeling and Designing Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。建模和设计数据库
- en: When implementing a new database, it’s easy to fall into the trap of quickly
    getting something up and running without dedicating adequate time and effort to
    the design. This carelessness frequently leads to costly redesigns and reimplementations
    down the road. Designing a database is like drafting the blueprints for a house;
    it’s silly to start building without detailed plans. Notably, good design allows
    you to extend the original building without pulling everything down and starting
    from scratch. And as you will see, bad designs are directly related to poor database
    performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施新数据库时，很容易陷入快速搭建并没有充分投入时间和精力进行设计的陷阱。这种粗心经常导致日后昂贵的重新设计和重新实施。设计数据库就像起草房子的蓝图；没有详细的计划就开始建造是愚蠢的。值得注意的是，良好的设计允许您扩展原始建筑，而无需拆除一切重新开始。正如您将看到的那样，糟糕的设计直接影响到数据库的性能不佳。
- en: How Not to Develop a Database
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何不开发数据库
- en: Database design is probably not the most exciting task in the world, but indeed
    it is becoming one of the most important ones. Before we describe how to go about
    the design process, let’s look at an example of database design on the run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计可能不是世界上最激动人心的任务，但确实成为了最重要的任务之一。在我们描述如何进行设计过程之前，让我们看一个动态设计数据库的例子。
- en: 'Imagine we want to create a database to store student grades for a university
    computer science department. We could create a `Student_Grades` table to store
    grades for each student and each course. The table would have columns for the
    given names and the surname of each student and each course they have taken, the
    course name, and the percentage result (shown as `Pctg`). We’d have a different
    row for each student for each of their courses:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们想为大学计算机科学系存储学生成绩的数据库。我们可以创建一个`Student_Grades`表，用于存储每个学生和每门课程的成绩。该表将为每位学生和他们所选课程的名字和姓氏，课程名称以及百分比结果（显示为`Pctg`）设置列。我们为每位学生的每门课程设置不同的行：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The list is nice and compact, we can easily access grades for any student or
    any course, and it looks similar to a spreadsheet. However, we could have more
    than one student with the same name. For instance, there are two entries for Susan
    Smith and the Computing Mathematics course in the sample data. Which Susan Smith
    got 75% and which got 80%? A common way to differentiate duplicate data entries
    is to assign a unique number to each entry. Here, we can assign a unique `StudentID`
    number to each student:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表很简洁，我们可以轻松访问任何学生或任何课程的成绩，看起来类似于电子表格。然而，我们可能会有多个同名学生。例如，示例数据中的Susan Smith和Computing
    Mathematics课程有两个条目。哪个Susan Smith获得了75%，哪个获得了80%？区分重复数据条目的常见方法是为每个条目分配唯一编号。在这里，我们可以为每个学生分配一个唯一的`StudentID`编号：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we know which Susan Smith got 80%: the one with the student ID number 12345303.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道哪个Susan Smith获得了80%：那位学生ID编号为12345303的Susan Smith。
- en: 'There’s another problem. In our table, John Paul Bloggs has two scores for
    the Computing Mathematics course: he failed it once with 43%, and then passed
    it with 65% on his second attempt. In a relational database, the rows form a set,
    and there is no implicit ordering between them. Looking at this table we might
    guess that the pass happened after the failure, but we can’t be sure. There’s
    no guarantee that the newer grade will appear after the older one, so we need
    to add information about when each grade was awarded, say by adding a year (`Year`)
    and semester (`Sem`):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个问题。在我们的表中，John Paul Bloggs在Computing Mathematics课程中有两个分数：他第一次以43%不及格，然后第二次以65%及格。在关系型数据库中，行形成一个集合，它们之间没有隐含的顺序。查看这张表时，我们可能会猜测通过发生在失败之后，但我们不能确定。不能保证更新的成绩会在较旧的成绩之后出现，因此我们需要添加每个成绩授予的时间信息，比如添加年份（`Year`）和学期（`Sem`）：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that the `Student_Grades` table has become a bit bloated. We’ve repeated
    the student ID, given names, and surname for every year. We could split up the
    information and create a `Student_Details` table:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Student_Grades`表变得有些臃肿。我们为每年重复了学生ID、名字和姓氏。我们可以拆分信息并创建一个`Student_Details`表：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And we could keep less information in the `Student_Grades` table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Student_Grades`表中保留更少的信息：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To look up a student’s grades, we would need to first look up their student
    ID from the `Student_Details` table and then read the grades for that student
    ID from the `Student_Grades` table.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找学生的成绩，我们首先需要从`Student_Details`表中查找他们的学生ID，然后从`Student_Grades`表中读取该学生ID的成绩。
- en: There are still issues we haven’t considered, though. For example, should we
    keep information on a student’s enrollment date, postal and email addresses, fees,
    or attendance? Should we store different types of postal addresses? How should
    we store addresses so that things don’t break when students change their addresses?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然有一些问题我们尚未考虑。例如，我们是否应该保留学生的入学日期、邮政地址和电子邮件地址、费用或出勤信息？我们应该如何存储地址以避免学生更改地址时出现问题？
- en: Implementing a database in this way is problematic; we keep running into things
    we hadn’t thought about and have to keep changing our database structure. We can
    save a lot of reworking by carefully documenting the requirements up front and
    then working through them to develop a coherent design.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实施数据库是有问题的；我们会不断遇到之前未考虑到的问题，并不得不不断更改我们的数据库结构。通过仔细记录需求并逐步解决它们以开发一致的设计，我们可以节省大量重复工作。
- en: The Database Design Process
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库设计过程
- en: 'There are three major stages in the database design, each producing a progressively
    lower-level description:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计有三个主要阶段，每个阶段都会产生一个逐步降低级别的描述：
- en: Requirements analysis
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需求分析
- en: First, we determine and write down what we need from the database, what data
    we will store, and how the data items relate to each other. In practice, this
    might involve a detailed study of the application requirements and talking to
    people in various roles that will interact with the database and application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定并写下了从数据库中所需的数据，我们将存储哪些数据以及数据项之间的关系。在实践中，这可能涉及详细研究应用程序需求，并与将与数据库和应用程序交互的各种角色的人员进行交谈。
- en: Conceptual design
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 概念设计
- en: Once we know the database requirements, we distill them into a formal description
    of the database design. Later in this chapter we’ll see how to use modeling to
    produce the conceptual design.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了数据库的需求，我们就会将它们提炼成数据库设计的正式描述。在本章的后面，我们将看到如何使用建模来产生概念设计。
- en: Logical design
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑设计
- en: Finally, we map the database design onto an existing database management system
    and database tables.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将数据库设计映射到现有的数据库管理系统和数据库表中。
- en: At the end of the chapter, we’ll look at how we can use the open source MySQL
    Workbench tool to convert the conceptual design to a MySQL database schema.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们将看看如何使用开源MySQL Workbench工具将概念设计转换为MySQL数据库模式。
- en: The Entity Relationship Model
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体关系模型
- en: At a basic level, databases store information about distinct objects, or *entities*,
    and the associations, or *relationships*, between these entities. For example,
    a university database might store information about students, courses, and enrollment.
    A student and a course are entities, whereas enrollment is a relationship between
    a student and a course. Similarly, an inventory and sales database might store
    information about products, customers, and sales. A product and a customer are
    entities, and a sale is a relationship between a customer and a product. It is
    common to get confused between entities and relationships when you’re starting
    out, and you may end up designing relationships as entities and vice versa. The
    best way to improve your database design skills is by practicing a lot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，数据库存储关于不同对象或*实体*及这些实体之间的关系或*关系*的信息。例如，大学数据库可能存储关于学生、课程和注册的信息。学生和课程是实体，而注册是学生和课程之间的关系。类似地，库存和销售数据库可能存储关于产品、客户和销售的信息。产品和客户是实体，销售是客户和产品之间的关系。在开始时，混淆实体和关系是很常见的，您可能会把关系设计为实体，反之亦然。提高数据库设计技能的最佳方法是多加练习。
- en: A popular approach to conceptual design uses the *Entity Relationship* (ER)
    model, which helps transform the requirements into a formal description of the
    entities and relationships in the database. We’ll start by looking at how the
    ER modeling process works and then observe it in [“Entity Relationship Modeling
    Examples”](#BAS-SEC-MODELING-EXAMPLES) for three sample databases.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一种流行的概念设计方法使用*实体关系*（ER）模型，帮助将需求转化为数据库中实体和关系的正式描述。我们将首先了解ER建模过程的工作原理，然后在[“实体关系建模示例”](#BAS-SEC-MODELING-EXAMPLES)中观察三个样本数据库的应用。
- en: Representing Entities
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体表示
- en: To help visualize the design, the ER modeling approach involves drawing an ER
    diagram. In the ER diagram, we represent an entity set by a rectangle containing
    the entity name. For our sales database example, our ER diagram would show the
    product and customer entity sets, as shown in [Figure 2-1](#FIG-DESIGN-ENTITY).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化设计，ER建模方法涉及绘制ER图。在ER图中，我们通过包含实体名称的矩形来表示实体集。对于我们的销售数据库示例，ER图将显示产品和客户实体集，如[图2-1](#FIG-DESIGN-ENTITY)所示。
- en: '![lm2e 0201](Images/lm2e_0201.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0201](Images/lm2e_0201.png)'
- en: Figure 2-1\. An entity set is represented by a named rectangle
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-1。实体集由一个命名的矩形表示
- en: We typically use the database to store specific characteristics, or *attributes*,
    of the entities. We could record the name, email address, postal address, and
    telephone number of each customer in a sales database. In a more elaborate customer
    relationship management (CRM) application, we could also store the names of the
    customer’s spouse and children, the languages the customer speaks, the customer’s
    history of interaction with our company, and so on. Attributes describe the entity
    they belong to.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用数据库来存储实体的特定特征或*属性*。在销售数据库中，我们可以记录每个客户的姓名、电子邮件地址、邮寄地址和电话号码。在更复杂的客户关系管理（CRM）应用程序中，我们还可以存储客户配偶和子女的姓名、客户所会说的语言、客户与公司互动的历史等信息。属性描述了它们所属的实体。
- en: We may form an attribute from smaller parts; for example, we compose a postal
    address from a street number, city, zip code, and country. We classify attributes
    as *composite* if they’re composed of smaller parts in this way, and as *simple*
    otherwise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从较小的部分形成属性；例如，我们将街道号码、城市、邮政编码和国家组成邮寄地址。如果属性是以这种方式由较小的部分组成的，则我们将其分类为*复合*属性；否则为*简单*属性。
- en: Some attributes can have multiple values for a given entity—for example, a customer
    can provide several telephone numbers, so the telephone number attribute is *multivalued*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性可以针对给定实体具有多个值——例如，一个客户可以提供多个电话号码，因此电话号码属性是*多值的*。
- en: Attributes help distinguish one entity from other entities of the same type.
    We could use the name attribute to differentiate between customers, but this could
    be an inadequate solution because several customers could have identical names.
    To tell them apart, we need an attribute (or a minimal combination of attributes)
    guaranteed to be unique to each customer. The identifying attribute or attributes
    form a unique key, and in this particular case, we call it a *primary key*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 属性有助于区分同一类型的实体。我们可以使用姓名属性来区分客户，但这可能是一个不够充分的解决方案，因为有几个客户可能具有相同的姓名。为了区分它们，我们需要一个保证每个客户都唯一的属性（或最小组合的属性）。这些唯一标识属性形成一个唯一键，特别情况下称为*主键*。
- en: In our example, we can assume that no two customers have the same email address,
    so the email address can be the primary key. However, when designing a database,
    we need to think carefully about the implications of our choices. For example,
    if we decide to identify customers by their email addresses, how will we handle
    a customer having multiple email addresses? Any applications we build to use this
    database might treat each email address as a separate person. It could be hard
    to adapt everything to allow people to have more than one. Using the email address
    as the key also means that every customer must have an email address; otherwise,
    we can’t distinguish between customers who don’t have one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以假设没有两个客户具有相同的电子邮件地址，因此电子邮件地址可以作为主键。然而，在设计数据库时，我们需要仔细考虑我们选择的影响。例如，如果我们决定通过电子邮件地址识别客户，我们将如何处理一个客户拥有多个电子邮件地址的情况？我们构建的任何应用程序可能会将每个电子邮件地址视为一个独立的人。难以适应所有人可以有多个电子邮件地址的情况。使用电子邮件地址作为键还意味着每个客户必须有一个电子邮件地址；否则，我们无法区分没有电子邮件地址的客户。
- en: Looking at the other attributes for one that can serve as an alternative key,
    we see that while it’s possible that two customers could have the same telephone
    number (and so we cannot use the telephone number as a key), it’s likely that
    people who have the same telephone number will not have the same name, so we can
    use the combination of the telephone number and the name as a composite key.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查看可以作为备用键的其他属性时，我们看到虽然两个客户可能具有相同的电话号码（因此不能将电话号码作为键），但可能拥有相同电话号码的人不会有相同的姓名，因此我们可以使用电话号码和姓名的组合作为复合键。
- en: Clearly, there may be several possible keys that could be used to identify an
    entity; we choose one of the alternatives, or *candidate* keys, to be our main
    or *primary* key. We usually choose based on how confident we are that the attribute
    will be nonempty and unique for each entity and how small the key is (shorter
    keys are faster to maintain and to use to perform lookup operations).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，可能有几个可能的键可以用来标识一个实体；我们选择其中一个备选键，或*候选键*，作为我们的主键。通常我们选择的标准是属性对于每个实体来说是否非空且唯一，并且键的长度多大（较短的键在维护和使用查找操作时更快）。
- en: In the ER diagram, attributes are represented as labeled ovals connected to
    their entity, as shown in [Figure 2-2](#FIG-DESIGN-CUSTOMER). Attributes comprising
    the primary key are shown underlined. The parts of any composite attributes are
    drawn connected to the composite attribute’s oval, and multivalued attributes
    are shown as double-lined ovals.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在ER图中，属性表示为标记的椭圆形与它们的实体连接，如[图 2-2](#FIG-DESIGN-CUSTOMER)所示。组成主键的属性显示为下划线。任何组合属性的部分都画在组合属性的椭圆形上，而多值属性显示为双线椭圆形。
- en: '![lm2e 0202](Images/lm2e_0202.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0202](Images/lm2e_0202.png)'
- en: Figure 2-2\. The ER diagram representation of the customer entity
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 客户实体的ER图表示
- en: Attribute values are chosen from a domain of legal values. For example, we could
    specify that a customer’s given names and surname attributes can each be a string
    of up to 100 characters, while a telephone number can be a string of up to 40
    characters. Similarly, a product price could be a positive rational number.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值是从合法值的域中选择的。例如，我们可以指定客户的名字和姓氏属性每个都可以是最多100个字符的字符串，而电话号码可以是最多40个字符的字符串。同样，产品价格可以是正有理数。
- en: Attributes can be empty; for example, some customers may not provide their telephone
    numbers. However, the primary key of an entity (including the components of a
    multiattribute primary key) must never be unknown (technically, it must be `NOT
    NULL`). So, if it’s possible for a customer to not provide an email address, we
    cannot use the email address as the key.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以是空的；例如，有些客户可能不提供他们的电话号码。但是，实体的主键（包括多属性主键的组成部分）绝不能是未知的（技术上来说，必须是`NOT NULL`）。因此，如果一个客户可能不提供电子邮件地址，我们就不能将电子邮件地址作为键。
- en: 'You should think carefully when classifying an attribute as multivalued: are
    all the values equivalent, or do they in fact represent different things? For
    example, when listing multiple telephone numbers for a customer, would they be
    more usefully labeled separately as the customer’s business phone number, home
    phone number, cell phone number, and so on?'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当将属性分类为多值时，你应该仔细思考：所有值是否等同，或者它们实际上代表了不同的事物？例如，当为客户列出多个电话号码时，它们是否更有用地分别标记为客户的办公电话号码、家庭电话号码、手机电话号码等？
- en: Let’s look at another example. The sales database requirements may specify that
    a product has a name and a price. We can see that the product is an entity because
    it’s a distinct object. However, the product’s name and price aren’t distinct
    objects; they’re attributes that describe the product entity. Note that if we
    want to have different prices for different markets, then the price is no longer
    just related to the product entity, and we will need to model it differently.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。销售数据库需求可能指定产品具有名称和价格。我们可以看到产品是一个实体，因为它是一个独立的对象。然而，产品的名称和价格不是独立的对象；它们是描述产品实体的属性。请注意，如果我们想为不同的市场设置不同的价格，则价格不再仅仅与产品实体相关，我们需要以不同的方式对其进行建模。
- en: 'For some applications, no combination of attributes can uniquely identify an
    entity (or it would be too unwieldy to use a large composite key), so we create
    an artificial attribute that’s defined to be unique and can therefore be used
    as a key: student numbers, Social Security numbers, driver’s license numbers,
    and library card numbers are examples of unique attributes created for various
    applications. In our inventory and sales application, it’s possible that we could
    stock different products with the same name and price. For example, we could sell
    two models of “Four-Port USB 2.0 Hub,” both at $4.95 each. To distinguish between
    products, we can assign a unique product ID number to each item we stock; this
    would be the primary key. Each product entity would have name, price, and product
    ID attributes. This is shown in the ER diagram in [Figure 2-3](#BAS-FIG-ER_TUTORIAL_PRODUCT).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，没有组合属性可以唯一标识一个实体（或者使用大型复合键将会太麻烦），因此我们创建了一个被定义为唯一的人造属性，可以作为键使用：学生编号、社会保障号码、驾驶证号码和图书卡号码是为各种应用程序创建的唯一属性的例子。在我们的库存和销售应用程序中，我们可能会存储名称和价格相同但型号不同的不同产品。例如，我们可以销售两款售价均为每件$4.95的“四口USB
    2.0集线器”。为了区分这些产品，我们可以为每个我们库存的物品分配一个唯一的产品ID号码；这将成为主键。每个产品实体将具有名称、价格和产品ID属性。这在ER图中显示为[图 2-3](#BAS-FIG-ER_TUTORIAL_PRODUCT)。
- en: '![lm2e 0203](Images/lm2e_0203.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0203](Images/lm2e_0203.png)'
- en: Figure 2-3\. The ER diagram representation of the product entity
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 产品实体的ER图表示
- en: Representing Relationships
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示关系
- en: Entities can participate in relationships with other entities. For example,
    a customer can buy a product, a student can take a course, an employee can have
    an address, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以参与与其他实体的关系。例如，客户可以购买产品，学生可以选修课程，员工可以有地址等等。
- en: 'Like entities, relationships can have attributes: we can define a sale to be
    a relationship between a customer entity (identified by the unique email address)
    and a given number of the product entity (identified by the unique product ID)
    that exists at a particular date and time (the timestamp).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像实体一样，关系也可以具有属性：我们可以定义销售关系为客户实体（通过唯一的电子邮件地址标识）和给定产品实体（通过唯一的产品ID标识）之间的关系，这些产品在特定的日期和时间（时间戳）存在。
- en: Our database could then record each sale and tell us, for example, that at 3:13
    p.m. on Wednesday, March 22, Marcos Albe bought one “Raspberry Pi 4,” one “500
    GB SSD M.2 NVMe,” and two sets of “2000 Watt 5.1 Channel Sub-Woofer Speakers.”
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库可以记录每笔销售，并告诉我们，例如在周三，3月22日下午3:13，Marcos Albe购买了一个“Raspberry Pi 4”，一个“500
    GB SSD M.2 NVMe”和两组“2000瓦5.1声道重低音喇叭”。
- en: Different numbers of entities can appear on each side of a relationship. For
    example, each customer can buy any number of products, and each product can be
    bought by any number of customers. This is known as a *many-to-many* relationship.
    We can also have *one-to-many* relationships. For example, one person can have
    several credit cards, but each credit card belongs to just one person. Looking
    at it the other way, a *one-to-many* relationship becomes a *many-to-one* relationship;
    for example, many credit cards belong to a single person. Finally, the serial
    number on a car engine is an example of a *one-to-one* relationship; each engine
    has just one serial number, and each serial number belongs to just one engine.
    We use the shorthand terms *1:1*, *1:N*, and *M:N* for one-to-one, one-to-many,
    and many-to-many relationships.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不同数量的实体可以出现在关系的每一侧。例如，每个客户都可以购买任意数量的产品，每个产品也可以被任意数量的客户购买。这被称为*多对多*关系。我们还可以有*一对多*关系。例如，一个人可以有多张信用卡，但每张信用卡只属于一个人。从另一个角度看，*一对多*关系变成了*多对一*关系；例如，多张信用卡属于一个人。最后，汽车发动机上的序列号是*一对一*关系的一个例子；每个发动机只有一个序列号，每个序列号只属于一个发动机。我们使用简写术语*1:1*，*1:N*和*M:N*分别表示一对一，一对多和多对多关系。
- en: The number of entities on either side of a relationship (the *cardinality* of
    the relationship) define the *key constraints* of the relationship. It’s important
    to think about the cardinality of relationships carefully. There are many relationships
    that may at first seem to be one-to-one, but turn out to be more complex. For
    example, people sometimes change their names; in some applications, such as police
    databases, this is of particular interest, and so it may be necessary to model
    a many-to-many relationship between a person entity and a name entity. Redesigning
    a database can be costly and time-consuming if you assume a relationship is simpler
    than it really is.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的每一侧的实体数量（关系的基数）定义了关系的*键约束*。仔细考虑关系的基数非常重要。有许多关系乍看起来可能是一对一的，但事实上更为复杂。例如，人们有时会更改他们的姓名；在一些应用程序中，如警方数据库，这尤为重要，因此可能需要对人实体和姓名实体之间建模为多对多的关系。如果假设关系比实际情况简单，重设计数据库可能会很昂贵且耗时。
- en: In an ER diagram, we represent a relationship set with a named diamond. The
    cardinality of the relationship is often indicated alongside the relationship
    diamond; this is the style we use in this book. (Another common style is to have
    an arrowhead on the line connecting the entity on the “1” side to the relationship
    diamond.) [Figure 2-4](#BAS-FIG-ER_TUTORIAL_BOUGHT) shows the relationship between
    the customer and product entities, along with the number and timestamp attributes
    of the sale relationship.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在ER图中，我们用一个带有名称的菱形表示关系集。关系的基数通常在关系菱形旁边标示；这是本书中使用的风格。（另一种常见的风格是在连接实体的“1”侧到关系菱形的线上有箭头头。）[图2-4](#BAS-FIG-ER_TUTORIAL_BOUGHT)展示了顾客和产品实体之间的关系，以及销售关系的数量和时间戳属性。
- en: '![lm2e 0204](Images/lm2e_0204.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0204](Images/lm2e_0204.png)'
- en: Figure 2-4\. The ER diagram representation of the customer and product entities,
    and the sale relationship between them
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4\. 顾客和产品实体之间的ER图表示，以及它们之间的销售关系
- en: Partial and Total Participation
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分和全参与
- en: Relationships between entities can be optional or compulsory. In our example,
    we could decide that a person is considered to be a customer only if they have
    bought a product. On the other hand, we could say that a customer is a person
    whom we know about and whom we hope might buy something—that is, we can have people
    listed as customers in our database who never buy a product. In the first case,
    the customer entity has *total participation* in the bought relationship (all
    customer have bought a product, and we can’t have a customer who hasn’t bought
    a product), while in the second case it has *partial participation* (a customer
    can buy a product). These are referred to as the *participation constraints* of
    the relationship. In an ER diagram, we indicate total participation with a double
    line between the entity box and the relationship diamond.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实体之间的关系可以是可选的或强制的。在我们的例子中，我们可以决定一个人只有在购买了产品后才被视为顾客。另一方面，我们也可以说顾客是我们知道并且希望可能购买东西的人，也就是说，在我们的数据库中可以列出从未购买产品的顾客。在第一种情况下，顾客实体在购买关系中具有*全参与*（所有顾客都购买了产品，我们不能有一个未购买产品的顾客），而在第二种情况下，它具有*部分参与*（顾客可以购买产品）。这些被称为关系的*参与约束*。在ER图中，我们用实体框和关系菱形之间的双线表示全参与。
- en: Entity or Attribute?
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体还是属性？
- en: 'From time to time, we encounter cases where we wonder whether an item should
    be an attribute or an entity on its own. For example, an email address could be
    modeled as an entity in its own right. When in doubt, consider these rules of
    thumb:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔我们会遇到这样的情况，我们在思考一个项目应该是属性还是自己的实体时会产生疑问。例如，电子邮件地址可以作为一个独立的实体进行建模。当有疑问时，请考虑以下经验法则：
- en: '*Is the item of direct interest to the database?*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*该项目是否直接关注数据库？*'
- en: Objects of direct interest should be entities, and information that describes
    them should be stored in attributes. Our inventory and sales database is really
    interested in customers, not their email addresses, so the email address would
    be best modeled as an attribute of the customer entity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 直接关注的对象应该是实体，并且描述它们的信息应该存储在属性中。我们的库存和销售数据库真正关心的是顾客，而不是他们的电子邮件地址，因此最好将电子邮件地址建模为顾客实体的属性。
- en: '*Does the item have components of its own?*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*项目本身是否有组成部分？*'
- en: If so, we must find a way of representing these components; a separate entity
    might be the best solution. In the student grades example at the start of the
    chapter, we stored the course name, year, and semester for each course that a
    student takes. It would be more compact to treat the course as a separate entity
    and to create a class ID number to identify each time a course is offered to students
    (the “offering”).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们必须找到一种表示这些组件的方法；一个独立的实体可能是最好的解决方案。在本章开头的学生成绩示例中，我们为每门学生选修的课程存储了课程名称、年份和学期。将课程视为一个独立的实体，并创建一个课程ID号来标识每次向学生提供课程（“提供”）可能更为紧凑。
- en: '*Can the object have multiple instances?*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象可以有多个实例吗？*'
- en: If so, we must find a way to store data on each instance. The cleanest way to
    do this is to represent the object as a separate entity. In our sales example,
    we must ask whether customers are allowed to have more than one email address;
    if they are, we should model the email address as a separate entity.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们必须找到一种方法来在每个实例上存储数据。最清晰的做法是将对象表示为一个独立的实体。在我们的销售示例中，我们必须询问客户是否允许拥有多个电子邮件地址；如果是的话，我们应该将电子邮件地址建模为一个独立的实体。
- en: '*Is the object often nonexistent or unknown?*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象经常不存在或未知吗？*'
- en: 'If so, it is effectively an attribute of only some of the entities, and it
    would be better to model it as a separate entity rather than as an attribute that
    is often empty. Consider a simple example: to store student grades for different
    courses, we could have an attribute for the student’s grade in every possible
    course, as shown in [Figure 2-5](#BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ATTRIBUTES).
    But because most students will have grades for only a few of these courses, it’s
    better to represent the grades as a separate entity set, as in [Figure 2-6](#BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ENTITY).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，它实际上只是一些实体的属性，并且最好将其建模为一个独立的实体，而不是经常为空的属性。考虑一个简单的例子：为了存储学生在不同课程中的成绩，我们可以在每门可能的课程中为学生的成绩设置一个属性，如[图
    2-5](#BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ATTRIBUTES)所示。但是因为大多数学生只会在其中几门课程中有成绩，所以最好将成绩表示为一个独立的实体集，如[图
    2-6](#BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ENTITY)所示。
- en: '![lm2e 0205](Images/lm2e_0205.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0205](Images/lm2e_0205.png)'
- en: Figure 2-5\. The ER diagram representation of student grades as attributes of
    the student entity
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 将学生成绩表示为学生实体的ER图
- en: '![lm2e 0206](Images/lm2e_0206.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0206](Images/lm2e_0206.png)'
- en: Figure 2-6\. The ER diagram representation of student grades as a separate entity
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 学生成绩的实体关系图表示
- en: Entity or Relationship?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体还是关系？
- en: An easy way to decide whether an object should be an entity or a relationship
    is to map nouns in the requirements to entities, and map verbs to relationships.
    For example, in the statement “A degree program is made up of one or more courses,”
    we can identify the entities “program” and “course,” and the relationship “is
    made up of.” Similarly, in the statement “A student enrolls in one program,” we
    can identify the entities “student” and “program,” and the relationship “enrolls
    in.” Of course, we can choose different terms for entities and relationships than
    those that appear in the relationships, but it’s a good idea not to deviate too
    far from the naming conventions used in the requirements so that the design can
    be checked against the requirements. All else being equal, try to keep the design
    simple, and avoid introducing trivial entities where possible. That is, there’s
    no need to have a separate entity for the student’s enrollment when we can model
    it as a relationship between the existing student and program entities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确定对象应该是实体还是关系的一个简单方法是将需求中的名词映射到实体，并将动词映射到关系。例如，在语句“A degree program is made
    up of one or more courses”中，我们可以识别实体“program”和“course”，以及关系“is made up of”。类似地，在语句“A
    student enrolls in one program”中，我们可以识别实体“student”和“program”，以及关系“enrolls in”。当然，我们可以选择不同于出现在关系中的实体和关系的术语，但最好不要偏离需求中使用的命名约定，以便可以根据需求检查设计。在其他一切相等的情况下，尽量保持设计简单，并尽量避免引入不必要的实体。也就是说，在我们可以将其建模为现有学生和项目实体之间的关系时，没有必要为学生的注册单独引入一个独立的实体。
- en: Intermediate Entities
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间实体
- en: It is often possible to conceptually simplify a many-to-many relationship by
    replacing it with a new *intermediate* entity (sometimes called an *associate*
    entity) and connecting the original entities through a many-to-one and a one-to-many
    relationship.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用一个新的*中间*实体（有时称为*关联*实体）替换它，通过多对一和一对多关系连接原始实体，通常可以在概念上简化多对多关系。
- en: 'Consider this statement: “A passenger can book a seat on a flight.” This is
    a many-to-many relationship between the entities “passenger” and “flight.” The
    related ER diagram fragment is shown in [Figure 2-7](#BAS-FIG-ER_TUTORIAL_BOOKING).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个声明：“一个乘客可以预订一个航班的座位。”这是“乘客”和“航班”之间的多对多关系。相关的ER图片段显示在[图2-7](#BAS-FIG-ER_TUTORIAL_BOOKING)中。
- en: '![lm2e 0207](Images/lm2e_0207.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0207](Images/lm2e_0207.png)'
- en: Figure 2-7\. A passenger participates in an M:N relationship with a flight
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-7\. 乘客参与M:N关系的航班
- en: 'However, let’s look at this from both sides of the relationship:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们从关系的两个方面来看：
- en: Any given flight can have many passengers with a booking.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何给定的航班都可以有多名预订乘客。
- en: Any given passenger can have bookings on many flights.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何给定的乘客都可以在多个航班上预订。
- en: 'Hence, we can consider the many-to-many relationship to be in fact two one-to-many
    relationships, one each way. This points us to the existence of a hidden intermediate
    entity, the booking, between the flight and passenger entities. The requirement
    could be better worded as: “A passenger can make a booking for a seat on a flight.”
    The updated ER diagram fragment is shown in [Figure 2-8](#BAS-FIG-ER_TUTORIAL_INTERMEDIATE).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以认为多对多关系实际上是两个单对多关系，各自的一条。这指向了一个隐藏的中间实体存在，即预订，在航班和乘客实体之间。需求可以更好地表述为：“一个乘客可以为一个航班预订座位。”更新后的ER图片段显示在[图2-8](#BAS-FIG-ER_TUTORIAL_INTERMEDIATE)中。
- en: '![lm2e 0208](Images/lm2e_0208.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0208](Images/lm2e_0208.png)'
- en: Figure 2-8\. The intermediate booking entity between the passenger and flight
    entities
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-8\. 位于乘客和航班实体之间的中间预订实体
- en: Each passenger can be involved in multiple bookings, but each booking belongs
    to a single passenger, so the cardinality of this relationship is 1:N. Similarly,
    there can be many bookings for a given flight, but each booking is for a single
    flight, so this relationship also has cardinality 1:N. Since each booking must
    be associated with a particular passenger and flight, the booking entity participates
    totally in the relationships with these entities (as described in [“Partial and
    Total Participation”](#SEC-PartialTotalParticipation) on page 77). This total
    participation could not be captured effectively in the representation in [Figure 2-7](#BAS-FIG-ER_TUTORIAL_BOOKING).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每位乘客可以参与多个预订，但每个预订只属于一位乘客，因此此关系的基数是1:N。类似地，一个给定航班可以有多个预订，但每个预订只属于一架航班，所以这个关系也有1:N的基数。由于每个预订必须与特定的乘客和航班相关联，预订实体在与这些实体的关系中完全参与（如第77页的[“部分和完全参与”](#SEC-PartialTotalParticipation)中描述的）。在[图2-7](#BAS-FIG-ER_TUTORIAL_BOOKING)的表示中无法有效捕捉这种完全参与。
- en: Weak and Strong Entities
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱实体和强实体
- en: Context is very important in our daily interactions; if we know the context,
    we can work with a much smaller amount of information. For example, we generally
    call family members by only their first name or nickname. Where ambiguity exists,
    we add further information such as the surname to clarify our intent. In database
    design, we can omit some key information for entities that are dependent on other
    entities. For example, if we wanted to store the names of our customers’ children,
    we could create a child entity and store only enough key information to identify
    it in the context of its parent. We could simply list a child’s first name on
    the assumption that a customer will never have several children with the same
    first name. Here, the child entity is a *weak* entity, and its relationship with
    the customer entity is called an *identifying relationship*. Weak entities participate
    totally in the identifying relationship, since they can’t exist in the database
    independently of their owning entity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们日常互动中，背景信息非常重要；如果了解背景，我们就可以处理更少量的信息。例如，我们通常只用名字或昵称称呼家庭成员。在存在歧义时，我们会添加更多信息，比如姓氏，以澄清我们的意图。在数据库设计中，我们可以省略某些依赖于其他实体的关键信息。例如，如果我们想存储客户孩子的名字，我们可以创建一个子实体，并且仅存储足够的关键信息以在其父实体的上下文中标识它。我们可以简单地列出孩子的名字，假设客户不会有几个同名的孩子。在这里，子实体是*弱*实体，它与客户实体的关系被称为*标识关系*。弱实体完全参与标识关系，因为它们无法独立于所属实体存在于数据库中。
- en: In the ER diagram, we show weak entities and identifying relationships with
    double lines and the partial key of a weak entity with a dashed underline, as
    in [Figure 2-9](#BAS-FIG-ER_TUTORIAL_WEAK). A weak entity is uniquely identified
    in the context of its owning (or *strong*) entity, and so the full key for a weak
    entity is the combination of its own (partial) key with the key of its owning
    entity. To uniquely identify a child in our example, we need the first name of
    the child and the email address of the child’s parent.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在ER图中，我们用双线显示弱实体和标识关系，并用虚线下划线表示弱实体的部分键，如[图 2-9](#BAS-FIG-ER_TUTORIAL_WEAK)所示。在其拥有（或*强*）实体的上下文中，弱实体可以唯一标识，因此弱实体的完整键是其自身（部分）键与其拥有实体的键的组合。例如，在我们的示例中唯一标识子实体需要子实体的名字和父母的电子邮件地址。
- en: '[Figure 2-10](#BAS-FIG-ER_TUTORIAL_LEGEND) shows a summary of the symbols we’ve
    explained for ER diagrams.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-10](#BAS-FIG-ER_TUTORIAL_LEGEND)显示了我们为ER图解释的符号总结。'
- en: '![lm2e 0209](Images/lm2e_0209.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0209](Images/lm2e_0209.png)'
- en: Figure 2-9\. The ER diagram representation of a weak entity
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-9\. 弱实体的ER图表示
- en: '![lm2e 0210](Images/lm2e_0210.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0210](Images/lm2e_0210.png)'
- en: Figure 2-10\. A summary of the ER diagram symbols
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-10\. ER图符号的总结
- en: Database Normalization
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库规范化
- en: Database normalization is an important concept when designing the relational
    data structure. Dr. Edgar F. Codd, the inventor of the relational database model,
    proposed the normal forms in the early ’70s, and these are still widely used by
    the industry nowadays. Even with the advent of the NoSQL databases, there is no
    evidence in the short or medium term that relational databases will disappear
    or that the normal forms will fall into disuse.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库规范化是设计关系数据结构时的重要概念。关系数据库模型的发明者埃德加·F·科德博士在70年代初提出了这些规范形式，现在仍被广泛应用于行业。即使随着NoSQL数据库的出现，短期或中期内也没有证据表明关系数据库会消失或规范形式会不再使用。
- en: The main objective of the normal forms is to reduce data redundancy and improve
    data integrity. Normalization also facilitates the process of redesigning and
    extending the database structure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 规范形式的主要目标是减少数据冗余并提高数据完整性。规范化还便于重设计和扩展数据库结构的过程。
- en: Officially, there are six normal forms, but most database architects deal only
    with the first three forms. That is because the normalization process is progressive,
    and we cannot achieve a higher level of database normalization unless the previous
    levels have been satisfied. Using all six norms constricts the database model
    too much, however, and in general, they become very complex to implement.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正式地说，有六个规范形式，但大多数数据库架构师只处理前三种形式。这是因为规范化过程是渐进的，除非满足了前几个级别，否则无法达到更高级别的数据库规范化。使用所有六种规范形式会过于束缚数据库模型，并且一般情况下，它们实现起来非常复杂。
- en: 'In real workloads, usually there are performance issues. This is one reason
    for extract, transform, load (*ETL*) jobs to exist: they denormalize the data
    to process it.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际工作负载中，通常会出现性能问题。这是提取、转换和加载（*ETL*）作业存在的一个原因：它们对数据进行去规范化以处理它。
- en: 'Let’s take a look at the first three normal forms:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看前三个范式：
- en: The first normal form (*1NF*) has the following goals
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一范式（*1NF*）的目标如下
- en: Eliminate repeating groups in individual tables.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除各个表中的重复组
- en: Create a separate table for each set of related data.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每组相关数据创建单独的表。
- en: Identify each set of related data with a primary key.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主键标识每组相关数据。
- en: If a relation contains composite or multivalued attributes, it violates the
    first normal form. Conversely, a relation is in first normal form if it does not
    contain any composite or multivalued attributes. So, a relation is in first normal
    form if every attribute in that relation has a single value of the appropriate
    type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个关系包含复合或多值属性，则违反了第一范式。反之，如果一个关系不包含任何复合或多值属性，则处于第一范式中。因此，如果该关系中的每个属性都具有适当类型的单个值，则该关系处于第一范式中。
- en: The goals of second normal form (*2NF*) are
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二范式（*2NF*）的目标是
- en: Create separate tables for sets of values that apply to multiple records.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为适用于多个记录的值集创建单独的表。
- en: Relate these tables with a foreign key.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用外键将这些表关联起来。
- en: Records should not depend on anything other than a table’s primary key (a compound
    key, if necessary).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记录不应依赖于除表的主键（必要时是复合键）之外的任何内容。
- en: Third normal form (*3NF*) adds one more goal
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第三范式（*3NF*）增加了一个目标
- en: Eliminate fields that do not depend on the key.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除不依赖于键的字段。
- en: Values in a record that are not part of that record’s key do not belong in the
    table. In general, any time the contents of a group of fields may apply to more
    than a single record in the table, you should consider placing those fields in
    a separate table.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 记录中的值如果不是记录的关键字，则不应该在表中。一般情况下，如果一组字段的内容可能适用于表中多个记录，则应考虑将这些字段放入单独的表中。
- en: Table 2-1 lists the normal forms, from the least normalized to the most normalized.
    The unnormalized form (UNF) is a database model that does not meet any of the
    database normalization conditions. Other normalization forms exist, but they are
    beyond the scope of this discussion.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1列出了从最不归一化到最归一化的各种范式。未归一化形式（UNF）是一个不符合数据库归一化条件的数据库模型。还有其他的归一化形式，但它们超出了本讨论的范围。
- en: Table 2-1\. The normal forms (from least to most normalized)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1. 各种范式（从最不归一化到最归一化）
- en: '|  | UNF (1970) | 1NF (1970) | 2NF (1971) | 3NF (1971) | 4NF (1977) | 5NF (1979)
    | 6NF (2003) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  | UNF（1970年） | 1NF（1970年） | 2NF（1971年） | 3NF（1971年） | 4NF（1977年） | 5NF（1979年）
    | 6NF（2003年） |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| Primary key (no duplicate tuples) | Maybe | Yes | Yes | Yes | Yes | Yes |
    Yes |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 主键（无重复元组） | 可能 | 是 | 是 | 是 | 是 | 是 | 是 |'
- en: '| No repeating groups | No | Yes | Yes | Yes | Yes | Yes | Yes |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 无重复组 | 否 | 是 | 是 | 是 | 是 | 是 | 是 |'
- en: '| Atomic columns (cells have single value) | No | Yes | Yes | Yes | Yes | Yes
    | Yes |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 原子列（单元格只有单一值） | 否 | 是 | 是 | 是 | 是 | 是 | 是 |'
- en: '| Every nontrivial functional dependency either does not begin with a proper
    subset of a candidate key or ends with a prime attribute (no partial functional
    dependencies of nonprime attributes on candidate keys) | No | No | Yes | Yes |
    Yes | Yes | Yes |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 每个非平凡的功能依赖要么不以候选键的真子集开始，要么以主属性结尾（不允许非主属性对候选键的部分功能依赖） | 否 | 否 | 是 | 是 | 是
    | 是 | 是 |'
- en: '| Every nontrivial functional dependency begins with a superkey or ends with
    a prime attribute (no transitive functional dependencies of nonprime attributes
    on candidate keys) | No | No | No | Yes | Yes | Yes | Yes |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 每个非平凡的功能依赖要么以超键开始，要么以主属性结尾（不允许非主属性对候选键的传递功能依赖） | 否 | 否 | 否 | 是 | 是 | 是 |
    是 |'
- en: '| Every nontrivial functional dependency either begins with a superkey or ends
    with an elementary prime attribute | No | No | No | No | Yes | Yes | N/A |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 每个非平凡的功能依赖要么以超键开始，要么以基本主属性结尾 | 否 | 否 | 否 | 否 | 是 | 是 | 不适用 |'
- en: '| Every nontrivial functional dependency begins with a superkey | No | No |
    No | No | Yes | Yes | N/A |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 每个非平凡的功能依赖都以超键开始 | 否 | 否 | 否 | 否 | 是 | 是 | 不适用 |'
- en: '| Every nontrivial multivalued dependency begins with a superkey | No | No
    | No | No | Yes | Yes | N/A |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 每个非平凡的多值依赖都以超键开始 | 否 | 否 | 否 | 否 | 是 | 是 | 不适用 |'
- en: '| Every join dependency has a superkey component | No | No | No | No | No |
    Yes | N/A |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 每个连接依赖都有一个超键组件 | 否 | 否 | 否 | 否 | 否 | 是 | 不适用 |'
- en: '| Every join dependency has only superkey components | No | No | No | No |
    No | Yes | N/A |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 每个连接依赖只有超键组件 | 否 | 否 | 否 | 否 | 否 | 是 | 不适用 |'
- en: '| Every constraint is a consequence of domain constraints and key constraints
    | No | No | No | No | No | No | N/A |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 每个约束都是领域约束和关键约束的结果 | 否 | 否 | 否 | 否 | 否 | 否 | 不适用 |'
- en: '| Every join dependency is trivial | No | No | No | No | No | No | Yes |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 每个连接依赖都是平凡的 | 否 | 否 | 否 | 否 | 否 | 否 | 是 |'
- en: Normalizing an Example Table
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归一化示例表
- en: To make these concepts clearer let’s walk through an example of normalizing
    a fictional student table.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这些概念，让我们通过一个虚构的学生表的归一化示例来详细讨论。
- en: 'We’ll start with the unnormalized table:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从未归一化的表开始：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First Normal Form: No Repeating Groups'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一范式：无重复组
- en: Tables should have only a single field for each attribute. Since one student
    has several classes, these classes should be listed in a separate table. The fields
    `Class1`, `Class2`, and `Class3` in our unnormalized table are indications of
    design trouble.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性应该在表中只有一个字段。因为一个学生有多门课程，这些课程应该在单独的表中列出。在我们未归一化的表中，字段`Class1`，`Class2`和`Class3`表明设计存在问题。
- en: 'Spreadsheets often have multiple fields for the same attribute (e.g., `address1`,
    `address2`, `address3`), but tables should not. Here’s another way to look at
    this problem: with a one-to-many relationship, don’t put the one side and the
    many side in the same table. Instead, create another table in first normal form
    by eliminating the repeating group—for example, with `Class#`, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格通常对同一属性有多个字段（例如 `address1`、`address2`、`address3`），但表不应如此。在一个一对多关系中，不要将一方和多方放在同一表中。而是通过消除重复组来创建第一范式中的另一个表，例如
    `Class#`，如下所示：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Second Normal Form: Eliminate Redundant Data'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二范式：消除冗余数据
- en: Note the multiple `Class#` values for each `Student#` value in the previous
    table. `Class#` is not functionally dependent on `Student#` (the primary key),
    so this relationship is not in second normal form.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前表中每个 `Student#` 值的多个 `Class#` 值。`Class#` 不是对 `Student#`（主键）的功能依赖，因此这种关系不符合第二范式。
- en: 'The following two tables demonstrate the conversion to second normal form.
    We now have a `Students` table:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面两张表演示了转换为第二范式。我们现在有一个 `Students` 表：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'and a `Registration` table:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `Registration` 表：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Third Normal Form: Eliminate Data Not Dependent on Key'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三范式：消除不依赖于键的数据
- en: In the previous example, `Adv-Room` (the advisor’s office number) is functionally
    dependent on the `Advisor` attribute. The solution is to move that attribute from
    the `Students` table to a `Faculty` table, as shown next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Adv-Room`（顾问的办公室号码）对 `Advisor` 属性具有功能依赖。解决方案是将该属性从 `Students` 表移至 `Faculty`
    表，如下所示。
- en: 'The `Students` table now looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Students` 表现在看起来像这样：'
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here’s the `Faculty` table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Faculty` 表：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Entity Relationship Modeling Examples
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体关系建模示例
- en: In the previous sections, we walked though hypothetical examples to help you
    understand the basics of database design, ER diagrams, and normalization. Now
    we’re going to look at some ER examples from sample databases available for MySQL.
    To visualize the ER diagrams, we are going to use [*MySQL Workbench*](https://oreil.ly/1971c).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中，我们通过假设示例帮助您了解数据库设计、ER 图和规范化的基础知识。现在我们将看一些 MySQL 可用示例数据库中的 ER 示例以可视化 ER
    图。为了可视化 ER 图，我们将使用 [*MySQL Workbench*](https://oreil.ly/1971c)。
- en: MySQL Workbench uses a physical ER representation. Physical ER diagram models
    are more granular, showing the processes necessary to add information to a database.
    Rather than using symbols, we use tables in the ER diagram, making it closer to
    the real database. MySQL Workbench goes one step further and uses *enhanced entity-relationship
    (EER) diagrams*. EER diagrams are an expanded version of ER diagrams.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Workbench 使用物理 ER 表示。物理 ER 图模型更加细粒度化，显示向数据库添加信息所需的过程。与使用符号不同，我们在 ER 图中使用表，使其更接近真实数据库。MySQL
    Workbench 更进一步使用 *增强实体-关系（EER）图*。EER 图是 ER 图的扩展版本。
- en: 'We won’t go into all the details, but the main advantage of an EER diagram
    is that it provides all the elements of an ER diagram while adding support for:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论，但 EER 图的主要优点是，它提供了 ER 图的所有元素，并增加了对以下内容的支持：
- en: Attribute and relationship inheritance
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和关系继承
- en: Category or union types
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别或联合类型
- en: Specialization and generalization
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业化和泛化
- en: Subclasses and superclasses
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类和超类
- en: Let’s start with the process to download the sample databases and visualize
    their EER diagrams in MySQL Workbench.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下载示例数据库并在 MySQL Workbench 中可视化其 EER 图的过程开始。
- en: 'The first one we’ll use is the `sakila` database. Development of this database
    began in 2005\. Early designs were based on the database used in the Dell whitepaper
    [“Three Approaches to MySQL Applications on Dell PowerEdge Servers”](https://oreil.ly/aDDlO),
    which was designed to represent an online DVD store. Similarly, the `sakila` sample
    database is designed to represent a DVD rental store, and it borrows film and
    actor names from the Dell sample database. You can use the following commands
    to import the `sakila` database to your MySQL instance:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的第一个是 `sakila` 数据库。该数据库的开发始于2005年。早期设计基于戴尔白皮书 [“三种在戴尔 PowerEdge 服务器上使用
    MySQL 应用的方法”](https://oreil.ly/aDDlO)，该白皮书设计用于代表在线 DVD 商店。类似地，`sakila` 示例数据库设计用于代表
    DVD 租赁店，并借用了戴尔示例数据库的电影和演员名称。您可以使用以下命令将 `sakila` 数据库导入到您的 MySQL 实例中：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`sakila` also provides the EER model, in the *sakila.mwb* file. You can open
    the file with MySQL Workbench, as shown in [Figure 2-11](#FIG-SAKILA-ER).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`sakila`还提供了EER模型，在*sakila.mwb*文件中。您可以使用MySQL Workbench打开该文件，如[图 2-11](#FIG-SAKILA-ER)所示。'
- en: '![lm2e 0211](Images/lm2e_0211.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0211](Images/lm2e_0211.png)'
- en: Figure 2-11\. The `sakila` database EER model; note the physical representation
    of the entities instead of using symbols
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-11\. `sakila`数据库的EER模型；注意实体的物理表示而不是使用符号
- en: Next is the `world` database, which uses sample data from [Statistics Finland](https://oreil.ly/0Y9tZ).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`world`数据库，使用来自[芬兰统计局](https://oreil.ly/0Y9tZ)的样本数据。
- en: 'The following commands will import the `world` database to your MySQL instance:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将`world`数据库导入到您的MySQL实例中：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `world` database does not come with an EER file as `sakila` does, but you
    can create the EER model from the database using MySQL Workbench. To do this,
    select Reverse Engineer from the Database menu, as in [Figure 2-12](#FIG-WOKBENCH-REVERSE).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`world`数据库没有像`sakila`那样的EER文件，但是您可以使用MySQL Workbench从数据库创建EER模型。要执行此操作，请从数据库菜单中选择反向工程，如[图 2-12](#FIG-WOKBENCH-REVERSE)所示。'
- en: '![lm2e 0212](Images/lm2e_0212.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0212](Images/lm2e_0212.png)'
- en: Figure 2-12\. Reverse engineering from the `world` database
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-12\. 从`world`数据库进行反向工程
- en: Workbench will connect to the database (if not connected already) and prompt
    you to choose the schema you want to reverse engineer, as shown in [Figure 2-13](#FIG-WORKBENCH-CHOOSE).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Workbench将连接到数据库（如果尚未连接），并提示您选择要反向工程的模式，如[图 2-13](#FIG-WORKBENCH-CHOOSE)所示。
- en: Click Continue, and then click Execute on the next screen, shown in [Figure 2-14](#FIG-WORKBENCH-FORWARDENG).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“继续”，然后在下一个屏幕上点击“执行”，如[图 2-14](#FIG-WORKBENCH-FORWARDENG)所示。
- en: '![lm2e 0213](Images/lm2e_0213.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0213](Images/lm2e_0213.png)'
- en: Figure 2-13\. Choosing the schema
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-13\. 选择模式
- en: '![lm2e 0214](Images/lm2e_0214.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0214](Images/lm2e_0214.png)'
- en: Figure 2-14\. Click *Execute* to start the reverse-engineering process
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-14\. 点击*执行*以启动反向工程过程
- en: This produces the ER model for the `world` database, shown in [Figure 2-15](#FIG-WORLD-ER).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了`world`数据库的ER模型，如[图 2-15](#FIG-WORLD-ER)所示。
- en: '![lm2e 0215](Images/lm2e_0215.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0215](Images/lm2e_0215.png)'
- en: Figure 2-15\. The ER model for the `world` database
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-15\. `world`数据库的ER模型
- en: The last database you’ll import is the `employees` database. Fusheng Wang and
    Carlo Zaniolo created the [original data](https://oreil.ly/1rvPc) at Siemens Corporate
    Research. Giuseppe Maxia made the relational schema, and Patrick Crews exported
    the data in relational format.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您将导入的最后一个数据库是`employees`数据库。Fusheng Wang和Carlo Zaniolo在Siemens Corporate Research创建了[原始数据](https://oreil.ly/1rvPc)，Giuseppe
    Maxia制作了关系模式，Patrick Crews以关系格式导出了数据。
- en: 'To import the database, first you need to clone the Git repository:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入数据库，首先您需要克隆Git仓库：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then you can use the reverse engineering procedure in MySQL Workbench again
    to create the ER model for the `employees` database, as shown in [Figure 2-16](#FIG-EMPLOYEE-ER).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以再次使用MySQL Workbench的反向工程过程为`employees`数据库创建ER模型，如[图 2-16](#FIG-EMPLOYEE-ER)所示。
- en: '![lm2e 0216](Images/lm2e_0216.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0216](Images/lm2e_0216.png)'
- en: Figure 2-16\. The ER model for the `employees` database
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-16\. `employees`数据库的ER模型
- en: It is important that you carefully review the ER models shown here so you understand
    the relationships between entities and their attributes. Once the concepts are
    solidified, start practicing. You will see how to do that in the next section.
    We’ll show you how to create a database on your MySQL server in [Chapter 4](ch04.xhtml#CH4_MODIFY).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须仔细审查此处显示的ER模型，以便理解实体及其属性之间的关系。一旦概念确立，开始实践。在下一节中，我们将向您展示如何在您的MySQL服务器上创建数据库，详见[第4章](ch04.xhtml#CH4_MODIFY)。
- en: Using the Entity Relationship Model
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实体关系模型
- en: This section looks at the steps required to create an ER model and deploy it
    into database tables. We saw previously that MySQL Workbench lets us reverse engineer
    an existing database. But how do we model a new database and deploy it? We can
    automate this process with the MySQL Workbench tool.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论创建ER模型并将其部署到数据库表所需的步骤。我们之前看到MySQL Workbench允许我们对现有数据库进行反向工程。但是，如何建模新数据库并部署它呢？我们可以使用MySQL
    Workbench工具自动化这个过程。
- en: Mapping Entities and Relationships to Database Tables
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实体和关系映射到数据库表
- en: When converting an ER model to a database schema, we work through each entity
    and then through each relationship according to the rules discussed in the following
    sections to end up with a set of database tables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在将ER模型转换为数据库模式时，我们根据以下部分讨论的规则处理每个实体，然后处理每个关系，以最终得到一组数据库表。
- en: Map the entities to database tables
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将实体映射到数据库表
- en: For each strong entity, create a table comprising its attributes and designate
    the primary key. The parts of any composite attributes are also included here.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个强实体，创建一个包含其属性的表，并指定主键。任何复合属性的部分也包括在此处。
- en: For each weak entity, create a table comprising its attributes and including
    the primary key of its owning entity. The owning entity’s primary key is a foreign
    key here because it’s a key not of this table but another table. The table’s primary
    key for the weak entity is the combination of the foreign key and the partial
    key of the weak entity. If the relationship with the owning entity has any attributes,
    add them to this table.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个弱实体，创建一个包含其属性的表，并包括其所属实体的主键。所属实体的主键在此处是外键，因为它不是本表的键，而是另一张表的键。弱实体的表主键是外键和弱实体部分键的组合。如果与所属实体的关系具有任何属性，请将它们添加到此表中。
- en: For each entity’s multivalued attribute, create a table comprising the entity’s
    primary key and the attribute.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个实体的多值属性，创建一个包含实体主键和属性的表。
- en: Map the relationships to database tables
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将关系映射到数据库表
- en: Each one-to-one relationship between two entities includes the primary key of
    one entity as a foreign key in the table belonging to the other. If one entity
    participates totally in the relationship, place the foreign key in its table.
    If both participate totally in the relationship, consider merging them into a
    single table.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 两个实体之间的每个一对一关系在属于另一个实体的表中包含一个实体的主键作为外键。如果一个实体完全参与关系，请将外键放置在其表中。如果两者都完全参与关系，请考虑将它们合并成一个单一表。
- en: For each nonidentifying one-to-many relationship between two entities, include
    the entity’s primary key on the “1” side as a foreign key in the table for the
    entity on the “N” side. Add any attributes of the relationship in the table alongside
    the foreign key. Note that identifying one-to-many relationships (between a weak
    entity and its owning entity) are captured as part of the entity-mapping stage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个实体之间的每个非标识一对多关系，在“1”侧的实体的主键作为外键包含在“N”侧实体的表中。在外键旁边的表中添加关系的任何属性。请注意，标识一对多关系（弱实体与其所属实体之间的关系）作为实体映射阶段的一部分进行捕捉。
- en: For each many-to-many relationship between two entities, create a new table
    containing each entity’s primary key as the primary key and add any attributes
    of the relationship. This step helps to identify intermediate entities.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个实体之间的每个多对多关系，请创建一个新表，其中包含每个实体的主键作为主键，并添加关系的任何属性。此步骤有助于识别中间实体。
- en: For each relationship involving more than two entities, create a table with
    the primary keys of all the participating entities, and add any relationship attributes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及多于两个实体的每个关系，创建一个包含所有参与实体的主键的表，并添加任何关系属性。
- en: Creating a Bank Database ER Model
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建银行数据库ER模型
- en: 'We’ve discussed database models for student grades and customer information,
    plus the three open source EERs available for MySQL. Now let’s see how we could
    model a bank database. We’ve collected all the requisites from the stakeholders
    and defined our requirements for the online banking system, and we’ve decided
    we need to have the following entities:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了学生成绩和客户信息的数据库模型，以及三个适用于MySQL的开源EER。现在让我们看看如何建模银行数据库。我们从利益相关者那里收集了所有必要信息，并为在线银行系统定义了我们的需求，我们决定需要以下实体：
- en: Employees
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 员工
- en: Branches
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支机构
- en: Customers
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: Accounts
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 账户
- en: Now, following the mapping rules as just described, we are going to create the
    tables and attributes for each table. We established primary keys to ensure every
    table has a unique identifier column for its records. Next, we need to define
    the relationships between the tables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据刚刚描述的映射规则，我们将为每个表创建表和属性。我们设定了主键，以确保每个表都有一个唯一的标识列用于其记录。接下来，我们需要定义表之间的关系。
- en: Many to many relationships (N:M)
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系（N:M）
- en: We’ve established this type of relationship between branches and employees,
    and between accounts and customers. An employee can work for any number of branches,
    and a branch could have any number of employees. Similarly, a customer could have
    many accounts, and an account could be a joint account held by more than two customers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在分支和员工之间，以及账户和客户之间建立了这种类型的关系。员工可以在任意数量的分支工作，而一个分支可以拥有任意数量的员工。类似地，一个客户可以拥有多个账户，而一个账户可以是由两个以上客户持有的联合账户。
- en: 'To model these relationships, we need two more intermediate entities. We create
    them as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建模这些关系，我们需要两个更多的中间实体。我们如下创建它们：
- en: account_customers
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: account_customers
- en: branch_employees
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: branch_employees
- en: The account_customers and branch_employees entities will be the bridges between
    account and customer entities and branch and employee entities, respectively.
    We are converting the N:M relationship into two 1:N relationships. You will see
    how the design looks in the next section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: account_customers 和 branch_employees 实体将成为账户和客户实体以及分支和员工实体之间的桥梁。我们将 N:M 关系转换为两个
    1:N 关系。你将在下一节看到设计的具体样子。
- en: One to many relationship (1:N)
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对多关系（1:N）
- en: This type of relationship exists between branches and accounts and between customers
    and account_customers. This brings up the concept of the *nonidentifying relationship*.
    For example, in the `accounts` table, the `branch_id` field is not part of the
    primary key (one reason for this is that you can move your bank account to another
    branch). It is common nowadays to keep a surrogate key as the primary key in each
    table; therefore, a genuine identifying relationship where the foreign key is
    also part of the primary key in a data model is rare.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 分支和账户之间，以及客户和 account_customers 之间存在这种类型的关系。这引出了 *非标识关系* 的概念。例如，在 `accounts`
    表中，`branch_id` 字段不是主键的一部分（原因之一是你可以将银行账户转移到另一个分支）。如今在每个表中保留一个代理键作为主键是很普遍的做法；因此，在数据模型中外键也是主键的真实标识关系比较罕见。
- en: Because we’re creating a physical EER model, we are also going to define the
    primary keys. It is common and recommended to use auto-incrementing unsigned fields
    for the primary key.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在创建一个物理 EER 模型，我们也将定义主键。通常建议使用自增无符号字段作为主键。
- en: '[Figure 2-17](#FIG-WORKBENCH-BANKMODEL) shows the final representation of the
    bank model.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-17](#FIG-WORKBENCH-BANKMODEL) 展示了银行模型的最终表示。'
- en: '![lm2e 0217](Images/lm2e_0217.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0217](Images/lm2e_0217.png)'
- en: Figure 2-17\. The EER model for the `bank` database
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-17\. `bank` 数据库的 EER 模型
- en: Note that there are items we haven’t considered for this model. For example,
    our model does not support a customer with multiple addresses (say, a work address
    and a home address). We did this intentionally to emphasize the importance of
    collecting the requisites prior to database deployment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有一些我们没有考虑到的项目。例如，我们的模型不支持客户拥有多个地址（比如工作地址和家庭地址）。我们有意为之，以突显在数据库部署之前收集需求的重要性。
- en: You can download the model from the book’s [GitHub repository](https://oreil.ly/FJm12).
    The file is *bank_model.mwb*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从本书的 [GitHub 仓库](https://oreil.ly/FJm12) 下载该模型。文件名为 *bank_model.mwb*。
- en: Converting the EER to a MySQL Database Using Workbench
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Workbench 将 EER 转换为 MySQL 数据库
- en: It’s a good idea to use a tool to draw your ER diagrams; this way, you can easily
    edit and redefine them until the final diagrams are clear and unambiguous. Once
    you’re comfortable with the model, you can deploy it. MySQL Workbench allows the
    conversion of the EER model into data definition language (DDL) statements to
    create a MySQL database, using the Forward Engineer option in the database menu
    ([Figure 2-18](#FIG-WORKBENCH-LAST)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具绘制ER图是个好主意；这样一来，你可以轻松编辑和重新定义它们，直到最终图表清晰明了。一旦你对模型感到满意，可以进行部署。MySQL Workbench
    允许将 EER 模型转换为数据定义语言（DDL）语句，用以创建 MySQL 数据库，使用数据库菜单中的正向工程选项（[图 2-18](#FIG-WORKBENCH-LAST)）。
- en: '![lm2e 0218](Images/lm2e_0218.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0218](Images/lm2e_0218.png)'
- en: Figure 2-18\. Forward Engineering a database in MySQL Workbench
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-18\. 在 MySQL Workbench 中进行正向工程设计数据库
- en: You’ll need to enter the credentials to connect to the database, and after that
    MySQL Workbench will present some options. For this model, we are going to use
    the standard options as shown in [Figure 2-19](#FIG-SETTING-OPT), with all but
    the last option unchecked.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要输入凭据来连接数据库，之后 MySQL Workbench 将展示一些选项。对于这个模型，我们将使用标准选项，如[图 2-19](#FIG-SETTING-OPT)所示，除了最后一个选项外都取消选择。
- en: '![lm2e 0219](Images/lm2e_0219.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0219](Images/lm2e_0219.png)'
- en: Figure 2-19\. Database creation options
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-19\. 数据库创建选项
- en: The next screen will ask which elements of the model we want to generate. Since
    we do not have anything special like triggers, stored procedures, users, and so
    on, we will only create the table objects and their relationships; the rest of
    the options are unchecked.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的屏幕将询问我们希望生成模型的哪些元素。因为我们没有特别的需求如触发器、存储过程、用户等，我们只会创建表对象及其关系；其余选项都未选中。
- en: MySQL Workbench will then present us with the SQL script that will be executed
    to create the database from our model, as shown in [Figure 2-20](#FIG-SQL-STATEMENTS).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Workbench 将会展示给我们执行以创建数据库的 SQL 脚本，如图 [2-20](#FIG-SQL-STATEMENTS) 所示。
- en: '![lm2e 0220](Images/lm2e_0220.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0220](Images/lm2e_0220.png)'
- en: Figure 2-20\. The script generated to create the database
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-20\. 用于创建数据库的生成脚本
- en: When we click Continue, MySQL Workbench will execute the statements on our MySQL
    server, as shown in [Figure 2-21](#FIG-RUN-SCRIPT).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“继续”时，MySQL Workbench 将在我们的 MySQL 服务器上执行这些语句，如图 [2-21](#FIG-RUN-SCRIPT)
    所示。
- en: We cover the details of the statements in this script in [“Creating Tables”](ch04.xhtml#MOD-SEC-CREATETABLE).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“创建表格”](ch04.xhtml#MOD-SEC-CREATETABLE) 中详细解释了此脚本中的语句。
- en: '![lm2e 0221](Images/lm2e_0221.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0221](Images/lm2e_0221.png)'
- en: Figure 2-21\. MySQL Workbench starts running the script
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-21\. MySQL Workbench 开始运行该脚本
