- en: Chapter 5\. Advanced Querying
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 高级查询
- en: Over the previous two chapters, you’ve completed an introduction to the basic
    features of querying and modifying databases with SQL. You should now be able
    to create, modify, and remove database structures, as well as work with data as
    you read, insert, delete, and update entries. Over this and the next two chapters,
    we’ll look at more advanced concepts and then will proceed to more administrative
    and operations-oriented content. You can skim these chapters and return to read
    them thoroughly when you’re comfortable using MySQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，你已经完成了 SQL 数据库查询和修改基本特性的介绍。现在你应该能够创建、修改和删除数据库结构，以及在读取、插入、删除和更新条目时处理数据。在本章和接下来的两章中，我们将深入研究更高级的概念，然后继续探讨更多关于管理和操作导向的内容。当你熟悉使用
    MySQL 后，你可以略读这些章节，等到需要时再仔细阅读。
- en: 'This chapter teaches you more about querying, giving you skills to answer complex
    information needs. You’ll learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教你更多关于查询的内容，提供了解答复杂信息需求的技能。你将学习以下内容：
- en: Use nicknames, or *aliases*, in queries to save typing and allow a table to
    be used more than once in a query.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询中使用昵称或*别名*，以节省输入并允许一个表在查询中被多次使用。
- en: Aggregate data into groups so you can discover sums, averages, and counts.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据聚合成组，以便发现总和、平均值和计数。
- en: Join tables in different ways.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同方式连接表格。
- en: Use nested queries.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套查询。
- en: Save query results in variables so they can be reused in other queries.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将查询结果保存在变量中，以便在其他查询中重复使用。
- en: Aliases
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名
- en: 'Aliases are nicknames. They give you a shorthand way of expressing a column,
    table, or function name, allowing you to:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是昵称。它们为你提供了一种简写的方式来表达列、表或函数名称，允许你：
- en: Write shorter queries.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写更短的查询。
- en: Express your queries more clearly.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更清晰地表达你的查询。
- en: Use one table in two or more ways in a single query.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个查询中以两种或更多方式使用同一张表。
- en: Access data more easily from programs.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更轻松地从程序中访问数据。
- en: Use special types of nested queries, discussed in [“Nested Queries”](#ADV1-SEC-NESTED).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特殊类型的嵌套查询，详见 [“Nested Queries”](#ADV1-SEC-NESTED)。
- en: Column Aliases
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列别名
- en: 'Column aliases are useful for improving the expression of your queries, reducing
    the number of characters you need to type, and making it easier to work with programming
    languages such as Python or PHP. Consider a simple, not-very-useful example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列别名对于改善查询表达、减少所需键入的字符数以及使得与诸如 Python 或 PHP 等编程语言的工作更加容易非常有用。考虑一个简单且不太实用的例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The column `first_name` is aliased as `First Name`, and column `last_name` as
    `Last Name`. You can see that in the output, the usual column headings, `first_name`
    and `last_name`, are replaced by the aliases `First Name` and `Last Name`. The
    advantage is that the aliases might be more meaningful to users. In this case,
    at the very least, they are more human-readable. Other than that, it’s not very
    useful, but it does illustrate the idea that for a column, you add the keyword
    `AS` and then a string that represents what you’d like the column to be known
    as. Specifying the `AS` keyword is not required but makes things much clearer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `first_name` 被别名为 `First Name`，列 `last_name` 被别名为 `Last Name`。你可以看到在输出中，通常的列标题
    `first_name` 和 `last_name` 被别名 `First Name` 和 `Last Name` 替代了。这样做的好处是别名可能更有意义，至少对人类更易读。除此之外，它并不是非常有用，但它确实说明了一个想法，即对于一列，你可以添加关键词
    `AS`，然后是一个代表你想让列被称为的字符串。指定 `AS` 关键词并非必需，但可以使事情更清晰。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll be using the `LIMIT` clause extensively throughout this chapter, as otherwise
    almost every output would be unwieldy and long. Sometimes we’ll mention that explicitly,
    sometimes not. You can experiment on your own by removing `LIMIT` from the queries
    we give. More information about the `LIMIT` clause can be found in [“The LIMIT
    Clause”](ch03.xhtml#BAS-SEC-LIMIT).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中广泛使用 `LIMIT` 子句，否则几乎每个输出都会非常冗长。有时我们会明确提到它，有时则不会。你可以尝试自己从我们给出的查询中删除 `LIMIT`
    来进行实验。关于 `LIMIT` 子句的更多信息可在 [“The LIMIT Clause”](ch03.xhtml#BAS-SEC-LIMIT) 中找到。
- en: 'Now let’s see column aliases doing something useful. Here’s an example that
    uses a MySQL function and an `ORDER BY` clause:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看列别名如何发挥作用。以下是一个使用 MySQL 函数和 `ORDER BY` 子句的示例：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The MySQL function `CONCAT()` *concatenates* the strings that are parameters—in
    this case, the `first_name`, a constant string with a space, the `last_name`,
    the constant string `played in`, and the `title`—to give output such as `ZERO
    CAGE played in CANYON STOCK`. We’ve added an alias to the function, `AS movie`,
    so that we can refer to it easily as `movie` throughout the query. You can see
    that we do this in the `ORDER BY` clause, where we ask MySQL to sort the output
    by ascending `movie` value. This is much better than the unaliased alternative,
    which requires you to write out the `CONCAT()` function again:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL函数`CONCAT()` *连接* 它的参数——在本例中是`first_name`、一个包含空格的常量字符串、`last_name`、常量字符串`played
    in`和`title`——以生成诸如`ZERO CAGE played in CANYON STOCK`之类的输出。我们给函数添加了一个别名`AS movie`，这样我们可以在整个查询中轻松地引用它作为`movie`。您可以看到，我们在`ORDER
    BY`子句中这样做时，请求MySQL按升序`movie`值对输出进行排序。这比未使用别名的替代方法要好得多，后者要求您再次编写`CONCAT()`函数：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The alternative is unwieldy, and worse, you risk mistyping some part of the
    `ORDER BY` clause and getting a result different from what you expect. (Note that
    we’ve used `AS movie` on the first line so that the displayed column has the label
    `movie`.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式不方便，更糟糕的是，您可能会在`ORDER BY`子句中打字错误，导致结果与您的预期不同。（请注意，我们在第一行使用了`AS movie`，以便显示的列具有标签`movie`。）
- en: 'There are restrictions on where you can use column aliases. You can’t use them
    in a `WHERE` clause, or in the `USING` and `ON` clauses that we discuss later
    in this chapter. This means you can’t write a query like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以使用列别名的地方有一些限制。您不能在`WHERE`子句中使用它们，也不能在我们稍后在本章中讨论的`USING`和`ON`子句中使用它们。这意味着您不能编写如下查询：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can’t do that because MySQL doesn’t always know the column values before
    it executes the `WHERE` clause. However, you can use column aliases in the `ORDER
    BY` clause, and in the `GROUP BY` and `HAVING` clauses discussed later in this
    chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MySQL在执行`WHERE`子句之前并不总是知道列值，所以您不能这样做。但是，您可以在`ORDER BY`子句中使用列别名，在稍后在本章中讨论的`GROUP
    BY`和`HAVING`子句中也可以使用列别名。
- en: 'The `AS` keyword is optional, as we’ve mentioned. Because of this, the following
    two queries are equivalent:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`AS`关键字是可选的，正如我们前面提到的那样。因此，以下两个查询是等价的：'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We recommend using the `AS` keyword, since it helps to clearly distinguish an
    aliased column, especially where you’re selecting multiple columns from a list
    of columns separated by commas.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用`AS`关键字，因为它有助于清晰地区分带别名的列，特别是在从逗号分隔的列列表中选择多列的情况下。
- en: Alias names have a few restrictions. They can be at most 255 characters in length
    and can contain any character. Aliases don’t always need to be quoted, and they
    follow the same rules as table and column names do, which we described in [Chapter 4](ch04.xhtml#CH4_MODIFY).
    If an alias is a single word and doesn’t include special symbols—like a dash,
    a plus sign, or a space, for example—and is not a keyword, like `USE`, then you
    don’t need to put quotes around it. Otherwise, you need to quote the alias, which
    you can do using double quotes, single quotes, or backticks. We recommend using
    lowercase alphanumeric strings for alias names and using a consistent character
    choice—such as an underscore—to separate words. Aliases are case-insensitive on
    all platforms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 别名的名称有一些限制。它们最多可以为255个字符，并且可以包含任何字符。别名不总是需要加引号，并且遵循与表名和列名相同的规则，我们在[第四章](ch04.xhtml#CH4_MODIFY)中进行了描述。如果别名是一个单词并且不包含特殊符号（例如破折号、加号或空格），并且不是关键字（如`USE`），那么您不需要在其周围加引号。否则，您需要引用别名，可以使用双引号、单引号或反引号。我们建议使用小写字母数字字符串作为别名，并使用一致的字符选择（例如下划线）来分隔单词。别名在所有平台上都不区分大小写。
- en: Table Aliases
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表别名
- en: Table aliases are useful for the same reasons as column aliases, but they are
    also sometimes the only way to express a query. This section shows you how to
    use table aliases, and [“Nested Queries”](#ADV1-SEC-NESTED) shows you some other
    sample queries where table aliases are essential.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表别名和列别名一样有用，但有时是表达查询的唯一方式。本节将向您展示如何使用表别名，而[“嵌套查询”](#ADV1-SEC-NESTED)将向您展示一些其他必不可少的表别名示例。
- en: 'Here’s a basic table alias example that shows you how to save some typing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基本的表别名示例，向您展示如何节省输入：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can see that the `film` and `actor` tables are aliased as `fl` and `ac`,
    respectively, using the `AS` keyword. This allows you to express column names
    more compactly, such as `fl.title`. Notice also that you can use table aliases
    in the `WHERE` clause; unlike column aliases, there are no restrictions on where
    table aliases can be used in queries. From our example, you can see that we’re
    referring to the table aliases in `SELECT` before they have been defined in `FROM`.
    There is, however, a catch with table aliases: if an alias has been used for a
    table, it’s impossible to refer to that table without using its new alias. For
    example, the following statement will error out, as it would if we’d mentioned
    `film` in the `SELECT` clause:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`film`表和`actor`表分别使用`AS`关键字别名为`fl`和`ac`。这允许您更紧凑地表示列名称，例如`fl.title`。请注意，您还可以在`WHERE`子句中使用表别名；与列别名不同，对查询中可以使用表别名的位置没有限制。从我们的例子中，您可以看到我们在`FROM`中定义`SELECT`之前引用了表别名。但是，表别名有一个陷阱：如果一个别名已用于一个表，则无法在不使用其新别名的情况下引用该表。例如，下面的语句将出错，就像我们在`SELECT`子句中提到`film`时那样：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As with column aliases, the `AS` keyword is optional. This means that:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与列别名一样，`AS`关键字是可选的。这意味着：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: is the same as
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, we prefer the `AS` style because it’s clearer to anyone looking at your
    queries than the alternative. The length and content restrictions on table aliases
    names are the same as for column aliases, and our recommendations on choosing
    them are the same, too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢`AS`风格，因为对于查看您的查询的任何人来说，它比替代方案更清晰。表别名名称的长度和内容限制与列别名相同，并且我们在选择它们时的建议也相同。
- en: 'As discussed in the introduction to this section, table aliases allow you to
    write queries that you can’t otherwise easily express. Consider an example: suppose
    you want to know whether two or more films in our collection have the same title,
    and if so, what those films are. Let’s think about the basic requirement: you
    want to know if two movies have the same name. To do get that, you might try a
    query like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节介绍中所讨论的，表别名允许您编写否则难以表达的查询。考虑一个例子：假设您想知道我们收藏的两部或更多电影是否具有相同的标题，如果是这样，这些电影是什么。让我们考虑基本要求：您想知道是否有两部电影具有相同的名称。为了做到这一点，您可能会尝试像这样的查询：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But that doesn’t make sense—every film has the same title as itself, so the
    query just produces all films as output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但这毫无意义 —— 每部电影都与自己有相同的标题，所以查询只是将所有电影作为输出：
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What you really want is to know whether two different films from the `film`
    table have the same name. But how can you do that in a single query? The answer
    is to give the table two different aliases; you then check to see whether one
    row in the first aliased table matches a row in the second:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你真正想知道的是`film`表中的两部不同电影是否有相同的名称。但如何在一个查询中做到这一点？答案是给表指定两个不同的别名；然后检查第一个别名表中的一行是否与第二个别名表中的一行匹配：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But it still doesn’t work! We get all 1,000 movies as answers. The reason is
    that again, each film matches itself because it occurs in both aliased tables.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但仍然不起作用！我们得到了所有 1,000 部电影作为答案。原因是因为每部电影都与自己匹配，因为它在两个别名表中都出现了。
- en: 'To get the query to work, we need to make sure a movie from one aliased table
    doesn’t match itself in the other aliased table. The way to do that is to specify
    that the movies in each table shouldn’t have the same ID:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使查询起作用，我们需要确保来自一个别名表的电影不与另一个别名表中的自身匹配。做到这一点的方法是指定每个表中的电影不应具有相同的ID：
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can now see that there aren’t two films in the database with the same name.
    The additional `AND m1.film_id != m2.film_id` stops answers from being reported
    where the movie ID is the same in both tables.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以看到数据库中没有两部电影具有相同的名称。附加的`AND m1.film_id != m2.film_id`阻止报告电影ID在两个表中相同的答案。
- en: Table aliases are also useful in nested queries that use the `EXISTS` and `ON`
    clauses. We’ll show you examples later in this chapter when we introduce nested
    queries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表别名在使用`EXISTS`和`ON`子句的嵌套查询中也很有用。在本章稍后介绍嵌套查询时，我们将为您展示示例。
- en: Aggregating Data
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合数据
- en: Aggregate functions allow you to discover the properties of a group of rows.
    You use them for purposes such as finding out how many rows there are in a table,
    how many rows in a table share a property (such as having the same name or date
    of birth), finding averages (such as the average temperature in November), or
    finding the maximum or minimum values of rows that meet some condition (such as
    finding the coldest day in August).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合函数允许您发现一组行的属性。您可以使用它们来查找表中有多少行，表中有多少行共享某个属性（例如具有相同的姓名或出生日期），查找平均值（例如11月份的平均温度），或查找满足某些条件的行的最大或最小值（例如找到8月份最冷的一天）。
- en: This section explains the `GROUP BY` and `HAVING` clauses, the two most commonly
    used SQL statements for aggregation. But first it explains the `DISTINCT` clause,
    which is used to report unique results for the output of a query. When neither
    the `DISTINCT` nor the `GROUP BY` clause is specified, the returned raw data can
    still be processed using the aggregate functions that we describe in this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了`GROUP BY`和`HAVING`子句，这是用于聚合的两个最常用的SQL语句。但首先它解释了`DISTINCT`子句，该子句用于报告查询输出的唯一结果。当未指定`DISTINCT`或`GROUP
    BY`子句时，仍然可以使用我们在本节中描述的聚合函数处理返回的原始数据。
- en: The DISTINCT Clause
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DISTINCT子句
- en: To begin our discussion of aggregate functions, we’ll focus on the `DISTINCT`
    clause. This isn’t really an aggregate function, but more of a post-processing
    filter that allows you to remove duplicates. We’ve added it into this section
    because, like aggregate functions, it’s concerned with picking examples from the
    output of a query, rather than processing individual rows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始讨论聚合函数之前，我们将专注于`DISTINCT`子句。这实际上不是一个聚合函数，而更像是一个后处理过滤器，允许您去除重复项。我们将其添加到本节中，因为与聚合函数一样，它关注的是从查询输出中选择示例，而不是处理单个行。
- en: 'An example is the best way to understand `DISTINCT`. Consider this query:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是理解`DISTINCT`的最佳方式。考虑这个查询：
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The query finds all first names of all the actors listed in our database that
    have participated in a film and reports one example of each name. If you remove
    the `DISTINCT` clause, you get one row of output for each role in every film we
    have in our database, or 5,462 rows. That’s a lot of output, so we’re limiting
    it to five rows, but you can spot the difference immediately with names being
    repeated:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询找到了我们数据库中列出的所有参与电影的演员的所有名字，并报告每个名字的一个示例。如果删除`DISTINCT`子句，您将得到我们数据库中每部电影中每个角色的一个输出行，或者说有5,462行。这是很多输出，所以我们将其限制为五行，但您可以立即看到重复的名字：
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, the `DISTINCT` clause helps you get a summary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`DISTINCT`子句帮助您得到一个摘要。
- en: 'The `DISTINCT` clause applies to the query output and removes rows that have
    identical values in the columns selected for output in the query. If you rephrase
    the previous query to output both `first_name` and `last_name` (but otherwise
    don’t change the `JOIN` clause and still use `DISTINCT`), you’ll get 199 rows
    in the output (that’s why we use last names):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`DISTINCT`子句应用于查询输出，并删除在查询中选择的输出列中具有相同值的行。如果重新构造前面的查询以输出`first_name`和`last_name`（但不更改`JOIN`子句并仍然使用`DISTINCT`），您将在输出中得到199行（这就是为什么我们使用姓氏）：'
- en: '[PRE28]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Unfortunately, people’s names even when last names are added still make for
    a bad unique key. There are 200 rows in the `actor` table in the `sakila` database,
    and we’re missing one of them. You should remember this issue, as using `DISTINCT`
    indiscriminately may result in incorrect query results.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使添加了姓氏，人们的名字仍然不适合作为一个糟糕的唯一键。在`sakila`数据库的`actor`表中有200行数据，我们遗漏了其中一个。您应该记住这个问题，因为不加区分地使用`DISTINCT`可能导致查询结果不正确。
- en: To remove duplicates, MySQL needs to sort the output. If indexes are available
    that are in the same order as required for the sort, or the data itself is in
    an order that’s useful, this process has very little overhead. However, for large
    tables and without an easy way of accessing the data in the right order, sorting
    can be very slow. You should use `DISTINCT` (and other aggregate functions) with
    caution on large datasets. If you do use it, you can check its behavior using
    the `EXPLAIN` statement discussed in [Chapter 7](ch07.xhtml#CH7_DOING_MORE).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要去除重复项，MySQL需要对输出进行排序。如果可用的索引与所需排序的顺序相同，或者数据本身按照有用的顺序排列，这个过程的开销非常小。然而，对于大表而言，如果没有一种简单的方式访问正确顺序的数据，排序可能会非常慢。在处理大型数据集时，您应该谨慎使用`DISTINCT`（以及其他聚合函数）。如果您确实使用了它，可以使用[第7章](ch07.xhtml#CH7_DOING_MORE)中讨论的`EXPLAIN`语句来检查其行为。
- en: The GROUP BY Clause
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP BY子句
- en: The `GROUP BY` clause groups output data for the purpose of aggregation. Particularly,
    that allows us to use aggregate functions (covered in [“Aggregate functions”](#ADV1-AGGREGATE-FUNCTIONS))
    on our data when our projection (that is, the contents of the `SELECT` clause)
    contains columns other than those within an aggregate function. `GROUP BY` is
    similar to `ORDER BY` in that it takes a list of columns as an argument. However,
    these clauses are evaluated at different times and are only similar in how they
    look, not how they operate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUP BY` 子句根据聚合的目的分组输出数据。特别是，这使我们能够在我们的投影（即`SELECT`子句的内容）包含除聚合函数之外的列时，对我们的数据使用聚合函数（在[“聚合函数”](#ADV1-AGGREGATE-FUNCTIONS)中已讨论）。'
- en: 'Let’s take a look at a few `GROUP BY` examples that will demonstrate what it
    can be used for. In its most basic form, when we list every column we `SELECT`
    in `GROUP BY`, we end up with a `DISTINCT` equivalent. We’ve already established
    that a first name is not a unique identifier for an actor:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些 `GROUP BY` 示例，这将演示它可以用于什么。在其最基本的形式中，当我们在`GROUP BY`中列出我们`SELECT`的每一列时，我们最终得到一个`DISTINCT`等效项。我们已经确定名字不是演员的唯一标识符：
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can tell MySQL to group the output by a given column to get rid of duplicates.
    In this case, we’ve selected only one column, so let’s use that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉 MySQL 通过给定的列分组输出以去除重复项。在这种情况下，我们只选择了一列，因此让我们使用它：
- en: '[PRE32]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that the original five rows were folded—or, more accurately, grouped—into
    just two resulting rows. That’s not very helpful, as `DISTINCT` could do the same.
    It’s worth mentioning, however, that this is not always going to be the case.
    `DISTINCT` and `GROUP BY` are evaluated and executed at different stages of query
    execution, so you should not confuse them, even if sometimes the effects are similar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，原始的五行被合并或更准确地说是分组为仅两行结果。这并不是很有帮助，因为`DISTINCT`可以做同样的事情。然而值得一提的是，这并不总是适用。`DISTINCT`
    和 `GROUP BY` 在查询执行的不同阶段进行评估和执行，因此即使有时效果相似，您也不应混淆它们。
- en: 'According to the SQL standard, every column projected in the `SELECT` clause
    that is not part of an aggregate function should be listed in the `GROUP BY` clause.
    The only time this rule may be violated is when the resulting groups have only
    one row each. If you think about it, that’s logical: if you select `first_name`
    and `last_name` from the `actor` table and group only by `first_name`, how should
    the database behave? It cannot output more than one row with the same first name,
    as that goes against the grouping rules, but there may be more than one last name
    for a given first name.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SQL 标准，`SELECT` 子句中投影的每一列如果不是聚合函数的一部分，应该在 `GROUP BY` 子句中列出。唯一可以违反此规则的情况是当结果组每个仅有一行时。仔细想想，这是合理的：如果你从`actor`表中选择`first_name`和`last_name`，并且仅按`first_name`分组，数据库应该如何处理？它不能输出多行具有相同的姓，因为那违反了分组规则，但可能有多个姓氏对应一个给定的名字。
- en: For a long time, MySQL extended the standard by allowing you to `GROUP BY` based
    on fewer columns than defined in `SELECT`. What did it do with the extra columns?
    Well, it output some value in a nondeterministic way. For example, when you grouped
    by first name but not by the last name, you could get either of the two rows `GENE,
    WILLIS` and `GENE, HOPKINS`. That’s a nonstandard and dangerous behavior. Imagine
    that for a year you got `Hopkins`, as if the results were ordered alphabetically,
    and came to rely on that—but then the table was reorganized, and the order changed.
    We firmly believe that the SQL standard is correct to limit such behaviors, to
    avoid unpredictability.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，MySQL 通过允许您基于`SELECT`中定义的少列来`GROUP BY` 扩展了标准。它如何处理额外的列呢？嗯，它以不确定的方式输出一些值。例如，当您按姓但不按名分组时，您可能会得到`GENE,
    WILLIS`和`GENE, HOPKINS`中的任一行。这是一种非标准和危险的行为。想象一下，一年来，您得到了`Hopkins`，就好像结果是按字母顺序排列的，而且依赖于此，但然后表被重新组织，顺序发生了变化。我们坚信
    SQL 标准正确地限制了这样的行为，以避免不可预测性。
- en: Note also that while every column in the `SELECT` must be used either in `GROUP
    BY` or in an aggregate function, you can `GROUP BY` columns that are not part
    of the `SELECT`. You’ll see some examples of that later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，虽然 `SELECT` 中的每一列必须在 `GROUP BY` 或聚合函数中使用，但可以 `GROUP BY` 不在 `SELECT` 中的列。稍后您将看到一些示例。
- en: 'Now let’s construct a more useful example. An actor usually takes part in many
    films throughout their career. We may want to find out just how many films a particular
    actor has played in, or do a calculation for each actor we know of and get a rating
    by productivity. To start, we can use the techniques we’ve learned so far and
    perform an `INNER JOIN` between the `actor` and `film_actor` tables. We don’t
    need the `film` table as we’re not looking for any details on the films themselves.
    We can then order the output by actor’s name, making it easier to count what we
    want:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建一个更有用的例子。演员通常在他们的职业生涯中参与许多电影。我们可能想知道某个特定演员演过多少部电影，或者为我们所知的每位演员进行计算，并通过生产率得到一个评级。首先，我们可以使用迄今为止学到的技术，在`actor`和`film_actor`表之间执行`INNER
    JOIN`。我们不需要`film`表，因为我们不关心电影本身的任何细节。然后我们可以按演员姓名对输出进行排序，以便更容易计算我们想要的内容：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By running down the list, it’s easy to count off how many films we’ve got for
    each actor, or at least for Adam Grant. Without a `LIMIT`, however, the query
    would return 5,462 distinct rows, and calculating our counts manually would take
    a lot of time. The `GROUP BY` clause can help automate this process by grouping
    the movies by actor; we can then use the `COUNT()` function to count off the number
    of films in each group. Finally, we can use `ORDER BY` and `LIMIT` to get the
    top 10 actors by the number of films they’ve appeared in. Here’s the query that
    does what we want:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐一列出列表，很容易计算出每个演员有多少部电影，至少亚当·格兰特是这样。但是，如果没有`LIMIT`，查询将返回5,462行不同的结果，手动计算我们的计数会花费很多时间。`GROUP
    BY`子句可以通过按演员分组来自动化这一过程；然后我们可以使用`COUNT()`函数来计算每个组中的电影数量。最后，我们可以使用`ORDER BY`和`LIMIT`来获取拥有最多电影出演次数的前10名演员。以下是执行我们所需操作的查询：
- en: '[PRE36]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can see that the output we’ve asked for is `first_name, last_name, COUNT(film_id)
    as num_films`, and this tells us exactly what we wanted to know. We group our
    data by the `first_name` and `last_name` columns, running the `COUNT()` aggregate
    function in the process. For each “bucket” of rows we got in the previous query,
    we now get only a single row, albeit giving the information we want. Notice how
    we’ve combined `GROUP BY` and `ORDER BY` to get the ordering we wanted: by the
    number of films, from more to fewer. `GROUP BY` doesn’t guarantee ordering, only
    grouping. Finally, we `LIMIT` the output to 10 rows representing our most productive
    actors, as otherwise we’d get 199 rows of output.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们请求的输出是`first_name, last_name, COUNT(film_id) as num_films`，这告诉我们确切想要知道的内容。我们按照`first_name`和`last_name`列对数据进行分组，在此过程中运行`COUNT()`聚合函数。对于上一个查询中得到的每个“桶”行，我们现在只得到一行，尽管提供了我们想要的信息。注意我们如何结合使用`GROUP
    BY`和`ORDER BY`来获得所需的顺序：按照电影数量，从多到少。`GROUP BY`不能保证顺序，只能进行分组。最后，我们通过`LIMIT`将输出限制为显示我们最多产的前10名演员，否则我们将得到199行输出。
- en: 'Let’s consider the query further. We’ll start with the `GROUP BY` clause. This
    tells us how to put rows together into groups: in this example, we’re telling
    MySQL that the way to group rows is by `first_name, last_name`. The result is
    that rows for actors with the same name form a cluster, or bucket—that is, each
    distinct name becomes one group. Once the rows are grouped, they’re treated in
    the rest of the query as if they’re one row. So, for example, when we write `SELECT
    first_name, last_name`, we get just one row for each group. This is exactly the
    same as `DISTINCT`, as we’ve already discussed. The `COUNT()` function tells us
    about the properties of the group. More specifically, it tells us the number of
    rows that form each group; you can count any column in a group and you’ll get
    the same answer, so `COUNT(film_id)` is almost always the same as `COUNT(*)` or
    `COUNT(first_name)`. (See [“Aggregate functions”](#ADV1-AGGREGATE-FUNCTIONS) for
    more details on why we say *almost*.) We could also just do `COUNT(1)`, or in
    fact specify any literal. Think of this as doing `SELECT 1` from a table and then
    counting the results. A value of 1 will be output for each row in the table, and
    `COUNT()` does the counting. One exception is `NULL`: while it’s perfectly acceptable
    and legal to specify `COUNT(NULL)`, the result will always be zero, as `COUNT()`
    discards `NULL` values. Of course, you can use a column alias for the `COUNT()`
    column.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步考虑这个查询。我们将从`GROUP BY`子句开始。这告诉我们如何将行放在一起形成组：在这个例子中，我们告诉MySQL按`first_name,
    last_name`来分组行。结果是相同姓名的演员行成一个集群或“桶”，也就是说，每个不同的姓名成为一个组。一旦行被分组，它们在查询的其余部分被视为一行。所以，例如，当我们写`SELECT
    first_name, last_name`时，我们对每个组只得到一行。这与`DISTINCT`完全相同，正如我们已经讨论过的。`COUNT()`函数告诉我们组的属性。更具体地说，它告诉我们每个组中形成的行数；您可以计算组中的任何列，您将得到相同的答案，因此`COUNT(film_id)`几乎总是与`COUNT(*)`或`COUNT(first_name)`相同。（有关为什么我们说“几乎”，请参见[“聚合函数”](#ADV1-AGGREGATE-FUNCTIONS)了解更多详细信息。）我们也可以只做`COUNT(1)`，或者实际指定任何文字。把这看作是从表中进行`SELECT
    1`，然后计算结果。对于表中的每一行，都将输出一个值为1的值，并且`COUNT()`进行计数。一个例外是`NULL`：虽然指定`COUNT(NULL)`是完全可接受和合法的，但结果总是零，因为`COUNT()`丢弃`NULL`值。当然，您可以为`COUNT()`列使用列别名。
- en: 'Let’s try another example. Suppose you want to know how many different actors
    played in each movie, along with the film name and its category, and get the five
    films with the largest crews. Here’s the query:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个例子。假设您想知道每部电影中有多少不同的演员参演，以及电影名称及其类别，并获取最大组的五部电影。这里是查询：
- en: '[PRE38]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Before we discuss what’s new, think about the general function of the query.
    We join four tables together with `INNER JOIN` using their identifier columns:
    `film`, `film_actor`, `film_category`, and `category`. Forgetting the aggregation
    for a moment, the output of this query is one row per combination of movie and
    actor.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论新内容之前，请考虑查询的一般功能。我们使用它们的标识列：`film`、`film_actor`、`film_category` 和 `category`，通过`INNER
    JOIN`将四个表连接在一起。暂且不考虑聚合，这个查询的输出是每个电影和演员组合的一行。
- en: The `GROUP BY` clause puts the rows together into clusters. In this query, we
    want the films grouped together with their categories. The `GROUP BY` clause uses
    `film_id` and `category_id` to do that. You can use the `film_id` column from
    any of the three tables; `film.film_id`, `film_actor.film_id`, and `film_category.film_id`
    are the same for this purpose. It doesn’t matter which one you use; the `INNER
    JOIN` makes sure they match anyway. The same applies to `category_id`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUP BY`子句将行组合成集群。在这个查询中，我们希望将电影与它们的类别分组在一起。`GROUP BY`子句使用`film_id`和`category_id`来完成这一点。您可以从任何三个表中使用`film_id`列；对于此目的，`film.film_id`、`film_actor.film_id`和`film_category.film_id`是相同的。使用哪一个并不重要；`INNER
    JOIN`确保它们匹配。同样适用于`category_id`。'
- en: 'As mentioned earlier, even though it’s required to list every non-aggregated
    column in `GROUP BY`, you can `GROUP BY` on columns outside of the `SELECT`. In
    the previous example query, we’re using the `COUNT()` function to tell us how
    many rows are in each group. For example, you can see that `COUNT(*)` tells us
    that there are 13 actors in the comedy *CRAZY HOME*. Again, it doesn’t matter
    what column or columns you count in the query: for example, `COUNT(*)` has the
    same effect as `COUNT(film.film_id)` or `COUNT(category.name)`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，即使需要在`GROUP BY`中列出每个非聚合列，您也可以在`SELECT`之外的列上`GROUP BY`。在前面的示例查询中，我们使用`COUNT()`函数告诉我们每个组中有多少行。例如，您可以看到`COUNT(*)`告诉我们在喜剧*CRAZY
    HOME*中有13位演员。再次强调，在查询中计数的列无关紧要：例如，`COUNT(*)`与`COUNT(film.film_id)`或`COUNT(category.name)`具有相同的效果。
- en: We’re then ordering the output by the `COUNT(*)` column aliased `cnt` in descending
    order and picking the first five rows. Note how there are multiple rows with `cnt`
    equal to 13\. In fact, there are even more of those—six in all—in the database,
    making this ordering a bit unfair, as movies having the same number of actors
    will be sorted randomly. You can add another column to the `ORDER BY` clause,
    like `title`, to make sorting more predictable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按`COUNT(*)`列的别名`cnt`降序排序输出，并选择前五行。请注意，有多行的`cnt`等于13。事实上，数据库中甚至有六个这样的行，使得这种排序有些不公平，因为具有相同演员数量的电影将随机排序。你可以添加另一个列到`ORDER
    BY`子句，比如`title`，使得排序更可预测。
- en: 'Let’s try another example. The `sakila` database isn’t only about movies and
    actors: it’s based on movie rentals, after all. We have, among other things, customer
    information, including data on what films they rented. Say we want to know which
    customers tend to rent movies from the same category. For example, we might want
    to adjust our ads based on whether a person likes different film categories or
    sticks to a single one most of the time. We need to carefully think about our
    grouping: we don’t want to group by movie, as that would just give us the number
    of times a customer rented it. The resulting query is quite complex, although
    it’s still based around `INNER JOIN` and `GROUP BY`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个例子。`sakila`数据库不仅仅是关于电影和演员：毕竟它是基于电影租借的。我们还有顾客信息，包括他们租借的电影数据。假设我们想知道哪些顾客倾向于租借同一类别的电影。例如，我们可能想根据一个人是否喜欢不同的电影类别或者大部分时间都喜欢某一类别来调整我们的广告。我们需要仔细考虑我们的分组方式：我们不希望按电影分组，因为那只会给我们提供顾客租借它的次数。最终的查询相当复杂，尽管它仍然围绕`INNER
    JOIN`和`GROUP BY`进行。
- en: '[PRE40]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These customers repeatedly rent films from the same category. What we don’t
    know is if any of them have rented the same movie multiple times, or if those
    were all different movies within a category. The `GROUP BY` clause hides the details.
    Again, we use `COUNT(*)` to do the counting of rows in the groups, and you can
    see the `INNER JOIN` spread over lines 2 to 5 in the query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些客户反复从同一类别租借电影。我们不知道的是，他们是否曾多次租借了同一部电影，还是仅仅是类别内的不同电影。`GROUP BY`子句隐藏了细节。同样，我们使用`COUNT(*)`来统计组中的行数，你可以看到查询中第2到第5行之间的`INNER
    JOIN`。
- en: The interesting thing about this query is that we didn’t explicitly specify
    column names for the `GROUP BY` or `ORDER BY` clauses. Instead, we used the columns’
    position numbers (counted from 1) as they appear in the `SELECT` clause. This
    technique saves on typing but can be problematic if you later decide to add another
    column in the `SELECT`, which would break the ordering.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的有趣之处在于，我们没有明确指定`GROUP BY`或`ORDER BY`子句的列名。相反，我们使用了列在`SELECT`子句中出现的位置编号（从1开始）。这种技术节省了输入时间，但如果稍后决定在`SELECT`中添加另一列，可能会导致顺序混乱。
- en: 'As with `DISTINCT`, there’s a danger with `GROUP BY` that we should mention.
    Consider the following query:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与`DISTINCT`类似，`GROUP BY`也存在一些风险需要提及。考虑以下查询：
- en: '[PRE42]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It looks simple enough, and it produces the number of times a combination of
    a given first name and last name was found in the `actor` table. You might assume
    that it just outputs 199 rows of the digit `1`. However, if we do a `COUNT(*)`
    on the `actor` table, we get 200 rows. What’s the catch? Apparently, two actors
    have the same first name and last name. These things happen, and you have to be
    mindful of them. When you group based on columns that do not form a unique identifier,
    you may accidentally group together unrelated rows, resulting in misleading data.
    To find the duplicates, we can modify a query that we constructed in [“Table Aliases”](#ADV1-SEC-TABLEALIASES)
    to look for films with the same name:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，并且它输出了给定名和姓在`actor`表中找到的组合出现次数。你可能会认为它只会输出199行数字`1`。然而，如果我们对`actor`表进行`COUNT(*)`，我们会得到200行。问题在哪里？显然，有两个演员具有相同的名和姓。这些情况偶尔会发生，你必须注意这一点。当你基于不构成唯一标识符的列进行分组时，可能会意外地将无关的行分组在一起，导致数据误导。为了找出重复项，我们可以修改一个我们在[“表别名”](#ADV1-SEC-TABLEALIASES)中构建的查询，以查找具有相同名称的电影：
- en: '[PRE44]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Before we end this section, let’s again touch on how MySQL extends the SQL standard
    around the `GROUP BY` clause. Before MySQL 5.7, it was possible by default to
    specify an incomplete column list in the `GROUP BY` clause, and, as we’ve explained,
    that resulted in a random rows being output within groups for non-grouped dependent
    columns. For reasons of supporting legacy software, both MySQL 5.7 and My SQL
    8.0 continue providing this behavior, though it has to be explicitly enabled.
    The behavior is controlled by the `ONLY_FULL_GROUP_BY` SQL mode, which is set
    by default. If you find yourself in a situation where you need to port a program
    that relies on the legacy `GROUP BY` behavior, we recommend that you do not resort
    to changing the SQL mode. There are generally two ways to handle this problem.
    The first is to understand whether the query logic requires incomplete grouping
    at all—that is rarely the case. The second is to support the random data behavior
    for non-grouped columns by using either an aggregate function like `MIN()` or
    `MAX()` or the special `ANY_VALUE()` aggregate function, which, unsurprisingly,
    just produces a random value from within a group. We’ll look more closely at aggregate
    functions next.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，让我们再次触及一下 MySQL 如何在 `GROUP BY` 子句周围扩展 SQL 标准。在 MySQL 5.7 之前，默认情况下可以在
    `GROUP BY` 子句中指定不完整的列列表，正如我们所解释的那样，这导致非分组依赖列中的随机行输出到组内。出于支持旧版软件的原因，MySQL 5.7 和
    MySQL 8.0 都继续提供这种行为，尽管必须显式启用。该行为由 `ONLY_FULL_GROUP_BY` SQL 模式控制，默认设置为启用。如果你发现自己需要迁移依赖于旧版
    `GROUP BY` 行为的程序，我们建议不要改变 SQL 模式。通常有两种方法来解决这个问题。第一种是了解查询逻辑是否真的需要不完整的分组，这种情况很少见。第二种是通过使用聚合函数如
    `MIN()` 或 `MAX()`，或者特殊的 `ANY_VALUE()` 聚合函数来支持非分组列的随机数据行为，后者只是从组内产生一个随机值。我们接下来会更仔细地看一下聚合函数。
- en: Aggregate functions
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合函数
- en: 'We’ve seen examples of how the `COUNT()` function can be used to tell how many
    rows are in a group. Here we will cover some other functions commonly used to
    explore the properties of aggregated rows. We’ll also expand a bit on `COUNT()`
    as it’s used frequently:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `COUNT()` 函数如何用于告诉组内有多少行。在这里，我们将介绍一些其他常用于探索聚合行属性的函数。我们还会稍微扩展一下 `COUNT()`
    的使用方式，因为它经常被用到：
- en: '`COUNT()`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`COUNT()`'
- en: 'Returns the number of rows *or* the number of values in a column. Remember
    we mentioned that `COUNT(*)` is *almost* always the equivalent of `COUNT``*(<column>)*`.
    The problem is `NULL`. `COUNT(*)` will do a count of rows returned, regardless
    of whether the column in those rows is `NULL` or not. However, when you do a `COUNT``*(<column>)*`,
    only non-`NULL` values will be counted. For example, in the `sakila` database,
    a customer’s email address may be `NULL`, and we can observe the impact:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 返回行的数量或列中值的数量。记得我们提到过 `COUNT(*)` 几乎总是等同于 `COUNT(<column>)`。问题在于 `NULL`。`COUNT(*)`
    会对返回的行数进行计数，无论这些行中的列是否为 `NULL`。然而，当你使用 `COUNT(<column>)` 时，只会计算非 `NULL` 值。例如，在
    `sakila` 数据库中，客户的电子邮件地址可能为空，我们可以观察其影响：
- en: '[PRE46]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We should also add that `COUNT()` can be run with an internal `DISTINCT` clause,
    as in `COUNT(DISTINCT` `*<column>*)`, and will return the number of distinct values
    instead of all values in this case.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该补充说明 `COUNT()` 可以在内部使用 `DISTINCT` 子句运行，例如 `COUNT(DISTINCT <column>)`，在这种情况下返回不同值的数量，而不是所有值的数量。
- en: '`AVG()`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVG()`'
- en: 'Returns the average (mean) of the values in the specified column for all rows
    in a group. For example, you could use it to find the average cost of a house
    in a city, when the houses are grouped by city:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 返回组内指定列中值的平均值（均值）。例如，你可以用它来找到一个城市房屋的平均成本，当房屋按城市分组时。
- en: '[PRE50]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`MAX()`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAX()`'
- en: Returns the maximum value from rows in a group. For example, you could use it
    to find the warmest day in a month, when the rows are grouped by month.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 返回组内行中的最大值。例如，你可以用它来找到一个月中最热的一天，当行按月份分组时。
- en: '`MIN()`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`MIN()`'
- en: Returns the minimum value from rows in a group. For example, you could use it
    to find the youngest student in a class, when the rows are grouped by class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 返回组内行中的最小值。例如，你可以用它来找到一个班级中年龄最小的学生，当行按班级分组时。
- en: '`STD()`, `STDDEV()`, and `STDDEV_POP()`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`STD()`，`STDDEV()` 和 `STDDEV_POP()`'
- en: Return the standard deviation of values from rows in a group. For example, you
    could use these to understand the spread of test scores, when rows are grouped
    by university course. All three of these are synonyms. `STD()` is a MySQL extension,
    `STDDEV()` is added for compatibility with Oracle, and `STDDEV_POP()` is a SQL
    standard function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 返回组中行的标准差。例如，您可以使用这些来了解按大学课程分组时测试分数的分布。这三个都是同义词。`STD()`是MySQL扩展，`STDDEV()`是为了与Oracle兼容而添加的，`STDDEV_POP()`是SQL标准函数。
- en: '`SUM()`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUM()`'
- en: Returns the sum of values from rows in a group. For example, you could use it
    to compute the dollar amount of sales in a given month, when rows are grouped
    by month.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 返回组中行的值的总和。例如，您可以使用它来计算按月分组时的销售金额。
- en: There are other functions available for use with `GROUP BY`, but they’re less
    frequently used than the ones we’ve introduced here. You can find more details
    on them in the section on [aggregate function descriptions](https://oreil.ly/QSZst)
    in the MySQL Reference Manual.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与`GROUP BY`一起使用的其他函数也可用，但它们的使用频率不如我们在此介绍的函数高。您可以在MySQL参考手册的[聚合函数描述](https://oreil.ly/QSZst)部分找到更多详细信息。
- en: The HAVING Clause
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`HAVING`子句'
- en: You’re now familiar with the `GROUP BY` clause, which allows you to sort and
    cluster data. You should be able to use it to find counts, averages, minimums,
    and maximums. This section shows how you can use the `HAVING` clause to gain additional
    control over the aggregation of rows in a `GROUP BY` operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了`GROUP BY`子句，它允许您对数据进行排序和分组。您应该能够使用它来查找计数、平均值、最小值和最大值。本节展示了如何使用`HAVING`子句对`GROUP
    BY`操作中的行进行额外控制。
- en: 'Suppose you want to know how many popular actors there are in our database.
    You’ve decided to define an actor as popular if they’ve taken part in at least
    40 movies. In the previous section, we tried an almost identical query but without
    the popularity limitation. We also found that when we grouped the actors by first
    and last name, we lost one record, so we’ll add grouping on the `actor_id` column,
    which we know to be unique. Here’s the new query, with an additional `HAVING`
    clause that adds the constraint:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想知道我们数据库中有多少受欢迎的演员。您决定将参与至少40部电影的演员定义为受欢迎的演员。在前一节中，我们尝试了一个几乎相同的查询，但没有受欢迎度限制。我们还发现，当我们按名字分组演员时，我们丢失了一条记录，因此我们将添加对`actor_id`列的分组，我们知道它是唯一的。以下是新查询，带有额外的`HAVING`子句，添加了约束条件：
- en: '[PRE51]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can see there are only two actors that meet the new criteria.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，只有两位演员符合新标准。
- en: The `HAVING` clause must contain an expression or column that’s listed in the
    `SELECT` clause. In this example, we’ve used `HAVING COUNT(film_id) >= 40`, and
    you can see that `COUNT(film_id)` is part of the `SELECT` clause. Typically, the
    expression in the `HAVING` clause uses an aggregate function such as `COUNT()`,
    `SUM()`, `MIN()`, or `MAX()`. If you find yourself wanting to write a `HAVING`
    clause that uses a column or expression that isn’t in the `SELECT` clause, chances
    are you should be using a `WHERE` clause instead. The `HAVING` clause is only
    for deciding how to form each group or cluster, not for choosing rows in the output.
    We’ll show you an example later that illustrates when not to use `HAVING`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`HAVING`子句必须包含在`SELECT`子句中列出的表达式或列。在本例中，我们使用了`HAVING COUNT(film_id) >= 40`，您可以看到`COUNT(film_id)`是`SELECT`子句的一部分。通常，`HAVING`子句中的表达式使用聚合函数，如`COUNT()`、`SUM()`、`MIN()`或`MAX()`。如果您发现自己想要编写一个`HAVING`子句，使用的列或表达式不在`SELECT`子句中，那么很可能应该使用`WHERE`子句。`HAVING`子句仅用于决定如何形成每个组或聚类，而不是用于选择输出中的行。稍后我们将展示一个示例，说明何时不应使用`HAVING`。'
- en: 'Let’s try another example. Suppose you want a list of the top 5 movies that
    were rented more than 30 times, together with the number of times they were rented,
    ordered by popularity in reverse. Here’s the query you’d use:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个例子。假设您想要一个列表，列出被租超过30次的前5部电影及其租赁次数，按人气逆序排序。以下是您将使用的查询：
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can again see that the expression `COUNT()` is used in both the `SELECT`
    and `HAVING` clauses. This time, though, we aliased the `COUNT(rental_id)` function
    to `num_rented` and used the alias in both the `HAVING` and `ORDER BY` clauses.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次看到，在`SELECT`和`HAVING`子句中都使用了表达式`COUNT()`。不过，这次我们将`COUNT(rental_id)`函数别名为`num_rented`，并在`HAVING`和`ORDER
    BY`子句中使用了该别名。
- en: 'Now let’s consider an example where you shouldn’t use `HAVING`. You want to
    know how many films a particular actor played in. Here’s the query you shouldn’t
    use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个不应该使用`HAVING`的例子。你想知道一个特定演员出演了多少部电影。以下是你不应该使用的查询：
- en: '[PRE55]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It gets the right answer, but in the wrong—and, for large amounts of data,
    a much slower—way. It’s not the correct way to write the query because the `HAVING`
    clause isn’t being used to decide what rows should form each group but is instead
    being incorrectly used to filter the answers to display. For this query, we should
    really use a `WHERE` clause, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它得到了正确的答案，但是用了错误的方式——对于大量数据来说，这种方式要慢得多。这不是编写查询的正确方式，因为`HAVING`子句并没有被用来决定哪些行应该形成每个组，而是被错误地用来过滤要显示的答案。对于这个查询，我们应该真正使用`WHERE`子句，如下所示：
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This correct query forms the groups and then picks which groups to display based
    on the `WHERE` clause.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正确的查询形成了组，然后根据`WHERE`子句选择要显示的组。
- en: Advanced Joins
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级连接
- en: 'So far in the book, we’ve used the `INNER JOIN` clause to bring together rows
    from two or more tables. We’ll explain the inner join in more detail in this section,
    contrasting it with the other join types we discuss: the union, left and right
    joins, and natural joins. At the conclusion of this section, you’ll be able to
    answer difficult information needs and be familiar with the correct choice of
    join for the task at hand.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经使用`INNER JOIN`子句从两个或多个表中汇集行。我们将在本节中更详细地解释内连接，并将其与我们讨论的其他连接类型进行对比：联合、左连接、右连接和自然连接。在本节结束时，你将能够回答困难的信息需求，并熟悉选择适合当前任务的正确连接方式。
- en: The Inner Join
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内连接
- en: 'The `INNER JOIN` clause matches rows between two tables based on the criteria
    you provide in the `USING` clause. For example, you’re very familiar now with
    an inner join of the `actor` and `film_actor` tables:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`INNER JOIN`子句根据你在`USING`子句中提供的条件匹配两个表之间的行。例如，你现在非常熟悉`actor`和`film_actor`表的内连接：'
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s review the key features of an `INNER JOIN`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下`INNER JOIN`的关键特点：
- en: Two tables (or results of a previous join) are listed on either side of the
    `INNER JOIN` keyphrase.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INNER JOIN`关键字短语的两侧列出了两个表（或前一个连接的结果）。'
- en: The `USING` clause defines one or more columns that are in both tables or results
    and are used to join or match rows.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USING`子句定义了一个或多个在两个表或结果中都存在并用于连接或匹配行的列。'
- en: Rows that don’t match aren’t returned. For example, if you have a row in the
    `actor` table that doesn’t have any matching films in the `film_actor` table,
    it won’t be included in the output.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不匹配的行不会被返回。例如，如果`actor`表中有一行没有在`film_actor`表中有任何匹配的电影，它将不会包含在输出中。
- en: 'You can actually write inner-join queries with the `WHERE` clause without using
    the `INNER JOIN` keyphrase. Here’s a rewritten version of the previous query that
    produces the same result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上可以使用`WHERE`子句编写带有`INNER JOIN`关键字的内连接查询。以下是产生相同结果的前一个查询的重写版本：
- en: '[PRE61]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can see that we didn’t spell out the inner join: we’re selecting from the
    `actor` and `film_actor` tables the rows where the identifiers match between the
    tables.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们没有明确说明内连接：我们正在从`actor`和`film_actor`表中选择标识符在表之间匹配的行。
- en: 'You can modify the `INNER JOIN` syntax to express the join criteria in a way
    that’s similar to using a `WHERE` clause. This is useful if the names of the identifiers
    don’t match between the tables, although that’s not the case in this example.
    Here’s the previous query, rewritten in this style:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改`INNER JOIN`语法，以一种类似于使用`WHERE`子句的方式表达连接条件。如果在表之间的标识符名称不匹配，这将非常有用，尽管在这个例子中并非如此。以下是以这种风格重写的前一个查询：
- en: '[PRE63]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can see that the `ON` clause replaces the `USING` clause and that the columns
    that follow are fully specified to include the table and column names. If the
    columns were named differently and uniquely between the two tables, you could
    omit the table names. There’s no real advantage or disadvantage to using `ON`
    or a `WHERE` clause; it’s just a matter of taste. Typically, these days, you’ll
    find most SQL professionals use the `INNER JOIN` with an `ON` clause in preference
    to `WHERE`, but it’s not universal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`ON`子句取代了`USING`子句，并且后面跟着的列完全指定了包括表和列名。如果两个表之间的列名称不同且唯一，你可以省略表名。使用`ON`或`WHERE`子句没有真正的优势或劣势；这只是一种口味问题。通常，如今，你会发现大多数SQL专业人员更喜欢使用带有`ON`子句的`INNER
    JOIN`，而不是`WHERE`，但这并非普遍适用。
- en: 'Before we move on, let’s consider what purpose the `WHERE`, `ON`, and `USING`
    clauses serve. If you omit the `WHERE` clause from the query we just showed you,
    you get a very different result. Here’s the query and the first few lines of output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们考虑`WHERE`、`ON`和`USING`子句的作用。如果从我们刚刚展示的查询中省略`WHERE`子句，将得到一个非常不同的结果。以下是查询和输出的前几行：
- en: '[PRE65]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is nonsensical: what’s happened is that each row from the `actor`
    table has been output alongside each row from the `film_actor` table, for all
    possible combinations. Since there are 200 actors and 5,462 records in the `film_actor`
    table, there are 200 × 5,462 = 1,092,400 rows of output, and we know that only
    5,462 of those combinations actually make sense (there are only 5,462 records
    for actors who played in films). We can see the number of rows we’d get without
    a `LIMIT` with the following query:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是荒谬的：发生的情况是将`actor`表中的每一行与`film_actor`表中的每一行一起输出，得到所有可能的组合。由于`actor`表有200名演员和`film_actor`表有5,462条记录，所以输出行数为200
    × 5,462 = 1,092,400行，我们知道其中只有5,462个组合是有意义的（即有5,462条记录是演员参演电影的记录）。我们可以看到在没有`LIMIT`的情况下我们会得到多少行，以下是查询的内容：
- en: '[PRE67]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This type of query, without a clause that matches rows, is known as a *Cartesian
    product*. Incidentally, you also get the Cartesian product if you perform an inner
    join without specifying a column with a `USING` or `ON` clause, as in this query:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种查询类型，如果没有匹配行的子句，被称为*笛卡尔积*。顺便说一句，如果在没有使用`USING`或`ON`子句指定列的情况下执行内连接，也会得到笛卡尔积，就像这个查询一样：
- en: '[PRE69]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In [“The Natural Join”](#ADV1-SEC-NATURAL) we’ll introduce the natural join,
    which is an inner join on identically named columns. While the natural join doesn’t
    use explicitly specified columns, it still produces an inner join, rather than
    a Cartesian product.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“自然连接”](#ADV1-SEC-NATURAL)中，我们将介绍自然连接，它是基于相同列名的内连接。虽然自然连接不使用明确指定的列，但它仍然产生内连接，而不是笛卡尔积。
- en: 'The keyphrase `INNER JOIN` can be replaced with `JOIN` or `STRAIGHT JOIN`;
    they all do the same thing. However, `STRAIGHT JOIN` forces MySQL to always read
    the table on the left before it reads the table on the right. We’ll have a look
    at how MySQL processes queries behind the scenes in [Chapter 7](ch07.xhtml#CH7_DOING_MORE).
    The keyphrase `JOIN` is the one you’ll see most commonly used: it’s a standard
    shorthand for `INNER JOIN` used by many other database systems besides MySQL,
    and we will use it in most of our inner-join examples.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词`INNER JOIN`可以用`JOIN`或`STRAIGHT JOIN`来替代；它们的功能是相同的。然而，`STRAIGHT JOIN`会强制MySQL在读取右表之前始终先读取左表。我们将在[第7章](ch07.xhtml#CH7_DOING_MORE)详细讨论MySQL在后台如何处理查询。关键词`JOIN`是最常见的，它是许多其他数据库系统（除了MySQL）中用于`INNER
    JOIN`的标准缩写，在我们的内连接示例中也会使用它。
- en: The Union
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合
- en: The `UNION` statement isn’t really a join operator. Rather, it allows you to
    combine the output of more than one `SELECT` statement to give a consolidated
    result set. It’s useful in cases where you want to produce a single list from
    more than one source, or you want to create lists from a single source that are
    difficult to express in a single query.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`UNION`语句实际上不是一个连接运算符。相反，它允许你组合多个`SELECT`语句的输出，以提供一个汇总的结果集。在你想要从多个源中产生单一列表的情况下，或者你想要从一个单一源中创建难以在单一查询中表达的列表时，它是非常有用的。'
- en: 'Let’s look at an example. If you wanted to output all actor *and* movie *and*
    customer names in the `sakila` database, you could do this with a `UNION` statement.
    It’s a contrived example, but you might want to do this just to list all of the
    text fragments, rather than to meaningfully present the relationships in the data.
    There’s text in the `actor.first_name`, `film.title`, and `customer.first_name`
    columns. Here’s how to display it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。如果你想在`sakila`数据库中输出所有演员和电影以及顾客的名字，你可以使用`UNION`语句。这是一个人为的例子，但你可能只是想列出所有的文本片段，而不是有意义地展示数据之间的关系。在`actor.first_name`、`film.title`和`customer.first_name`列中都有文本。以下是如何显示它的方式：
- en: '[PRE70]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We’ve shown only a few of the 1,647 rows. The `UNION` statement outputs the
    results from all the queries together, under a heading appropriate to the first
    query.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只展示了1,647行中的一小部分。`UNION`语句会将所有查询的结果一起输出，在第一个查询下显示适当的标题。
- en: 'A slightly less contrived example is to create a list of the five most- and
    least-rented movies in our database. You can do this easily with the `UNION` operator:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微不那么人为的例子是创建一个数据库中租借最多和最少的五部电影的列表。你可以很容易地使用`UNION`运算符来实现这一点：
- en: '[PRE72]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The first query uses `ORDER BY` with the `DESC` (descending) modifier and a
    `LIMIT 5` clause to find the top five most-rented movies. The second query uses
    `ORDER BY` with the `ASC` (ascending) modifier and a `LIMIT 5` clause to find
    the five least-rented movies. The `UNION` combines the result sets. Note that
    there are multiple titles with the same `num_rented` value, and the ordering of
    titles with the same value is not guaranteed to be determined. You may see different
    titles listed for `num_rented` values of 32 and 5 on your end.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个查询使用带有`DESC`（降序）修饰符和`LIMIT 5`子句来查找租借次数最多的前五部电影。第二个查询使用带有`ASC`（升序）修饰符和`LIMIT
    5`子句来查找租借次数最少的五部电影。`UNION`组合了结果集。请注意，具有相同`num_rented`值的多个标题，其顺序不能保证确定。在您的系统上，可能会看到不同标题列出`num_rented`值为32和5的情况。
- en: 'The `UNION` operator has several limitations:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`UNION`运算符有几个限制：'
- en: The output is labeled with the names of the columns or expressions from the
    first query. Use column aliases to change this behavior.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出标记为来自第一个查询的列名或表达式的名称。使用列别名可以更改此行为。
- en: The queries must output the same number of columns. If you try using different
    numbers of columns, MySQL will report an error.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询必须输出相同数量的列。如果尝试使用不同数量的列，MySQL将报错。
- en: All matching columns must have the same type. So, for example, if the first
    column output from the first query is a date, the first column output from any
    other query must also be a date.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有匹配列必须具有相同的类型。因此，例如，如果第一个查询输出的第一列是日期，则任何其他查询输出的第一列也必须是日期。
- en: 'The results returned are unique, as if you’d applied a `DISTINCT` to the overall
    result set. To see this in action, let’s try a simple example. Remember we had
    issues with actors’ names—the first name is a bad unique identifier. If we select
    two actors with the same first name and `UNION` the two queries, we will end up
    with just one row. The implicit `DISTINCT` operation hides the duplicate (for
    `UNION`) rows:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的结果是唯一的，就像你应用了`DISTINCT`到整个结果集一样。为了看到它的效果，让我们尝试一个简单的例子。记住我们之前在演员名字方面遇到的问题——名字不是一个好的唯一标识符。如果我们选择两个具有相同名字的演员，并且将这两个查询使用`UNION`，我们最终只会得到一行结果。隐式的`DISTINCT`操作隐藏了重复（对于`UNION`）的行：
- en: '[PRE74]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you want to show any duplicates, replace `UNION` with `UNION ALL`:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想显示任何重复项，请用`UNION`替换为`UNION ALL`：
- en: '[PRE76]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, the first name `KENNETH` appears twice.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，名为`KENNETH`的名字出现了两次。
- en: The implicit `DISTINCT` that `UNION` performs has a nonzero cost on the performance
    side of things. Whenever you use `UNION`, see whether `UNION ALL` fits logically,
    and if it can improve query performance.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UNION`执行的隐式`DISTINCT`会对性能产生非零的影响。每当使用`UNION`时，请查看是否逻辑上适合使用`UNION ALL`，以及它是否可以提高查询性能。'
- en: If you want to apply `LIMIT` or `ORDER BY` to an individual query that is part
    of a `UNION` statement, enclose that query in parentheses (as shown in the previous
    example). It’s useful to use parentheses anyway to keep the query easy to understand.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在`UNION`语句的一个单独查询中应用`LIMIT`或`ORDER BY`，请将该查询用括号括起来（如前面的例子所示）。无论如何，使用括号使查询易于理解是很有用的。
- en: The `UNION` operation simply concatenates the results of the component queries
    with no attention to order, so there’s not much point in using `ORDER BY` within
    one of the subqueries. The only time that it makes sense to order a subquery in
    a `UNION` operation is when you want to select a subset of the results. In our
    example, we’ve ordered the movies by the number of times they were rented and
    then selected only the top five (in the first subquery) and the bottom five (in
    the second subquery).
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UNION`操作仅简单地连接组成查询的结果，不考虑顺序，因此在子查询中使用`ORDER BY`没有太大意义。在`UNION`操作中对子查询进行排序只有在想要选择结果子集时才有意义。在我们的示例中，我们通过电影租借次数对电影进行了排序，并仅选择了前五部（在第一个子查询中）和最后五部（在第二个子查询中）。'
- en: For efficiency, MySQL will actually ignore an `ORDER BY` clause within a subquery
    if it’s used without `LIMIT`. Let’s look at some examples to see exactly how this
    works.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出于效率考虑，如果在子查询中使用`ORDER BY`而没有`LIMIT`，MySQL实际上会忽略`ORDER BY`子句。让我们看一些示例来确切了解其工作原理。
- en: 'First, let’s run a simple query to list the rental information for a particular
    movie, along with the time at which the rental happened. We’ve enclosed the query
    in parentheses for consistency with our other examples—the parentheses don’t actually
    have any effect here—and haven’t used an `ORDER BY` or `LIMIT` clause:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，让我们运行一个简单的查询，列出特定电影的租赁信息，以及租赁发生的时间。为了与我们的其他示例保持一致，我们将查询括在括号中——这里括号实际上没有任何效果——并且没有使用`ORDER
    BY`或`LIMIT`子句：
- en: '[PRE78]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The query returns all the times the movie was rented, in no particular order
    (see the fourth and fifth entries).
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查询返回所有租用电影的时间，顺序没有特定要求（参见第四和第五条目）。
- en: 'Now, let’s add an `ORDER BY` clause to this query:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们在这个查询中添加一个`ORDER BY`子句：
- en: '[PRE80]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As expected, we get all the times the movie was rented, in the order of the
    rental date.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如预期的那样，我们按照租赁日期的顺序获取了所有租用电影的时间。
- en: 'Adding a `LIMIT` clause to the previous query selects the first five rentals,
    in chronological order—no surprises here:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前一个查询中添加一个`LIMIT`子句会选择前五个租赁，按时间顺序排列——这里没有意外：
- en: '[PRE82]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let’s see what happens when we perform a `UNION` operation. In this example,
    we’re using two subqueries, each with an `ORDER BY` clause. We’ve used a `LIMIT`
    clause for the second subquery, but not for the first:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看在执行`UNION`操作时会发生什么。在这个例子中，我们使用了两个带有`ORDER BY`子句的子查询。我们对第二个子查询使用了`LIMIT`子句，但没有对第一个子查询使用：
- en: '[PRE84]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As expected, the first subquery returns all the times the movie was rented (the
    first nine rows of this output), and the second subquery returns the first five
    rentals (the last five rows of this output). Notice how the first nine rows are
    not in order (see the fourth and fifth rows), even though the first subquery does
    have an `ORDER BY` clause. Since we’re performing a `UNION` operation, the MySQL
    server has decided that there’s no point sorting the results of the subquery.
    The second subquery includes a `LIMIT` operation, so the results of that subquery
    are sorted.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如预期的那样，第一个子查询返回所有租用电影的时间（输出的前九行），第二个子查询返回前五个租赁（输出的最后五行）。请注意，尽管第一个子查询有`ORDER
    BY`子句，前九行并未按顺序排列（参见第四和第五行）。由于我们执行了`UNION`操作，MySQL服务器决定不对子查询的结果进行排序。第二个子查询包含了一个`LIMIT`操作，因此该子查询的结果是排序的。
- en: 'The output of a `UNION` operation isn’t guaranteed to be ordered even if the
    subqueries are ordered, so if you want the final output to be ordered, you should
    add an `ORDER BY` clause at the end of the whole query. Note that it can be in
    another order from the subqueries. See the following:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使子查询已经排序，`UNION`操作的输出并不能保证有序，因此如果你希望最终输出有序，应该在整个查询的末尾添加一个`ORDER BY`子句。请注意，它可以是另一种顺序，不同于子查询。参见以下内容：
- en: '[PRE86]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here’s another example of sorting the final results, including a limit on the
    number of returned results:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是另一个示例，包括对最终结果进行排序并限制返回结果的数量：
- en: '[PRE88]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `UNION` operation is somewhat unwieldy, and there are generally alternative
    ways of getting the same result. For example, the previous query could have been
    written more simply like this:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UNION`操作有些笨重，通常有获得相同结果的替代方法。例如，前面的查询可以更简单地写成这样：'
- en: '[PRE90]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The Left and Right Joins
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左连接和右连接
- en: The joins we’ve discussed so far output only rows that match between tables.
    For example, when you join the `film` and `rental` tables through the `inventory`
    table, you see only the films that were rented. Rows for films that haven’t been
    rented are ignored. This makes sense in many cases, but it isn’t the only way
    to join data. This section explains other options you have.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止讨论的连接仅输出两个表之间匹配的行。例如，当你通过`inventory`表连接`film`和`rental`表时，只会看到已经租出的电影。未租出的电影行将被忽略。在许多情况下这是有道理的，但这并不是连接数据的唯一方式。本节将解释你可以选择的其他选项。
- en: Suppose you do want a comprehensive list of all films and the number of times
    they’ve been rented. Unlike in the example earlier in this chapter, included in
    the list you want to see a zero next to movies that haven’t been rented. You can
    do this with a *left join*, a different type of join that’s driven by one of the
    two tables participating in the join. In a left join, each row in the left table—the
    one that’s doing the driving—is processed and output, with the matching data from
    the second table if it exists and `NULL` values if there is no matching data in
    the second table. We’ll show you how to write this type of query later in this
    section, but we’ll start with a simpler example.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您确实想要一个全面的电影列表以及它们被租赁的次数。与本章前面的示例不同，您希望在列表中看到未被租赁的电影旁边的数字为零。您可以使用 *left join*
    来实现这一点，这是一种由参与连接的两个表中的一个驱动的不同类型的连接。在左连接中，左表中的每一行（驱动表）都会被处理并输出，如果第二个表中存在匹配的数据，则显示第二个表中的匹配数据，如果第二个表中没有匹配的数据，则显示
    `NULL` 值。我们将在本节后面向您展示如何编写这种类型的查询，但我们将从一个更简单的示例开始。
- en: 'Here’s a simple `LEFT JOIN` example. You want to list all movies, and next
    to each movie you want to show when it was rented. If a movie has never been rented,
    you want to see that. If it’s been rented many times, you want to see that too.
    Here’s the query:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的 `LEFT JOIN` 示例。您想列出所有电影，并在每部电影旁边显示它们被租赁的时间。如果一部电影从未被租赁过，您也想看到这一点。如果一部电影被租赁多次，您也想看到这一点。查询如下：
- en: '[PRE92]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You can see what happens: movies that have been rented have dates and times,
    and those that haven’t don’t (the `rental_date` value is `NULL`). Note also that
    we `LEFT JOIN` twice in this example. First we join `film` and `inventory`, and
    we want to make sure that even if a movie is not in our inventory (and thus cannot
    be rented by definition), we still output it. Then we join the `rental` table
    with the dataset resulting from the previous join. We use a `LEFT JOIN` again,
    as we may have films that are not in our inventory, and those won’t have any rows
    in the `rental` table. However, we may also have films listed in our inventory
    that just haven’t been rented. That’s why we need to `LEFT JOIN` both tables here.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到发生了什么：已租赁的电影有日期和时间，而未租赁的电影则没有（`rental_date` 值为 `NULL`）。还要注意，此示例中我们两次使用了
    `LEFT JOIN`。首先，我们连接了 `film` 和 `inventory`，并且我们希望即使一部电影不在我们的库存中（因此根据定义不能租赁），我们仍然输出它。然后我们将
    `rental` 表与从前面连接结果中的数据集连接。我们再次使用 `LEFT JOIN`，因为我们可能有一些电影不在我们的库存中，这些电影在 `rental`
    表中将没有任何行。然而，我们也可能有列在我们库存中但从未被租赁的电影。这就是我们在这里需要在两个表上使用 `LEFT JOIN` 的原因。
- en: 'The order of the tables in the `LEFT JOIN` is important. If you reverse the
    order in the previous query, you get very different output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`LEFT JOIN` 中表的顺序很重要。如果您反转上一个查询中的顺序，将得到非常不同的输出：'
- en: '[PRE94]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In this version, the query is driven by the `rental` table, so all rows from
    it are matched against the `inventory` table and then against `film`. Since all
    the rows in the `rental` table by definition are based on the `inventory` table,
    which is linked to the `film` table, we have no `NULL` values in the output. There
    can be no rental for a film that doesn’t exist. We adjusted the query with `ORDER
    BY rental_date DESC` to show that we really didn’t get any `NULL` values (these
    would have been last).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，查询由 `rental` 表驱动，因此所有从它中得到的行都与 `inventory` 表和 `film` 表匹配。由于根据定义 `rental`
    表中的所有行都基于 `inventory` 表，后者与 `film` 表关联，因此我们在输出中没有 `NULL` 值。不存在没有对应电影的租赁。我们通过使用
    `ORDER BY rental_date DESC` 调整了查询以显示我们确实没有得到任何 `NULL` 值（这些将是最后出现的）。
- en: 'By now you can see that left joins are useful when we’re sure that our *left*
    table has some important data, but we’re not sure whether the *right* table does.
    We want to get the rows from the left one with or without the corresponding rows
    from the right one. Let’s try to apply this to a query we wrote in [“The GROUP
    BY Clause”](#ADV1-SEC-GROUPBY), which showed customers renting a lot from the
    same category. Here’s the query, as a reminder:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到，在我们确信我们的 *left* 表中有一些重要数据但不确定 *right* 表中是否有数据时，左连接非常有用。我们希望从左表获取带有或不带有右表相应行的行。让我们试着将这个应用到我们在
    [“GROUP BY 子句”](#ADV1-SEC-GROUPBY) 中编写的查询中，该查询显示了从同一类别大量租赁的客户。以下是查询，作为提醒：
- en: '[PRE96]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: What if we now want to see whether a customer we found this way rents films
    from anything but their favorite category? It turns out that’s actually pretty
    difficult!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要查看通过这种方式找到的客户是否租赁除了他们最喜欢的类别之外的电影？事实证明这实际上相当困难！
- en: Let’s consider this task. We need to start with the `category` table, as that
    will have all the categories we have for our films. We then need to start constructing
    a whole chain of left joins. First we left join `category` to `film_category`,
    as we may have categories with no films. Then we left join the result to the `inventory`
    table, as some movies we know about may not be in our catalog. We then left join
    that result to the `rental` table, as customers may not have rented some of the
    films in a category. Finally, we need to left join that result to our `customer`
    table. Even though there can be no associated customer record without a rental,
    omitting the left join here will cause MySQL to discard rows for categories that
    end up with no customer records.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个任务。我们需要从`category`表开始，因为那里有我们电影的所有分类。然后，我们需要开始构建一整个链条的左连接。首先，我们将`category`左连接到`film_category`，因为我们可能有没有电影的分类。然后，我们将结果左连接到`inventory`表，因为我们知道的一些电影可能不在我们的目录中。然后，我们将该结果左连接到`rental`表，因为顾客可能没有租用某些类别的电影。最后，我们需要将该结果左连接到我们的`customer`表。即使没有租赁记录与关联的客户记录，省略此处的左连接将导致MySQL丢弃没有顾客记录的类别行。
- en: 'Now, after this whole long explanation, can we finally go ahead and filter
    by email address and get our data? No! Unfortunately, by adding a `WHERE` condition
    on the table that is not *left* in our left-join relationship, we break the idea
    of this join. See what happens:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这整个长篇解释之后，我们可以继续按电子邮件地址过滤并获取我们的数据吗？不！不幸的是，通过在左连接关系中不是左侧的表上添加`WHERE`条件，我们破坏了此连接的理念。看看会发生什么：
- en: '[PRE98]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We got 14 categories for our customer, while there are 16 in total. In fact,
    MySQL will optimize away all the left joins in this query, as it understands they
    are meaningless when put like this. There’s no easy way to answer the question
    we have with just joins—we’ll get back to this example in [“Nested Queries in
    JOINs”](#ADV1-SEC-NESTEDJOIN).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的客户获得了14个类别，而总共有16个。实际上，MySQL将在这个查询中优化所有左连接，因为它理解到它们放在这里是没有意义的。在仅使用连接来回答我们的问题没有简单的方法——我们将在[“嵌套连接中的查询”](#ADV1-SEC-NESTEDJOIN)中返回到这个例子。
- en: 'The query that we’ve written is still useful, though. While by default `sakila`
    does not have a film category in which no films have been rented, if we expand
    our database slightly, we can see the effectiveness of left joins:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认情况下`sakila`没有未租用电影的电影类别，但如果我们稍微扩展我们的数据库，我们可以看到左连接的有效性：
- en: '[PRE102]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If we were to use a regular `INNER JOIN` (or just `JOIN`, its synonym) here,
    we wouldn’t get information for the Thriller category, and we might get different
    counts for other categories. As `category` is our leftmost table, it drives the
    process of the query, and every row from that table is present in the output.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里使用常规的`INNER JOIN`（或其同义词`JOIN`），我们将无法获取Thriller类别的信息，而其他类别的计数可能会有所不同。由于`category`是我们最左边的表，它驱动查询的过程，并且该表中的每一行都存在于输出中。
- en: We’ve shown you that it matters what comes before and after the `LEFT JOIN`
    keyphrase. Whatever is on the left drives the process, hence the name “left join.”
    If you really don’t want to reorganize your query so it matches that template,
    you can use `RIGHT JOIN`. It’s exactly the same, except whatever is on the right
    drives the process.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向您展示了`LEFT JOIN`关键词之前和之后的内容很重要。左侧的内容驱动整个过程，因此称为“左连接”。如果您真的不想重新组织查询以匹配该模板，可以使用`RIGHT
    JOIN`。它完全相同，只是右侧的内容驱动整个过程。
- en: 'Earlier we showed the importance of the order of the tables in a left join
    using two queries for film rental information. Let’s rewrite the second of them
    (which showed incorrect data) using a right join:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们展示了左连接中表的顺序的重要性，使用两个用于电影租赁信息的查询。让我们使用右连接重新编写第二个查询（显示不正确数据）：
- en: '[PRE106]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We got the same number of rows, and we can see that the `NULL` values are the
    same as those the “correct” query gave us. The right join is useful sometimes
    because it allows you to write a query more naturally, expressing it in a way
    that’s more intuitive. However, you won’t often see it used, and we’d recommend
    avoiding it where possible.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了相同数量的行，并且我们可以看到`NULL`值与“正确”查询给我们的值相同。右连接有时很有用，因为它允许您更自然地编写查询，以更直观的方式表达它。然而，您不经常看到它被使用，我们建议在可能的情况下避免使用它。
- en: 'Both left and right joins can use the `USING` and `ON` clauses discussed in
    [“The Inner Join”](#ADV1-SEC-INNERJOIN). You should use one or the other: without
    them you’ll get the Cartesian product, as discussed in that section.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 左连接和右连接都可以使用[“内连接”](#ADV1-SEC-INNERJOIN)中讨论的`USING`和`ON`子句。你应该选择其中之一：没有它们，你将得到笛卡尔积，正如该节中讨论的那样。
- en: There’s also an extra `OUTER` keyword that you can optionally use in left and
    right joins to make them read as `LEFT OUTER JOIN` and `RIGHT OUTER JOIN`. It’s
    just an alternative syntax that doesn’t do anything different, and you won’t often
    see it used. We stick to the basic versions in this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在左连接和右连接中，还可以选择使用额外的`OUTER`关键字，使它们读起来像`LEFT OUTER JOIN`和`RIGHT OUTER JOIN`。这只是一种不同的语法，实际上并没有任何不同，你不经常看到它被使用。在本书中，我们坚持使用基本版本。
- en: The Natural Join
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然连接
- en: We’re not big fans of the natural join that we describe in this section. It’s
    included here only for completeness, and because you’ll see it used sometimes
    in SQL statements you’ll encounter. Our advice is to avoid using it where possible.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是这里描述的自然连接的铁杆支持者。它在这里仅仅是为了完整性，也因为你会在遇到的SQL语句中偶尔看到它。我们的建议是尽可能避免在可以的情况下使用它。
- en: 'A natural join is, well, supposed to be magically natural. This means that
    you tell MySQL what tables you want to join, and it figures out how to do it and
    gives you an `INNER JOIN` result set. Here’s an example for the `actor_info` and
    `film_actor` tables:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 自然连接应该是一种自然而然的魔法。这意味着你告诉MySQL你想连接哪些表，它会找出如何连接它们，并给你一个`INNER JOIN`的结果集。这里有一个关于`actor_info`和`film_actor`表的例子：
- en: '[PRE108]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In reality, it’s not quite magical: all MySQL does is look for columns with
    the same names and, behind the scenes, add these silently into an inner join with
    join conditions written into the `WHERE` clause. So, the previous query is actually
    translated into something like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这并不是什么神奇的事情：MySQL只是查找具有相同名称的列，并在幕后将这些列静默地添加到具有连接条件的`WHERE`子句中。因此，前面的查询实际上被转换成类似于这样的内容：
- en: '[PRE110]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If the identifier columns don’t share the same name, natural joins won’t work.
    Also, more dangerously, if columns that do share the same names aren’t identifiers,
    they’ll get thrown into the behind-the-scenes `USING` clause anyway. You can very
    easily see this in the `sakila` database. In fact, that’s why we resorted to showing
    the preceding example with `actor_info`, which isn’t even a table: it’s a view.
    Let’s see what would have happened if we used the regular `actor` and `film_actor`
    tables:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标识符列没有相同的名称，自然连接将无法工作。更危险的是，如果具有相同名称的列不是标识符，它们将被静默地添加到后台的`USING`子句中。你可以很容易地在`sakila`数据库中看到这一点。事实上，这就是为什么我们选择显示前面的例子与`actor_info`，它甚至不是一个表：它是一个视图。让我们看看如果我们使用常规的`actor`和`film_actor`表会发生什么：
- en: '[PRE111]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'But how? The problem is: `NATURAL JOIN` really does take *all* of the columns
    into consideration. With the `sakila` database, that’s a huge roadblock, as every
    table has a `last_update` column. If you were to run an `EXPLAIN` statement on
    the previous query and then execute `SHOW WARNINGS`, you’d see that the resulting
    query is meaningless:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何呢？问题是：`NATURAL JOIN`确实考虑了*所有*列。在`sakila`数据库中，这是一个巨大的障碍，因为每个表都有一个`last_update`列。如果你运行前面查询的`EXPLAIN`语句，然后执行`SHOW
    WARNINGS`，你会发现生成的查询是毫无意义的：
- en: '[PRE113]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You’ll sometimes see the natural join mixed with left and right joins. The
    following are valid join syntaxes: `NATURAL LEFT JOIN`, `NATURAL LEFT OUTER JOIN`,
    `NATURAL RIGHT JOIN`, and `NATURAL RIGHT OUTER JOIN`. The former two are left
    joins without `ON` or `USING` clauses, and the latter two are right joins. Again,
    avoid writing them when you can, but you should understand what they mean if you
    see them used.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时会看到自然连接与左连接和右连接混合使用。以下是有效的连接语法：`NATURAL LEFT JOIN`、`NATURAL LEFT OUTER JOIN`、`NATURAL
    RIGHT JOIN`和`NATURAL RIGHT OUTER JOIN`。前两者是没有`ON`或`USING`子句的左连接，后两者是右连接。同样，尽量避免使用它们，但是如果你看到它们被使用，你应该理解它们的含义。
- en: Constant Expressions in Joins
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接中的常数表达式
- en: In all of the examples of joins we’ve given you so far, we’ve used column identifiers
    to define the join condition. When you’re using the `USING` clause, that’s the
    only possible way to go. When you’re defining the join conditions in a `WHERE`
    clause, that’s also the only thing that will work. However, when you’re using
    the `ON` clause, you can actually add constant expressions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止提供的所有连接示例中，我们都使用列标识符来定义连接条件。当你使用`USING`子句时，这是唯一可能的方法。当你在`WHERE`子句中定义连接条件时，这也是唯一有效的方法。然而，当你使用`ON`子句时，你实际上可以添加常数表达式。
- en: 'Let’s consider an example, listing all films for a particular actor:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，列出特定演员的所有电影：
- en: '[PRE115]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can move the `actor_id` clause into the join like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样将 `actor_id` 子句移入联接：
- en: '[PRE117]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Well, that’s neat, of course, but why? Is this any more expressive than having
    the proper `WHERE` clause? The answer to both questions is that constant conditions
    in joins are evaluated and resolved differently than the conditions in the `WHERE`
    clause are. It’s easier to show this with an example, but the preceding query
    is a poor one. The impact of constant conditions in joins is best shown with a
    left join.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这当然很棒，但为什么呢？这比有适当的 `WHERE` 子句更具表现力吗？对这两个问题的答案是，在联接中的常量条件与 `WHERE` 子句中的条件的评估和解析方式不同。最好通过示例来展示这一点，但前面的查询不好。常量条件在联接中的影响最好通过左连接来显示。
- en: 'Remember this query from the section on left joins:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住本节中关于左连接的查询：
- en: '[PRE119]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'If we go ahead and move the `cs.email` clause to the `LEFT JOIN customer cs`
    part, we’ll see completely different results:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `cs.email` 子句移到 `LEFT JOIN customer cs` 部分，我们将看到完全不同的结果：
- en: '[PRE121]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: That’s interesting! Instead of getting only Wesley’s rental counts per category,
    we also get rental counts for everyone else broken down by category. That even
    includes our new and so far empty Thriller category. Let’s try to understand what
    happens here.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣！与其仅获取Wesley每个类别的租赁次数，我们还得到了每个其他人按类别分解的租赁次数。甚至包括我们新的到目前为空的惊悚类别。让我们试着理解这里发生了什么。
- en: The `WHERE` clause’s contents are applied logically after the joins are resolved
    and executed. We tell MySQL we only need rows from whatever we join where the
    `cs.email` column equals `'WESLEY.BULL@sakilacustomer.org'`. In reality, MySQL
    is smart enough to optimize this situation and will actually start the plan execution
    as if regular inner joins were used. When we have the `cs.email` condition within
    the `LEFT JOIN customer` clause, we tell MySQL that we want to add columns from
    the `customer` table to our result set so far (which includes the `category`,
    `inventory`, and `rental` tables), but only when the certain value is present
    in the `email` column. Since this is a `LEFT JOIN`, we get `NULL` in every column
    of `customer` in rows that didn’t match.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句的内容在解析和执行联接之后逻辑应用。我们告诉MySQL，我们只需要来自我们加入的任何内容的行，其中 `cs.email` 列等于
    `''WESLEY.BULL@sakilacustomer.org''`。事实上，MySQL 足够聪明，可以优化这种情况，并且实际上会开始执行计划，就好像使用了常规的内连接。当我们在
    `LEFT JOIN customer` 子句中有 `cs.email` 条件时，我们告诉MySQL，我们希望将 `customer` 表的列添加到我们到目前为止的结果集中（包括
    `category`、`inventory` 和 `rental` 表），但仅在 `email` 列中出现特定值时。由于这是 `LEFT JOIN`，在未匹配的行中，我们在
    `customer` 的每一列中得到 `NULL`。'
- en: It’s important to be aware of this behavior.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意这种行为。
- en: Nested Queries
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套查询
- en: Nested queries, supported by MySQL since version 4.1, are the most difficult
    to learn. However, they provide a powerful, useful, and concise way of expressing
    difficult information needs in short SQL statements. This section explains them,
    beginning with simple examples and leading to the more complex features of the
    `EXISTS` and `IN` statements. At the conclusion of this section, you’ll have completed
    everything this book contains about querying data, and you should understand almost
    any SQL query you encounter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 自MySQL 4.1版本以来支持的嵌套查询是最难学习的。然而，它们提供了一种强大、有用且简洁的方式来表达短SQL语句中难以理解的信息需求。本节将从简单的示例开始解释它们，并引导您了解
    `EXISTS` 和 `IN` 语句的更复杂特性。在本节结束时，您将完成本书关于查询数据的所有内容，并且应该能够理解您遇到的几乎任何SQL查询。
- en: Nested Query Basics
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套查询基础
- en: 'You know how to find the names of all the actors who played in a particular
    movie using an `INNER JOIN`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何使用 `INNER JOIN` 找到参与特定电影的所有演员的名字：
- en: '[PRE123]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'But there’s another way, using a *nested query*:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一种方法，使用 *嵌套查询*：
- en: '[PRE125]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'It’s called a nested query because one query is inside another. The *inner
    query*, or *subquery*—the one that is nested—is written in parentheses, and you
    can see that it determines the `film_id` for the film with the title `ZHIVAGO
    CORE`. The parentheses are required for inner queries. The *outer query* is the
    one that’s listed first and isn’t parenthesized here: you can see that it finds
    the `first_name` and `last_name` of the actors from a `JOIN` with `film_actor`
    with a `film_id` that matches the result of the subquery. So, overall, the inner
    query finds the `film_id`, and the outer query uses it to find actors’ names.
    Whenever nested queries are used, it’s possible to rewrite them as a few separate
    queries. Let’s do that with the previous example, as it may help you understand
    what is going on:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为嵌套查询，因为一个查询在另一个查询内部。*内部查询* 或 *子查询* ——被嵌套的查询——写在括号中，你可以看到它确定了具有标题 `ZHIVAGO
    CORE` 的电影的 `film_id`。内部查询需要用括号括起来。*外部查询* 是首先列出的查询，在这里没有括号：你可以看到它通过与 `film_actor`
    的 `JOIN` 来找到与子查询结果匹配的 `film_id`，从而找到演员的 `first_name` 和 `last_name`。因此，总体而言，内部查询找到
    `film_id`，而外部查询则使用它来找到演员的姓名。每当使用嵌套查询时，都可以将其重写为几个单独的查询。让我们对先前的示例进行这样的操作，因为这可能有助于您理解正在发生的情况：
- en: '[PRE127]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'So, which approach is preferable: nested or not nested? The answer isn’t easy.
    In terms of performance, the answer is usually *not*: nested queries are hard
    to optimize, so they’re almost always slower to run than the unnested alternative.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪种方法更可取：嵌套还是非嵌套？答案并不容易。从性能角度来看，答案通常是 *不是*：嵌套查询很难优化，因此几乎总是比非嵌套的替代方法运行速度慢。
- en: 'Does this mean you should avoid nesting? The answer is no: sometimes it’s your
    only choice if you want to write a single query, and sometimes nested queries
    can answer information needs that can’t be easily solved otherwise. What’s more,
    nested queries are expressive. Once you’re comfortable with the idea, they’re
    a very readable way to show how a query is evaluated. In fact, many SQL designers
    advocate teaching nested queries before the join-based alternatives we’ve shown
    you in the past few sections. We’ll show you examples where nesting is readable
    and powerful throughout this section.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你应该避免嵌套？答案是否定的：有时这是你唯一的选择，如果你想要编写单个查询，有时嵌套查询可以回答其他方法难以解决的信息需求。此外，嵌套查询具有表达能力。一旦你熟悉这个概念，它们是一种非常可读的方式来展示查询如何被评估。事实上，许多
    SQL 设计者倡导在向你展示的前几节中展示基于连接的替代方法之前教授嵌套查询。我们将向您展示在本节中嵌套查询如何既可读又强大的示例。
- en: 'Before we begin to cover the keywords that can be used in nested queries, let’s
    take a look at an example that can’t be done easily in a single query—at least,
    not without MySQL’s nonstandard, although ubiquitous, `LIMIT` clause! Suppose
    you want to know what movie a customer rented most recently. To do this, following
    the methods we’ve learned previously, you could find the date and time of the
    most recently stored row in the `rental` table for that customer:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论可以在嵌套查询中使用的关键字之前，让我们看一个例子，这个例子不容易在一个单独的查询中完成——至少不是没有 MySQL 的非标准，尽管普遍存在的
    `LIMIT` 子句！假设你想知道客户最近租了哪部电影。根据我们之前学到的方法，你可以找到该客户在 `rental` 表中最近存储行的日期和时间：
- en: '[PRE131]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You can then use the output as input to another query to find the film title:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将输出用作另一个查询的输入来查找电影标题：
- en: '[PRE133]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [“User Variables”](#ADV1-SEC-VARIABLES) we’ll show you how you can use variables
    to avoid having to type in the value in the second query.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“用户变量”](#ADV1-SEC-VARIABLES) 中，我们将向您展示如何使用变量来避免在第二个查询中键入值。
- en: 'With a nested query, you can do both steps in one shot:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嵌套查询，你可以一次完成两个步骤：
- en: '[PRE135]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: You can see the nested query combines the two previous queries. Rather than
    using the constant date and time value discovered from a previous query, it executes
    the query directly as a subquery. This is the simplest type of nested query, one
    that returns a *scalar operand*--that is, a single value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到嵌套查询结合了两个先前的查询。与使用从先前查询中发现的常量日期和时间值不同，它直接执行子查询作为子查询。这是最简单的嵌套查询类型，返回一个 *标量操作数*——即单个值。
- en: Tip
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The previous example used the equality operator (`=`). You can use all types
    of comparison operators: `<` (less than), `<=` (less than or equal to), `>` (greater
    than), `>=` (greater than or equal to), and `!=` (not equals) or `<>` (not equals).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例使用了等号运算符（`=`）。你可以使用所有类型的比较运算符：`<`（小于）、`<=`（小于或等于）、`>`（大于）、`>=`（大于或等于）、`!=`（不等于）或
    `<>`（不等于）。
- en: The ANY, SOME, ALL, IN, and NOT IN Clauses
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意、某些、所有、IN 和 NOT IN 子句
- en: Before we start to show some more advanced features of nested queries, we need
    to switch to a new database in our examples. Unfortunately, the `sakila` database
    is a little too well normalized to effectively demonstrate the full power of nested
    querying. So, let’s add a new database to give us something to play with.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始展示更多嵌套查询的高级特性之前，我们需要在我们的示例中切换到一个新的数据库。不幸的是，`sakila`数据库过于规范化，无法有效地展示嵌套查询的全部功能。所以，让我们添加一个新的数据库来玩耍。
- en: The database we’ll install is the `employees` sample database. You can find
    instructions for installation in the [MySQL documentation](https://oreil.ly/vODJG)
    or in the database’s GitHub repo. Either clone the repository using `git` or download
    the latest release ([1.0.7](https://oreil.ly/zW0E1) at the time of writing). Once
    you have the necessary files ready, you need to run two commands.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装的数据库是`employees`样本数据库。您可以在[MySQL文档](https://oreil.ly/vODJG)或数据库的GitHub存储库中找到安装说明。使用`git`克隆存储库或下载最新版本（在撰写本文时为[1.0.7](https://oreil.ly/zW0E1)）。一旦准备好所需的文件，您需要运行两个命令。
- en: 'The first command creates the necessary structures and loads the data:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建必要的结构并加载数据：
- en: '[PRE137]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The second command verifies the installation:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令验证安装是否正确：
- en: '[PRE138]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Once this is done, you can proceed to work through the examples we’ll be providing
    next.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，您可以继续执行我们将提供的示例。
- en: 'To connect to the new database, either run `mysql` from the command line like
    this (or specify `employees` as a target for your MySQL client of choice):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到新数据库，可以像这样从命令行运行`mysql`（或者指定`employees`作为您选择的MySQL客户端的目标）：
- en: '[PRE139]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Or execute the following at a `mysql` prompt to change the default database:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在`mysql`提示符下执行以下操作来更改默认数据库：
- en: '[PRE140]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Now you’re ready to move forward.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以继续前进了。
- en: Using ANY and IN
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ANY和IN
- en: 'Now that you’ve created the sample tables, you can try an example using `ANY`.
    Suppose you’re looking to find assistant engineers who’ve been working longer
    than the least experienced manager. You can express this information need as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建了示例表，可以使用`ANY`尝试一个示例。假设您想找到比最不经验的经理工作时间更长的助理工程师。您可以将此信息需求表达如下：
- en: '[PRE141]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Turns out there are a lot of people who meet these criteria! The subquery finds
    the dates on which managers were hired:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明符合这些条件的人有很多！子查询查找经理被聘用的日期：
- en: '[PRE143]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The outer query goes through each employee with the title `Associate Engineer`,
    returning the engineer if their hire date is lower (older) than any of the values
    in the set returned by the subquery. So, for example, `Sumant Peac` is output
    because `1985-02-18` is older than at least one value in the set (as you can see,
    the second hire date returned for managers is `1986-04-12`). The `ANY` keyword
    means just that: it’s true if the column or expression preceding it is true for
    *any* of the values in the set returned by the subquery. Used in this way, `ANY`
    has the alias `SOME`, which was included so that some queries can be read more
    clearly as English expressions; it doesn’t do anything different, and you’ll rarely
    see it used.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 外部查询遍历每个标题为`Associate Engineer`的员工，如果他们的入职日期比子查询返回的任何值都早（更旧），则返回该工程师。因此，例如，`Sumant
    Peac`会被输出，因为`1985-02-18`比子查询返回的至少一个值更早（正如您可以看到，经理的第二个入职日期是`1986-04-12`）。`ANY`关键字的含义正是如此：如果在子查询返回的集合中的*任何*值上，前面的列或表达式为真，那么它就是真的。以这种方式使用，`ANY`有一个别名`SOME`，这是为了更清晰地读取某些查询作为英语表达式而包含的；它并不做任何不同的事情，您很少会看到它被使用。
- en: The `ANY` keyword gives you more power in expressing nested queries. Indeed,
    the previous query is the first nested query in this section with a *column subquery*—that
    is, the results returned by the subquery are one or more values from a column,
    instead of a single scalar value as in the previous section. With this, you can
    now compare a column value from an outer query to a set of values returned from
    a subquery.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANY`关键字在表达嵌套查询时提供了更大的表达力。确实，前面的查询是本节中第一个带有*列子查询*的嵌套查询——也就是说，子查询返回的结果是来自列的一个或多个值，而不是像前一节中那样的单一标量值。有了这个，您现在可以将外部查询的列值与子查询返回的一组值进行比较了。'
- en: 'Consider another example using `ANY`. Suppose you want to know the managers
    who also have some other title. You can do this with the following nested query:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个使用`ANY`的例子。假设您想知道还有其他头衔的经理。您可以使用以下嵌套查询来执行此操作：
- en: '[PRE145]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The `= ANY` causes the outer query to return a manager when the `emp_no` is
    equal to any of the engineer employee numbers returned by the subquery. The `=
    ANY` keyphrase has the alias `IN`, which you’ll see commonly used in nested queries.
    Using `IN`, the previous example can be rewritten as:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`= ANY`会导致外部查询在`emp_no`等于子查询返回的工程师员工号之一时返回经理。`= ANY`短语具有别名`IN`，您将在嵌套查询中经常看到其使用。使用`IN`，前面的示例可以重写为：'
- en: '[PRE147]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Of course, for this particular example, you could also have used a join query.
    Note that we have to use `DISTINCT` here, because otherwise we get 30 rows returned.
    Some people hold more than one non-engineer title:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这个特定的例子，您也可以使用连接查询。请注意，在这里我们必须使用`DISTINCT`，因为否则会返回30行。有些人拥有多个非工程师职称：
- en: '[PRE149]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Again, nested queries are expressive but typically slow in MySQL, so use a join
    where you can.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，嵌套查询在MySQL中表达力强但通常速度较慢，因此尽可能使用连接。
- en: Using ALL
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ALL
- en: 'Suppose you want to find assistant engineers who are more experienced than
    all of the managers—that is, more experienced than the most experienced manager.
    You can do this with the `ALL` keyword in place of `ANY`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要找出比所有经理更有经验的助理工程师——即比最有经验的经理更有经验的助理工程师。您可以使用`ALL`关键字代替`ANY`来完成这一操作：
- en: '[PRE151]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'You can see that there are no answers. We can inspect the data further to check
    what is the oldest hire date of a manager and of an assistant engineer:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到没有答案。我们可以进一步检查数据，以确定经理和助理工程师的最早雇佣日期分别是什么：
- en: '[PRE153]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Looking at the data, we see that the first manager was hired on January 1, 1985,
    and the first assistant engineer only on February 1 of the same year. While the
    `ANY` keyword returns values that satisfy at least one condition (Boolean OR),
    the `ALL` keyword returns values only where all the conditions are satisfied (Boolean
    AND).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数据，我们看到第一位经理的雇佣日期是1985年1月1日，而第一位助理工程师是同年2月1日雇佣的。而`ANY`关键字返回满足至少一个条件的值（布尔OR），`ALL`关键字仅返回所有条件都满足的值（布尔AND）。
- en: 'We can use the alias `NOT IN` in place of `<> ANY` or `!= ANY`. Let’s find
    all the managers who aren’t senior staff:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`NOT IN`别名代替`<> ANY`或`!= ANY`。让我们找出所有不是高级员工的经理：
- en: '[PRE155]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: As an exercise, try writing this query using the `ANY` syntax and as a join
    query.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试使用`ANY`语法和连接查询来编写此查询。
- en: 'The `ALL` keyword has a few tricks and traps:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALL`关键字有一些技巧和陷阱：'
- en: If it’s false for any value, it’s false. Suppose that table `a` contains a row
    with the value 14, and table `b` contains the values 16, 1, and `NULL`. If you
    check whether the value in `a` is greater than `ALL` values in `b`, you’ll get
    `false`, since 14 isn’t greater than 16\. It doesn’t matter that the other values
    are 1 and `NULL`.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对任何值为false，则为false。假设表`a`包含值为14的行，表`b`包含值为16、1和`NULL`。如果您检查`a`中的值是否大于`b`中所有值，您将得到`false`，因为14不大于16。其他值为1和`NULL`并不重要。
- en: If it isn’t false for any value, it isn’t true unless it’s true for all values.
    Suppose that table `a` again contains 14, and `b` contains 1 and `NULL`. If you
    check whether the value in `a` is greater than `ALL` values in `b`, you’ll get
    `UNKNOWN` (neither true nor false) because it can’t be determined whether `NULL`
    is greater than or less than 14.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对任何值都不为false，则除非对所有值都为true，否则它不为true。假设表`a`再次包含14，`b`包含1和`NULL`。如果你检查`a`中的值是否大于`b`中所有值，你会得到`UNKNOWN`（既非true也非false），因为不能确定`NULL`是大于还是小于14。
- en: If the table in the subquery is empty, the result is always true. Hence, if
    `a` contains 14 and `b` is empty, you’ll get `true` when you check if the value
    in `a` is greater than `ALL` values in `b`.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子查询中的表为空，则结果始终为true。因此，如果`a`包含14且`b`为空，则在检查`a`中的值是否大于`b`中所有值时将得到`true`。
- en: When using the `ALL` keyword, be very careful with tables that can have `NULL`
    values in columns; consider disallowing `NULL` values in such cases. Also, be
    careful with empty tables.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ALL`关键字时，要特别注意表中可能存在列值为`NULL`的情况；在这种情况下，考虑不允许`NULL`值。同时，要小心处理空表。
- en: Writing row subqueries
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写行子查询
- en: In the previous examples, the subquery returned a single scalar value (such
    as an `actor_id`) or a set of values from one column (such as all of the `emp_no`
    values). This section describes another type of subquery, the *row subquery*,
    that works with multiple columns from multiple rows.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，子查询返回单个标量值（例如`actor_id`）或来自一个列的一组值（例如所有`emp_no`的值）。本节描述了另一种类型的子查询，即*行子查询*，它可以处理来自多行的多列。
- en: 'Suppose you’re interested in whether a manager had another position within
    the same calendar year. To answer this need, you must match both the employee
    number and the title assignment date, or, more precisely, year. You can write
    this as a join:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想知道经理在同一日历年内是否有其他职位。要回答这个问题，您必须匹配员工编号和职务分配日期，或者更准确地说，年份。您可以将其写为连接查询：
- en: '[PRE157]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'But you can also write it as a nested query:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你也可以将其编写为嵌套查询：
- en: '[PRE159]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'You can see there’s a different syntax being used in this nested query: a list
    of two column names in parentheses follows the `WHERE` statement, and the inner
    query returns two columns. We’ll explain this syntax next.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在这个嵌套查询中使用了不同的语法：括号内跟随`WHERE`语句的两个列名列表，并且内部查询返回两列。我们将在接下来解释这个语法。
- en: 'The row subquery syntax allows you to compare multiple values per row. The
    expression `(emp_no, YEAR(from_date))` means two values per row are compared to
    the output of the subquery. You can see following the `IN` keyword that the subquery
    returns two values, `emp_no` and `YEAR(from_date)`. So, the fragment:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 行子查询语法允许您每行比较多个值。表达式`(emp_no, YEAR(from_date))`表示每行比较子查询的输出的两个值。您可以看到在`IN`关键字后面，子查询返回两个值，`emp_no`和`YEAR(from_date)`。因此，片段如下：
- en: '[PRE161]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'matches manager numbers and starting years to nonmanager numbers and starting
    years, and returns a true value when a match is found. The result is that if a
    matching pair is found, the overall query outputs a result. This is a typical
    row subquery: it finds rows that exist in two tables.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配经理编号和起始年份到非经理编号和起始年份，并且当找到匹配时返回一个真值。结果是，如果找到匹配对，整个查询输出结果。这是一个典型的行子查询：它找到存在于两个表中的行。
- en: 'To explain the syntax further, let’s consider another example. Suppose you
    want to see if a particular employee is a senior staff member. You can do this
    with the following query:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释语法，让我们考虑另一个例子。假设您想查看特定员工是否是高级员工。您可以使用以下查询完成：
- en: '[PRE162]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: It’s not a nested query, but it shows you how the new row subquery syntax works.
    You can see that the query matches the list of columns before the equals sign,
    `(employees.emp_no, first_name, last_name, title)`, to the list of columns and
    values after the equals sign, `(titles.emp_no, 'Marjo', 'Giarratana', 'Senior
    Staff')`. So, when the `emp_no` values match, the employee’s full name is `Marjo`
    `Giarratana`, and the title is `Senior Staff`, we get output from the query. We
    don’t recommend writing queries like this—use a regular `WHERE` clause with multiple
    `AND` conditions instead—but it does illustrate exactly what’s going on. For an
    exercise, try writing this query using a join.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是一个嵌套查询，但它展示了新的行子查询语法如何工作。您可以看到查询在等号之前匹配列的列表`(employees.emp_no, first_name,
    last_name, title)`与等号之后列和值的列表`(titles.emp_no, 'Marjo', 'Giarratana', 'Senior Staff')`。因此，当`emp_no`值匹配时，员工的全名是`Marjo`
    `Giarratana`，职务是`Senior Staff`时，我们从查询中获取输出。我们不建议编写像这样的查询——而是使用带有多个`AND`条件的常规`WHERE`子句——但它确实说明了正在发生的情况。作为一项练习，尝试使用连接编写此查询。
- en: Row subqueries require that the number, order, and type of values in the columns
    match. So, for example, our previous example matches an `INT` to an `INT`, and
    two character strings to two character strings.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 行子查询要求列中的值的数量、顺序和类型匹配。例如，我们的前一个示例将一个`INT`匹配到一个`INT`，两个字符字符串匹配到两个字符字符串。
- en: The EXISTS and NOT EXISTS Clauses
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在和不存在子句
- en: 'You’ve now seen three types of subquery: scalar subqueries, column subqueries,
    and row subqueries. In this section, you’ll learn about a fourth type, the *correlated
    subquery*, where a table used in the outer query is referenced in the subquery.
    Correlated subqueries are often used with the `IN` statement we’ve already discussed
    and almost always used with the `EXISTS` and `NOT EXISTS` clauses that are the
    focus of this section.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了三种类型的子查询：标量子查询、列子查询和行子查询。在本节中，您将学习第四种类型，即*相关子查询*，其中外部查询中使用的表在子查询中被引用。相关子查询通常与我们已经讨论过的`IN`语句一起使用，并且几乎总是与本节重点讨论的`EXISTS`和`NOT
    EXISTS`子句一起使用。
- en: EXISTS and NOT EXISTS basics
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EXISTS和NOT EXISTS基础知识
- en: 'Before we start on our discussion of correlated subqueries, let’s investigate
    what the `EXISTS` clause does. We’ll need a simple but strange example to introduce
    the clause, since we’re not discussing correlated subqueries just yet. So, here
    goes: suppose you want to find a count of all films in the database, but only
    if the database is active, which you’ve defined to mean only if at least one movie
    from any branch has been rented. Here’s the query that does it (don’t forget to
    connect to the `sakila` database again before running this query—hint: use the
    `use <db>` command):'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论相关子查询之前，让我们探讨一下`EXISTS`子句的作用。我们需要一个简单但奇怪的例子来介绍这个子句，因为我们暂时不讨论相关子查询。所以，这里是例子：假设您想在数据库中找到所有电影的计数，但仅当数据库处于活动状态时，您定义为只有在任何分支的至少一部电影已出租时才算活动。这是执行此操作的查询（在运行此查询之前不要忘记重新连接到`sakila`数据库——提示：使用`use
    <db>`命令）：
- en: '[PRE164]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The subquery returns all rows from the `rental` table. However, what’s important
    is that it returns at least one row; it doesn’t matter what’s in the row, how
    many rows there are, or whether the row contains only `NULL` values. So, you can
    think of the subquery as being true or false, and in this case it’s true because
    it produces some output. When the subquery is true, the outer query that uses
    the `EXISTS` clause returns a row. The overall result is that all rows in the
    `film` table are counted because, for each one, the subquery is true.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询返回`rental`表中的所有行。然而，重要的是它至少返回一行；行的内容不重要，行数多少也无关紧要，或者行只包含`NULL`值也无关紧要。因此，您可以将子查询视为真或假，在这种情况下它是真的，因为它生成了一些输出。当子查询为真时，使用`EXISTS`子句的外部查询返回一行。总体结果是计算`film`表中的所有行，因为对于每一行，子查询都是真的。
- en: 'Let’s try a query where the subquery isn’t true. Again, let’s contrive a query:
    this time, we’ll output the names of all films in the database, but only if a
    particular film exists. Here’s the query:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个子查询不为真的查询。再次编造一个查询：这次，我们将输出数据库中所有电影的名称，但只有在存在特定电影时才这样做。以下是查询：
- en: '[PRE166]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Since the subquery isn’t true—no rows are returned because `IS THIS A MOVIE?`
    isn’t in our database—no results are returned by the outer query.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子查询不为真——因为`IS THIS A MOVIE?`不在我们的数据库中——外部查询不会返回结果。
- en: 'The `NOT EXISTS` clause does the opposite. Imagine you want a list of all actors
    if you *don’t* have a particular movie in the database. Here it is:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOT EXISTS`子句则相反。想象一下，如果您不在数据库中有一个特定电影，您希望获得所有演员的列表。以下是查询：'
- en: '[PRE168]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: This time, the inner query is true, but the `NOT EXISTS` clause negates it to
    give false. Since it’s false, the outer query doesn’t produce results.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，内部查询为真，但`NOT EXISTS`子句否定了它以生成假。因为它是假的，外部查询不会产生结果。
- en: You’ll notice that the subquery begins with `SELECT * FROM film`. It doesn’t
    actually matter what you select in an inner query when you’re using the `EXISTS`
    clause, since it’s not used by the outer query anyway. You can select one column,
    everything, or even a constant (as in `SELECT 'cat' from film`), and it’ll have
    the same effect. Traditionally, though, you’ll see most SQL authors write `SELECT`
    `*` by convention.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到子查询以`SELECT * FROM film`开头。当您使用`EXISTS`子句时，实际上不管您在内部查询中选择什么，因为外部查询不使用它。您可以选择一个列、所有内容，甚至常量（如`SELECT
    'cat' from film`），效果都是一样的。但传统上，大多数SQL作者按照约定会写`SELECT *`。
- en: Correlated subqueries
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关子查询
- en: So far, it’s probably difficult to imagine what you’d do with the `EXISTS` and
    `NOT EXISTS` clauses. This section shows you how they’re really used, illustrating
    the most advanced type of nested query that you’ll typically see in action.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能很难想象您如何使用`EXISTS`和`NOT EXISTS`子句。本节展示了它们的实际用途，演示了您通常会看到的最高级别的嵌套查询类型。
- en: 'Let’s think about the realistic kinds of information you might want from the
    `sakila` database. Suppose you want a list of all employees who’ve rented something
    from our company, or are just customers. You can do this easily with a join query,
    which we recommend you try to think about before you continue. You can also do
    it with the following nested query that uses a correlated subquery:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑您可能从`sakila`数据库中获取的实际信息类型。假设您想要所有曾租用过公司产品的员工列表，或者只是顾客。您可以轻松地使用联接查询来实现这一点，我们建议您在继续之前考虑一下。您还可以使用以下使用相关子查询的嵌套查询来实现：
- en: '[PRE170]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'There’s no output because nobody from the staff is also a customer (or that’s
    forbidden, but we’ll bend the rules). Let’s add a customer with the same details
    as one of the staff members:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出，因为没有员工也是客户（或者禁止这样做，但我们会打破规则）。让我们添加一个与某个员工具有相同详细信息的客户：
- en: '[PRE172]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'And try the query again:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试查询：
- en: '[PRE174]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: So, the query works; now, we just need to understand how!
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个查询有效；现在，我们只需要理解如何操作！
- en: 'Let’s examine the subquery in our previous example. You can see that it lists
    only the `customer` table in the `FROM` clause, but it uses a column from the
    `staff` table in the `WHERE` clause. If you run it in isolation, you’ll see this
    isn’t allowed:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们之前示例中的子查询。您可以看到它只列出了 `FROM` 子句中的 `customer` 表，但它在 `WHERE` 子句中使用了 `staff`
    表的一个列。如果您单独运行它，您会发现这是不允许的：
- en: '[PRE176]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'However, it’s legal when executed as a subquery because tables listed in the
    outer query are allowed to be accessed in the subquery. So, in this example, the
    current value of `staff.first_name` and `staff.last_name` in the outer query is
    supplied to the subquery as a constant, scalar value and compared to the customer’s
    first and last names. If the customer’s name matches the staff member’s name,
    the subquery is true, and so the outer query outputs a row. Consider two cases
    that illustrate this more clearly:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当作为子查询执行时是合法的，因为外部查询中列出的表允许在子查询中访问。因此，在此示例中，`staff.first_name` 和 `staff.last_name`
    的当前值在外部查询中作为常量标量值提供给子查询，并与客户的名字进行比较。如果客户的名称与员工成员的名称匹配，则子查询为真，因此外部查询输出一行。考虑两种更清晰地说明这一点的情况：
- en: When the `first_name` and `last_name` being processed by the outer query are
    `Jon` and `Stephens`, the subquery is false because `SELECT * FROM customer WHERE
    first_name = 'Jon' and last_name = 'Stephens';` doesn’t return any rows, and so
    the staff row for Jon Stephens isn’t output as an answer.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部查询正在处理的 `first_name` 和 `last_name` 是 `Jon` 和 `Stephens` 时，子查询为假，因为 `SELECT
    * FROM customer WHERE first_name = 'Jon' and last_name = 'Stephens';` 没有返回任何行，因此
    Jon Stephens 的 staff 行不作为答案输出。
- en: When the `first_name` and `last_name` being processed by the outer query are
    `Mike` and `Hillyer`, the subquery is true because `SELECT * FROM customer WHERE
    first_name = 'Mike' and last_name = 'Hillyer';` returns at least one row. Overall,
    the staff row for Mike Hillyer is returned.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部查询正在处理的 `first_name` 和 `last_name` 是 `Mike` 和 `Hillyer` 时，子查询为真，因为 `SELECT
    * FROM customer WHERE first_name = 'Mike' and last_name = 'Hillyer';` 返回至少一行。因此，Mike
    Hillyer 的 staff 行被返回。
- en: Can you see the power of correlated subqueries? You can use values from the
    outer query in the inner query to evaluate complex information needs.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 您能看到相关子查询的威力吗？您可以在内部查询中使用外部查询的值来评估复杂的信息需求。
- en: 'We’ll now explore another example using `EXISTS`. Let’s try to find a count
    of all films of which we own at least two copies. To do this with `EXISTS`, we
    need to think through what the inner and outer queries should do. The inner query
    should produce a result only when the condition we’re checking is true; in this
    case, it should produce output when there are at least two rows in the inventory
    for the same film. The outer query should increment the counter whenever the inner
    query is true. Here’s the query:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探讨另一个使用 `EXISTS` 的例子。让我们试着找出我们至少拥有两份副本的所有电影的数量。为了使用 `EXISTS` 来做到这一点，我们需要思考内部和外部查询应该做什么。内部查询应该在我们检查的条件为真时产生结果；在这种情况下，当库存中有至少两行属于同一电影时，它应该产生输出。外部查询应在内部查询为真时增加计数器。以下是查询：
- en: '[PRE178]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'This is yet another query where nesting isn’t necessary and a join would suffice,
    but let’s stick with this version for the purpose of explanation. Have a look
    at the inner query: you can see that the `WHERE` clause ensures that films match
    by the unique `film_id`, and only matching rows for the current film are considered
    by the subquery. The `GROUP BY` clause clusters the rows for that film, but only
    if there are at least two entries in the inventory. Therefore, the inner query
    produces output only when there are at least two rows for the current film in
    our inventory. The outer query is straightforward: it can be thought of as incrementing
    a counter when the subquery produces output.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个不需要嵌套而使用联接就足够的查询示例，但为了解释的目的，我们坚持使用这个版本。看一下内部查询：您可以看到 `WHERE` 子句确保电影通过唯一的
    `film_id` 进行匹配，并且子查询仅考虑当前电影的匹配行。`GROUP BY` 子句将这些行按电影进行分组，但仅当库存中至少有两个条目时。因此，内部查询仅在我们的库存中的当前电影至少有两行时才会产生输出。外部查询很简单：可以将其视为在子查询产生输出时递增计数器。
- en: 'Here’s one more example before we move on and discuss other issues. This example
    will be in the `employees` database, so switch your client. We’ve already shown
    you a query that uses `IN` and finds managers who also had some other position:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论其他问题之前，这里再举一个例子。此例将在`employees`数据库中进行，所以请切换你的客户端。我们已经展示了一个使用`IN`并查找同时拥有其他职位的经理的查询：
- en: '[PRE180]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Let’s rewrite the query to use `EXISTS`. First, think about the subquery: it
    should produce output when there’s a `title` record for an employee with the same
    name as a manager.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写查询以使用`EXISTS`。首先考虑子查询：当有一个与经理同名的`title`记录的员工时，它应该产生输出。
- en: 'Second, think about the outer query: it should return the employee’s name when
    the inner query produces output. Here’s the rewritten query:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑外部查询：它应该在内部查询产生输出时返回员工的姓名。以下是重写后的查询：
- en: '[PRE182]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Again, you can see that the subquery references the `emp_no` column, which comes
    from the outer query.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 再次可以看到子查询引用了来自外部查询的`emp_no`列。
- en: 'Correlated subqueries can be used with any nested query type. Here’s the previous
    `IN` query rewritten with an outer reference:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 关联子查询可以与任何嵌套查询类型一起使用。这里是先前的`IN`查询使用外部引用重写后的版本：
- en: '[PRE184]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The query is more convoluted than it needs to be, but it illustrates the idea.
    You can see that the `emp_no` in the subquery references the `employees` table
    from the outer query.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 查询比需要的更复杂，但它说明了这个想法。你可以看到子查询中的`emp_no`引用了外部查询的`employees`表。
- en: 'If the query would return a single row, it can also be rewritten to use an
    equals instead of `IN`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询只返回一行，也可以重写为使用等号而不是`IN`：
- en: '[PRE186]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'This doesn’t work in this case because the subquery returns more than one scalar
    value. Let’s narrow it down:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它不起作用，因为子查询返回了多个标量值。让我们缩小范围：
- en: '[PRE188]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: It works now—there’s only one manager and senior engineer title with each name—so
    the column subquery operator `IN` isn’t necessary. Of course, if titles are duplicated
    (for example, if a person switches back and forth between positions), you’d need
    to use `IN`, `ANY`, or `ALL` instead.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它起作用了——每个名称只有一个经理和高级工程师头衔——所以列子查询操作符`IN`不再必要。当然，如果标题重复（例如，如果一个人在职位之间来回切换），你需要使用`IN`、`ANY`或`ALL`。
- en: Nested Queries in the FROM Clause
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FROM子句中的嵌套查询
- en: The techniques we’ve shown all use nested queries in the `WHERE` clause. This
    section shows you how they can alternatively be used in the `FROM` clause. This
    is useful when you want to manipulate the source of the data you’re using in a
    query.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的技术都在`WHERE`子句中使用了嵌套查询。本节向您展示了当您想要操作查询中使用的数据源时，如何在`FROM`子句中替代地使用它们。
- en: 'In the `employees` database, the `salaries` table stores the annual wage alongside
    the employee ID. If you want to find the monthly rate, for example, you can do
    some math in the query. One option in this case is to do it with a subquery:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在`employees`数据库中，`salaries`表存储了员工ID和年薪。例如，如果您想找到月薪，可以在查询中进行一些数学计算。在这种情况下的一个选项是使用子查询：
- en: '[PRE190]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Focus on what follows the `FROM` clause. The subquery uses the `salaries` table
    and returns two columns: the first column is the `emp_no`; the second column is
    aliased as `monthly_salary` and is the `salary` value divided by 12\. The outer
    query is straightforward: it just returns the `emp_no` and the `monthly_salary`
    value created through the subquery. Note that we’ve added the table alias `ms`
    for the subquery. When we use a subquery as a table—that is, we use a `SELECT
    FROM` operation on it—this “derived table” must have an alias, even if we don’t
    use the alias in our query. MySQL complains if we omit the alias:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意关注`FROM`子句后面的内容。子查询使用`salaries`表并返回两列：第一列是`emp_no`；第二列别名为`monthly_salary`，是`salary`值除以12。外部查询很简单：它只返回通过子查询创建的`emp_no`和`monthly_salary`值。请注意，我们为子查询添加了表别名`ms`。当我们将子查询作为表使用时，这个“派生表”必须有一个别名，即使我们在查询中没有使用别名。如果省略别名，MySQL会报错：
- en: '[PRE192]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Here’s another example, now in the `sakila` database. Suppose we want to find
    out the average sum a film brings us through rentals, or the average gross, as
    we’ll call it. Let’s begin by thinking through the subquery. It should return
    the sum of payments that we have for each film. Then, the outer query should average
    the values to give the answer. Here’s the query:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子，现在在`sakila`数据库中。假设我们想通过租借来计算电影带来的平均收益，或者称之为平均总收益。让我们先考虑子查询。它应该返回每部电影的支付总和。然后，外部查询应该对这些值求平均以得出答案。以下是查询：
- en: '[PRE194]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'You can see that the inner query joins together `payment`, `rental`, `inventory`,
    and `film`, and groups the sales together by film so you can get a sum for each
    film. If you run it in isolation, here’s what happens:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到内部查询将 `payment`、`rental`、`inventory` 和 `film` 进行连接，并按电影分组销售，以便你可以获取每部电影的总和。如果单独运行它，会发生以下情况：
- en: '[PRE196]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Now, the outer query takes these sums—which are aliased as `gross`--and averages
    them to give the final result. This query is the typical way that you apply two
    aggregate functions to one set of data. You can’t apply aggregate functions in
    a cascade, as in `AVG(SUM(amount))`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，外部查询获取这些总和，它们被别名为 `gross`，并对它们进行平均处理，得出最终结果。这个查询是应用两个聚合函数到一组数据的典型方式。你不能像
    `AVG(SUM(amount))` 这样级联应用聚合函数：
- en: '[PRE198]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: With subqueries in `FROM` clauses, you can return a scalar value, a set of column
    values, more than one row, or even a whole table. However, you can’t use correlated
    subqueries, meaning that you can’t reference tables or columns from tables that
    aren’t explicitly listed in the subquery. Note also that you must alias the whole
    subquery using the `AS` keyword and give it a name, even if you don’t use that
    name anywhere in the query.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FROM` 子句中使用子查询，可以返回标量值、一组列值、多行甚至整个表格。但是，不能使用相关子查询，也就是说，不能引用未在子查询中显式列出的表或列。还要注意，必须使用
    `AS` 关键字为整个子查询起别名，并给它一个名称，即使在查询中没有使用该名称。
- en: Nested Queries in JOINs
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JOIN 中的嵌套查询
- en: The last use of nested queries we’ll show, but not the least useful, is using
    them in joins. In this use case, the results of the subquery basically form a
    new table and can be used in any of the join types we have discussed.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示的最后一种嵌套查询用途，但不是最不实用的，是在连接中使用它们。在这种用法中，子查询的结果基本上形成一个新表，并可以在我们讨论过的任何连接类型中使用。
- en: 'For an example of this, let’s go back to the query that listed the number of
    films from each of the categories a particular customer has rented. Remember,
    we had an issue writing that query using just joins: we didn’t get a zero count
    for categories from which our customer didn’t rent. This was the query:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一点的例子，让我们回到列出某个客户租用的每个类别的电影数量的查询。记住，我们在仅使用连接时编写该查询时遇到了问题：对于我们的客户没有租用的类别，我们没有得到零计数。这是该查询：
- en: '[PRE200]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Now that we know about subqueries and joins and that subqueries can be used
    in joins, we can easily finish the task. This is our new query:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了子查询和连接，以及子查询可以在连接中使用，我们可以轻松完成任务。这是我们的新查询：
- en: '[PRE202]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Finally, we get all the categories displayed, and we get `NULL` values for
    those where no rentals were made. Let’s review what’s going on in our new query.
    The subquery, which we aliased as `customer_cat`, is our previous query without
    the `ORDER BY` clause. Thus, we know what it will return: 14 rows for categories
    in which Wesley rented something, and the number of rentals in each. Next, use
    `LEFT JOIN` to concatenate that information to the full list of categories from
    the `category` table. The `category` table is driving the join, so it’ll have
    every row selected. We join the subquery using the `name` column that matches
    between the subquery’s output and the `category` table’s column.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到所有类别的显示，并且对于那些没有租赁的类别，我们得到 `NULL` 值。让我们回顾一下我们的新查询中发生了什么。子查询被别名为 `customer_cat`，是我们之前查询的不带
    `ORDER BY` 子句的版本。因此，我们知道它将返回：Wesley 租用物品的类别中的 14 行，以及每个类别的租赁数量。接下来，使用 `LEFT JOIN`
    将该信息连接到 `category` 表的完整类别列表中。`category` 表驱动连接，因此它将选择每行。我们使用与子查询输出和 `category`
    表列之间匹配的 `name` 列将子查询连接起来。
- en: The technique we showed here is a very powerful one; however, as always with
    subqueries, it comes at a cost. MySQL cannot optimize the whole query as efficiently
    when a subquery is present in the join clause.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示的技术是非常强大的；然而，像所有的子查询一样，它也有代价。当子查询出现在连接子句中时，MySQL 无法像优化整个查询那样高效地操作。
- en: User Variables
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户变量
- en: 'Often you’ll want to save values that are returned from queries. You might
    want to do this so that you can easily use a value in a later query. You might
    also simply want to save a result for later display. In both cases, user variables
    solve the problem: they allow you to store a result and use it later.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会希望保存从查询返回的值。你可能希望这样做是为了能够轻松地在后续查询中使用一个值。你可能也只是想为稍后显示保存一个结果。在这两种情况下，用户变量可以解决问题：它们允许你存储一个结果并在以后使用它。
- en: 'Let’s illustrate user variables with a simple example. The following query
    finds the title of a film and saves the result in a user variable:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明用户变量。下面的查询找到一部电影的标题，并将结果保存在一个用户变量中：
- en: '[PRE204]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The user variable is named `film`, and it’s denoted as a user variable by the
    `@` character that precedes it. The value is assigned using the `:=` operator.
    You can print out the contents of the user variable with the following very short
    query:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 用户变量名为`film`，通过前置的`@`字符表示为用户变量。值是使用`:=`运算符赋值的。您可以使用以下非常简短的查询打印用户变量的内容：
- en: '[PRE206]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: You may have noticed the warning—what was that about?
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了警告——那是关于什么的？
- en: '[PRE208]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Let’s cover the two alternatives proposed. First, we can still execute a nested
    query within a `SET` statement:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论提出的两种备选方案。首先，我们仍然可以在`SET`语句内执行嵌套查询：
- en: '[PRE210]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Second, we can use the `SELECT INTO` statement:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以使用`SELECT INTO`语句：
- en: '[PRE214]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'You can explicitly set a variable using the `SET` statement without a `SELECT`.
    Suppose you want to initialize a counter to zero:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`SET`语句显式设置变量而不使用`SELECT`。假设您想将计数器初始化为零：
- en: '[PRE218]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The `:=` is optional, and you can write `=` instead and mix them up. You should
    separate several assignments with a comma or put each in a statement of its own:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`:=`是可选的，您可以改用`=`并混合使用它们。您应该用逗号分隔多个赋值或将每个赋值放在独立的语句中：'
- en: '[PRE220]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'The alternative syntax for `SET` is `SELECT INTO`. You can initialize a single
    variable:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`的替代语法是`SELECT INTO`。您可以初始化单个变量：'
- en: '[PRE222]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Or multiple variables at once:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 或同时初始化多个变量：
- en: '[PRE224]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'The most common use of user variables is to save a result and use it later.
    You’ll recall the following example from earlier in the chapter, which we used
    to motivate nested queries (which are certainly a better solution for this problem).
    Here, we want to find the name of the film that a particular customer rented most
    recently:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 用户变量的最常见用途是保存结果并稍后使用。您可能还记得本章早些时候的以下示例，我们用它来推动嵌套查询（对于此问题肯定是更好的解决方案）。在这里，我们想找出特定客户最近租赁的电影的名称：
- en: '[PRE226]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'You can use a user variable to save the result for input into the following
    query. Here’s the same query pair rewritten using this approach:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用用户变量保存结果以便输入到后续查询中。以下是使用此方法重写的相同查询对：
- en: '[PRE230]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: This can save you cutting and pasting, and it certainly helps you avoid typing
    errors.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以避免复制粘贴，并且确实有助于避免输入错误。
- en: 'Here are some guidelines on using user variables:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于使用用户变量的一些指导方针：
- en: 'User variables are unique to a connection: variables that you create can’t
    be seen by anyone else, and two different connections can have two different variables
    with the same name.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户变量是唯一于连接的：您创建的变量对其他人不可见，两个不同的连接可以具有相同名称的两个不同变量。
- en: The variable names can be alphanumeric strings and can also include the period
    (`.`), underscore (`_`), and dollar sign (`$`) characters.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名称可以是字母数字字符串，还可以包括句点（`.`）、下划线（`_`）和美元符号（`$`）字符。
- en: Variable names are case-sensitive in MySQL versions earlier than version 5,
    and case-insensitive from version 5 onward.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MySQL版本5之前，变量名称区分大小写，在版本5及以后则不区分大小写。
- en: Any variable that isn’t initialized has the value `NULL`; you can also manually
    set a variable to be `NULL`.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何未初始化的变量都具有值`NULL`；您还可以手动将变量设置为`NULL`。
- en: Variables are destroyed when a connection closes.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量在连接关闭时被销毁。
- en: You should avoid trying to both assign a value to a variable and use the variable
    as part of a `SELECT` query. Two reasons for this are that the new value may not
    be available for use immediately in the same statement, and a variable’s type
    is set when it’s first assigned in a query; trying to use it later as a different
    type in the same SQL statement can lead to unexpected results.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该避免尝试将值分配给变量并将变量用作`SELECT`查询的一部分。此做法的两个原因是，新值可能不能立即在同一语句中使用，以及变量的类型在首次分配时设置；在同一SQL语句中稍后尝试将其用作不同类型可能会导致意外结果。
- en: 'Let’s look at the first issue in more detail using the new variable `@fid`.
    Since we haven’t used this variable before, it’s empty. Now, let’s show the `film_id`
    for movies that have an entry in the `inventory` table. Instead of showing it
    directly, we’ll assign the `film_id` to the `@fid` variable. Our query will show
    the variable three times—once before the assignment operation, once as part of
    the assignment operation, and once afterward:'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更详细地查看使用新变量`@fid`的第一个问题。由于我们之前没有使用过此变量，它是空的。现在，让我们显示具有`inventory`表中条目的电影的`film_id`。我们将`film_id`分配给`@fid`变量，而不是直接显示它。我们的查询将显示变量三次——一次是在赋值操作之前，一次作为赋值操作的一部分，一次在赋值操作之后：
- en: '[PRE234]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'This returns nothing apart from a deprecation warning; since there’s nothing
    in the variable to start with, the `WHERE` clause tries to look for empty `inventory.film_id`
    values. If we modify the query to use `film.film_id` as part of the `WHERE` clause,
    things work as expected:'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这只返回一个废弃警告；因为变量中一开始没有任何内容，`WHERE` 子句尝试查找空的 `inventory.film_id` 值。如果我们修改查询以将
    `film.film_id` 作为 `WHERE` 子句的一部分，事情将按预期工作：
- en: '[PRE236]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Now that if `@fid` isn’t empty, the initial query will produce some results:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在如果 `@fid` 不为空，初始查询将产生一些结果：
- en: '[PRE238]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: It’s best to avoid such circumstances where the behavior is not guaranteed and
    is hence unpredictable.
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最好避免这种行为不被保证且因此不可预测的情况。
