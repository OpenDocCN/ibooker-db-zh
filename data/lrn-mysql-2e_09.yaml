- en: Chapter 8\. Managing Users and Privileges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 管理用户和权限
- en: 'The simplest database system is just a bunch of files lying around, with some
    data in them, and no unified access process. With any RDBMS, we come to expect
    a significantly higher level of sophistication and abstraction. For one, we want
    to be able to access the database from multiple clients simultaneously. However,
    not all of the clients are similar, and not every one of them necessarily needs
    access to all of the data in the database. It’s possible to imagine a database
    where every user is a superuser, but that would mean you’d have to install a dedicated
    database for every app and dataset: wasteful. Instead, databases have evolved
    to support multiple users and roles and provide a means to control privileges
    and access on a very fine-grained level to guarantee secure shared environments.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的数据库系统只是一堆文件，其中包含一些数据，并且没有统一的访问过程。在任何关系型数据库管理系统中，我们期望有更高级别的复杂性和抽象性。例如，我们希望能够从多个客户端同时访问数据库。然而，并非所有客户端都相似，并且并非每个客户端都必需访问数据库中的所有数据。可以想象一个数据库，其中每个用户都是超级用户，但这意味着您必须为每个应用程序和数据集安装专用数据库：这是一种浪费。因此，数据库已经发展到支持多个用户和角色，并提供了一种非常精细的级别来控制特权和访问，以保证安全的共享环境。
- en: Understanding users and privileges is an important part of working efficiently
    with a database system. Well-planned and managed roles result in a secure system
    that is easy to manage and work with. In this chapter, we will review most of
    the things one needs to know about user and privilege management, starting from
    the basics and moving toward new features like roles. After finishing this chapter,
    you should have all the basics required to manage access within a MySQL database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解用户和权限是高效处理数据库系统的重要组成部分。精心规划和管理角色可以确保系统安全且易于管理和操作。在本章中，我们将回顾大多数用户和权限管理相关的事项，从基础开始逐步介绍如角色等新功能。完成本章后，您将具备管理MySQL数据库访问所需的所有基础知识。
- en: Understanding Users and Privileges
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解用户和权限
- en: 'The first building block in the foundation of a shared system is the concept
    of a *user*. Most modern operating systems have user-based access, so it’s highly
    likely that you already know what that means. Users in MySQL are special objects
    used for the purpose of:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 共享系统基础的第一个构建块是*用户*的概念。大多数现代操作系统都有基于用户的访问控制，因此您很可能已经了解其含义。MySQL中的用户是专用对象，用于以下目的：
- en: Authentication (making sure that a user can access the MySQL server)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证（确保用户可以访问MySQL服务器）
- en: Authorization (making sure that a user can interact with objects in the database)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权（确保用户可以与数据库中的对象交互）
- en: One thing that makes MySQL distinct from other DBMSs is that users do not *own*
    schema objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使MySQL与其他数据库管理系统不同的一点是用户不*拥有*模式对象。
- en: Let’s consider these points in a little more detail. Every time you access the
    MySQL server, you must specify a user to be used during authentication. Once you’ve
    been authenticated and your identity has been confirmed, you have access to the
    database. Usually, the user you will be acting as when interacting with schema
    objects will be the same as the one you used for authentication, but that’s not
    strictly necessary, and that’s why we separate the second point. A proxy user
    is a user that is used for the purpose of checking privileges and actually acting
    within the database, when another user is used during authentication. That’s a
    rather complex topic and requires nondefault configuration, but it’s still possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考虑这些观点。每次访问MySQL服务器时，您必须指定一个用户用于认证。一旦您经过认证并确认了您的身份，您就可以访问数据库。通常，在与模式对象交互时，您将作为操作的用户与进行身份验证的用户相同，但这并非绝对必要，这就是我们将第二点分开的原因。代理用户是用于检查权限和实际在数据库内部操作的用户，当在认证过程中使用另一个用户时。这是一个相当复杂的主题，需要非默认配置，但仍然可能。
- en: This is an important distinction to remember between authentication and authorization.
    While you can authenticate with one user, you can be authorized as another and
    have or not have various permissions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权之间有一个重要的区别需要记住。虽然您可以使用一个用户进行认证，但可以作为另一个用户进行授权，并具有或不具有各种权限。
- en: With these two covered, let’s discuss the last point. Some DBMSs support the
    concept of object ownership. That is, when the user creates a database object—a
    database or schema, a table, or a stored procedure—that user automatically becomes
    the new object’s owner. The owner usually has the ability to modify objects it
    owns and grant other users access to them. The important thing here is that MySQL
    does not in any way have a concept of object ownership.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个内容，让我们讨论最后一点。一些数据库管理系统支持对象所有权的概念。也就是说，当用户创建数据库对象（数据库或模式、表或存储过程）时，该用户自动成为新对象的所有者。所有者通常有权修改其拥有的对象，并授予其他用户对其的访问权限。这里重要的是MySQL在任何情况下都没有对象所有权的概念。
- en: This lack of ownership makes it even more important to have flexible rules so
    that users can create objects and then potentially share access to those objects
    with other users. That is achieved using *privileges*. Privileges can be thought
    of as sets of rules controlling what actions users are allowed to perform and
    what data they can access. It’s important to understand that by default in MySQL
    a database user has no privileges at all. Granting a privilege means allowing
    some action that by default is forbidden.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缺乏所有权概念使得更加重要的是有灵活的规则，以便用户可以创建对象，然后可能与其他用户分享对这些对象的访问。这是通过*权限*来实现的。权限可以被视为一组规则，控制用户被允许执行的操作以及可以访问的数据。重要的是要理解，默认情况下，在MySQL中，数据库用户根本没有任何权限。授予权限意味着允许默认情况下禁止的某些操作。
- en: Users in MySQL are also a bit different than in other databases, because the
    user object includes a network access control list (ACL). Usually, a MySQL user
    is represented not just by its name, like `bob`, but with an appended network
    address, like `bob@localhost`. This particular example defines a user that can
    be accessed only locally through the loopback interface or a Unix socket connection.
    We will touch on this topic later, when we discuss the SQL syntax for creating
    and manipulating existing users.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL中的用户与其他数据库中的用户也有些不同，因为用户对象包含一个网络访问控制列表（ACL）。通常，一个MySQL用户不仅仅用其名称表示，比如`bob`，而是附加了网络地址，例如`bob@localhost`。这个特定的示例定义了一个仅能通过回环接口或Unix套接字连接本地访问的用户。当我们讨论用于创建和操作现有用户的SQL语法时，我们稍后会详细讨论这个主题。
- en: MySQL stores all information related to users and privileges in special tables
    in the `mysql` system database called *grant tables*. We’ll talk about this concept
    in a bit more depth in [“Grant Tables”](#USR-GRANT-TABLES).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL将所有与用户和权限相关的信息存储在`mysql`系统数据库中的特殊表中，称为*授权表*。稍后我们将更深入地讨论这个概念，详见[“授权表”](#USR-GRANT-TABLES)。
- en: This short theoretical foundation should be sufficient to form a basic understanding
    of MySQL’s system of users and privileges. Let’s get practical and review the
    commands and capabilities that the database provides for managing users and privileges.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的理论基础应该足以形成对MySQL用户和权限系统的基本理解。让我们来实际操作，回顾一下数据库提供的用于管理用户和权限的命令和功能。
- en: The root User
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根用户
- en: 'Every MySQL installation comes with a few users installed by default. Most
    of them you don’t ever need to touch, but there’s one that’s extremely frequently
    used. Some might even say that it’s overused, but that’s not the discussion we
    want to have here. The user we’re talking about is the ubiquitous and all-powerful
    `root` user. With the same name as the default Unix and Linux superuser, this
    user is just that in MySQL: a user that can do anything by default.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MySQL安装都默认安装了一些用户。大多数情况下，你根本不需要触碰它们，但有一个用户非常频繁地被使用。有些人甚至会说它被过度使用了，但这不是我们想要在这里讨论的话题。我们要谈论的用户是无处不在且全能的`root`用户。与默认的Unix和Linux超级用户具有相同的名称，在MySQL中，这个用户就是那样：默认情况下可以执行任何操作的用户。
- en: To be more specific, the user is `root@localhost`, sometimes called the *initial
    user*. The `localhost` part of the username, as you now know, limits its use to
    only local connections. When you install MySQL, depending on the specific MySQL
    flavor and the OS, you might be able to access `root@localhost` from the OS root
    account by just executing the `mysql` command. In some other cases, a temporary
    password will be generated for this user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，用户是`root@localhost`，有时被称为*初始用户*。正如你现在所知，用户名中的`localhost`部分限制了其仅能在本地连接中使用。当你安装MySQL时，根据具体的MySQL版本和操作系统，你可能可以通过仅执行`mysql`命令从操作系统的root账户访问`root@localhost`。在某些情况下，会为这个用户生成一个临时密码。
- en: The initial user is not the only superuser you can create, as you’ll see in
    [“The SUPER Privilege”](#USR-PRIV-SUPER). While you can create a `root@<ip>` user,
    or even a `root@%` user, we strongly discourage you from doing so, as it is a
    security hole waiting to be exploited. Not every MySQL server even needs to listen
    on an interface apart from loopback (that is, localhost), let alone have a superuser
    with a default name available for login. Of course, you can set secure passwords
    for all users and should probably set one for `root`, but it is arguably that
    little bit safer to not allow remote superuser access, if that is possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 初始用户并不是你能创建的唯一超级用户，正如你将在[“SUPER 权限”](#USR-PRIV-SUPER)中看到的那样。虽然你可以创建一个`root@<ip>`用户，甚至是`root@%`用户，但我们强烈建议你不要这样做，因为这是一个等待被利用的安全漏洞。并非每个
    MySQL 服务器都需要在除回环（即 localhost）之外的接口上监听，更不用说有一个默认名称的超级用户可用于登录。当然，你可以为所有用户设置安全密码，可能还应该为`root`设置一个，但如果可能的话，不允许远程超级用户访问可能会更安全一点。
- en: For all intents and purposes, `root@localhost` is just a regular user with all
    privileges granted. You can even drop it, which can happen by mistake. Losing
    access to the `root@localhost` user is a fairly common problem when running MySQL.
    You may have set a password and forgotten it or you inherited a server and were
    not given the password or something else might have happened. We cover the procedure
    to recover a forgotten password for the `root@localhost` initial user in [“Changing
    root’s Password and Insecure Startup”](#USR-ROOT-RESET). If you dropped your last
    available superuser, you will have to follow the same procedure but create a new
    user instead of changing an existing one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就功能而言，`root@localhost`只是一个拥有所有授权的常规用户。你甚至可以删除它，这可能会不小心发生。当运行 MySQL 时，失去`root@localhost`用户访问权限是一个相当常见的问题。你可能设置了密码却忘记了它，或者继承了一个服务器但没有得到密码，或者可能发生了其他事情。我们在[“更改
    root 的密码和不安全的启动”](#USR-ROOT-RESET)中介绍了恢复忘记密码的`root@localhost`初始用户的过程。如果你删除了最后一个可用的超级用户，你将不得不按照相同的步骤进行操作，但是要创建一个新用户而不是更改现有用户。
- en: Creating and Using New Users
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用新用户
- en: 'The first task we’ll cover is creating a new user. Let’s start with a rather
    simple example and review each part:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍创建新用户的任务。让我们从一个相当简单的例子开始，逐步审视每个部分：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_managing_users_and_privileges_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_managing_users_and_privileges_CO1-1)'
- en: SQL statement to create a user
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户的 SQL 语句
- en: '[![2](Images/2.png)](#co_managing_users_and_privileges_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_managing_users_and_privileges_CO1-2)'
- en: User and host definition
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和主机定义
- en: '[![3](Images/3.png)](#co_managing_users_and_privileges_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_managing_users_and_privileges_CO1-3)'
- en: Password specification
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 密码规范
- en: 'Here’s a more complex example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更复杂的例子：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_managing_users_and_privileges_CO2-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_managing_users_and_privileges_CO2-1)'
- en: SQL statement to create a user
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户的 SQL 语句
- en: '[![2](Images/2.png)](#co_managing_users_and_privileges_CO2-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_managing_users_and_privileges_CO2-2)'
- en: User and host definition
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和主机定义
- en: '[![3](Images/3.png)](#co_managing_users_and_privileges_CO2-3)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_managing_users_and_privileges_CO2-3)'
- en: Authentication plugin specification
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 认证插件规范
- en: '[![4](Images/4.png)](#co_managing_users_and_privileges_CO2-4)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_managing_users_and_privileges_CO2-4)'
- en: Authentication string/password
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 认证字符串/密码
- en: '[![5](Images/5.png)](#co_managing_users_and_privileges_CO2-5)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_managing_users_and_privileges_CO2-5)'
- en: Default role set once user is authenticated and connected
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证和连接后设置的默认角色
- en: '[![6](Images/6.png)](#co_managing_users_and_privileges_CO2-6)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_managing_users_and_privileges_CO2-6)'
- en: Require SSL for connections for this user
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要求此用户的连接使用 SSL
- en: '[![7](Images/7.png)](#co_managing_users_and_privileges_CO2-7)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_managing_users_and_privileges_CO2-7)'
- en: Require specific ciphers
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要求使用特定的加密算法
- en: '[![8](Images/8.png)](#co_managing_users_and_privileges_CO2-8)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_managing_users_and_privileges_CO2-8)'
- en: Limit maximum number of connections from this user
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 限制此用户的最大连接数
- en: '[![9](Images/9.png)](#co_managing_users_and_privileges_CO2-9)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](Images/9.png)](#co_managing_users_and_privileges_CO2-9)'
- en: Override global password expiration settings
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖全局密码过期设置
- en: 'This is just scratching the surface, but should give an idea of the parameters
    that can be changed for a user during its creation. There are quite a lot of them.
    Let’s review the specific parts of that statement in a little more detail:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是冰山一角，但应该让你了解可以在用户创建过程中更改的参数。这些参数非常多。让我们稍微详细地审视该语句的特定部分：
- en: User and host definition
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和主机定义
- en: 'We mentioned in [“Understanding Users and Privileges”](#USR-SEC-UNDERSTAND)
    that users in MySQL are defined not only by their name, but also by hostname.
    In the previous example, the user is `''bob''@''10.0.2.%''`, where `*bob*` is
    the username and `*10.0.2.%*` is a hostname specification. In fact, it’s a hostname
    specification with a wildcard. Each time someone connects with the username `*bob*`
    using TCP, MySQL will do a few things:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“理解用户和权限”](#USR-SEC-UNDERSTAND)中提到，MySQL中的用户不仅由其名称定义，还由主机名定义。在前面的示例中，用户是`'bob'@'10.0.2.%'`，其中`*bob*`是用户名，`*10.0.2.%*`是主机名规范。实际上，它是带通配符的主机名规范。每当有人使用TCP连接使用用户名`*bob*`连接时，MySQL会执行几项操作：
- en: Get the IP address of the connecting client.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取连接客户端的IP地址。
- en: Perform a reverse DNS lookup of the IP address to a hostname.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对IP地址执行反向DNS查找，以获取主机名。
- en: Perform a DNS lookup for that hostname (to make sure the reverse lookup wasn’t
    compromised).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行该主机名的DNS查找（以确保反向查找未被篡改）。
- en: Check the hostname or IP address with the user’s hostname specification.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查主机名或IP地址与用户的主机名规范。
- en: Only if the hostnames match is access granted. For our user `*bob*`, a connection
    from IP address `10.0.2.121` would be allowed, while a connection from `10.0.3.22`
    would be denied. In fact, to allow connections from another hostname, a new user
    should be created. Internally, `'bob'@'10.0.2.%'` is a completely different user
    from `'bob'@'10.0.3.%'`. It’s also possible to use fully qualified domain names
    (FQDNs) in the hostname specification, as in `'bob'@'acme.com'`, but DNS lookups
    take time, and it’s a common optimization to disable them completely.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当主机名匹配时才授予访问权限。对于我们的用户`*bob*`，来自IP地址`10.0.2.121`的连接将被允许，而来自`10.0.3.22`的连接将被拒绝。事实上，要允许来自另一个主机名的连接，应创建一个新用户。在内部，`'bob'@'10.0.2.%'`是一个完全不同的用户，而不是`'bob'@'10.0.3.%'`。在主机名规范中还可以使用完全限定域名（FQDN），例如`'bob'@'acme.com'`，但DNS查找需要时间，通常会完全禁用它们以进行常见优化。
- en: Specifying all possible hostnames for all users to connect from might be tedious,
    but it’s a useful security feature. However, sometimes a database is set up behind
    a firewall, or it’s simply impractical to specify hostnames. To completely subvert
    this system, a single wildcard can be used in the host specification, as in `'bob'@'10.0.2%'`.
    The `'%'` wildcard is also used when you do not specify the host at all (`'bob'@'%'`).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 指定所有用户连接的所有可能主机名可能会很麻烦，但这是一个有用的安全功能。但是，有时数据库设置在防火墙后面，或者仅仅指定主机名是不切实际的。为了完全颠覆此系统，可以在主机规范中使用单个通配符，如`'bob'@'10.0.2%'`。`'%'`通配符也在您根本不指定主机时使用(`'bob'@'%'`)。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When proxying connections to MySQL, pay attention to what IP address MySQL “sees”
    for incoming connections. For example, when HAProxy is used, by default all connections
    will come from the IP addresses of machines where HAProxy is running. This fact
    should be taken into consideration when configuring users. We cover HAProxy configuration
    for MySQL in [Chapter 15](ch15.xhtml#CH15_LOAD_BAlANCERS).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理连接到MySQL时，请注意MySQL“看到”的传入连接的IP地址。例如，当使用HAProxy时，默认情况下所有连接将来自于运行HAProxy的机器的IP地址。在配置用户时应考虑此事实。我们在[第15章](ch15.xhtml#CH15_LOAD_BAlANCERS)中讨论了MySQL的HAProxy配置。
- en: 'You’ll notice that we’ve enclosed both the username and the host specification
    in single quotes (`''''`). That is not mandatory, and username and host specification
    follow a similar set of rules to those that were outlined for table and column
    names and aliases in [“Creating and Using Databases”](ch04.xhtml#MOD-SEC-CREATEDB)
    and [“Aliases”](ch05.xhtml#ADV1-SEC-ALIASES). For example, when creating or altering
    the user `bob@localhost` or `bob@172.17.0.2`, there’s no need to use any quoting.
    You can’t, though, create this user without using quotes: `''username with a space''@''172.%''`.
    Double quotes, single quotes, or backticks can be used to enclose usernames and
    hostnames with special symbols.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们在单引号(`''`)中同时包含了用户名和主机规范。这并非强制性要求，用户名和主机规范遵循与我们在[“创建和使用数据库”](ch04.xhtml#MOD-SEC-CREATEDB)和[“别名”](ch05.xhtml#ADV1-SEC-ALIASES)中概述的表名和列名以及别名相似的规则集。例如，在创建或更改用户`bob@localhost`或`bob@172.17.0.2`时，无需使用任何引号。但是，不能创建不使用引号的此用户：`'username
    with a space'@'172.%'`。双引号、单引号或反引号可用于包含具有特殊符号的用户名和主机名。
- en: Authentication plugins specification
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 认证插件规范
- en: MySQL supports a wide variety of ways to authenticate users through its system
    of authentication plugins. These plugins also provide a way for developers to
    implement new means of authentication without changing MySQL itself. You can set
    a particular plugin for a user in the creation phase or later.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持通过其认证插件系统的多种方式对用户进行认证。这些插件还为开发人员提供了一种在不更改MySQL本身的情况下实现新的认证方式的方法。您可以在创建阶段或之后为用户设置特定的插件。
- en: You might never need to change the plugin for a user, but it’s still worth knowing
    about this subsystem. In particular, LDAP authentication with MySQL can be achieved
    by using a special authentication plugin. MySQL Enterprise Edition supports a
    first-class LDAP plugin, and other MySQL versions and flavors can use PAM as a
    middleman.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能永远不需要更改用户的插件，但了解此子系统仍然是值得的。特别是，使用特殊认证插件可以实现与MySQL的LDAP认证。MySQL企业版支持一流的LDAP插件，其他MySQL版本和变种可以使用PAM作为中间人。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*PAM* stands for Pluggable Authentication Modules. It’s a standard interface
    on Unix-like systems that, in very simple terms, allows MySQL to provide authentication
    by various methods, such as OS passwords, or LDAP. PAM hides the complexity of
    those authentication methods, and programs like MySQL only need to interface with
    PAM itself.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*PAM*代表可插拔认证模块。这是Unix-like系统上的标准接口，简单来说，它允许MySQL通过各种方法提供认证，例如操作系统密码或LDAP。PAM隐藏了这些认证方法的复杂性，像MySQL这样的程序只需要与PAM本身进行接口交互。'
- en: MySQL 8.0 uses the `caching_sha2_password` plugin by default, which provides
    superior security and performance compared to the legacy `mysql_native_password`
    but is not compatible with every client library. To change the default plugin
    you can configure the `default_authentication_plugin` variable, which will cause
    new users to be created with the specified plugin instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8.0默认使用`caching_sha2_password`插件，与传统的`mysql_native_password`相比，提供了更优越的安全性和性能，但不兼容每个客户端库。要更改默认插件，您可以配置`default_authentication_plugin`变量，这将导致新用户使用指定的插件创建。
- en: Authentication string/password
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 认证字符串/密码
- en: 'Some authentication plugins, including the default one, require you to set
    a password for the user. Other plugins, like the PAM one, require you to define
    a mapping from OS users to MySQL users. `auth_string` will be used in both cases.
    Let’s take a look at an example mapping with PAM:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些认证插件，包括默认插件，要求您为用户设置密码。其他插件，如PAM插件，要求您定义从操作系统用户到MySQL用户的映射。在这两种情况下都将使用`auth_string`。让我们看一个使用PAM的示例映射：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What’s defined here is a mapping that can be read as follows: the PAM configuration
    file *mysqld* will be used (usually located at */etc/pam.d/mysqld*); OS users
    with group `dba` will be mapped to MySQL user `dbausr`, and OS users with group
    `dev` to `devusr`. The mapping alone is not enough, however, as the necessary
    permissions have to be assigned.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的映射可以按照以下方式阅读：PAM配置文件*mysqld*将被使用（通常位于*/etc/pam.d/mysqld*）；具有`dba`组的操作系统用户将映射到MySQL用户`dbausr`，具有`dev`组的操作系统用户将映射到`devusr`。然而，仅仅映射是不够的，因为必须分配必要的权限。
- en: Note that either the Percona PAM plugin or MySQL Enterprise Edition is required
    for this to work. This example creates a proxy user, which we briefly discussed
    in [“Understanding Users and Privileges”](#USR-SEC-UNDERSTAND).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要使此功能正常工作，需要使用Percona PAM插件或MySQL企业版。此示例创建了一个代理用户，我们在[“理解用户和权限”](#USR-SEC-UNDERSTAND)中简要讨论过。
- en: Using nondefault authentication plugins is a relatively advanced topic, so we’re
    only bringing up PAM here to show you that the authentication string is not always
    a password.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非默认认证插件是一个相对高级的主题，所以我们只在这里提到PAM，以向您展示认证字符串并非总是密码。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can consult the documentation for details on installing the [Percona plugin](https://oreil.ly/A5rbp)
    and the MySQL [Enterprise Edition plugin](https://oreil.ly/oihnX).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查阅有关安装[Percona插件](https://oreil.ly/A5rbp)和MySQL[企业版插件](https://oreil.ly/oihnX)的详细文档。
- en: Default role set
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认角色设置
- en: Roles are a fairly recent addition to MySQL. You may think of a role as a collection
    of privileges. We discuss them in [“Roles”](#USR-SEC-ROLES).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是MySQL的一个相对较新的添加。您可以将角色视为权限集合。我们在[“角色”](#USR-SEC-ROLES)中讨论它们。
- en: SSL configuration
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SSL配置
- en: 'You can force connections from particular users to use SSL by passing `REQUIRE
    SSL` to the `CREATE USER` or `ALTER USER` command. Unencrypted connections to
    the user will be forbidden. Additionally, you can, as shown in the example we
    gave, specify a particular cipher suite or a number of suites that can be used
    for this user. Ideally, you should set the acceptable cipher suites on the system
    level, but setting this on the user level is useful to allow some less safe suites
    for specific connections. You don’t need to specify `REQUIRE SSL` to specify `REQUIRE
    CIPHER`, and in that case unencrypted connections can be established. However,
    if an encrypted connection is established, it will use only the particular set
    of ciphers you supply:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向`CREATE USER`或`ALTER USER`命令传递`REQUIRE SSL`来强制特定用户的连接使用SSL。用户的未加密连接将被禁止。此外，您可以像我们所示的示例那样指定一个特定的密码套件或一组可用于该用户的套件。理想情况下，您应该在系统级别设置可接受的密码套件，但在用户级别设置此项对于允许某些较不安全的套件进行特定连接是有用的。您不需要指定`REQUIRE
    SSL`来指定`REQUIRE CIPHER`，在这种情况下可以建立未加密的连接。但是，如果建立了加密连接，它将仅使用您提供的特定密码集合：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Additional configurable options that are available include the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些可用的额外可配置选项，包括以下内容：
- en: '`X509`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`X509`'
- en: Forcing a client to present a valid certificate. This, as well as the following
    options, implies the use of `SSL`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 强制客户端提供有效证书。这一点以及以下选项都意味着使用`SSL`。
- en: '`ISSUER` `*issuer*`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`ISSUER` `*issuer*`'
- en: Forcing a client to present a valid certificate issued by a particular CA, specified
    in `**issuer**`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 强制客户端提供由特定`**issuer**`指定的特定CA颁发的有效证书。
- en: '`SUBJECT` `*subject*`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUBJECT` `*subject*`'
- en: Forcing a client to present a valid certificate with a particular subject.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 强制客户端提供具有特定主题的有效证书。
- en: 'These options can be combined to specify a very particular certificate and
    encryption requirement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以组合使用，以指定非常特定的证书和加密要求：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Resource consumption limits
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 资源消耗限制
- en: You can define resource consumption limits. In our example we are limiting the
    maximum number of concurrent connections by this user to 10\. This and other resource
    options default to 0, meaning unlimited. The other possible constraints are `MAX_CONNECTIONS_PER_HOUR`,
    `MAX_QUERIES_PER_HOUR`, and `MAX_UPDATES_PER_HOUR`. All of these options are part
    of the `WITH` specification.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义资源消耗限制。在我们的示例中，我们通过此用户将最大并发连接数限制为10。这些和其他资源选项默认为0，意味着无限制。其他可能的约束条件包括`MAX_CONNECTIONS_PER_HOUR`、`MAX_QUERIES_PER_HOUR`和`MAX_UPDATES_PER_HOUR`。所有这些选项都是`WITH`规范的一部分。
- en: 'Let’s create a fairly restricted user, which can run only 10 queries during
    each given hour, can have only a single concurrent connection, and may not connect
    more than twice per hour:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个相当受限的用户，在每个小时内仅能运行10次查询，只能有一个并发连接，并且每小时最多只能连接两次：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the number of `MAX_QUERIES_PER_HOUR` is inclusive of `MAX_UPDATES_PER_HOUR`
    and will limit updates as well. The number of queries also includes everything
    that the MySQL CLI executes, so setting a really low value is not recommended.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`MAX_QUERIES_PER_HOUR`的数量包括`MAX_UPDATES_PER_HOUR`，并且还将限制更新。查询数量还包括MySQL CLI执行的所有内容，因此不建议设置一个非常低的值。
- en: Password management options override
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 密码管理选项覆盖
- en: For authentication plugins that deal with passwords, which are stored in grant
    tables (covered in [“Grant Tables”](#USR-GRANT-TABLES)), you can specify a variety
    of options related to passwords. In our example, we’re setting up a user that
    has the `PASSWORD EXPIRE NEVER` policy, meaning that its password will never expire
    based on time. You could also create a user that would have a password expiring
    every other day, or each week.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理存储在授权表中的密码的身份验证插件（在[“授权表”](#USR-GRANT-TABLES)中涵盖），您可以指定与密码相关的各种选项。在我们的示例中，我们正在设置一个用户，其具有`PASSWORD
    EXPIRE NEVER`策略，意味着其密码不会因时间而过期。您还可以创建一个用户，其密码每隔一天或每周过期一次。
- en: 'MySQL 8.0 extends control capabilities to include tracking of failed authentication
    attempts and the ability to lock an account temporarily. Let’s consider an important
    user with strict control:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8.0扩展了控制能力，包括跟踪失败的身份验证尝试并临时锁定帐户的能力。让我们考虑一个有严格控制的重要用户：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This user’s password will need to be changed every 30 days, and previous passwords
    will not be eligible for reuse for 180 days. When changing the password, the current
    password must be presented. For good measure, we also only allow three consecutive
    failed login attempts and will block this user for one day if those are made.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户的密码需要每30天更改一次，之前使用过的密码在180天内不能再次使用。在更改密码时，必须输入当前密码。为了安全起见，我们还只允许连续三次登录失败尝试，并且如果发生这些情况，将会封锁此用户一天。
- en: Note that these are overrides on the default system options. It’s impractical
    to set up each individual user manually, so we instead recommend that you set
    up the defaults and only use overrides for particular users. For example, you
    can have your DBA users’ passwords expire more frequently.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些是对默认系统选项的覆盖。手动设置每个个体用户是不现实的，因此我们建议您设置默认值，并仅对特定用户使用覆盖。例如，您可以使DBA用户的密码更频繁地过期。
- en: There are some other options available for user creation, which we won’t cover
    here. As MySQL evolves, more options become available, but we believe the ones
    we’ve covered so far should be enough while learning your way around MySQL.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他用于用户创建的选项，我们在此不进行详述。随着MySQL的发展，会有更多选项可用，但我们认为迄今为止我们所涵盖的应该足够您在MySQL中学习的过程中使用。
- en: 'Since this section is about not only creating but also using new users, let’s
    talk about these uses. They typically fall into a few categories:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本节不仅涉及创建新用户，还涉及使用新用户，让我们来谈谈这些用途。它们通常可以分为几类：
- en: Connecting and authenticating
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 连接和认证
- en: 'This is the default and most widespread use of any user entity. You specify
    the user and password, and MySQL authenticates you with that user and your origin
    host. Then that pair forms a user as defined within grant tables, which will be
    used for authorization when you access database objects. This is the default situation.
    You can run the following query to see the currently authenticated user as well
    as the user provided by the client:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何用户实体的默认和最广泛使用方式。您指定用户和密码，MySQL将使用该用户和您的原始主机进行身份验证。然后，该对组成了授权表中定义的用户，在访问数据库对象时将用于授权。这是默认情况。您可以运行以下查询来查看当前验证的用户以及客户端提供的用户：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Quite unsurprisingly, the records match. This is the most common occurrence,
    but as you’ll see next, it’s not the only possibility.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，记录匹配。这是最常见的情况，但正如接下来您将看到的，这并不是唯一的可能性。
- en: Providing security for stored objects
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为存储对象提供安全性
- en: 'When a stored object (like a stored procedure or a view) is created, any user
    can be specified within the `DEFINER` clause of that object. That allows you to
    execute an object from the standpoint of another user: definer, instead of invoker.
    This can be a useful way to provide elevated privileges for some specific operation,
    but it can also be a security hole in your system.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建存储对象（如存储过程或视图）时，可以在该对象的`DEFINER`子句中指定任何用户。这允许您以另一个用户的身份执行对象：定义者，而不是调用者。这可以是提供某些特定操作的提升权限的有用方式，但也可能是系统中的安全漏洞。
- en: 'When a MySQL account is specified in the `DEFINER` clause of an object, such
    as a stored procedure, that account will be used for authorization when the stored
    procedure is executed or when a view is queried. In other words, the current user
    of a session changes temporarily. As we mentioned, this can be used to elevate
    privileges in a controlled manner. For example, instead of granting a user permission
    to read from some tables, you can create a view with a `DEFINER`: the account
    you specify will be allowed to access the tables when the view is being queried,
    but not under any other circumstances. Also, the view itself can further restrict
    what data is returned. The same is true for stored procedures. To interact with
    an object that has a `DEFINER`, a caller must have the necessary permissions.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当在对象的`DEFINER`子句中指定MySQL账户时，例如存储过程中，当执行存储过程或查询视图时，将使用该账户进行授权。换句话说，会话的当前用户会临时改变。正如我们提到的，这可以用来以受控方式提升权限。例如，与其授予用户从某些表中读取的权限，您可以创建一个视图，其`DEFINER`是您指定的账户，此时在查询视图时将允许访问表，但在其他情况下不允许。此外，视图本身也可以进一步限制返回的数据。对于存储过程也是如此。要与具有`DEFINER`的对象交互，调用者必须具有必要的权限。
- en: 'Let’s take a look at an example. Here’s a simple stored procedure that returns
    the current user used for authorization, as well as the authenticated user. The
    `DEFINER` is set to `''bob''@''localhost''`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。这是一个简单的存储过程，返回用于授权的当前用户以及已认证的用户。`DEFINER`设置为`'bob'@'localhost'`：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If this procedure is executed by the user `john` from the previous examples,
    output similar to the following will be printed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此过程由先前示例中的用户`john`执行，则将打印类似以下内容的输出：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It’s important to keep this in mind. Sometimes users are not who they appear
    to be, and to keep your database safe that has to be noted.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点非常重要。有时用户并非表面上看起来那样，并且需要注意保护您的数据库安全。
- en: Proxying
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代理
- en: 'Some authentication methods, like PAM and LDAP, do not operate with a one-to-one
    mapping from authenticating users to database ones. We showed before how to create
    a PAM-authenticated user—let’s see what such a user would see if they queried
    the authenticating and provided users:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 某些认证方法，如PAM和LDAP，不支持从认证用户到数据库用户的一对一映射。我们之前展示了如何创建一个使用PAM认证的用户 —— 让我们看看如果这样一个用户查询认证用户和提供用户时会看到什么：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before we close this section, we should bring up a couple of important points
    related to the `CREATE USER` statement. First, it is possible to create multiple
    user accounts with a single command, instead of executing multiple `CREATE USER`
    statements individually. Second, if the user already exists, `CREATE USER` doesn’t
    fail, but will change that user in subtle ways. This can be dangerous. To avoid
    this, you can specify an `IF NOT EXISTS` option to the command. By doing so, you
    tell MySQL to create the user only if no such user already exists, and do nothing
    if it does.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一节之前，我们应该提到与`CREATE USER`语句相关的一些重要点。首先，可以使用单个命令创建多个用户账户，而不是逐个执行`CREATE
    USER`语句。其次，如果用户已经存在，`CREATE USER`不会失败，但会在细微的方面更改该用户。这可能是危险的。为了避免这种情况，您可以在命令中指定`IF
    NOT EXISTS`选项。通过这样做，您告诉MySQL仅在不存在此类用户时创建用户，如果存在则不执行任何操作。
- en: At this point, you should have a good understanding of what a MySQL user is
    and how it can be used. Next we’ll show you how users can be modified, but first
    you need to understand how user-related information is stored internally.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对MySQL用户及其使用有了很好的理解。接下来，我们将向您展示如何修改用户，但首先您需要了解内部存储的与用户相关的信息。
- en: Grant Tables
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授予表
- en: 'MySQL stores both user information and privileges as records in *grant tables*.
    These are special internal tables in the `mysql` database, which should ideally
    never be modified manually and instead are implicitly modified when statements
    like `CREATE USER` or `GRANT` are run. For example, here is the slightly truncated
    output of a `SELECT` query on the `mysql.user` table, which contains user records,
    including their passwords (in hashed form):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL将用户信息和权限存储为*授权表*中的记录。这些是`mysql`数据库中的特殊内部表，理论上不应该手动修改，而应在执行诸如`CREATE USER`或`GRANT`等语句时隐式修改。例如，这里是对`mysql.user`表执行`SELECT`查询的部分截断输出，其中包含用户记录，包括其密码（以哈希形式）：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can immediately see that a lot of the fields directly correspond to specific
    invocations of the `CREATE USER` or `ALTER USER` statements. For example, you
    can see that this `root` user doesn’t have any specific rules set regarding its
    password’s lifecycle. You can also see quite a lot of privileges, though we have
    omitted some for brevity. These are privileges that don’t require a target, like
    a table. Such privileges are called *global*. We’ll show you how to view targeted
    privileges later.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以立即看到，许多字段直接对应于特定的`CREATE USER`或`ALTER USER`语句的具体调用。例如，您可以看到此`root`用户没有关于其密码生命周期的任何特定规则设置。您还可以看到相当多的权限，尽管我们出于简洁起见省略了一些。这些是不需要目标（如表）的权限，称为*全局*权限。稍后我们将向您展示如何查看针对性的权限。
- en: 'As of MySQL 8.0, the other grant tables are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 自MySQL 8.0起，其他授予表包括：
- en: '`mysql.user`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.user`'
- en: User accounts, static global privileges, and other nonprivilege columns
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用户账户、静态全局权限和其他非特权列
- en: '`mysql.global_grants`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.global_grants`'
- en: Dynamic global privileges
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 动态全局权限
- en: '`mysql.db`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.db`'
- en: Database-level privileges
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库级别的权限
- en: '`mysql.tables_priv`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.tables_priv`'
- en: Table-level privileges
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表级权限
- en: '`mysql.columns_priv`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.columns_priv`'
- en: Column-level privileges
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列级权限
- en: '`mysql.procs_priv`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.procs_priv`'
- en: Stored procedure and function privileges
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程和函数权限
- en: '`mysql.proxies_priv`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.proxies_priv`'
- en: Proxy-user privileges
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代理用户权限
- en: '`mysql.default_roles`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.default_roles`'
- en: Default user roles
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认用户角色
- en: '`mysql.role_edges`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.role_edges`'
- en: Edges for role subgraphs
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 角色子图的边缘
- en: '`mysql.password_history`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql.password_history`'
- en: Password change history
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 密码更改历史
- en: You don’t need to remember all of these tables, let alone their structure and
    contents, but you should remember that they exist. When necessary, you can easily
    look up the necessary structure information in the docs or in the database itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需记住所有这些表，更不用说它们的结构和内容，但您应记住它们的存在。在必要时，您可以轻松地在文档或数据库本身中查找必要的结构信息。
- en: Internally, MySQL caches grant tables in memory and refreshes this cached representation
    every time an account management statement is run and thus modifies grant tables.
    Cache invalidation happens only for the specific user affected. Ideally, you should
    never modify these grant tables directly, and there’s rarely a use case for that.
    However, in the unfortunate event that you do need to modify a grant table, you
    can tell MySQL to reread them by running the `FLUSH PRIVILEGES` command. Failure
    to do so will mean that the in-memory cache won’t get updated until either the
    database is restarted, an account management statement is run against the same
    user that was updated directly in the grant tables, or `FLUSH PRIVILEGES` is executed
    for some other purpose. Even though the command’s name suggests it only affects
    privileges, MySQL will reread information from all of the tables and refresh its
    cache in memory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，MySQL 在内存中缓存授权表，并在运行帐户管理语句并因此修改授权表时刷新此缓存表示。仅对受影响的特定用户进行缓存失效。理想情况下，您不应直接修改这些授权表，而且很少有使用情况。但是，如果不幸需要修改授权表，可以通过运行`FLUSH
    PRIVILEGES`命令告知 MySQL 重新读取它们。如果不这样做，意味着内存中的缓存不会更新，直到数据库重新启动，针对直接在授权表中更新的同一用户运行帐户管理语句，或出于其他目的执行`FLUSH
    PRIVILEGES`为止。尽管命令的名称暗示它仅影响特权，但 MySQL 将从所有表中重新读取信息并刷新其内存中的缓存。
- en: User Management Commands and Logging
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理命令和日志记录
- en: 'There are some direct consequences of the fact that all the commands we’re
    discussing in this chapter are, under the hood, modifying the grant tables. They
    are close to DML operations in some regards. They are atomic: any `CREATE USER`,
    `ALTER USER`, `GRANT`, or other such operation either succeeds or fails without
    actually changing its target. They are logged: all of the changes done to grant
    tables either manually or through the relevant commands are logged to the binary
    log. Thus, they are replicated (see [Chapter 13](ch13.xhtml#CH13_HA)) and will
    also be available for point-in-time recovery (see [Chapter 10](ch10.xhtml#CH10_BACKUP)).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在本章讨论的所有命令的直接后果是它们在幕后修改授权表。在某些方面，它们接近 DML 操作。它们是原子的：任何`CREATE USER`、`ALTER
    USER`、`GRANT`或其他此类操作要么成功，要么失败，而不会实际更改其目标。它们被记录：手动或通过相关命令对授权表进行的所有更改都记录在二进制日志中。因此，它们被复制（参见[第
    13 章](ch13.xhtml#CH13_HA)）并且还可以用于时点恢复（参见[第 10 章](ch10.xhtml#CH10_BACKUP)）。
- en: Application of these statements on the source can break replication if the targeted
    user doesn’t exist on the replica. We therefore recommend that you keep your replicas
    consistent with their sources not only in data, but also in users and other metadata.
    Of course, it’s only “meta” in the sense that it exists outside of your real application
    data; users are records in the `mysql.user` table, and that should be remembered
    when setting up replication.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在源上应用这些语句可能会破坏复制，如果复制副本上不存在目标用户。因此，我们建议您保持副本与其源的一致性，不仅在数据上，还在用户和其他元数据上。当然，“元数据”仅在它存在于您的真实应用数据之外的意义上存在；用户是`mysql.user`表中的记录，设置复制时应记住这一点。
- en: Mostly, replicas are full copies of their sources. In more complex topologies,
    like fan-in, that may not be true, but even in such cases we recommend keeping
    users consistent across the topology. In general, it is easier and safer than
    fixing broken replicas or remembering whether you need to disable binary logging
    before altering a user.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，复制副本是其源的完整副本。在像扇入这样的更复杂的拓扑中，可能不是这样，但即使在这种情况下，我们也建议在整个拓扑中保持用户的一致性。总体而言，这比修复损坏的副本或记住在更改用户之前是否需要禁用二进制日志更容易和更安全。
- en: While we say that execution of `CREATE USER` is similar to an `INSERT` to the
    `mysql.user` table, the `CREATE USER` statement itself is not changed in any way
    before being logged. That is true for the binary log, the slow query log (with
    a caveat), the general query log, and audit logs. The same is true for every other
    operation discussed in this chapter. The caveat for the slow query log is that
    an extra server option, `log_slow_admin_statements`, has to be enabled for administrative
    statements to be logged here.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们说 `CREATE USER` 的执行类似于对 `mysql.user` 表进行 `INSERT` 操作，但 `CREATE USER` 语句本身在被记录之前并没有任何改变。这对二进制日志、慢查询日志（有一个警告）、通用查询日志和审计日志都是适用的。本章讨论的每个其他操作也是如此。慢查询日志的警告是，必须启用额外的服务器选项
    `log_slow_admin_statements` 才能将管理语句记录在此处。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can find the locations of the logs we’ve mentioned under the following
    system variable names: `log_bin_basename`, `slow_query_log_file`, and `general_log_file`.
    Their values can include the full path to the file or just the filename. In the
    latter case, that file will be in the MySQL server’s data directory. Binary logs
    always have a numeric suffix: for example, *binlog.000271*. We do not cover audit
    log configuration in this book.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下系统变量名称下找到我们提到的日志位置：`log_bin_basename`、`slow_query_log_file` 和 `general_log_file`。它们的值可以包括文件的完整路径或只是文件名。在后一种情况下，该文件将位于
    MySQL 服务器的数据目录中。二进制日志始终具有数字后缀，例如 *binlog.000271*。本书不涵盖审计日志配置。
- en: 'Consider the following example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s an example of how the same `CREATE USER` command is reflected in the
    general, slow query, and binary logs:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了相同的 `CREATE USER` 命令在通用、慢查询和二进制日志中的反映：
- en: General log
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通用日志
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Slow query log
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 慢查询日志
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Binary log
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制日志
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don’t worry if the binary log output is intimidating. It’s not intended for
    easy human consumption. However, you can see that the actual hash of the password,
    as it would appear in `mysql.user`, gets written to the binary log. We’ll talk
    more about this log in [Chapter 10](ch10.xhtml#CH10_BACKUP).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二进制日志输出让您感到难以理解，请不要担心。它并不是为了方便人类阅读而设计的。但是，您可以看到密码的实际哈希值，正如它将出现在 `mysql.user`
    中。我们将在[第10章](ch10.xhtml#CH10_BACKUP)中详细讨论这个日志。
- en: Modifying and Dropping Users
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改和删除用户
- en: Creating a user usually isn’t the end of your interaction with it. You may later
    need to change its properties, perhaps to require an encrypted connection. It
    also happens that users need to be dropped. Neither of these operations is too
    different from user creation, but you need to know how to perform them in order
    to fully grasp user management.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户通常不是与之互动的终点。您可能会后来需要更改其属性，也许是要求加密连接。还有可能需要删除用户。这些操作与用户创建并没有太大不同，但您需要知道如何执行它们才能完全掌握用户管理。
- en: Modifying a User
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改用户
- en: Any parameter that it’s possible to set during user creation can also be altered
    at a later time. This is generally achieved using the `ALTER USER` command. MySQL
    5.7 and before also have `RENAME USER` and `SET PASSWORD` shortcuts, while version
    8.0 expanded that list to include `SET DEFAULT ROLE` (we’ll cover the role system
    in [“Roles”](#USR-SEC-ROLES)). Note that `ALTER USER` can be used to change everything
    about the user, and the other commands are just convenient ways to run common
    maintenance operations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在稍后的时间修改任何在用户创建时可以设置的参数。通常可以使用 `ALTER USER` 命令实现这一点。MySQL 5.7及之前版本还有 `RENAME
    USER` 和 `SET PASSWORD` 快捷方式，而8.0版本扩展了该列表以包括 `SET DEFAULT ROLE`（我们将在[“角色”](#USR-SEC-ROLES)中介绍角色系统）。请注意，`ALTER
    USER` 可用于更改用户的所有内容，而其他命令只是运行常见维护操作的便捷方式。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We called `RENAME USER` a shortcut, but it’s special in that it doesn’t have
    a “full” `ALTER USER` alternative. As you’ll see, the privileges required to run
    the `RENAME USER` command are also different, and are the same as for user creation
    (we’ll talk more about privileges soon).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称 `RENAME USER` 为快捷方式，但它在于没有“完整”的 `ALTER USER` 替代方式。正如您将看到的，运行 `RENAME USER`
    命令所需的特权也不同，与用户创建时相同（我们将很快更多地讨论特权）。
- en: 'We will start with the regular `ALTER USER` command. In the first example,
    we’re going to modify the authentication plugin used. A lot of older programs
    do not support the new and standard in MySQL 8.0 `caching_sha2_password` plugin
    and require you to either create the users using the older `mysql_native_password`
    plugin or alter them after creation to use that plugin. We can check the current
    plugin in use by querying one of the grant tables (see [“Grant Tables”](#USR-GRANT-TABLES)
    for more information on these):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从常规的`ALTER USER`命令开始。在第一个例子中，我们将修改使用的认证插件。许多较旧的程序不支持MySQL 8.0中的新标准`caching_sha2_password`插件，并要求您在创建用户时使用较旧的`mysql_native_password`插件或在创建后修改它们以使用该插件。我们可以通过查询授权表中的一张表（有关这些信息，请参见[“授权表”](#USR-GRANT-TABLES)）来检查当前正在使用的插件：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And now we can alter the plugin for this user and make sure the change is reflected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为此用户更改插件并确保更改反映出来：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since the change was made via an `ALTER` command, there’s no need to run `FLUSH`
    `PRIVILEGES`. Once this command executes successfully, each new authentication
    attempt will use the new plugin. You could modify the user record directly to
    make this change, but again, we recommend against that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于更改是通过`ALTER`命令进行的，所以无需运行`FLUSH PRIVILEGES`。一旦该命令成功执行，每次新的认证尝试将使用新的插件。你可以直接修改用户记录来进行此更改，但我们仍然建议不要这样做。
- en: 'The properties that `ALTER USER` can modify are pretty numerous and were explained
    or at least outlined in [“Creating and Using New Users”](#USR-CREATE). There are,
    however, some frequently required operations that you should know a bit more about:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALTER USER`可以修改的属性非常多，或者至少在[“创建和使用新用户”](#USR-CREATE)中有所解释。然而，有一些经常需要的操作你应该更加了解：'
- en: Changing a user’s password
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更改用户的密码
- en: 'This is probably the single most frequent operation that’s ever done on a user.
    Changing a user’s password can be done by another user that has the necessary
    privileges, or by anyone authorized as that user, using a command like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是对用户进行的最频繁的操作之一。更改用户的密码可以由具有必要特权的另一个用户执行，或者由授权为该用户的任何人使用以下命令执行：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This change takes effect immediately, so the next time this user authenticates
    they’ll need to use the updated password. There’s also a `SET PASSWORD` shortcut
    for this command. It can be executed by the authenticated user without any target
    specification like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改立即生效，因此下次该用户进行认证时，他们将需要使用更新后的密码。这个命令也有一个`SET PASSWORD`的快捷方式。可以由已认证用户执行，无需任何目标规范，如下所示：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Or it can be executed by another user, with the target specification.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以由另一个具有目标规范的用户执行。
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Locking and unlocking a user
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定和解锁用户
- en: If you need to temporarily (or permanently) block access to a specific user,
    you can do that using the `ACCOUNT LOCK` option of `ALTER USER`. The user in this
    case is only blocked for authentication. While nobody will be able to connect
    to MySQL as the blocked user, it can still be used both as a proxy and in a `DEFINER`
    clause. That makes such users slightly more secure and easier to manage. The `ACCOUNT
    LOCK` can also be used to, for example, block traffic from an application connecting
    as a specific user that is generating excessive load.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要暂时（或永久）阻止对特定用户的访问，可以使用`ALTER USER`的`ACCOUNT LOCK`选项来执行。在这种情况下，该用户只能在认证时被阻止。虽然没有人能够以被阻止的用户连接到MySQL，但它仍然可以作为代理使用，并在`DEFINER`子句中使用。这使得此类用户稍微更安全且更易于管理。`ACCOUNT
    LOCK`也可以用来，例如，阻止作为特定用户连接的应用程序生成过多负载。
- en: 'We can block `bob` from authenticating using the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令阻止`bob`进行认证：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Only new connections will be affected. The message that MySQL produces in this
    case is clear:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 只有新连接会受到影响。MySQL在这种情况下产生的消息非常清楚：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The counterpart to `ACCOUNT LOCK` is `ACCOUNT UNLOCK`. This option to `ALTER
    USER` does exactly what it says. Let’s allow access to `bob` again:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ACCOUNT LOCK`相对应的是`ACCOUNT UNLOCK`。`ALTER USER`的此选项确切地执行其描述的功能。让我们再次允许`bob`访问：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now the connection attempt will succeed:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接尝试将成功：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Expiring a user’s password
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户密码过期
- en: Instead of blocking a user’s access completely or changing the password for
    them, you may instead want to force them to change their password. That is possible
    in MySQL with the `PASSWORD EXPIRE` option of the `ALTER USER` command. After
    this command is executed, the user will still be able to connect to the server
    using the previous password. However, as soon as they run a query from the new
    connection—that is, as soon as their privileges are checked—the user will be presented
    with an error and forced to change the password. Existing connections are not
    affected.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不要完全阻止用户的访问或更改其密码，您可能希望强制其更改密码。在MySQL中，可以通过`ALTER USER`命令的`PASSWORD EXPIRE`选项实现这一点。执行此命令后，用户仍然可以使用先前的密码连接到服务器。然而，一旦他们从新连接运行查询——也就是说，一旦检查他们的权限——用户将会遇到错误，并被强制更改密码。现有的连接不受影响。
- en: 'Let’s see what this looks like for the user. First, the actual alter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这对用户是什么样子。首先，实际修改：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, what the user gets. Note the successful authentication:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户得到了什么。注意成功的身份验证：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Even though the error states you have to run `ALTER USER`, you now know that
    you can use `SET PASSWORD` instead. It also doesn’t matter who changes the password:
    the user in question or another user. The `PASSWORD EXPIRE` option just forces
    the password change. If another user changes the password, then sessions authenticated
    with the old password after the password has been expired will need to be reopened.
    As we saw earlier, the authenticated user can change the password without a target
    specification, and they’ll be able to continue with their session as normal (new
    connections, however, will need to be authenticated with the new password):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管错误声明你必须运行`ALTER USER`，但现在你知道可以改用`SET PASSWORD`。谁更改密码并不重要：问题用户还是另一个用户。`PASSWORD
    EXPIRE`选项只是强制密码更改。如果另一个用户更改了密码，那么在密码过期后仍使用旧密码进行身份验证的会话需要重新打开。正如我们早些时候看到的，经过验证的用户可以在没有目标规范的情况下更改密码，并且他们将能够继续正常进行会话（但新连接将需要使用新密码进行身份验证）：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, you should also be aware that without password reuse and history
    controls in place, the user could just reset the password to the original one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你还应该注意，如果没有密码重用和历史控制措施，用户可以将密码重置为原始密码。
- en: Renaming a user
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 用户重命名
- en: 'Changing a username is a relatively rare operation, but it is sometimes necessary.
    This operation has a special command: `RENAME USER`. It requires the `CREATE USER`
    privilege, or the `UPDATE` privilege on the `mysql` database or just the grant
    tables. There’s no `ALTER USER` alternative for this command.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更改用户名是一个相对罕见的操作，但有时是必要的。这个操作有一个特殊的命令：`RENAME USER`。它需要`CREATE USER`权限，或者在`mysql`数据库或授权表上的`UPDATE`权限。对于这个命令，没有`ALTER
    USER`的替代方案。
- en: 'You can change both the “name” part of the username and the “host” part. Since,
    as you know by now, the “host” part acts as a firewall, be cautious when changing
    it, as you may cause outages (actually, the same is true of the “name” part as
    well). Let’s rename our `bob` user to something more formal:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以同时更改用户名的“名称”部分和“主机”部分。因为正如你现在所知，这个“主机”部分充当了防火墙的角色，在更改时要小心，可能会导致服务中断（实际上，“名称”部分也是如此）。让我们将我们的`bob`用户重命名为更正式的名称：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When the username changes, MySQL automatically scans through its internal tables
    to see whether that user has been named in the `DEFINER` clause of a view or a
    stored object. Whenever that is the case, a warning is produced. Since we did
    get a warning when we renamed `bob`, let’s check it out:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户名更改时，MySQL会自动扫描其内部表，查看该用户是否在视图或存储对象的`DEFINER`子句中命名。每当出现这种情况时，会产生一个警告。由于我们在重命名`bob`时收到了警告，让我们来看看：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Failure to address this issue can potentially result in orphaned objects that
    will error out when accessed or executed. We discuss this in detail in the next
    section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不解决这个问题，可能会导致孤立的对象，在访问或执行时出错。我们将在下一节详细讨论这个问题。
- en: Dropping a User
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'The final part of the lifecycle of a database user is its end of life. Like
    any database object, users can be deleted. In MySQL, the `DROP USER` command is
    used to achieve that. This is one of the simplest commands discussed in this chapter,
    and potentially in the whole book. `DROP USER` takes a user or, optionally, a
    list of users as an argument, and has a single modifier: `IF NOT EXISTS`. Successful
    execution of the command irrevocably deletes the user-related information from
    the grant tables (with a caveat we’ll discuss later) and thus prevents further
    logins.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库用户生命周期的最后阶段是其结束。像任何数据库对象一样，用户可以被删除。在 MySQL 中，使用 `DROP USER` 命令来实现这一点。这是本章讨论的最简单的命令之一，可能也是整本书中最简单的命令。`DROP
    USER` 接受一个用户或者可选地一组用户作为参数，并且有一个修饰符：`IF NOT EXISTS`。成功执行该命令将从授权表中不可撤销地删除与用户相关的信息（我们稍后会讨论一个警告），从而防止进一步的登录。
- en: 'When you drop a user that has made one or more connections to the database
    that are still open, even though the drop succeeds, the associated records will
    be removed only when the last of those connections ends. The next attempt to connect
    with the given user will result in the `ERROR 1045 (28000): Access denied` message.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '当你删除一个仍然有一个或多个连接到数据库的用户时，即使删除成功，关联的记录只有在最后一个连接结束时才会被移除。下一次尝试使用该用户连接将导致`ERROR
    1045 (28000): Access denied`错误信息。'
- en: 'The `IF NOT EXISTS` modifier works similarly to with `CREATE USER`: if the
    user you target with `DROP USER` does not exist, no error will be returned. This
    is useful in unattended scripts. If the host part of the username is not specified,
    the wildcard `%` is used by default.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`IF NOT EXISTS` 修饰符与 `CREATE USER` 的工作方式类似：如果目标用户不存在于 `DROP USER` 中，不会返回错误。这在无人值守脚本中非常有用。如果未指定用户名的主机部分，默认使用通配符
    `%`。'
- en: 'In its most basic form, the `DROP USER` command looks like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，`DROP USER` 命令如下所示：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Executing the same command again will result in an error:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行相同的命令将导致错误：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you want to construct an idempotent command that won’t fail, then use the
    following construct instead:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想构建一个不会失败的幂等命令，那么使用以下结构：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Again, if you do not specify the host part of the username, MySQL will assume
    the default `%`. It’s also possible to drop multiple users at once:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果你没有指定用户名的主机部分，MySQL 将假定默认为 `%`。也可以一次性删除多个用户：
- en: '[PRE66]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In MySQL, as users do not own objects, they can be dropped quite easily and
    without much preparation. However, as we have already discussed, users can fulfill
    extra roles. If the dropped user is used as a proxy user or is part of the `DEFINER`
    clause of some object, then dropping it can create an orphaned record. Whenever
    the user you drop is part of such a relationship, MySQL emits a warning. Note
    that the `DROP USER` command will still succeed, so it’s up to you to resolve
    the resulting inconsistencies and fix any orphaned records:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中，由于用户不拥有对象，因此可以相对容易地删除它们而无需做太多准备。然而，正如我们已经讨论过的，用户可以担任额外的角色。如果删除的用户用作代理用户或是某个对象的
    `DEFINER` 子句的一部分，则删除它可能会创建一个孤立的记录。每当您删除的用户属于这种关系时，MySQL 会发出警告。请注意，`DROP USER`
    命令仍将成功执行，因此您需要解决由此产生的不一致性并修复任何孤立的记录：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We recommend that you check this before actually dropping the user. If you
    fail to notice the warning and take action, the objects are left orphaned. Orphaned
    objects will produce errors when used:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在实际删除用户之前检查这一点。如果你未能注意到警告并采取行动，这些对象将会变成孤立的。孤立的对象在使用时会产生错误：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For users in a proxy relationship, no warning is produced. However, a subsequent
    attempt to use the proxied user will result in an error. As proxy users are used
    in authentication, the end result will be the inability to log into MySQL with
    users dependent on the dropped one. This arguably can be more impactful than temporarily
    losing the ability to call a procedure or query a view, but still, no warning
    will be emitted. If you are using pluggable authentication relying on proxy users,
    remember this.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处于代理关系的用户，不会产生警告。然而，后续尝试使用代理用户将导致错误。由于代理用户用于身份验证，结果将是无法使用依赖于已删除用户的用户登录 MySQL。这可能比暂时失去调用存储过程或查询视图的能力更有影响力，但仍然不会发出警告。如果你使用依赖于代理用户的可插拔认证，请记住这一点。
- en: 'If you find yourself in a situation where you dropped a user and unexpectedly
    got a warning, you can easily create the user again to avoid the errors. Note
    how the following `CREATE USER` statement results in the now-familiar warning:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己处于这样的情况，即删除了用户却意外地收到了警告，您可以轻松地重新创建用户以避免错误。注意下面的`CREATE USER`语句产生了现在熟悉的警告：
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: However, the problem here is that if you don’t know or remember the initial
    privileges of the account, the new one can become a security issue.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题在于，如果您不知道或记得帐户的初始权限，新帐户可能会成为安全问题。
- en: 'To identify orphaned records, you need to manually review MySQL’s catalog tables.
    Specifically, you’re going to need to look at the `DEFINER` column of the following
    tables:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别孤立的记录，您需要手动查看MySQL的目录表。具体来说，您需要查看以下表的`DEFINER`列：
- en: '[PRE78]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now that you know that, you can easily construct a query to check if a user
    you’re going to drop or have already dropped is specified within any `DEFINER`
    clauses:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道了这一点，您可以轻松构建一个查询，以检查要删除或已经删除的用户是否在任何`DEFINER`子句中指定：
- en: '[PRE80]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'That query might look intimidating, but by now you should’ve seen `UNION` used
    in [“The Union”](ch05.xhtml#ADV1-SEC-UNION), and the query is just a union of
    four simple queries. Each individual query looks for an object with a `DEFINER`
    value of `bob@localhost` in one of the following tables: `EVENTS`, `ROUTINES`,
    `TRIGGERS`, and `VIEWS`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询看起来可能令人生畏，但是到目前为止，您应该已经看到了在[“The Union”](ch05.xhtml#ADV1-SEC-UNION)中使用的`UNION`，而该查询只是四个简单查询的联合。每个单独的查询都查找具有`DEFINER`值为`bob@localhost`的对象之一，分别是`EVENTS`、`ROUTINES`、`TRIGGERS`和`VIEWS`表中的一个。
- en: 'In our example, the query returns a single record for `bob@localhost`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，查询为`bob@localhost`返回了单个记录：
- en: '[PRE81]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It’s similarly easy to check if the proxy privilege was granted for this user:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否为该用户授予了代理权限同样很容易：
- en: '[PRE82]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We recommend that you always check for possible orphaned objects and proxy privileges
    before you drop a particular user. Such gaps left in the database will not only
    cause obvious issues (errors) but are, in fact, a security risk.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在删除特定用户之前，始终检查可能存在的孤立对象和代理权限。数据库中留下的这些空白不仅会导致明显的问题（错误），而且实际上是安全风险。
- en: Privileges
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 权限
- en: When a user connects to a MySQL server, authentication is performed using the
    username and host information, as explained before. However, the permissions the
    user has to perform different actions aren’t checked before any commands are executed.
    MySQL grants privileges according to the identity of the connected user and the
    actions it performs. As discussed at the beginning of this chapter, privileges
    are sets of permissions to perform actions on various objects. By default, a user
    is not entitled to any permissions, and thus it has no privileges assigned after
    `CREATE USER` is executed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户连接到MySQL服务器时，将使用用户名和主机信息执行身份验证，如前所述。但是，在执行任何命令之前不会检查用户执行不同操作的权限。MySQL根据连接用户的身份和其执行的操作授予权限。正如本章开头讨论的那样，权限是在各种对象上执行操作的权限集。默认情况下，用户没有任何权限，因此在执行`CREATE
    USER`后没有分配权限。
- en: 'There are a lot of privileges that you can grant to a user and later revoke.
    For example, you can allow a user to read from a table or modify data in it. You
    can grant a privilege to create tables and databases, and another to create stored
    procedures. The list is vast. Curiously, you will not find a connection privilege
    anywhere: it’s impossible to disallow a user from connecting to MySQL, assuming
    the host part of username matches. That’s a direct consequence of what was outlined
    in the previous paragraph: privileges are checked only when an action is performed,
    so by nature they will apply only once a user is authenticated.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多特权可以授予用户，并且之后可以撤销。例如，您可以允许用户从表中读取或修改数据。您可以授予创建表和数据库的权限，以及创建存储过程的权限。清单非常广泛。有趣的是，你无法在任何地方找到连接权限：假设用户名的主机部分匹配，不可能阻止用户连接到MySQL。这是前一段概述的直接结果：权限仅在执行操作时进行检查，因此它们的应用只有在用户通过身份验证后才会生效。
- en: 'To get a full list of privileges supported and provided by your MySQL installation,
    we always recommend checking the manual. However, we’ll cover the few broad categories
    of privileges here. We’ll also talk about levels of privileges, as the same privileges
    can be allowed on multiple levels. Actually, that’s what we’ll start with. There
    are four levels of privileges in MySQL:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取您的 MySQL 安装支持和提供的所有权限列表，我们始终建议查阅手册。但是，我们将在此介绍少数广泛的权限类别。我们还将讨论权限级别，因为相同的权限可以在多个级别上允许。实际上，这是我们将要开始的内容。MySQL
    中有四个权限级别：
- en: Global privileges
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 全局权限
- en: These privileges allow the *grantee* (the user who is granted the privilege—we
    cover the `GRANT` command in [“Privilege Management Commands”](#USR-PRIV-MGMT))
    to either act on every object in every database or act on the cluster as a whole.
    The latter applies to commands that are usually considered administrative. For
    example, you can allow a user to shut down the cluster.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限允许*被授予者*（被授予权限的用户，我们在 [“权限管理命令”](#USR-PRIV-MGMT) 中介绍 `GRANT` 命令）在每个数据库中的每个对象上操作，或者在整个集群上操作。后者适用于通常被视为管理性的命令。例如，您可以允许用户关闭集群。
- en: Privileges in this category are stored within the tables `mysql.user` and `mysql.global_grants`.
    The first one stores conventional static privileges, and the second one stores
    dynamic privileges. The difference is explained in the following section. MySQL
    versions prior to 8.0 store all global privileges in `mysql.user`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此类别中的权限存储在 `mysql.user` 和 `mysql.global_grants` 表中。第一个表存储传统的静态权限，第二个表存储动态权限。后面的章节将详细解释其区别。MySQL
    8.0 之前的版本将所有全局权限存储在 `mysql.user` 中。
- en: Database privileges
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库权限
- en: Privileges granted on a database level will allow the user to act upon objects
    within that database. As you can imagine, the list of privileges is narrower at
    this level, since there’s little sense in breaking down the `SHUTDOWN` privilege
    below the global level, for example. Records for these privileges are stored within
    the `mysql.db` table and include the ability to run DDL and DML queries within
    the target database.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库级别授予的权限将允许用户在该数据库中操作对象。由于在这个级别下，没有必要将 `SHUTDOWN` 权限下降到全局级别，因此在此级别的权限列表较窄。这些权限的记录存储在
    `mysql.db` 表中，包括在目标数据库中运行 DDL 和 DML 查询的能力。
- en: Object privileges
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对象权限
- en: A logical continuation of database-level privileges, these target a particular
    object. Tracked in `mysql.tables_priv`, `mysql.procs_priv`, and `mysql.proxies_priv`,
    they respectively cover tables and views, all types of stored routines, and finally
    the proxy user permissions. Proxy privileges are special, but the other privileges
    in this category are again regular DDL and DML permissions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库级别权限的逻辑延伸，这些权限针对特定对象。分别在 `mysql.tables_priv`、`mysql.procs_priv` 和 `mysql.proxies_priv`
    中跟踪，分别涵盖表和视图、所有类型的存储过程以及代理用户权限。代理权限是特殊的，但该类别中的其他权限再次是常规的 DDL 和 DML 权限。
- en: Column privileges
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列权限
- en: Stored in `mysql.columns_priv`, these are an interesting set of privileges.
    You can separate permissions within a particular table by column. For example,
    a reporting user may not have the need to read the `password` column of a particular
    table. This is a powerful tool, but column privileges can be difficult to manage
    and maintain.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `mysql.columns_priv` 中，这些是一组有趣的权限。您可以按列在特定表中分离权限。例如，报告用户可能不需要读取特定表的 `password`
    列。这是一个强大的工具，但是列权限可能难以管理和维护。
- en: The complete list of privileges, frankly, is very long. It is always advisable
    to consult the MySQL documentation for your particular version for the complete
    details. You should remember that any action a user can perform either will have
    a dedicated privilege assigned or will be covered by a privilege controlling a
    wider range of behaviors. In general, database- and object-level privileges will
    have a dedicated privilege name that you can grant (`UPDATE`, `SELECT`, and so
    on), and global privileges will be quite broadly grouped together, allowing multiple
    actions at once. For example, the `GROUP_REPLICATION_ADMIN` privilege allows five
    different actions at once. Global privileges will also usually be granted on a
    system level (the **`.`** object).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的特权列表实际上非常长。建议您始终查阅MySQL文档，以获取特定版本的完整细节。您应该记住，用户可以执行的任何操作都将分配专用特权或由控制更广泛行为范围的特权所覆盖。一般来说，数据库和对象级别的特权将有一个您可以授予的专用特权名称（`UPDATE`、`SELECT`等），而全局特权则通常会广泛地分组在一起，允许一次执行多个操作。例如，`GROUP_REPLICATION_ADMIN`特权一次允许五种不同的操作。全局特权通常也会在系统级别（`.`对象）上授予。
- en: 'You can always access the list of privileges available in your MySQL instance
    by running the `SHOW PRIVILEGES` command:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`SHOW PRIVILEGES`命令随时访问您的MySQL实例中可用的特权列表：
- en: '[PRE84]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Static Versus Dynamic Privileges
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态特权与动态特权
- en: 'Before we go on to review the commands used to manage privileges in MySQL,
    we must pause and talk about an important distinction. There are two types of
    privileges in MySQL, starting with version 8.0: static and dynamic. The *static*
    privileges are built into the server, and every installation will have them available
    and usable. The *dynamic* privileges are, on the other hand, “volatile”: they
    are not guaranteed to be present all the time.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查看在MySQL中管理特权所用到的命令之前，我们必须停下来谈谈一个重要的区别。从版本8.0开始，MySQL中有两种类型的特权：静态和动态。*静态*特权内置于服务器中，每个安装都可以使用和利用。*动态*特权则是“不稳定”的：它们不能保证始终存在。
- en: What are these dynamic privileges? They are privileges that are registered within
    the server at runtime. Only registered privileges can be granted, so it is possible
    that some privileges will never be registered and will never be grantable. All
    of that is a fancy way of saying that it’s now possible to extend privileges via
    plugins and components. However, most of the dynamic privileges currently available
    are registered by default in a regular Community Server installation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是这些动态特权？它们是在运行时在服务器内注册的特权。只有注册的特权才能被授予，因此某些特权可能永远不会被注册，也不会被授予。所有这些都是说，现在可以通过插件和组件扩展特权的一种高级方式。然而，目前在常规社区服务器安装中，默认情况下注册的大多数动态特权都是可用的。
- en: The important role of the dynamic privileges provided with MySQL 8.0 is that
    they are aimed at reducing the necessity of using the `SUPER` privilege, which
    was previously abused (we’ll talk about this privilege in the next section). The
    other distinction of dynamic privileges is that they usually control a set of
    activities users can perform. For example, unlike a direct `SELECT` privilege
    on a table, which just allows querying the data, the `CONNECTION_ADMIN` privilege
    allows a whole list of actions. In this particular example, that includes killing
    other accounts’ connections, updating data in a read-only server, connecting through
    an extra connection when the limit is reached, and more. You can easily spot the
    difference.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 8.0 提供的动态特权的重要作用在于，它们旨在减少以前滥用的`SUPER`特权的必要性（我们将在下一节讨论此特权）。动态特权的另一个区别在于，它们通常控制用户可以执行的一组活动。例如，与直接对表进行`SELECT`特权不同，后者仅允许查询数据，`CONNECTION_ADMIN`特权允许执行一整套操作。在这个特定示例中，包括终止其他账户的连接、在只读服务器中更新数据，在达到连接限制时通过额外连接连接，等等。您可以轻松地辨认出这些差异。
- en: The SUPER Privilege
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**超级特权**'
- en: 'This section is not long, but it is important. We mentioned in [“The root User”](#USR-ROOT)
    that there’s a superuser created by default with every MySQL installation: `root@localhost`.
    Sometimes you might want to provide the same capabilities to another user, for
    example one used by a DBA. The convenient built-in way of doing so is by using
    the special `SUPER` privilege.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节不长，但很重要。我们在[“root用户”](#USR-ROOT)中提到，每个MySQL安装默认创建一个超级用户：`root@localhost`。有时，您可能希望为另一个用户（例如DBA使用的用户）提供相同的功能。方便的内置方法是使用特殊的`SUPER`特权。
- en: '`SUPER` is basically a catchall privilege that turns a user to which it is
    assigned into a superuser. As with any privilege, it can be assigned via a `GRANT`
    statement, which we’ll review in the following section.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUPER`基本上是一个通用权限，使其被分配的用户成为超级用户。与任何权限一样，可以通过`GRANT`语句分配它，我们将在以下部分进行回顾。'
- en: There are two huge problems with the `SUPER` privilege, however. First, starting
    with MySQL 8.0 it is deprecated, and it is going to be removed in a future release
    of MySQL. Second, it is a security and operational nightmare. The first point
    is clear, so let’s talk about the second one, and about the alternatives we have.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`SUPER`权限存在两个巨大的问题。首先，在MySQL 8.0开始，它已经被弃用，并且将在未来的MySQL版本中删除。其次，它是一个安全和操作上的噩梦。第一点很明显，现在让我们谈谈第二点，以及我们所拥有的替代方案。
- en: 'Using the `SUPER` privilege poses the same risks and results in the same issues
    as using the default `root@localhost` user. Instead of carefully inspecting the
    scope of privileges required, we’re resorting to using an all-purpose hammer to
    solve all problems. The main problem with `SUPER` is its all-encompassing scope.
    When you create a superuser, you create a liability: the user must be restricted
    and ideally audited, and operators and programs authenticating as the user must
    be extremely precise and careful in their actions. With great power comes great
    responsibility—and, among other things, the ability to just outright shut down
    the MySQL instance. Imagine executing that by mistake.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SUPER`权限会带来与使用默认的`root@localhost`用户相同的风险和问题。与仔细检查所需权限的范围不同，我们正在使用一个全能工具解决所有问题。`SUPER`的主要问题是其全面的范围。当您创建超级用户时，您正在创建一个责任：必须对用户进行限制，并在理想情况下进行审计，以及作为该用户进行认证的操作员和程序在其行动中必须极其精确和小心。伴随强大的权力而来的是巨大的责任，包括完全关闭MySQL实例的能力。想象一下误执行该操作的后果。
- en: In MySQL versions before 8.0, it’s not feasible to avoid using the `SUPER` privilege,
    as there are no alternatives provided for some of the permissions. Starting with
    version 8.0, which deprecates `SUPER`, MySQL provides a whole set of dynamic privileges
    that are aimed at removing the need for the single catchall privilege. You should
    try to avoid using the `SUPER` privilege, if possible.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL 8.0之前的版本中，避免使用`SUPER`权限是不可行的，因为某些权限没有提供替代方法。从8.0版本开始，MySQL提供了一整套动态权限，旨在消除单一通用权限的需求。如果可能的话，您应该尽量避免使用`SUPER`权限。
- en: Consider the example of a user that needs to control group replication. In MySQL
    5.7, you would need to grant the `SUPER` privilege to that user. Starting with
    version 8.0, however, you can instead grant the special `GROUP_REPLICATION_ADMIN`
    privilege, which only allows users to perform a very small subset of actions related
    to group replication.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以控制组复制为例。在MySQL 5.7中，您需要向用户授予`SUPER`权限。然而，从8.0版本开始，您可以改为授予特殊的`GROUP_REPLICATION_ADMIN`权限，该权限仅允许用户执行与组复制相关的非常少量的操作。
- en: Sometimes, you will still need a full-on DBA user that can do anything. Instead
    of granting `SUPER`, consider looking at the `root@localhost` privileges and copying
    them instead. We show you how to do that in [“Checking Privileges”](#USR-PRIVS-CHECK).
    Taking this further, you can skip granting some of the privileges, such as the
    `INNODB_REDO_LOG_ENABLE` privilege, which authorizes a user to basically enable
    a crash-unsafe mode. It is much safer to not have that privilege granted at all,
    and to be able to grant it to yourself when absolutely required, than to open
    up the risk of someone running that statement by mistake.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您仍然需要一个完整的DBA用户，可以执行任何操作。与其授予`SUPER`权限，不如查看`root@localhost`的权限并复制它们。我们会在[“检查权限”](#USR-PRIVS-CHECK)中展示如何操作。更进一步，您可以跳过授予一些权限，比如`INNODB_REDO_LOG_ENABLE`权限，该权限授权用户基本上启用了一个不安全的崩溃模式。最安全的做法是根本不授予该权限，并且在绝对必要时可以自行授予。
- en: Privilege Management Commands
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限管理命令
- en: Now that you know a bit about privileges, we can proceed to the basic commands
    that allow you to control them. You can never `ALTER` a privilege itself, though,
    so by controlling privileges here we mean giving them to and removing them from
    users. These actions are achieved with the `GRANT` and `REVOKE` statements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了一些关于权限的信息，我们可以继续介绍基本命令，允许您控制它们。不过，请注意，您不能`ALTER`权限本身，因此在此处控制权限意味着向用户授予和移除权限。这些操作通过`GRANT`和`REVOKE`语句实现。
- en: GRANT
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GRANT
- en: The `GRANT` statement is used to grant users (or roles) permissions to perform
    activities, either in general or on specific objects. The same statement can also
    be used to assign roles to users, but you cannot at the same time alter permissions
    and assign roles. To be able to grant a permission (privilege), you need to have
    that privilege assigned yourself and have the special `GRANT OPTION` privilege
    (we’ll review that later). Users with the `SUPER` (or newer `CONNECTION_ADMIN`)
    privilege can grant anything, and there’s a special condition related to grant
    tables, which we’ll discuss shortly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRANT` 语句用于授予用户（或角色）在通常或特定对象上执行活动的权限。同一语句也可以用于将角色分配给用户，但您不能同时修改权限和分配角色。为了能够授予权限（特权），您需要自己分配该特权，并拥有特殊的
    `GRANT OPTION` 特权（稍后我们将进行讨论）。具有 `SUPER`（或更新的 `CONNECTION_ADMIN`）特权的用户可以授予任何内容，并且与授予表相关的特殊条件，我们稍后会讨论。'
- en: 'For now, let’s check out the basic structure of a `GRANT` statement:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下 `GRANT` 语句的基本结构：
- en: '[PRE86]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'That statement, once executed, tells MySQL that user `''john''@''192.168.%''`
    is allowed to perform read-only queries (`SELECT`) on any table in the `app_db`
    database. Note that we have used a wildcard in the object specification. We could
    allow a particular user access to every table of every database by specifying
    a wildcard for the database as well:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句一旦执行，告诉 MySQL 用户 `'john'@'192.168.%'` 被允许在 `app_db` 数据库的任何表上执行只读查询 (`SELECT`)。请注意，我们在对象规范中使用了通配符。我们也可以通过为数据库指定通配符来允许特定用户访问每个数据库的每个表：
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The preceding invocation notably lacks the host specification for the user
    `''john''`. This shortcut translates to `''john''@''%''`; thus, it will not be
    the same user as the `''john''@''192.168.%''` we used before. Speaking of wildcards
    and users, it is not possible to specify a wildcard for the username portion of
    the user. Instead, you can specify multiple users or roles in one go like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用明显缺少用户 `'john'` 的主机规范。这个快捷方式相当于 `'john'@'%'`；因此，它不是我们之前使用的 `'john'@'192.168.%'`
    用户。说到通配符和用户，不可能为用户的用户名部分指定通配符。相反，您可以像这样一次指定多个用户或角色：
- en: '[PRE90]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We cautioned you about granting too many privileges in the previous section,
    but it can be useful to remember that there’s an `ALL` shortcut that allows you
    to grant every possible privilege on an object or set of objects. That can come
    handy when you define permissions for the “owner” user—for example, a read/write
    application user:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们警告您不要授予太多权限，但是请记住有一个 `ALL` 快捷方式，允许您在一个对象或一组对象上授予所有可能的权限。当您为“owner”用户（例如，读/写应用程序用户）定义权限时，这可能会很方便：
- en: '[PRE92]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You cannot chain object specifications, so you won’t be able to grant the `SELECT`
    privilege on two tables at once, unless that statement can be expressed using
    wildcards. As you’ll see in the next section, you can combine wildcard grants
    and specific revokes for extra flexibility.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能链式对象规范，因此除非可以使用通配符表达该语句，否则无法同时对两个表授予 `SELECT` 权限。正如您将在下一节中看到的，您可以结合通配符授权和特定撤销以获取额外的灵活性。
- en: An interesting property of the `GRANT` command is that it doesn’t check for
    the presence of the objects that you allow. That is, a wildcard is not expanded,
    but stays a wildcard forever. No matter how many new tables are added to the `app_db`
    database, both `john` and `kate` will be able to issue `SELECT` statements on
    them. Earlier versions of MySQL also would create a user to whom privileges were
    granted if it wasn’t found in the `mysql.user` table, but that behavior is deprecated
    starting with MySQL 8.0.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRANT` 命令的一个有趣特性是它不会检查您允许的对象是否存在。也就是说，通配符不会被扩展，而是永远保持为通配符。无论 `app_db` 数据库中添加了多少新表，`john`
    和 `kate` 都能够对它们发出 `SELECT` 语句。在 MySQL 8.0 开始，先前版本的 MySQL 也会为授予权限的用户创建一个用户，如果在
    `mysql.user` 表中找不到该用户，但该行为已经弃用。'
- en: 'As we discussed in depth in [“Grant Tables”](#USR-GRANT-TABLES) the `GRANT`
    statement updates grant tables. One thing that follows from the fact that there’s
    an update on grant tables is that if a user has the `UPDATE` privilege on those
    tables, that user can grant any account any privilege. Be extremely careful with
    permissions on objects in the `mysql` database: there’s little benefit to granting
    users any privileges there. Note also that when the `read_only` system variable
    is enabled, any grant requires super user privileges (`SUPER` or `CONNECTION_ADMIN`).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [“授权表”](#USR-GRANT-TABLES) 中深入讨论的那样，`GRANT` 语句会更新授权表。从更新授权表的事实可以得出一个结论，即如果用户对这些表有
    `UPDATE` 权限，那么该用户可以为任何帐户授予任何权限。在 `mysql` 数据库的对象上赋予权限时要格外小心：在这里为用户授予任何权限的好处甚微。还要注意，当启用
    `read_only` 系统变量时，任何授权都需要超级用户权限 (`SUPER` 或 `CONNECTION_ADMIN`)。
- en: 'There are a few other points we’d like to make about `GRANT` before moving
    on. In the introduction to this section, we mentioned column privileges. This
    set of privileges controls whether a user can read and update data in a particular
    column of a table. Like all other privileges, they can be permitted using the
    `GRANT` command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们还想对 `GRANT` 提出几点建议。在本节的介绍中，我们提到了列权限。这组权限控制用户是否可以读取和更新表的特定列中的数据。与所有其他权限一样，它们可以使用
    `GRANT` 命令授权：
- en: '[PRE94]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The user `kate` will now be able to issue the statement `SELECT id` `FROM` `bobs_db.bobs_private_table`,
    but not `SELECT *` or `SELECT data`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 `kate` 现在可以执行语句 `SELECT id` `FROM` `bobs_db.bobs_private_table`，但不能执行 `SELECT
    *` 或 `SELECT data`。
- en: Finally, you can grant every static privilege on a particular object, or globally,
    by running `GRANT ALL PRIVILEGES` instead of specifying each privilege in turn.
    `ALL PRIVILEGES` is just a shorthand and is not itself a special privilege, unlike
    `SUPER`, for example.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行 `GRANT ALL PRIVILEGES` 而不是逐个指定每个权限来授予特定对象或全局上的所有静态权限。`ALL PRIVILEGES`
    只是一种简写，不像 `SUPER` 那样本身不是一种特权。
- en: REVOKE
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 撤销
- en: 'The `REVOKE` statement is the opposite of the `GRANT` statement: you can use
    it to revoke privileges and roles assigned using `GRANT`. Unless otherwise specified,
    every property of `GRANT` applies to `REVOKE`. For example, to revoke privileges
    you need to have the `GRANT OPTION` privilege and the particular privileges that
    you are revoking.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`REVOKE` 语句是 `GRANT` 语句的反义词：您可以使用它来撤销使用 `GRANT` 分配的权限和角色。除非另有规定，`GRANT` 的每个属性都适用于
    `REVOKE`。例如，要撤销权限，您需要拥有 `GRANT OPTION` 权限以及要撤销的特定权限。'
- en: 'Starting with MySQL version 8.0.16, it’s possible to revoke privileges for
    particular schemas from users that have privileges granted globally. That makes
    it possible to easily restrict access to some databases while allowing access
    to all others, including ones that are newly created. For example, consider a
    database system where you have a single restricted schema. You need to create
    a user for your BI application. You start by running the usual command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MySQL 版本 8.0.16 开始，可以撤销对全局授权用户的特定模式的权限。这使得可以轻松限制对某些数据库的访问，同时允许访问所有其他数据库，包括新创建的数据库。例如，考虑一个数据库系统，其中有一个受限模式。您需要为您的
    BI 应用程序创建一个用户。您可以通过运行以下常规命令来开始：
- en: '[PRE96]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'However, this user has to be forbidden from querying any data in the restricted
    database. This is extremely easy to set up using partial revokes:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，此用户必须被禁止查询受限数据库中的任何数据。这可以通过部分撤销非常轻松地设置：
- en: '[PRE98]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Before version 8.0.16 to achieve this you would need to fall back to explicitly
    running `GRANT SELECT` for each individual allowed schema.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 8.0.16 之前，要实现这一点，您需要明确运行 `GRANT SELECT` 以允许每个允许的模式。
- en: 'Just as you can grant all privileges, a special invocation of `REVOKE` exists
    that allows the removal of all privileges from a particular user. Remember that
    you need to have all the privileges you are revoking, and thus this option is
    likely to be used only by an administrative user. The following statement will
    strip a user of their privileges, including the ability to assign any privileges:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以授予所有权限一样，还存在一种特殊的 `REVOKE` 调用，允许从特定用户中删除所有权限。请记住，您需要拥有您正在撤销的所有权限，因此此选项可能仅由管理员用户使用。以下语句将从用户中剥夺其权限，包括分配任何权限的能力：
- en: '[PRE100]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `REVOKE` statement doesn’t under any circumstances remove the user itself.
    You can use the `DROP USER` statement for that, as described earlier in this chapter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`REVOKE` 语句在任何情况下都不会删除用户本身。您可以使用前面在本章中描述的 `DROP USER` 语句来执行此操作。'
- en: Checking Privileges
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查权限
- en: 'An important part of managing privileges is reviewing them—but it would be
    impossible to remember every privilege granted to every user. You can query the
    grant tables to see what users have what privileges, but that’s not always convenient.
    (It is still an option, however, and it can be a good way to find, for example,
    every user that has write privileges on a certain table.) The more straightforward
    option for viewing the privileges granted to a particular user is to use the built-in
    `SHOW GRANTS` command. Let’s take a look at it:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 管理权限的一个重要部分是审查它们，但是要记住授予每个用户的每个权限是不可能的。您可以查询授予权限表以查看用户拥有的权限，但这并不总是方便。 （但这仍然是一种选择，并且可以成为查找例如在某个表上具有写权限的每个用户的良好方法。）查看授予特定用户的权限的更直接选项是使用内置的`SHOW
    GRANTS`命令。 让我们来看看它：
- en: '[PRE102]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In general, you can expect to see every privilege in this output, but there’s
    a special case. When a user has every static privilege granted for a particular
    object, instead of listing each and every one of them, MySQL will output `ALL
    PRIVILEGES` instead. This is not a special privilege itself, but rather a shorthand
    for every possible privilege. Internally, `ALL PRIVILEGES` just translates to
    `Y` set for every privilege in the respective grant table:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，您可以在此输出中看到每个权限，但也有一个特殊情况。 当用户对特定对象授予每个静态权限时，MySQL将输出`ALL PRIVILEGES`而不是列出每个权限。
    这不是特殊的权限本身，而是每个可能权限的简写。 内部，`ALL PRIVILEGES`只是将相应授权表中的每个权限设置为`Y`：
- en: '[PRE104]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can also view the permissions granted to roles using the `SHOW GRANTS`
    command, but we’ll talk about that in more detail in [“Roles”](#USR-SEC-ROLES).
    To review the permissions of the currently authenticated and authorized user,
    you can use any of the following statements, which are synonymous:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SHOW GRANTS`命令，您也可以查看授予角色的权限，但我们将在[“角色”](#USR-SEC-ROLES)中详细讨论此问题。要查看当前已验证和授权用户的权限，可以使用以下任一语句，这些语句是同义的：
- en: '[PRE106]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Whenever you do not remember what a specific privilege means, you can either
    consult the documentation or run the `SHOW PRIVILEGES` command, which will list
    every privilege currently available. That covers both static object privileges
    and dynamic server privileges.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您不记得特定权限的含义时，您可以查阅文档或运行`SHOW PRIVILEGES`命令，该命令将列出当前可用的每个权限。 这涵盖了静态对象权限和动态服务器权限。
- en: 'Sometimes you might need to review privileges related to all accounts or transfer
    those privileges to another system. One option that you have is to use the `mysqldump`
    command provided with MySQL Server for all supported platforms. We will be reviewing
    that command in detail in [Chapter 10](ch10.xhtml#CH10_BACKUP). In short, you’ll
    need to dump all of the grant tables, as otherwise you might miss some of the
    permissions. The safest way to go is to dump all of the data in the `mysql` database:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要审查与所有帐户相关的权限或将这些权限转移到另一个系统。 您拥有的一个选项是使用MySQL Server为所有支持的平台提供的`mysqldump`命令。
    我们将在[第10章](ch10.xhtml#CH10_BACKUP)中详细审查该命令。 简而言之，您需要转储所有授予权限表，否则您可能会错过一些权限。 最安全的方法是转储`mysql`数据库中的所有数据：
- en: '[PRE107]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The output will include all the table definitions, along with a lot of `INSERT`
    statements. This output can be redirected to a file and then used to seed a new
    database. We talk more about that in [Chapter 10](ch10.xhtml#CH10_BACKUP). If
    your server versions don’t match or the target server already has some users and
    privileges stored, it might be best to avoid dropping the existing objects. Add
    the `--no-create-info` option to the `mysqldump` invocation to only receive the
    `INSERT` statements.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将包括所有表定义以及大量的`INSERT`语句。 此输出可以重定向到文件，然后用于种子新数据库。 我们在[第10章](ch10.xhtml#CH10_BACKUP)中详细讨论这个问题。
    如果您的服务器版本不匹配或目标服务器已经存储了一些用户和权限，则最好避免删除现有对象。 在`mysqldump`调用中添加`--no-create-info`选项，只接收`INSERT`语句。
- en: 'By using `mysqldump` you get a portable list of users and privileges, but it’s
    not exactly easily readable. Here is an example of some of the rows in the output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`mysqldump`，您可以获得一个可移植的用户和权限列表，但它并不是易于阅读的。 这里是输出中一些行的示例：
- en: '[PRE109]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Another option to review the privileges would be to write custom queries over
    grant tables, as already mentioned. We won’t give any guidelines on that, as there’s
    no one-size-fits-all solution.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个审查权限的选项是在授权表上编写自定义查询，如前所述。我们不会给出任何指导方针，因为没有一种大小适合所有的解决方案。
- en: 'Yet another way is by running `SHOW GRANTS` for every user in the database.
    By combining that with the `SHOW CREATE USER` statement, you can generate the
    list of privileges, which can also be used to re-create the users and their privileges
    in another database:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是通过为数据库中的每个用户运行`SHOW GRANTS`。结合`SHOW CREATE USER`语句，您可以生成特权列表，这些特权也可以用于在另一个数据库中重新创建用户及其特权：
- en: '[PRE110]"SHOW GRANTS FOR `"[PRE111],` `host``,`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE110]"显示授予`"[PRE111],` `host``,`'
- en: -> ``"`; SHOW CREATE USER `"[PRE112],` `host``,` ``"`;"[PRE113]
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> ``"`; 显示创建用户 `"[PRE112],` `host``,` ``"`;"[PRE113]
- en: '[PRE114]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'As you can imagine, the idea of automating this procedure is not new. In fact,
    there’s a tool in Percona Toolkit—`pt-show-grants`—that does exactly that, and
    more. Unfortunately, the tool can be used only on Linux officially and might not
    work at all on any other platform:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以想象的那样，自动化这个过程的想法并不新鲜。事实上，在Percona Toolkit中有一个工具——`pt-show-grants`——正是如此，而且更多。不幸的是，这个工具只能在Linux上正式使用，并且可能在其他平台上根本无法工作：
- en: '[PRE115]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The GRANT OPTION Privilege
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GRANT OPTION特权
- en: As discussed at the beginning of this chapter, MySQL does not have a concept
    of object ownership. Thus, unlike in some other systems, the fact that some user
    created a table does not automatically mean that the same user can allow another
    user to do anything with that table. To make this slightly less convoluted, let’s
    review an example.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头讨论的那样，MySQL没有对象所有权的概念。因此，与其他一些系统不同，某个用户创建表并不意味着该用户自动可以允许另一个用户对该表执行任何操作。为了让这个过程稍微清晰一些，让我们来看一个例子。
- en: 'Suppose the user `bob` has permissions to create tables in a database called
    `bobs_db`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户`bob`有权限在名为`bobs_db`的数据库中创建表格：
- en: '[PRE117]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'An operator using the `bob` user wants to allow the `john` user to read data
    in the newly created table—but, alas, that is not possible:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用`bob`用户的操作员希望允许`john`用户读取新创建表中的数据——但很遗憾，这是不可能的：
- en: '[PRE119]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Let’s check what privileges `bob` actually has:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下`bob`实际拥有哪些特权：
- en: '[PRE121]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The missing piece here is a privilege that would allow a user to grant other
    users privileges it has been granted. If a DBA wants to allow `bob` to grant other
    users access to tables in the `bobs_db` database, an extra privilege needs to
    be granted. `bob` can’t grant that to itself, so a user with administrative privileges
    is required:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里缺少的一部分是一种特权，允许用户授予其他用户它已被授予的特权。如果DBA想要允许`bob`将其他用户访问`bobs_db`数据库中的表格，就需要授予额外的特权。`bob`不能将其授予自己，因此需要具有管理特权的用户：
- en: '[PRE123]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Note the `WITH GRANT OPTION` addition. That’s exactly the privilege that we
    were looking for. This option will allow the `bob` user to pass its privileges
    to other users. Let’s confirm that by running the `GRANT SELECT` statement as
    `bob` again:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`WITH GRANT OPTION`的添加。这正是我们正在寻找的特权。这个选项将允许`bob`用户将其特权传递给其他用户。让我们再次以`bob`的身份运行`GRANT
    SELECT`语句来确认一下：
- en: '[PRE125]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As expected, the statement was accepted and executed. There are still few clarifications
    to make, however. First, we may want to know how granular the `GRANT OPTION` privilege
    is. That is, what exactly (apart from `SELECT` on `bobs_private_table`) can `bob`
    grant to other users? `SHOW GRANTS` can answer that question for us neatly:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，该语句被接受并执行。然而仍有一些澄清需要做。首先，我们可能想知道`GRANT OPTION`特权的粒度有多高。也就是说，除了在`bobs_private_table`上的`SELECT`，`bob`还能够授予其他用户什么特权？`SHOW
    GRANTS`可以为我们整洁地回答这个问题：
- en: '[PRE127]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: That’s much clearer. We can see that `WITH GRANT OPTION` is applied to privileges
    that `bob` has on a particular database. That’s important to remember. Even though
    we executed `GRANT SELECT ... WITH GRANT OPTION`, `bob` got the ability to grant
    every privilege it has in the `bobs_db` database.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更清晰了。我们可以看到`WITH GRANT OPTION`应用于`bob`在特定数据库上拥有的特权。这一点很重要。尽管我们执行了`GRANT SELECT
    ... WITH GRANT OPTION`，`bob`获得了在`bobs_db`数据库中授予其每个特权的能力。
- en: 'Second, we may want to know if it is possible to revoke just the `GRANT OPTION`
    privilege:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可能想知道是否可能仅撤销`GRANT OPTION`特权：
- en: '[PRE129]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Finally, looking at how `GRANT OPTION` can be revoked, we may want to know
    whether it can be granted alone. The answer is yes, with a caveat that we’ll show.
    Let’s grant the `GRANT OPTION` privilege to `bob` on the `sakila` and `test` databases.
    As you can see from the preceding output, `bob` currently has the `SELECT` privilege
    on `sakila`, but no privileges on the `test` database:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，看一下如何撤销`GRANT OPTION`，我们可能想知道是否可以单独授予它。答案是可以，但有一个我们将会展示的警告。让我们给`bob`在`sakila`和`test`数据库上授予`GRANT
    OPTION`特权。正如您从前面的输出中可以看到的那样，`bob`当前在`sakila`上拥有`SELECT`特权，但在`test`数据库上没有任何特权：
- en: '[PRE133]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Both statements succeeded. It’s pretty clear what exactly `bob` can grant on
    `sakila`: the `SELECT` privilege. However, it’s less clear what happened with
    `test`. Let’s check it out:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 两个语句都成功了。很明显，`bob` 在 `sakila` 上可以授予 `SELECT` 权限。然而，`test` 发生了什么就不那么清楚了。让我们来看看：
- en: '[PRE137]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Okay, so `GRANT OPTION` alone only gives the user a `USAGE` privilege, which
    is the “no privileges” specifier. However, the `GRANT OPTION` privilege can be
    seen as a switch, and when “turned on,” it’ll apply for privileges `bob` is granted
    in the `test` database:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以仅仅单独使用 `GRANT OPTION` 只会给用户一个 `USAGE` 权限，这是“无权限”指定符。但是，`GRANT OPTION` 权限可以看作是一个开关，当“打开”时，它将适用于
    `bob` 在 `test` 数据库中被授予的权限：
- en: '[PRE139]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'So far we’ve been using wildcard privileges, but it is possible to enable `GRANT
    OPTION` for a specific table:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用通配符权限，但是也可以为特定表启用 `GRANT OPTION`：
- en: '[PRE143]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: By now, it should be clear that `GRANT OPTION` is a powerful addition to the
    privileges system. Given that MySQL lacks the concept of ownership, it’s the only
    way to make sure users that aren’t superusers can grant each other permissions.
    However, it is also important, as always, to remember that `GRANT OPTION` applies
    to every permission the user has.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该清楚 `GRANT OPTION` 是权限系统的一个强大补充。考虑到 MySQL 缺乏所有权的概念，这是确保非超级用户可以相互授予权限的唯一方式。然而，像往常一样，记住
    `GRANT OPTION` 适用于用户拥有的每个权限是非常重要的。
- en: Roles
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: '*Roles*, introduced in MySQL 8.0, are collections of privileges. They simplify
    user and privilege management by grouping and “containerizing” necessary permissions.
    You may have a few different DBA users that all need the same permissions. Instead
    of granting privileges individually to each of the users, you can create a role,
    grant permissions to that role, and assign users that role. In doing so, you also
    simplify management in that you won’t need to update each user individually. Should
    your DBAs need their privileges adjusted, you can simply adjust the role.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*角色*，在 MySQL 8.0 中引入，是权限的集合。它们通过将必要的权限分组和“容器化”来简化用户和权限管理。您可能有几个不同的 DBA 用户，他们都需要相同的权限。您可以创建一个角色，向该角色授予权限，并分配给用户该角色，而不是单独为每个用户授予权限。通过这样做，您还简化了管理，因为您不需要单独更新每个用户。如果您的
    DBA 需要调整其权限，您只需调整角色即可。'
- en: Roles are quite similar to users in how they are created, stored, and managed.
    To create a role, you need to execute a `CREATE ROLE [IF NOT EXISTS]` *`role1`*[,
    *`role2`*[, *`role3`* …]] statement. To remove a role, you execute a `DROP ROLE
    [IF EXISTS]` *`role1`*[, *`role2`*[, *`role3`* …]] statement. When you drop a
    role, the assignments of that role to all users is removed. Privileges required
    to create a role are `CREATE ROLE` or `CREATE USER`. To drop a role, the `DROP
    ROLE` or `DROP USER` privilege is required. As with the user management commands,
    if `read_only` is set, an admin privilege is additionally required to create and
    drop roles. Direct modification privileges on grant tables allow a user to modify
    anything, as we’ve also discussed.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 角色在创建、存储和管理方式上与用户非常相似。要创建角色，您需要执行 `CREATE ROLE [IF NOT EXISTS]` *`role1`*[,
    *`role2`*[, *`role3`* …]] 语句。要删除角色，您需要执行 `DROP ROLE [IF EXISTS]` *`role1`*[, *`role2`*[,
    *`role3`* …]] 语句。当您删除角色时，将移除分配给所有用户的该角色的权限。创建角色所需的权限是 `CREATE ROLE` 或 `CREATE
    USER`。删除角色时，需要 `DROP ROLE` 或 `DROP USER` 权限。与用户管理命令一样，如果设置了 `read_only`，还需要管理员权限来创建和删除角色。对授予权限表的直接修改权限允许用户修改任何内容，正如我们之前讨论过的。
- en: 'Just like usernames, role names consist of two parts: the name itself and the
    host specification. When host is not specified, the `%` wildcard is assumed. The
    host specification for a role does not limit its use in any way. The reason it’s
    there is because roles are stored just like users in the `mysql.user` grant table.
    As a consequence, you cannot have the same *`rolename`*@*`host`* as an existing
    user. To have a role with the same name as an existing user, specify a different
    hostname for the role.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 就像用户名一样，角色名由两部分组成：名称本身和主机规范。当未指定主机时，默认为 `%` 通配符。角色的主机规范不会以任何方式限制其使用。它存在的原因是因为角色与用户一样存储在
    `mysql.user` 授权表中。因此，您不能将相同的 *`rolename`*@*`host`* 作为现有用户。要创建与现有用户同名的角色，请为角色指定不同的主机名。
- en: Unlike privileges, roles are not active all the time. When a user is granted
    a role, they’re authorized to use that role but not obliged to do so. In fact,
    a user can have multiple roles and can “enable” one or more of them within the
    same connection.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 与权限不同，角色并非始终处于活动状态。当用户被授予角色时，他们被授权使用该角色，但不一定要这样做。实际上，用户可以拥有多个角色，并且可以在同一连接中“启用”其中一个或多个角色。
- en: One or more roles can be assigned as defaults to a user during the user’s creation
    or at a later time through the `ALTER USER` command. Such roles will be active
    as soon as the user is authenticated.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在用户创建时或稍后通过`ALTER USER`命令向一个或多个角色分配一个或多个角色作为默认值。这些角色将在用户验证后立即生效。
- en: 'Let’s review the commands, settings, and terminology related to role management:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾与角色管理相关的命令、设置和术语：
- en: '`GRANT PRIVILEGE` and `REVOKE PRIVILEGE` commands'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRANT PRIVILEGE`和`REVOKE PRIVILEGE`命令'
- en: We covered these commands in [“Privilege Management Commands”](#USR-PRIV-MGMT).
    For all intents and purposes, roles can be used just the same as users with the
    `GRANT` and `REVOKE` `PRIVILEGE` commands. That is, you can assign all the same
    privileges to a role as you can to a user, and revoke them, too.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“权限管理命令”](#USR-PRIV-MGMT)中介绍了这些命令。在所有目的上，角色可以像用户一样使用`GRANT`和`REVOKE` `PRIVILEGE`命令。也就是说，您可以向角色分配与用户相同的所有特权，并撤销它们。
- en: '`GRANT` *`role`* [, *`role`* …] TO user` command'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRANT` *`role`* [, *`role`* …] TO user` 命令'
- en: 'The basic command related to role management. By running this command, you
    authorize a user to assume a particular role. As mentioned previously, the user
    is not obliged to use the role. Let’s create a couple of roles that will be able
    to operate on the `sakila` database:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 与角色管理相关的基本命令。通过运行此命令，您授权用户承担特定角色。正如前面提到的，用户无需使用该角色。让我们创建一些可以在`sakila`数据库上操作的角色：
- en: '[PRE147]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now you can assign these roles to an arbitrary number of users and change the
    roles only when needed. Here, we allow our `bob` user read-only access to the
    `sakila` database:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以将这些角色分配给任意数量的用户，并仅在需要时更改角色。在这里，我们允许我们的`bob`用户对`sakila`数据库进行只读访问：
- en: '[PRE155]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: You can also grant more than one role in a single statement.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在单个语句中授予多个角色。
- en: '`WITH ADMIN OPTION` modifier'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`WITH ADMIN OPTION`修饰符'
- en: 'When you grant a role to a user, that user is allowed only to activate the
    role, but not to alter it in any way. That user may not grant the role to any
    other user. If you wish to allow both modification of the role and the ability
    to grant it to other users, you can specify `WITH ADMIN OPTION` in the `GRANT
    ROLE` command. The result will be reflected in grant tables and will be visible
    in the `SHOW GRANTS` command’s output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向用户授予角色时，该用户仅被允许激活角色，而不能以任何方式更改它。该用户可能不会将角色授予任何其他用户。如果您希望允许修改角色并有能力将其授予其他用户，则可以在`GRANT
    ROLE`命令中指定`WITH ADMIN OPTION`。其结果将反映在授予表中，并将显示在`SHOW GRANTS`命令的输出中：
- en: '[PRE157]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`SHOW GRANTS` and roles'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHOW GRANTS`和角色'
- en: 'The `SHOW GRANTS` command, which we introduced in [“Checking Privileges”](#USR-PRIVS-CHECK),
    is capable of showing you both assigned roles and the effective permissions with
    one or more roles activated. This is possible by adding an optional `USING` *`role`*
    modifier. Here, we show the effective privileges that `bob` will have as soon
    as the `application_ro` role is activated:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHOW GRANTS`命令，我们在[“检查权限”](#USR-PRIVS-CHECK)中引入了，能够显示激活一个或多个角色的已分配角色和有效权限。这可以通过添加可选的`USING`
    *`role`*修饰符来实现。在这里，我们展示`bob`激活`application_ro`角色后将拥有的有效权限：'
- en: '[PRE159]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '`SET ROLE DEFAULT | NONE | ALL | ALL EXCEPT` *`role`* [, *`role1`* …] | *`role`*
    [, *`role1`* …] command'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET ROLE DEFAULT | NONE | ALL | ALL EXCEPT` *`role`* [, *`role1`* …] | *`role`*
    [, *`role1`* …] 命令'
- en: 'The `SET ROLE` role management command is invoked by an authenticated user
    to assign a particular role or roles to itself. Once the role is set, its permissions
    apply to the user. Let’s continue with our example for `bob`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET ROLE`角色管理命令由经过身份验证的用户调用，用于向自身分配特定角色或角色。一旦设置了角色，其权限将适用于用户。让我们继续使用我们的`bob`示例：'
- en: '[PRE161]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Only when the role is assigned can `bob` use its privileges. Note that you cannot
    use `SET ROLE` to assign yourself a role you aren’t authorized (through `GRANT
    ROLE`) to use.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在分配了角色后，`bob`才能使用其权限。请注意，您不能使用`SET ROLE`为自己分配未经授权（通过`GRANT ROLE`）使用的角色。
- en: There’s no `UNSET ROLE` command, but there are few other extensions to `SET
    ROLE` that allow this behavior. To unset every role, run `SET ROLE NONE`. A user
    can also go back to its default set of roles by executing `SET ROLE DEFAULT`,
    or activate all the roles it has access to by running `SET ROLE ALL`. If you need
    to set a subset of roles which is neither default nor all, you can construct a
    `SET ROLE ALL EXCEPT` *`role`* [, *`role1`* …] statement and explicitly avoid
    setting one or more roles.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `UNSET ROLE` 命令，但是有几个扩展功能可以用于 `SET ROLE` 命令的这种行为。要取消所有角色，请执行 `SET ROLE NONE`。用户也可以通过执行
    `SET ROLE DEFAULT` 返回到其默认角色集，或者通过运行 `SET ROLE ALL` 激活其所有可访问的角色。如果需要设置既非默认角色又非全部角色的子集角色，则可以构造
    `SET ROLE ALL EXCEPT` *`role`* [, *`role1`* …] 语句，并显式避免设置一个或多个角色。
- en: '`DEFAULT ROLE` user option'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT ROLE` 用户选项'
- en: 'When you run `CREATE USER`, or later through `ALTER USER`, you can set one
    or more roles to be the default for a particular user. These roles will be implicitly
    set once the user is authenticated, saving you a `SET ROLE` statement. This is
    convenient, for example, for application users that use a single role or a known
    set of roles most of the time. Let’s set `application_ro` as a default role for
    `bob`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `CREATE USER` 或稍后通过 `ALTER USER`，您可以设置一个或多个角色为特定用户的默认角色。一旦用户认证，这些角色将隐式设置，避免了
    `SET ROLE` 命令。例如，对于大多数时间使用单个角色或已知角色集的应用程序用户，这很方便。让我们将 `application_ro` 设置为 `bob`
    的默认角色：
- en: '[PRE170]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: As soon as `bob@localhost` is logged in, the `CURRENT_ROLE()` function returns
    the desired `application_ro`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `bob@localhost` 登录，`CURRENT_ROLE()` 函数将返回所需的 `application_ro`。
- en: Mandatory roles
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 强制角色
- en: It is possible to grant one or more roles to every user in the database implicitly.
    This is achieved by setting the `mandatory_roles` system parameter (global in
    scope, and dynamic) to a list of roles. Roles granted this way are not activated
    until `SET ROLE` is run. It’s impossible to revoke roles assigned this way, but
    you can grant them explicitly to a user. Roles listed in `mandatory_roles` cannot
    be dropped until removed from the setting.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置 `mandatory_roles` 系统参数（全局范围内，动态变更）为角色列表来隐式地授予数据库中的每个用户一个或多个角色。通过 `mandatory_roles`
    方式授予的角色在运行 `SET ROLE` 命令之前不会激活。无法撤销通过此方式分配的角色，但可以显式授予用户。在 `mandatory_roles` 中列出的角色在从设置中移除之前无法删除。
- en: Automatically activating roles
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 自动激活角色
- en: By default, roles are not active until `SET ROLE` is executed. However, it is
    possible to override that behavior and automatically activate every role available
    to a user upon authentication. This is analogous to running `SET ROLE ALL` upon
    login. This behavior can be enabled or disabled (which is the default) by changing
    the `activate_all_roles_on_login` system parameter (global in scope, and dynamic).
    When `activate_all_roles_on_login` is set to `ON`, both explicitly and implicitly
    (through `mandatory_roles`) granted roles will be activated for every user.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，角色在执行 `SET ROLE` 命令之前不会激活。但是，可以覆盖此行为，在用户认证时自动激活所有可用角色。这类似于登录时执行 `SET ROLE
    ALL` 的行为。可以通过更改 `activate_all_roles_on_login` 系统参数（全局范围内，动态变更）来启用或禁用此行为，默认情况下为禁用。当
    `activate_all_roles_on_login` 设置为 `ON` 时，对每个用户都会激活通过显式或隐式（通过 `mandatory_roles`）授予的角色。
- en: Cascading role permissions
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 级联角色权限
- en: 'Roles can be granted to roles. What happens then is that all permissions of
    the granted role are inherited by the grantee role. Once the grantee role is activated
    by a user, you can think of that user as having activated a granted role. Let’s
    make our example slightly more complex. We will have an `application` role that
    is granted the `application_ro` and `application_rw` roles. The `application`
    role itself has no direct permissions assign. We will assigned the `application`
    role to our `bob` user and examine the result:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 角色可以授予给其他角色。然后，授予角色的所有权限都会被授予接受角色。一旦用户激活了接受角色，您可以将该用户视为已激活授予角色。让我们稍微复杂化我们的例子。我们将有一个
    `application` 角色，该角色被授予 `application_ro` 和 `application_rw` 角色。`application` 角色本身没有直接的权限分配。我们将
    `application` 角色分配给我们的 `bob` 用户并检查结果：
- en: '[PRE176]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'What happens now is that when `bob` activates the `application` role, it will
    have the permissions of both the `rw` and `ro` roles. We can easily verify this.
    Note that `bob` cannot activate any of the roles it was granted indirectly:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `bob` 激活 `application` 角色时，现在的情况是，它将同时具备 `rw` 和 `ro` 角色的权限。我们可以轻松验证这一点。请注意，`bob`
    无法激活任何间接授予其的角色：
- en: '[PRE184]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Roles graph
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 角色图
- en: 'Since roles can be granted to roles, the resulting hierarchy can be pretty
    hard to follow. You can review it by examining the `mysql.role_edges` grant table:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 由于角色可以授予角色，因此生成的层次结构可能非常难以跟踪。您可以通过检查 `mysql.role_edges` 授予表来查看它：
- en: '[PRE189]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'For more complex hierarchies, MySQL conveniently includes a built-in function
    that allows you to generate an XML document in a valid GraphML format. You can
    use any capable software to visualize the output. Here’s the function call, and
    the resulting heavily formatted output (XML doesn’t work well in books):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的层次结构，MySQL 方便地包含了一个内置函数，允许您生成一个有效的 GraphML 格式的 XML 文档。您可以使用任何能力强大的软件来可视化输出。以下是函数调用及其生成的高度格式化输出（XML
    在书籍中的效果不佳）：
- en: '[PRE191]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Ideally, you should use `SELECT ... INTO OUTFILE` (see [“Writing Data into Comma-Delimited
    Files”](ch07.xhtml#WRITECSV)). Then you can use a tool such as the [yEd graph
    editor](https://oreil.ly/VpIYA), which is a powerful, cross-platform, free desktop
    application, to visualize that output. You can see a zoomed-in section of the
    complete graph, concentrating on our `bob` user and surrounding roles, in [Figure 8-1](#fig0801).
    The privilege required to run this function is `ROLE_ADMIN`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该使用 `SELECT ... INTO OUTFILE`（参见[“将数据写入逗号分隔文件”](ch07.xhtml#WRITECSV)）。然后可以使用诸如
    [yEd 图形编辑器](https://oreil.ly/VpIYA) 这样的工具来可视化输出。您可以看到完整图表的放大部分，重点放在我们的 `bob` 用户和周围的角色上，见
    [图 8-1](#fig0801)。运行此功能所需的权限是 `ROLE_ADMIN`。
- en: '![lm2e 0801](Images/lm2e_0801.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 0801](Images/lm2e_0801.png)'
- en: Figure 8-1\. Section of a visualized MySQL roles graph
  id: totrans-498
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. MySQL 角色图可视化部分
- en: Differences between roles and users
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 角色与用户之间的区别
- en: 'Earlier we mentioned that the `CREATE USER` and `DROP USER` privileges allow
    modification of roles. Given that roles are stored along with users in `mysql.user`,
    you might also guess that the regular user management commands will work for roles.
    That’s easy to test and confirm: just run `RENAME USER` or a `DROP USER` on a
    role. Another thing to note is how the `GRANT` and `REVOKE` `PRIVILEGE` commands
    target roles as if they were users.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到 `CREATE USER` 和 `DROP USER` 权限允许修改角色。考虑到角色与用户存储在 `mysql.user` 中，您可能也会猜到常规用户管理命令对角色也适用。这很容易测试和确认：只需在角色上运行
    `RENAME USER` 或 `DROP USER`。另一个需要注意的是，`GRANT` 和 `REVOKE` `PRIVILEGE` 命令如何以角色为目标，就像它们是用户一样。
- en: 'Roles are, at their core, just regular users. In fact, it is possible to use
    `GRANT ROLE` to grant an unlocked user to another unlocked user or to a role:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 角色在本质上只是普通用户。事实上，可以使用 `GRANT ROLE` 将一个解锁的用户授予另一个解锁的用户或角色：
- en: '[PRE193]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Roles are a powerful and flexible addition to MySQL’s user and privilege system.
    As with almost any feature, they can be overused, resulting in unnecessarily complex
    hierarchies that will be hard to follow. However, if you keep things simple, roles
    can save you a lot of work.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是 MySQL 用户和权限系统的强大而灵活的补充。与几乎任何功能一样，它们可能会被滥用，导致不必要复杂的层次结构，难以跟踪。但是，如果保持简单，角色可以节省大量工作。
- en: Changing root’s Password and Insecure Startup
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 root 的密码和不安全的启动
- en: 'Sometimes, it can become necessary to gain access to a MySQL instance without
    knowing any user’s password. Or you could accidentally drop every user in the
    database, effectively locking you out. MySQL provides a workaround in such situations,
    but requires you to be able to change its configuration and restart the instance
    in question. You might think this is shady or dangerous, but actually it’s just
    a protection from one of the simplest problems DBAs run up against: forgotten
    passwords. Just imagine having a production instance running that has no superuser
    access available: that’s obviously not something desirable. Luckily, it’s possible
    to bypass authorization when necessary.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能需要访问 MySQL 实例而不知道任何用户的密码。或者您可能会意外删除数据库中的每个用户，从而有效地将自己锁在外面。在这种情况下，MySQL 提供了一个解决方法，但需要您能够更改其配置并重新启动相应的实例。您可能会认为这很可疑或危险，但实际上只是为了防止数据库管理员经常遇到的最简单的问题之一：忘记密码。想象一下运行着没有超级用户访问权限的生产实例：这显然是不可取的。幸运的是，在必要时可以绕过授权。
- en: 'To perform the authentication and privileges bypass, you have to restart a
    MySQL instance with the `--skip-grant-tables` option specified. Since most installations
    use service scripts to start the instance, you can specify `skip-grant-tables`
    in the *my.cnf* configuration file under the `[mysqld]` section. When `mysqld`
    is started in this mode, it (pretty obviously) skips reading grant tables, which
    has the following effects:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行身份验证和权限绕过操作，您必须使用指定了`--skip-grant-tables`选项重新启动MySQL实例。由于大多数安装使用服务脚本来启动实例，您可以在*my.cnf*配置文件的`[mysqld]`部分指定`skip-grant-tables`。当以这种模式启动`mysqld`时（相当明显地），它将跳过读取授权表，具体效果如下：
- en: No authentication is performed; thus, there’s no need to know any usernames
    or passwords.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不执行身份验证，因此不需要知道任何用户名或密码。
- en: No privileges are loaded, and no permissions are checked.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不加载权限，并且不检查权限。
- en: MySQL will implicitly set `--skip-networking` to prevent any but local access
    while it’s running in the unsafe configuration.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行在不安全配置下的情况下，MySQL将隐式设置`--skip-networking`以阻止除本地访问外的任何访问。
- en: 'When you connect to a MySQL instance running with `--skip-grant-tables`, you’ll
    be authorized as a special user. This user has access to every table and can alter
    any user. Before altering, for example, the `root` user’s lost password, you need
    to run `FLUSH PRIVILEGES`; otherwise, the `ALTER` will fail:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当您连接到使用`--skip-grant-tables`运行的MySQL实例时，您将作为特殊用户授权。此用户可以访问每个表并可以更改任何用户。例如，在更改`root`用户的丢失密码之前，您需要运行`FLUSH
    PRIVILEGES`；否则，`ALTER`将失败：
- en: '[PRE199]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Once the password is reset, it’s recommended to restart the MySQL instance in
    a normal mode.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 重置密码后，建议以正常模式重新启动MySQL实例。
- en: There’s also another way to recover `root`’s password, which is arguably more
    secure. One of the numerous command-line arguments that `mysqld` takes is `--init-file`
    (or `init_file` if used through *my.cnf*). This argument specifies a path to a
    file containing some SQL statements that will be executed during MySQL startup.
    No privilege checks are done at that time, so it’s possible to put an `ALTER USER
    root` statement there. It’s recommended to delete the file and unset the option
    once you’ve regained access or created a new `root` user.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种恢复`root`密码的方法，可能更安全。`mysqld`可以使用的众多命令行参数之一是`--init-file`（或者通过*my.cnf*使用`init_file`）。该参数指定一个包含一些SQL语句的文件路径，在MySQL启动时将执行这些语句。此时不进行特权检查，因此可以在那里放置一个`ALTER
    USER root`语句。建议在恢复访问或创建新的`root`用户后删除该文件并取消该选项。
- en: Warning
  id: totrans-526
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Both of the options presented here can potentially lead to security issues.
    Please use them carefully!
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的两种选项都可能导致安全问题，请谨慎使用！
- en: Some Ideas for Secure Setup
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些安全设置的想法
- en: During the course of this chapter, we outlined a few practices related to user
    and privilege management that can help make your server more secure and safe.
    Here we will provide a short summary of those techniques and our recommendations
    for using them.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节中，我们概述了与用户和权限管理相关的一些实践，这些实践可以帮助使您的服务器更安全和稳定。这里我们将简要总结这些技术以及我们对它们的推荐。
- en: 'From the administrative side, we have the following recommendations:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理方面来看，我们有以下建议：
- en: Avoid overusing the built-in superuser `root@localhost`. Imagine five people
    having access to this user. Even if you have auditing enabled in MySQL, you won’t
    be able to effectively discern which particular person accessed the user and when.
    This user will also be the first one that potential attackers will try to exploit.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免过度使用内置超级用户`root@localhost`。想象一下五个人都能访问这个用户。即使在MySQL启用了审计，您也无法有效地区分哪个特定的人访问了用户以及何时访问的。这个用户也将是潜在攻击者首先尝试利用的用户。
- en: Starting with MySQL 8.0, avoid creating new superusers through the `SUPER` privilege.
    Instead, you can create a special DBA role that has either all dynamic privileges
    assigned individually or just some of them that are frequently required.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从MySQL 8.0开始，避免通过`SUPER`特权创建新的超级用户。相反，可以创建一个特殊的DBA角色，该角色可以分配所有动态权限或仅分配经常需要的部分权限。
- en: Consider organizing privileges for DBA functions into separate roles. For example,
    the `INNODB_REDO_LOG_ARCHIVE` and `INNODB_REDO_LOG_ENABLE` privileges could be
    a part of the `innodb_redo_admin` role. Since roles are not by default automatically
    activated, one would first need to `SET ROLE` explicitly before running potentially
    dangerous administrative commands.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 DBA 功能的特权组织成单独的角色考虑一下。例如，`INNODB_REDO_LOG_ARCHIVE` 和 `INNODB_REDO_LOG_ENABLE`
    权限可以作为 `innodb_redo_admin` 角色的一部分。由于角色默认不会自动激活，运行潜在危险的管理命令之前，需要显式地使用 `SET ROLE`。
- en: 'For regular users, the recommendations are pretty similar:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通用户，推荐基本相似：
- en: Try to minimize the scope of permissions. Always ask if this user needs access
    to every database in the cluster, or even every table in a particular database.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 努力减少权限的范围。始终询问这个用户是否需要访问集群中的每个数据库，甚至是特定数据库中的每张表。
- en: With MySQL 8.0, using roles is a convenient and arguably safer way to group
    and manage privileges. If you have three users that need the same or similar privileges,
    they could share a single role.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MySQL 8.0 中，使用角色是一种方便且可以说更安全的方式来分组和管理权限。如果有三个用户需要相同或类似的权限，他们可以共享一个角色。
- en: Never allow any non-superuser modification permissions on tables in the `mysql`
    database. This is a simple mistake that follows from the first recommendation
    in this list. Granting `UPDATE` on `*.*` will allow the grantee to grant itself
    any permissions.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝不允许任何非超级用户在 `mysql` 数据库中修改表的权限。这是一个简单的错误，源自于本列表中的第一个建议。授予 `UPDATE` 权限于 `*.*`
    将允许授权用户自行授予任何权限。
- en: To make things even more secure and visible, you can consider periodically saving
    all of the privileges currently assigned to users and comparing the result with
    the previously saved sample. You can easily diff the `pt-show-grants` output,
    or even the `mysqldump` output.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使事情更加安全和可见，您可以考虑定期保存当前分配给用户的所有权限，并将结果与先前保存的样本进行比较。您可以轻松地比较 `pt-show-grants`
    的输出，甚至是 `mysqldump` 的输出。
- en: With this chapter done, you should be comfortable administering users and privileges
    in MySQL.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您应该能够轻松管理 MySQL 中的用户和权限。
