- en: Chapter 12\. Monitoring MySQL Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 监控 MySQL 服务器
- en: '*Monitoring* can be defined as observing or checking the quality or progress
    of something over a period of time. Applying that definition to MySQL, what we
    observe and check are the server’s “health” and performance. Quality, then, would
    be maintaining uptime and having performance meet desired levels. So really, monitoring
    is a continuous effort to keep things under observation and control. Usually it’s
    thought of as something optional, which may not be needed unless there’s a particularly
    high load or high stakes. However, just like backups, monitoring benefits almost
    every installation of any database.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*监控*可以定义为在一段时间内观察或检查某物的质量或进展。将这个定义应用于MySQL，我们观察和检查的是服务器的“健康”和性能。因此，质量就是保持正常运行时间并使性能达到期望水平。因此，监控实际上是一个持续的努力，用于保持事物的观察和控制。通常认为监控是可选的，除非存在特别高的负载或高风险。然而，就像备份一样，几乎每个数据库的安装都会受益于监控。'
- en: 'We think that having monitoring in place and understanding the metrics you’re
    getting from it is one of the most important tasks for anyone operating a database
    system—probably just after setting up proper verified backups. Like operating
    a database without backups, failing to monitor your database is dangerous: what
    use is a system that provides unpredictable performance and may be “down” randomly?
    The data may be safe, but it might not be usable.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，建立监控并理解从中获得的指标，对于任何操作数据库系统的人来说都是最重要的任务之一——可能仅次于设置正确的验证备份。就像没有备份的数据库操作一样，未能监控数据库也是危险的：一个提供不可预测性能并可能随机“宕机”的系统有什么用呢？数据可能是安全的，但可能无法使用。
- en: In this chapter, we’ll try to give you a foundation for understanding how to
    monitor MySQL efficiently. This book is not called *High Performance MySQL*, and
    we won’t be going into depth on the specifics of exactly what different metrics
    mean or how to perform a complex analysis of a system. But we will talk about
    few basic metrics that should be checked regularly in every MySQL installation,
    and we’ll discuss important OS-level metrics and tools. We’ll then briefly touch
    on a few widely used methodologies for assessing system performance. After that,
    we will review a few popular open source monitoring solutions, and finally we’ll
    show you how to gather data for investigation and monitoring purposes manually.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将试图为您提供一个有效监控MySQL的基础。这本书不叫*高性能MySQL*，我们不会深入讨论不同指标的具体含义或如何对系统进行复杂分析。但我们将讨论一些应在每个MySQL安装中定期检查的基本指标，并讨论重要的操作系统级别指标和工具。然后我们将简要介绍几种广泛使用的评估系统性能的方法。之后，我们将回顾几种流行的开源监控解决方案，最后我们将展示如何手动收集数据以进行调查和监控目的。
- en: After completing this chapter, you should feel comfortable picking a monitoring
    tool and be able to understand some of the most important metrics it shows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您应该能够自如地选择一个监控工具，并理解它显示的一些最重要的指标。
- en: Operating System Metrics
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统性能指标
- en: 'An operating system is a complex computer program: an interface between applications,
    mainly MySQL in our case, and hardware. In the early days, OSs were simple; now
    they are arguably quite complex, but the idea behind them never really changed.
    An OS tries to hide, or abstract away, the complexity of dealing with the underlying
    hardware. It’s possible to imagine some special-purpose RDBMS running directly
    on hardware, being its own operating system, but realistically you’ll likely never
    see that. Apart from providing a convenient and powerful interface, operating
    systems also expose a lot of performance metrics. You don’t need to know each
    and every one of them, but it’s important to have a basic understanding of how
    to assess the performance of the layer underneath your database.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统是一个复杂的计算机程序：在我们的情况下，主要是应用程序（主要是MySQL）和硬件之间的接口。在早期，操作系统很简单；现在它们可以说相当复杂，但背后的思想从未真正改变过。操作系统试图隐藏或抽象掉处理底层硬件复杂性的细节。可以想象某些特殊用途的RDBMS直接在硬件上运行，成为自己的操作系统，但实际上你可能永远不会看到那样的东西。除了提供方便和强大的接口外，操作系统还公开了许多性能指标。你不需要了解每一个指标，但了解如何评估数据库下层性能的基本知识是很重要的。
- en: Usually, when we talk about operating system performance and metrics, what’s
    really being discussed is hardware performance assessed at the operating system
    level. There’s nothing wrong in saying “OS metrics,” but remember that at the
    end of the day they are mostly showing hardware performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们讨论操作系统的性能和指标时，实际上讨论的是在操作系统级别评估的硬件性能。称之为“操作系统指标”没有问题，但请记住，归根结底它们主要显示的是硬件性能。
- en: 'Let’s take a look at the most important OS metrics that you’ll want to monitor
    and in general have a feel for. We will be covering two major OSs in this section:
    Linux and Windows. Unix-like systems, like macOS and others, will have either
    the same tools as Linux or at least tools showing the same or similar outputs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您将要监视和大致了解的最重要的操作系统指标。在本节中，我们将涵盖两个主要操作系统：Linux和Windows。类Unix系统，如macOS和其他系统，将具有与Linux相同或至少显示相同或类似输出的工具。
- en: CPU
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU
- en: The *central processing unit* (CPU) is the heart of any computer. Nowadays,
    CPUs are so complex they can be considered separate computers within computers.
    Luckily, the basic metrics we think you should understand are universal. In this
    section, we’ll take a look at CPU utilization as reported by Linux and Windows
    and see what contributes to the overall load.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*中央处理单元*（CPU）是任何计算机的核心。如今，CPU非常复杂，可以被看作是计算机内部的独立计算机。幸运的是，我们认为您应该理解的基本指标是普遍适用的。在本节中，我们将看看Linux和Windows报告的CPU利用率，并了解对总体负载的贡献。'
- en: Before we get into measuring CPU utilization, let’s do a quick recap of what
    a CPU is and what characteristics of it are most important for database operators.
    We called it the “heart of a computer,” but that’s oversimplified. In fact, a
    CPU is a device that can do a few basic (and not so basic) operations, on top
    of which we build layers and layers of complexity from machine code up to the
    high-level programming languages running operating systems and ultimately (for
    us) database systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入CPU利用率的测量之前，让我们快速回顾一下CPU的定义及其对数据库操作员最重要的特性。我们称它为“计算机的核心”，但这过于简化。事实上，CPU是一个可以执行几个基本（和不那么基本）操作的设备，在这些操作的基础上，我们从机器代码到高级编程语言再到运行操作系统和最终（对我们来说）数据库系统，逐层堆叠复杂性。
- en: Every operation a computer does is done by a CPU. As [Kevin Closson](https://oreil.ly/8uwkg)
    has said, “Everything is a CPU problem.” When a program is actively being executed—for
    example, MySQL parsing a query—the CPU is doing all the work. When a program is
    waiting for a resource—MySQL waiting for a data read from disk—the CPU is involved
    in “telling” the program when the data is available. Such a list could go on forever.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机执行的每个操作都由CPU完成。正如[Kevin Closson](https://oreil.ly/8uwkg)所说，“一切都是CPU的问题。”当程序正在被执行时——例如，MySQL解析查询——CPU正在处理所有工作。当程序等待资源时——例如，MySQL等待从磁盘读取数据——CPU参与“告诉”程序数据何时可用。这样的列表可以无限延续。
- en: 'Here are a few of the most important metrics of a CPU for a server (or any
    computer in general):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是服务器（或一般计算机）CPU的几个最重要的指标：
- en: CPU frequency
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CPU频率
- en: CPU frequency is the number of times per second a CPU core can “wake up” to
    execute a piece of work. This is basically the “speed” of the CPU. The more the
    merrier, but surprisingly often frequency is not the most important metric.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CPU频率是CPU核心每秒“唤醒”执行工作的次数。这基本上是CPU的“速度”。越多越好，但令人惊讶的是频率并不总是最重要的指标。
- en: Cache memory
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存内存
- en: The size of the cache defines the amount of memory located directly within the
    CPU, making it extremely fast. Again, the more the better, and there are no downsides
    to having more.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存大小定义了直接位于CPU内部的内存量，使其速度极快。同样，越多越好，增加缓存没有任何不利因素。
- en: Number of cores
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数量
- en: 'This is the number of execution units within a single CPU “package” (a physical
    item), and the sum of those units across all CPUs we can fit into a server. Nowadays,
    it’s increasingly difficult to find a CPU that has a single core: most CPUs are
    multicore systems. Some even have “virtual” cores, making the difference between
    the “actual” number of CPUs and the total number of cores even higher.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单个CPU“包裹”（一个物理项目）内执行单元的数量，以及我们可以放入服务器中的所有CPU的总和。如今，越来越难找到只有一个核心的CPU：大多数CPU都是多核系统。有些甚至有“虚拟”核心，使“实际”CPU数量与总核心数之间的差异更大。
- en: Usually, having more cores is a good thing, but there are caveats to that. In
    general, the more cores are available, the more processes can be scheduled by
    the OS to be executed simultaneously. For MySQL, that means more queries executed
    in parallel, and less impact from background operations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，拥有更多的核心是件好事，但其中也有一些注意事项。一般来说，可用的核心越多，操作系统可以调度的进程就越多，可以同时执行。对于 MySQL 来说，这意味着可以并行执行更多查询，并且后台操作对其影响较小。
- en: 'But if half of the available cores are “virtual,” you don’t get the 2x performance
    increase you might expect. Rather, you *may* get a 2x increase, or you may get
    anywhere between a 1x and a 2x increase: not every workload (even within MySQL)
    benefits from virtual cores.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果一半的可用核心是“虚拟”的，你得不到你可能期望的 2 倍性能提升。相反，*可能* 会得到 2 倍增加，或者你可能会在 1 倍到 2 倍之间得到任何增加：不是每个工作负载（即使在
    MySQL 内部）都会从虚拟核心中受益。
- en: Also, having multiple CPUs in different sockets makes interfacing with memory
    (RAM) and other onboard devices (like network cards) more complicated. Usually,
    regular servers are physically laid out in such a way that some CPUs (and their
    cores) will access parts of RAM quicker than other parts—this is the NUMA architecture
    we talked about in the previous chapter. For MySQL, this means that memory allocation
    and memory-related issues can become a pain point. We covered the necessary configuration
    on NUMA systems in [“NUMA architecture”](ch11.xhtml#CH11_conf_NUMA).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在不同插槽中具有多个 CPU 会使得与内存（RAM）和其他板载设备（如网络卡）的接口更加复杂。通常，常规服务器在物理布局上会使一些 CPU（及其核心）能够更快地访问
    RAM 的某些部分，这就是我们在前一章中讨论过的 NUMA 架构。对于 MySQL 来说，这意味着内存分配和与内存相关的问题可能成为痛点。我们在 [“NUMA
    架构”](ch11.xhtml#CH11_conf_NUMA) 中涵盖了 NUMA 系统上的必要配置。
- en: The basic measurement of CPU is its load in percent. When someone tells you
    “CPU 20,” you can be *pretty* sure that they mean “the CPU is 20% busy at the
    moment.” You can never be totally sure, though, so you’d better double-check.
    For example, 20% of one core on a multicore system may be just 1% of the overall
    load. Let’s try to visualize this load.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 的基本度量是其负载百分比。当有人告诉你“CPU 20”，你可以相当确定他们的意思是“CPU 当前忙碌 20%”。但你永远也不能完全确定，所以最好再确认一次。例如，在多核系统上的一个核心的
    20% 可能只是整体负载的 1%。让我们尝试可视化这个负载。
- en: On Linux, the basic command to get the CPU load is `vmstat`. If run without
    arguments, it will output current average values and then exit. If we run it with
    a digit argument (we’ll call it `X` here), it’ll print values every `X` seconds.
    We recommend that you run `vmstat` with a digit argument—for example, `vmstat
    1`—for a few seconds. If you run just `vmstat`, you get averages since boot, which
    are usually misleading. `vmstat 1` will execute forever until interrupted (pressing
    Ctrl+C is the easiest way out).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，获取 CPU 负载的基本命令是 `vmstat`。如果没有参数运行，它将输出当前的平均值然后退出。如果我们用一个数字参数（这里称为
    `X`）运行它，它会每 `X` 秒打印一次值。我们建议你使用一个数字参数运行 `vmstat`，例如 `vmstat 1`，持续几秒钟。如果仅运行 `vmstat`，你会得到自启动以来的平均值，通常这些值会误导。`vmstat
    1` 将持续执行直到中断（按 Ctrl+C 是最简单的方式）。
- en: The `vmstat` program prints information not only on CPU load, but also memory
    and disk-related metrics, as well as advanced system metrics. We will be exploring
    some other sections of the `vmstat` output soon, but here we’ll concentrate on
    CPU and process metrics.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmstat` 程序不仅打印有关 CPU 负载的信息，还包括内存和磁盘相关指标，以及高级系统指标。我们很快将探讨 `vmstat` 输出的其他部分，但这里我们将集中在
    CPU 和进程指标上。'
- en: 'To start, let’s see the `vmstat` output on an idle system. The CPU section
    is truncated; we’ll review it in detail later:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看空闲系统上的 `vmstat` 输出。CPU 部分被截断了；稍后我们将详细审查它：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line of the output after the header is an average since boot, and
    later lines represent current values when printed. The output can be hard to read
    at first, but you get used to it rather quickly. For clarity, in the rest of this
    section we will provide a truncated output with only the information we want,
    in the `procs` and `cpu` sections:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题之后的第一行输出是自启动以来的平均值，后面的行表示打印时的当前值。刚开始时输出可能难以阅读，但你很快就会习惯。为了清晰起见，在本节的其余部分中，我们将提供一个带有我们想要的信息的截断输出，包括
    `procs` 和 `cpu` 部分：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`r` and `b` are process metrics: the number of processes actively running and
    the number of processes blocked (usually waiting for I/O). The other columns represent
    a breakdown of CPU utilization in percentage points (from 0% to 100%, even on
    a multicore system). Together, the values in these columns will always add up
    to 100\. Here’s what the `cpu` columns indicate:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`r` 和 `b` 是进程指标：正在活动运行的进程数和被阻塞的进程数（通常是在等待 I/O）。其他列表示 CPU 利用率的百分比（从 0% 到 100%，即使在多核系统上也是如此）。这些列的值加起来将始终为
    100。以下是 `cpu` 列的含义：'
- en: '`us` (user)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`us`（用户）'
- en: Time spent running user programs (or, the load put on a system by these programs).
    MySQL Server is a user program, as is every piece of code that exists outside
    of the kernel. Importantly, this metric shows time spent purely inside the program
    itself. For example, when MySQL is doing some computation, or parsing a complex
    query, this value will go up. When MySQL wants to perform a disk or network operation,
    this value will also go up, but so will two other values, as you’ll soon see.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行用户程序所花费的时间（或者说这些程序对系统的负载）。MySQL 服务器是一个用户程序，每个存在于内核之外的代码也是如此。重要的是，此指标显示的是纯粹在程序本身内部花费的时间。例如，当
    MySQL 进行某些计算或解析复杂查询时，此值会增加。当 MySQL 想要执行磁盘或网络操作时，此值也会增加，但很快您将看到另外两个值也在增加。
- en: '`sy` (system)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`sy`（系统）'
- en: Time spent running kernel code. Due to the way Linux and other Unix-like systems
    are organized, user programs increase this counter. For example, whenever MySQL
    needs to do a disk read, some work will have to be done by the OS kernel. Time
    spent doing that work will be included in the `sy` value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行内核代码的时间。由于 Linux 和其他类 Unix 系统的组织方式，用户程序会增加此计数器。例如，每当 MySQL 需要进行磁盘读取时，操作系统内核将需要进行一些工作。花费在执行这些工作上的时间将包含在
    `sy` 值中。
- en: '`id` (idle)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`（空闲）'
- en: Time spent doing nothing; idle time. On a perfectly idle server, this metric
    will be 100.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无所事事的时间；空闲时间。在一个完全空闲的服务器上，这个指标将为 100。
- en: '`wa` (I/O wait)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`wa`（I/O 等待）'
- en: Time spent waiting for I/O. This is an important metric for MySQL, as reading
    and writing to various files are a relatively large part of MySQL operation. When
    MySQL does a disk read, some time will be spent in MySQL’s internal functions
    and reflected in `us`. Then some time will be spent inside the kernel and reflected
    in `sy`. Finally, once the kernel has sent a read request to the underlying storage
    device (which could be a local or network device) and is waiting for the response
    and data, all the time spent is accumulated in `wa`. If our program and kernel
    are very slow and all we do is I/O, in theory this metric could be close to 100\.
    In reality, double-digit values are rare and usually indicate some I/O issues.
    We’ll talk about I/O in depth in [“Disk”](#MONITORING_OS_DISK).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 等待时间。这是 MySQL 的一个重要指标，因为读写各种文件占 MySQL 操作的相对较大部分。当 MySQL 进行磁盘读取时，会在 MySQL
    的内部函数中花费一些时间，并反映在 `us` 中。然后会在内核中花费一些时间，并反映在 `sy` 中。最后，一旦内核向底层存储设备（可以是本地设备或网络设备）发送读取请求，并等待响应和数据时，所有花费的时间都累积在
    `wa` 中。如果我们的程序和内核非常慢，而我们所做的一切都是 I/O 操作，理论上这个指标可能接近 100。实际上，两位数的数值很少见，通常表示某些 I/O
    问题。我们将在 [“磁盘”](#MONITORING_OS_DISK) 中深入讨论 I/O。
- en: '`st` (steal)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`st`（窃取）'
- en: 'This is a difficult metric to explain without getting deep into the weeds.
    It’s defined by the MySQL Reference Manual as “time stolen from a virtual machine.”
    You can think of this as the time during which the VM wanted to execute its instructions
    but had to wait for the host server to allocate CPU time. There are multiple reasons
    for this behavior, a couple of which are notable. The first is host overprovisioning:
    running too many large VMs, resulting in a situation where the sum of resources
    the VMs require is more than the host’s capacity. The second is the “noisy neighbor”
    situation, where one or more VMs suffer from a particularly loaded VM.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很难解释的指标，如果不深入细节。MySQL 参考手册将其定义为“从虚拟机中窃取的时间”。您可以将其视为虚拟机希望执行其指令但必须等待主机服务器分配
    CPU 时间的时间段。此行为有多种原因，其中一些值得注意。首先是主机过度配置：运行过多的大型虚拟机，导致虚拟机需要的资源总和超过了主机的容量。其次是“吵闹的邻居”情况，其中一个或多个虚拟机受到特别负载的虚拟机的影响。
- en: Other commands, like `top` (which we’ll show in a bit), will have finer CPU
    load breakdowns. However, the columns just listed are a good starting point and
    cover most of what you need to know about a running system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他命令，如稍后将显示的 `top`，将有更精细的 CPU 负载分解。但是，刚刚列出的列是一个很好的起点，并涵盖了您需要了解的大部分正在运行的系统内容。
- en: 'Now let’s get back to our `vmstat 1` output on an idle system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到在空闲系统上的 `vmstat 1` 输出：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What can we tell from this output? As mentioned previously, the first line is
    an average since boot. On average, there are two processes running (`r`) on this
    system, with 0 blocked (`b`); user CPU utilization is 18% (`us`), system CPU utilization
    is 7% (`sy`), and overall the CPU is 75% idle (`id`). I/O wait (`wa`) and steal
    time (`st`) are 0.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中我们能得出什么结论呢？如前所述，第一行是从启动以来的平均值。平均来看，此系统上有两个进程运行（`r`），0 个被阻塞（`b`）；用户 CPU
    利用率为 18%（`us`），系统 CPU 利用率为 7%（`sy`），总体上 CPU 空闲率为 75%（`id`）。I/O 等待（`wa`）和偷取时间（`st`）均为
    0。
- en: After the first one, each line of the output printed is an average over a sampling
    interval, which is 1 second in our example. This is pretty close to what we could
    call “current” values. As this is an idle machine, we see that overall the values
    are below average. Only one or no processes are running or blocked, user CPU time
    is 2–3%, system CPU time is 1–2%, and the system is idle 96–97% of the time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个输出后，输出的每一行都是采样间隔内的平均值，例如我们的例子中是 1 秒。这与我们所谓的“当前”值相当接近。由于这是一台空闲的机器，我们可以看到整体值低于平均水平。只有一个或没有进程在运行或被阻塞，用户
    CPU 时间为 2–3%，系统 CPU 时间为 1–2%，系统空闲时间为 96–97%。
- en: 'For good measure, let’s look at the `vmstat 1` output on the same system doing
    a CPU-intensive computation in a single process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解，让我们来看看在相同系统上进行 CPU 密集型计算的 `vmstat 1` 输出：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The averages since boot are the same, but we have a single process running in
    every sample, and it drives the user CPU time to 13–15%. The problem with `vmstat`
    is that we can’t learn from its output which process specifically is burning the
    CPU. Of course, if this is a dedicated database server, you can suppose that most
    if not all user CPU time is going to be accounted for by MySQL and its threads,
    but things happen. The other problem is that on machines with a high CPU core
    count, you can mistakenly take low readings in `vmstat` output for a fact—but
    `vmstat` gives a reading from 0% to 100% even on a 256-core machine. If 8 cores
    of such a machine are 100% loaded, the user time shown by `vmstat` will be 3%,
    but in reality some workload may be throttled.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从启动以来的平均值相同，但每个样本中我们都有一个单独的进程运行，并且它将用户 CPU 时间推到了 13–15%。 `vmstat` 的问题在于，我们无法从其输出中了解到底是哪个具体的进程在消耗
    CPU。当然，如果这是专用的数据库服务器，你可以假设大部分，如果不是所有的用户 CPU 时间都由 MySQL 及其线程占用，但事情总是变化的。另一个问题是，在具有高
    CPU 核心数的机器上，你可能会误认为 `vmstat` 输出的低读数是事实，但即使在 256 核心的机器上， `vmstat` 也会显示 0% 到 100%
    的读数。如果这样的机器的 8 个核心都是 100% 负载，那么 `vmstat` 显示的用户时间将是 3%，但实际上某些工作负载可能已被限制。
- en: 'Before we talk about a solution to those problems, let’s talk Windows a little
    bit. A lot of what we’ve said in general about CPU utilization and especially
    about CPUs will translate to Windows, with some notable differences:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这些问题的解决方案之前，让我们稍微谈谈 Windows。总体而言，我们在 CPU 利用率以及特别是 CPU 方面的许多内容可以推广到 Windows，但有一些显著的不同点：
- en: There’s no I/O wait accounting in Windows, as the I/O subsystem is fundamentally
    different. Time spent by threads waiting for I/O is going into the idle counter.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 中没有 I/O 等待的账户，因为 I/O 子系统本质上是不同的。线程等待 I/O 的时间会计入空闲计数器。
- en: The system CPU time counterpart is, roughly, the privileged CPU time.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统 CPU 时间的对应部分大致是特权 CPU 时间。
- en: Steal information is not available.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有可用的偷取信息。
- en: The user and idle counters remain unchanged, so you can base your CPU monitoring
    on user, privileged, and idle CPU time as it is exposed by Windows. There are
    other counters and metrics available, but this should have you covered quite well.
    Getting the current CPU utilization on Windows can be done using many different
    tools. The simplest one, and probably the closest one to `vmstat` in spirit, is
    the good old Task Manager, a staple of looking at Windows performance metrics.
    It’s readily available, it’s simple, and you’ve probably used it before. The Task
    Manager can show you CPU utilization in percentage points broken down by CPU cores
    and also split between user and kernel time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和空闲计数器保持不变，因此你可以基于 Windows 显示的用户、特权和空闲 CPU 时间进行 CPU 监控。还有其他可用的计数器和指标，但这应该已经很好地涵盖了。在
    Windows 上获取当前 CPU 利用率可以使用许多不同的工具。最简单的一个，也可能是最接近 `vmstat` 精神的，是老牌的任务管理器，它是查看 Windows
    性能指标的重要工具。它易于获取，简单易用，你可能以前已经使用过。任务管理器可以显示按 CPU 核心分割的百分比形式的 CPU 利用率，并分别显示用户和内核时间。
- en: '[Figure 12-1](#MON-FIG-TASKMANAGER-CPU-IDLE) shows the Task Manager running
    on an idle system.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](#MON-FIG-TASKMANAGER-CPU-IDLE) 显示了在空闲系统上运行的任务管理器。'
- en: '![lm2e 1201](Images/lm2e_1201.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1201](Images/lm2e_1201.png)'
- en: Figure 12-1\. Task Manager showing an idle CPU
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 任务管理器显示空闲CPU
- en: '[Figure 12-2](#MON-FIG-TASKMANAGER-CPU-BUSY) shows the Task Manager running
    on a busy system.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](#MON-FIG-TASKMANAGER-CPU-BUSY)展示了在繁忙系统上运行的任务管理器。'
- en: '![lm2e 1202](Images/lm2e_1202.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1202](Images/lm2e_1202.png)'
- en: Figure 12-2\. Task Manager showing a busy CPU
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-2\. 任务管理器显示繁忙CPU
- en: 'As we said earlier, `vmstat` has a couple of problems: it doesn’t break down
    load per process or per CPU core. Solving both problems requires running other
    tools. Why not just run them right away? `vmstat` is universal, gives more than
    just CPU readings, and is very concise. It’s a good way to quickly see if there’s
    anything very wrong with a given system. The same goes for the Task Manager, although
    it is actually more capable than `vmstat`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们前面所说，`vmstat`存在一些问题：它不会分解每个进程或每个CPU核心的负载。解决这两个问题需要运行其他工具。为什么不立即运行它们呢？`vmstat`是通用的，提供的不仅仅是CPU读数，而且非常简洁。它是快速查看给定系统是否有严重问题的好方法。任务管理器也是如此，尽管它实际上比`vmstat`更为强大。
- en: On Linux, the next-simplest tool to use after `vmstat` is `top`, another basic
    element in the toolbox of anyone dealing with a Linux server. It expands on the
    basic CPU metrics we have discussed, and adds both per-core load breakdown and
    per-process load accounting. When you execute `top` without any arguments, it
    starts in a terminal UI, or TUI, mode. Press `?` to see the help menu. To display
    the per-core load breakdown, press `1`. [Figure 12-3](#MON-FIG-TOP-TUI) shows
    what the output of `top` looks like.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，在`vmstat`之后使用的下一个最简单的工具是`top`，这是任何处理Linux服务器的人工具箱中的另一个基本元素。它扩展了我们讨论的基本CPU指标，并添加了每个核心负载分解和每个进程负载统计。当您在没有任何参数的情况下执行`top`时，它会以终端UI或TUI模式启动。按下`?`键查看帮助菜单。按`1`显示每个核心的负载分解。[图 12-3](#MON-FIG-TOP-TUI)展示了`top`的输出内容。
- en: You can see here that each process gets its own overall CPU utilization shown
    under the `%CPU` column. For example, `mysqld` is using 104.7% of the overall
    CPU time. Now we can also see how that load is distributed among the many cores
    the server has. In this particular case, one core (`Cpu0`) is slightly more loaded
    than the other one. There are cases when MySQL hits a limit of single-CPU throughput,
    and thus having per-core load breakdown is important. Having a view on how load
    is distributed between processes is important if you suspect some rogue process
    is eating into the server’s capacity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以看到，每个进程都在`%CPU`列下显示其自己的整体CPU利用率。例如，`mysqld`正在使用总CPU时间的104.7%。现在我们还可以看到这个负载是如何在服务器的多个核心之间分布的。在这种特定情况下，一个核心（`Cpu0`）的负载略高于另一个核心。当MySQL达到单CPU吞吐量限制时，单核心负载分解变得重要。如果怀疑某些恶意进程正在耗尽服务器的容量，了解负载在进程之间的分布就显得很重要。
- en: '![lm2e 1203](Images/lm2e_1203.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1203](Images/lm2e_1203.png)'
- en: Figure 12-3\. `top` in TUI mode
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-3\. TUI模式下的`top`
- en: There are many more tools that can show you even more data. We can’t talkin
    detail about all of them, but we’ll name a few. `mpstat` can give very in-depth
    CPU statistics. `pidstat` is a universal tool that provides stats on CPU, memory,
    disk, and network utilization for each individual process running. `atop` is an
    advanced version of `top`. There are more, and everyone has their favorite set
    of tools. We firmly believe that what really matters is not the tools themselves,
    though they help, but an understanding of the core metrics and stats that they
    provide.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他工具可以显示更多数据。我们无法详细讨论所有这些工具，但我们会列出其中一些。`mpstat`可以提供非常深入的CPU统计信息。`pidstat`是一个通用工具，可以为每个正在运行的进程提供CPU、内存、磁盘和网络利用率的统计数据。`atop`是`top`的高级版本。还有其他工具，每个人都有自己喜欢的工具集。我们坚信，真正重要的不是工具本身，尽管它们很有帮助，而是理解它们提供的核心指标和统计数据。
- en: On Windows, the Task Manager program is actually much closer to `top` than it
    is to `vmstat`, although we’ve done just that comparison. The Task Manager’s ability
    to show per-core load and per-process load makes it quite a useful first step
    in any investigation. We recommend diving into the Resource Monitor right away,
    as it provides more details. The easiest way to access it is to click the Open
    Resource Monitor link in the Task Manager.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，任务管理器程序实际上比`vmstat`更接近`top`，尽管我们刚刚做了这个比较。任务管理器显示每个核心负载和每个进程负载的能力使其在任何调查中都是一个非常有用的第一步。我们建议立即深入了解资源监视器，因为它提供了更多细节。访问它的最简单方法是单击任务管理器中的打开资源监视器链接。
- en: '[Figure 12-4](#MON-FIG-RESOURCE-MONITOR-CPU) shows a Resource Monitor window
    with CPU load details.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-4](#MON-FIG-RESOURCE-MONITOR-CPU)显示了一个带有CPU负载详细信息的资源监视器窗口。'
- en: 'The Task Manager and Resource Monitor are not the only tools on Windows capable
    of showing performance metrics. Here are a couple other tools that you may want
    to get comfortable using. They are more advanced, so we won’t go into detail here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 任务管理器和资源监视器并不是Windows上能够显示性能指标的唯一工具。以下是几个其他可能需要你熟悉的高级工具，这里不详细介绍：
- en: Performance Monitor
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 性能监视器
- en: This built-in tool is a GUI for the performance counter subsystem in Windows.
    In short, you can view and plot any (or all) of the various performance metrics
    Windows measures, not only those related to the CPU.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内置工具是Windows中性能计数器子系统的图形用户界面。简而言之，你可以查看和绘制Windows测量的各种性能指标（不仅限于CPU相关的）。
- en: Process Explorer
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 进程资源管理器
- en: This tool is a part of a suite of advanced system utilities called [Windows
    Sysinternals](https://oreil.ly/mKGKF). It’s more powerful and more advanced than
    the other tools listed here and can be useful to learn. Unlike the other tools,
    you’ll have to install Process Explorer separately from its [home page on the
    Sysinternals site](https://oreil.ly/C2tGo).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是名为[Windows Sysinternals](https://oreil.ly/mKGKF)的高级系统实用工具套件的一部分。它比这里列出的其他工具更强大、更先进，对学习很有帮助。与其他工具不同，你需要单独从其[Sysinternals网站上的主页](https://oreil.ly/C2tGo)安装Process
    Explorer。
- en: '![lm2e 1204](Images/lm2e_1204.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1204](Images/lm2e_1204.png)'
- en: Figure 12-4\. Resource Monitor showing CPU load details
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-4\. 资源监视器显示CPU负载详细信息
- en: Disk
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘
- en: The disk or I/O subsystem is crucial for database performance. Although the
    CPU underpins every operation done on any given system, for databases in particular,
    the disk is likely to be the most problematic bottleneck. That’s only logical—after
    all, databases store data on disk and then serve that data from disk. There are
    many layers of caches on top of slow and durable long-term storage, but they cannot
    always be utilized and are not infinitely large. Thus, understanding basic disk
    performance is extremely important when dealing with database systems. The other
    important and frequently underestimated property of any storage system is not
    related to performance at all—it’s the capacity. We’ll start with that.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库性能来说，磁盘或I/O子系统至关重要。尽管CPU支撑着系统上的每个操作，但特别是对于数据库而言，磁盘很可能是最棘手的瓶颈。这是很合乎逻辑的——毕竟，数据库将数据存储在磁盘上，然后从磁盘上提供数据。在慢速和持久的长期存储之上，有许多层缓存，但不能总是利用它们，而且它们也不是无限大的。因此，在处理数据库系统时，理解基本的磁盘性能非常重要。存储系统的另一个重要且经常被低估的属性与性能无关——那就是容量。我们将从这里开始。
- en: Disk capacity and utilization refer to the total amount of data that can be
    stored on a given disk (or a lot of disks together in a storage system) and how
    much of that data is already stored. These are boring but important metrics. While
    it’s not really necessary to monitor the disk capacity, as it’s unlikely to change
    without you noticing, you absolutely must keep an eye on the disk utilization
    and available space.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘容量和利用率是指可以存储在给定磁盘上（或者存储系统中的许多磁盘）的数据总量，以及已经存储了多少数据。这些指标虽然不那么有趣，但却非常重要。尽管监视磁盘容量并不是真正必要的，因为它不太可能在您注意不到的情况下发生变化，但您绝对必须关注磁盘的利用率和可用空间。
- en: Most databases only grow in size over time. MySQL in particular requires a healthy
    amount of available disk space headroom to accommodate table changes, long-running
    transactions, and spikes in write load. When there’s no more disk space available
    for use by a MySQL database instance, it may crash or stop working and is unlikely
    to start working again until some space is freed up or more disk capacity is added.
    Depending on your circumstances, adding more capacity may take from minutes to
    days. That’s something you probably want to plan for ahead of time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库的大小会随时间增长。特别是MySQL需要足够的可用磁盘空间余地来适应表更改、长时间运行的事务和写入负载的突发增加。当MySQL数据库实例没有更多可用的磁盘空间时，可能会崩溃或停止工作，并且不太可能在没有释放空间或增加磁盘容量的情况下重新开始工作。根据您的情况，增加更多容量可能需要从几分钟到几天不等的时间。这是您可能想提前计划的事情。
- en: 'Luckily, monitoring disk space usage is very easy. On Linux, it can be done
    using the simple `df` command. Without arguments, it will show capacity and usage
    in 1 KB blocks for every filesystem. You can add the `-h` argument to get human-readable
    measurements, and specify a mountpoint (or just a path) to limit the check. Here’s
    an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，幸运的是，监控磁盘空间使用非常容易。可以使用简单的`df`命令来完成。不带参数时，它将显示每个文件系统的容量和使用情况（以1 KB块为单位）。你可以添加`-h`参数以获取人类可读的测量结果，并指定一个挂载点（或者只是一个路径）来限制检查。以下是一个示例：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`df`’s output is self-explanatory, and it’s one of the easiest tools to work
    with. We recommend that you try to keep your database mountpoints at 90% capacity
    unless you run multiterabyte systems. In that case, go higher. A trick that you
    can use is to put some large dummy files on the same filesystem as your database.
    Should you start running out of space, you can remove one or more of these files
    to give yourself some more time to react. Instead of relying on this trick, though,
    we recommend that you have some disk space monitoring in place.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`df` 命令的输出是不言自明的，是最容易使用的工具之一。我们建议您尝试将数据库挂载点保持在90%的容量，除非您运行的是多 TB 系统。在这种情况下，可以选择更高的容量。您可以使用的一个技巧是在与数据库相同的文件系统上放置一些大型虚拟文件。如果开始空间不足，可以删除其中一个或多个文件以获得更多时间进行响应。但是，我们建议您建立一些磁盘空间监控来替代依赖这种技巧。'
- en: On Windows, the trusty File Explorer can provide disk space utilization and
    capacity information, as shown in [Figure 12-5](#MON-FIG-FILE-EXPLORER-DISK-SPACE).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，可信的文件资源管理器可以提供磁盘空间利用率和容量信息，如[图 12-5](#MON-FIG-FILE-EXPLORER-DISK-SPACE)所示。
- en: '![lm2e 1205](Images/lm2e_1205.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1205](Images/lm2e_1205.png)'
- en: Figure 12-5\. File Explorer showing available disk space
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-5\. 文件资源管理器显示可用磁盘空间
- en: 'With disk space covered, we will now explore the key performance properties
    of any I/O subsystem:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖了磁盘空间之后，我们现在将探讨任何 I/O 子系统的关键性能特性：
- en: Bandwidth
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽
- en: How many bytes of data can be pushed to (or pulled from) storage per unit of
    time
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每单位时间内可以推送（或从存储中拉取）多少字节的数据
- en: I/O operations per second (IOPS)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒 I/O 操作数（IOPS）
- en: The number of operations a disk (or other storage system) is capable of serving
    per unit of time
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘（或其他存储系统）每单位时间内能够提供的操作数
- en: Latency
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟
- en: How long it takes for a read or a write to be served by the storage system
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 存储系统提供读取或写入服务的时间长短
- en: These three properties are enough to describe any storage system and start forming
    an understanding of whether it’s good, bad, or ugly. As we did in the CPU section,
    we’ll show you a couple of tools to inspect disk performance and use their output
    to explain the specific metrics. We’re again focusing on Linux and Windows; other
    systems will have something similar, so the knowledge is portable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性足以描述任何存储系统，并开始形成对其优劣的理解。就像在 CPU 部分所做的那样，我们将向您展示几个工具来检查磁盘性能，并使用它们的输出来解释具体的度量指标。我们再次关注
    Linux 和 Windows；其他系统将有类似的内容，因此这些知识是通用的。
- en: 'The I/O load analog to `vmstat` on Linux is the `iostat` program. The pattern
    of interaction should be familiar: invoke the command without arguments, and you
    get average values since boot; pass a number as an argument, and you get averages
    for the sampling period. We also prefer running the tool with the `-x` argument,
    which adds a lot of useful details. Unlike `vmstat`, `iostat` gives metrics broken
    down by a block device, similar to the `mpstat` command we mentioned earlier.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，`iostat` 是 `vmstat` 的 I/O 负载模拟。交互模式模式应该很熟悉：调用不带参数的命令，您将得到自启动以来的平均值；传递一个数字作为参数，您将得到采样期间的平均值。我们还建议使用
    `-x` 参数运行该工具，它添加了许多有用的细节。与 `vmstat` 不同，`iostat` 提供按块设备细分的指标，类似于我们之前提到的 `mpstat`
    命令。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`iostat` is usually installed as part of the `sysstat` package. Use `apt` on
    Ubuntu/Debian or `yum` on RHEL-based operating systems to install the package.
    You should be comfortable using these tools after following the instructions in
    [Chapter 1](ch01.xhtml#CH1_INSTALL).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostat` 通常作为 `sysstat` 包的一部分安装。在 Ubuntu/Debian 上使用 `apt`，在基于 RHEL 的操作系统上使用
    `yum` 安装此包。在按照 [第1章](ch01.xhtml#CH1_INSTALL) 中的说明后，您应该能够轻松使用这些工具。'
- en: 'Let’s take a look at an example output. We’ll use a `iostat -dxyt 5` command,
    which translates to: print the device utilization report, display extended statistics,
    omit the first report with averages since boot, add the timestamp for each report,
    and report the average values over every 5-second period some sample output on
    a loaded system:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例输出。我们将使用 `iostat -dxyt 5` 命令，其含义是：打印设备利用报告，显示扩展统计信息，省略从启动以来的第一个带有平均值的报告，为每个报告添加时间戳，并报告每5秒钟的平均值，在负载系统上提供一些示例输出：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There’s quite a lot to unpack here. We won’t cover every column, but we’ll
    highlight the ones that correspond to properties we mentioned before:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容需要理解。我们不会覆盖每一列，但会突出显示与之前提到的属性对应的内容：
- en: Bandwidth
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽
- en: In `iostat` output, the columns `rkB/s` and `wkB/s` correspond to bandwidth
    utilization (read and write, respectively). If you know the characteristics of
    the underlying storage (for example, you may know it promises 200 MiB/s of combined
    read and write bandwidth), you can tell if you’re pushing the limits. Here you
    can see a respectable figure of just over 200,000 KB per second being written
    to the `/dev/sda` device and no reads taking place.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iostat`输出中，列`rkB/s`和`wkB/s`对应于带宽利用率（分别为读和写）。如果您了解底层存储的特性（例如，您可能知道它承诺的读写带宽为200
    MiB/s），您可以确定是否正在推动极限。在这里，您可以看到每秒仅写入超过200,000 KB到`/dev/sda`设备，且没有读操作正在进行。
- en: IOPS
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: IOPS
- en: This metric is represented by the `r/s` and `w/s` columns, giving the number
    of read and write operations per second, respectively. Our example shows 1,599
    write operation per second happening. As expected, no read operations are registered.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此度量由`r/s`和`w/s`列表示，分别给出每秒读和写操作的次数。我们的示例显示每秒发生1,599次写操作。如预期，没有读操作被注册。
- en: Latency
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟
- en: 'Shown in a slightly more complex manner, latency is broken down into four columns
    (or more, in newer `iostat` versions): `await`, `r_await`, `w_await`, and `svctm`.
    For a basic analysis you should be looking at the `await` value, which is the
    average latency for serving any request. `r_await` and `w_await` break `await`
    down by reads and writes. `svctime` is a deprecated metric, which attempts to
    show the pure device latency without any queueing.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以稍微复杂的方式显示，延迟被分解为四列（或者在更新的`iostat`版本中更多列）：`await`、`r_await`、`w_await`和`svctm`。对于基本分析，您应该查看`await`值，这是为任何请求提供服务的平均延迟。`r_await`和`w_await`将`await`按读和写分解。`svctime`是一个被弃用的度量，试图显示纯设备延迟而没有任何排队。
- en: Having these basic metric readings and knowing some basic facts about the storage
    used, it is possible to tell what’s going on. Our example is running on a modern
    consumer-grade NVMe SSD in one of the author’s laptops. While the bandwidth is
    pretty good, each request averages 88 ms, which is a lot. You can also do some
    simple math to get an I/O load pattern from these metrics. For example, if we
    divide bandwidth by IOPS, we get a figure of 128 KB per request. `iostat` does,
    actually, include that metric in the `avgrq-sz` column, which shows the average
    request size in a historical unit of *sectors* (512 bytes). You can go forward
    and measure that 1,599 writes per second can be served only at ~40 ms/request,
    meaning that there’s parallel write load (and also that our device is capable
    of serving parallel requests).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些基本度量读取并了解所使用的存储的一些基本事实，可以知道正在发生什么。我们的示例正在一位作者笔记本电脑上运行现代消费级NVMe SSD。虽然带宽相当不错，但每个请求的平均时间为88毫秒，这相当长。您还可以通过简单的数学运算从这些度量中得到I/O负载模式。例如，如果我们将带宽除以IOPS，我们得到每个请求128
    KB的数字。`iostat`确实包括在`avgrq-sz`列中，它显示了历史单位*扇区*（512字节）的平均请求大小。您可以继续测量每秒1,599次写操作只能在约40毫秒/请求下服务，这意味着存在并行写入负载（同时表明我们的设备能够服务并行请求）。
- en: I/O patterns—size of requests, degree of parallelism, random versus sequential—can
    shift the upper limits of the underlying storage. Most devices will advertise
    maximum bandwidth, maximum IOPS, and minimal latency at specific conditions, but
    these conditions may vary for maximum IOPS and maximum bandwidth measurements,
    as well as for optimal latency. It is rather difficult to definitely answer the
    question of whether metric readings are good or bad. Without knowing anything
    about the underlying storage, one way to look at utilization is to try to assess
    saturation. Saturation, which we’ll touch on in [“The USE Method”](#USE_method_sect),
    is a measure of how overloaded a resource is. This becomes increasingly complicated
    with modern storage, capable of servicing long queues efficiently in parallel,
    but in general, queueing on a storage device is a sign of saturation. In the `iostat`
    output, that is the `avgqu-sz` column (or `aqu-sz` in newer versions of `iostat`),
    and values larger than 1 usually mean that a device is saturated. Our example
    shows a queue of 146 requests, which is a lot, likely telling us that I/O is highly
    utilized and may be a bottleneck.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: I/O模式——请求大小、并行度、随机与顺序——可以改变底层存储的上限。大多数设备将在特定条件下宣传最大带宽、最大IOPS和最小延迟，但这些条件对于最大IOPS和最大带宽的测量以及最佳延迟可能会有所变化。要确定指标读数是好是坏，是相当困难的。在不了解底层存储的情况下，评估饱和度是观察利用率的一种方式。饱和度，我们将在[“USE方法”](#USE_method_sect)中涉及，是资源过载程度的一种度量。对于现代存储，能够高效地并行服务长队列，这变得越来越复杂，但总体上，存储设备上的排队是饱和的迹象。在`iostat`输出中，这是`avgqu-sz`列（或者在较新版本的`iostat`中是`aqu-sz`），数值大于1通常意味着设备饱和。我们的例子显示了一个队列有146个请求，这是很多，可能告诉我们I/O被高度利用并可能成为瓶颈。
- en: 'Unfortunately, as you might’ve noticed, there’s no simple straight measure
    of I/O utilization: there seems to be a caveat for every metric. Measuring storage
    performance is a difficult task!'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，正如您可能注意到的那样，没有关于I/O利用率的简单直接的度量：每个指标似乎都有一个特例。衡量存储性能是一项困难的任务！
- en: The same metrics define storage devices on Linux, Windows, and any other OS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的指标定义了Linux、Windows和任何其他操作系统上的存储设备。
- en: Let’s now take a look at basic Windows tools for assessing I/O performance.
    Their readings should be familiar by now. We recommend using the Resource Monitor,
    which we showed in the CPU section, but this time navigate to the Disk tab. [Figure 12-6](#MON-FIG-RESOURCE-MONITOR-DISK-IO)
    shows that view with MySQL under heavy write load.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下评估I/O性能的基本Windows工具。现在这些读数应该很熟悉了。我们建议使用资源监视器，在CPU部分中展示过，但这次切换到磁盘选项卡。[图12-6](#MON-FIG-RESOURCE-MONITOR-DISK-IO)显示MySQL在高写入负载下的视图。
- en: '![lm2e 1206](Images/lm2e_1206.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1206](Images/lm2e_1206.png)'
- en: Figure 12-6\. Resource Monitor showing IO load details
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-6. 资源监视器显示的I/O负载详细信息
- en: The metrics presented by the Resource Monitor are similar to those of `iostat`.
    You can see bandwidth, latency, and length of the request queue. One metric that’s
    missing is IOPS. To get that information, you’ll need to use the Performance Monitor
    (`perfmon`), but we’ll leave that as an exercise.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 资源监视器显示的指标与`iostat`类似。您可以查看带宽、延迟和请求队列长度。一个缺少的指标是IOPS。要获取这些信息，您需要使用性能监视器(`perfmon`)，但我们将其留作练习。
- en: 'The Resource Monitor actually shows a slightly more detailed view than `iostat`.
    There’s a breakdown of I/O load per process, and a further breakdown of that load
    per file. We don’t know of a single tool on Linux that is capable of showing load
    broken down like that simultaneously. To get the load breakdown per program, you
    can use the `pidstat` tool on Linux, which we mentioned before. Here’s some example
    output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，资源监视器显示的视图比`iostat`稍微详细。有每个进程的I/O负载细分，以及进一步的每个文件的负载细分。我们不知道Linux上有一个能够同时显示这样负载细分的单一工具。要获取每个程序的负载细分，您可以使用Linux上的`pidstat`工具，我们之前提到过。以下是一些示例输出：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Getting a breakdown per file on Linux is quite easily achieved using the BCC
    Toolkit, specifically the `filetop` tool. There are many more tools to explore
    in the toolkit, but most are quite advanced. The tools we’ve shown here should
    be enough to cover basic investigation and monitoring needs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上通过使用BCC工具包特别是`filetop`工具可以很容易地实现对每个文件的详细分解。工具包中还有许多更先进的工具可供探索。我们在这里展示的工具应该足以涵盖基本的调查和监控需求。
- en: Memory
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: Memory, or RAM, is another important resource for any database. Memory offers
    vastly superior performance to disk for reading and writing data, and thus databases
    strive to operate “in memory” as much as possible. Unfortunately, memory is not
    persistent, so eventually every operation must be reflected on the disk. (For
    more on disk performance, refer to the previous section.)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 内存或 RAM 对于任何数据库来说是另一个重要资源。与磁盘相比，内存在读写数据时提供了极大的性能优势，因此数据库尽可能地“在内存中”运行。不幸的是，内存不是持久的，因此最终每个操作都必须在磁盘上反映出来（有关磁盘性能的更多信息，请参阅前一节）。
- en: In contrast to the CPU and disk sections, we won’t actually be talking about
    memory performance. Even though it’s important, it’s also a very advanced and
    deep topic. Instead, we will be focusing on memory utilization. That can also
    get quite complex quite quickly, so we’ll try to stay focused.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CPU 和磁盘部分相比，我们不会详细讨论内存性能。尽管它很重要，但也是一个非常高级和深奥的话题。相反，我们将专注于内存利用。这也可能很快变得非常复杂，所以我们会保持专注。
- en: Let’s start with some basic premises. Every program needs some memory to operate.
    Database systems, including MySQL, usually need a *lot* of memory. When you run
    out of it, applications start having performance issues and may even fail, as
    you’ll see at the end of the section. Monitoring memory utilization therefore
    is crucial to any system’s stability, but especially to a database system’s.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本前提开始。每个程序都需要一些内存来运行。包括 MySQL 在内的数据库系统通常需要*大量*内存。当内存不足时，应用程序开始出现性能问题，甚至可能失败，正如本节末尾所述。因此，监视内存利用对任何系统的稳定性至关重要，特别是对数据库系统而言。
- en: In this case, we’ll actually start with Windows, since on the surface it has
    slightly less convoluted memory accounting mechanism than Linux. To get the overall
    OS memory utilization on Windows, all you need to do is start the Task Manager,
    as described in [“CPU”](#MONITORING_OS_CPU), navigate to the Performance tab,
    and pick Memory. You can see the Task Manager’s memory usage display in [Figure 12-7](#MON-FIG-TASKMANAGER-MEMORY).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们实际上将从 Windows 开始，因为表面上它的内存记账机制比 Linux 略微简单。要获取 Windows 上的整体操作系统内存利用情况，您只需启动任务管理器，如[“CPU”](#MONITORING_OS_CPU)中所述，转到“性能”选项卡，然后选择“内存”。您可以在[图
    12-7](#MON-FIG-TASKMANAGER-MEMORY)中看到任务管理器的内存使用显示。
- en: This machine has 4 GB of memory in total, with 2.4 GB being currently used and
    1.6 GB available, making overall utilization 60%. This is a safe amount, and we
    may even want to allocate more memory to MySQL to minimize “wasted” free memory.
    Some ideas on MySQL’s InnoDB buffer pool sizing can be found in [“Buffer pool
    size”](ch11.xhtml#CH11_conf_IBP).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这台机器总共有 4 GB 内存，当前使用了 2.4 GB，可用 1.6 GB，总利用率为 60%。这是一个安全的量，我们甚至可能希望为 MySQL 分配更多内存，以减少“浪费”的空闲内存。有关
    MySQL InnoDB 缓冲池大小的一些想法可以在[“缓冲池大小”](ch11.xhtml#CH11_conf_IBP)中找到。
- en: 'On Linux, the simplest tool to get memory utilization details is the `free`
    command. We recommend using it with the `-h` argument, which converts all fields
    to a human-readable format. Here’s some sample output on a machine running CentOS
    7:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，获取内存利用详细信息的最简单工具是`free`命令。我们建议使用带有`-h`参数，将所有字段转换为人类可读格式。以下是在运行 CentOS
    7 的机器上的示例输出：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![lm2e 1207](Images/lm2e_1207.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1207](Images/lm2e_1207.png)'
- en: Figure 12-7\. Task Manager showing memory utilization details
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-7\. 任务管理器显示内存利用详情
- en: Now, that’s more data than we saw on Windows. In reality, Windows has most of
    these counters; they are just not as visible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这比我们在 Windows 上看到的数据要多。实际上，Windows 拥有大多数这些计数器；它们只是不那么显眼。
- en: Let’s go through the output. For now, we’ll be covering the Mem row, and we’ll
    talk about Swap later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一下输出。现在，我们将涵盖“Mem”行，稍后再讨论“Swap”。
- en: The two key metrics here are `used` and `available`, which translate to the
    Task Manager’s *In use* and *Available*. A frequent mistake, and one your authors
    used to make, is to look at the `free` metric instead of `available`. That’s not
    correct! Linux (and, in fact, Windows) doesn’t like to keep memory free. After
    all, free memory is a wasted resource. When there’s memory available that’s not
    needed by applications directly, Linux will use that memory to keep a cache of
    data being read and written from and to the disk. We’ll show later that Windows
    does the same, but you cannot see that from the Task Manager. For more on why
    it’s a mistake to focus on the `free` metric, see the site [“Linux ate my ram”](https://oreil.ly/qa88s).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个关键指标是`used`和`available`，它们对应于任务管理器的*正在使用*和*可用*。一个常见的错误，也是作者们过去常犯的错误，是查看`free`指标而不是`available`。这是不正确的！Linux（实际上，包括Windows）不喜欢保持空闲内存。毕竟，空闲内存是一种浪费的资源。当有可用的内存，而应用程序并不直接需要时，Linux将使用该内存来保持正在从磁盘读写的数据的缓存。我们将稍后展示Windows也在做同样的事情，但你无法从任务管理器看到。有关为什么专注于`free`指标是错误的更多信息，请参阅网站[“Linux
    ate my ram”](https://oreil.ly/qa88s)。
- en: 'Let’s further break down the output of this command. The columns are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步分解这个命令的输出。列是：
- en: '`total`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`total`'
- en: Total amount of memory available on the machine
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 机器上可用的总内存量
- en: '`used`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`used`'
- en: Amount of memory currently used by applications
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序当前使用的内存量
- en: '`free`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`'
- en: Actual free memory not used by the OS at all
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上系统未使用的空闲内存
- en: '`shared`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared`'
- en: A special type of memory that needs to be specifically requested and allocated
    and that multiple processes can access together; because it’s not used by MySQL,
    we’re skipping the details here
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的内存，需要专门请求和分配，多个进程可以共同访问；因为MySQL没有使用它，我们在这里跳过了细节
- en: '`buff/cache`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`buff/cache`'
- en: Amount of memory the OS is currently using as a cache to improve I/O
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统当前正在使用的内存作为缓存以提高I/O的数量
- en: '`available`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`available`'
- en: Amount of memory that applications could use if they needed it; usually the
    sum of `free` and `buff/cache`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要使用的内存量；通常是`free`和`buff/cache`的总和
- en: In general, for basic but robust monitoring, you only need to look at the `total`,
    `used`, and `available` amounts. Linux should be capable of handling the cached
    memory on its own. We’re deliberately not covering the page cache here, as that’s
    an advanced topic. By default, MySQL on Linux will utilize the page cache, so
    you should size your instance to accommodate for that. An often recommended change,
    however, is to tell MySQL to avoid the page cache (look for the documentation
    on `innodb_​​flush_method`), which will allow more memory to be used by MySQL
    itself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，对于基本但健壮的监控，你只需要关注`total`、`used`和`available`这几个量。Linux应该能够自行处理缓存的内存。在这里，我们故意不涉及页面缓存，因为那是一个高级主题。默认情况下，Linux上的MySQL会利用页面缓存，因此你应该调整实例大小以适应这一点。然而，一个经常推荐的改变是告诉MySQL避免页面缓存（查看`innodb_flush_method`的文档），这将允许MySQL本身使用更多的内存。
- en: We’ve mentioned that Windows has mostly the same metrics; they’re just hidden.
    To see that, open the Resource Monitor and navigate to the Memory tab. [Figure 12-8](#MON-FIG-RESOURCE-MONITOR-MEMORY)
    shows the contents of this tab.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到Windows基本上具有相同的指标；它们只是被隐藏起来了。要查看这些，请打开资源监视器并导航到内存选项卡。[图 12-8](#MON-FIG-RESOURCE-MONITOR-MEMORY)显示了此选项卡的内容。
- en: You’ll immediately notice that the amount of free memory is just 52 MB, and
    there’s a hefty chunk of standby memory, with a little bit of modified memory.
    The Cached value in the list below is the sum of the modified and standby amounts.
    When the screenshot was taken, 1,593 MB of memory was being used by cache, with
    33 MB of that being dirty (or modified). Windows, like Linux, caches filesystem
    pages in an attempt to minimize and smooth I/O and utilize the memory to its fullest
    capacity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您将立即注意到，空闲内存量仅为52 MB，并且有相当大的一部分是待机内存，还有一小部分是修改过的内存。下面列表中的Cached值是修改和待机数量的总和。当截图被拍摄时，缓存中使用了1,593
    MB的内存，其中33 MB是脏（或修改过的）。像Linux一样，Windows会缓存文件系统页面，以尽量减少和平滑I/O，并充分利用内存的容量。
- en: Another thing you can see is a breakdown of memory utilization per process,
    with `mysqld.exe` holding just under 500 MB of memory. On Linux, a similar output
    can be obtained with the `top` command, which we first used in [“CPU”](#MONITORING_OS_CPU).
    Once `top` is running, press Shift+M to sort the output by memory usage and get
    human-readable figures. `top` output showing memory usage details is in [Figure 12-9](#MON-FIG-TOP-MEMORY).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件你可以看到的事情是，按进程分解的内存利用情况，其中 `mysqld.exe` 占用的内存略低于500 MB。在 Linux 上，可以通过 `top`
    命令获得类似的输出，我们首先在[“CPU”](#MONITORING_OS_CPU)中使用了它。运行 `top` 后，按 Shift+M 可以按内存使用排序输出，并获得人类可读的数字。显示内存使用详细信息的
    `top` 输出在[图12-9](#MON-FIG-TOP-MEMORY)中。
- en: '![lm2e 1208](Images/lm2e_1208.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1208](Images/lm2e_1208.png)'
- en: Figure 12-8\. Resource Monitor showing memory utilization details
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-8\. 资源监视器显示内存利用详细信息
- en: '![lm2e 1209](Images/lm2e_1209.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1209](Images/lm2e_1209.png)'
- en: Figure 12-9\. `top` showing memory utilization details
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-9\. `top` 显示内存利用详细信息
- en: On this system the output is not very interesting, but you can quickly see that
    it’s MySQL that consumes the most memory with its `mysqld` process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统上，输出并不是非常有趣，但你可以迅速看到，MySQL 通过它的 `mysqld` 进程消耗了最多的内存。
- en: Before finishing this section, we want to talk about what happens when you run
    out of memory. Before that, though, let’s discuss swapping, or paging. We should
    mention here that most modern OSs implement memory management in such a way that
    individual applications each have their own view of the system’s memory (hence
    you may see application memory being called *virtual* memory) and that the sum
    total of the virtual memory that applications can use exceeds the total actual
    memory capacity of the system. Discussion of the former point is better suited
    for a university course on operating system design, but the latter point is very
    important when running database systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，我们想讨论的是当内存耗尽时会发生什么。但在此之前，让我们先讨论交换或分页。我们应该在这里提到，大多数现代操作系统以一种方式实现内存管理，使得每个应用程序都有自己对系统内存的视图（因此你可能会看到应用程序内存被称为*虚拟*内存），而应用程序可以使用的虚拟内存总和超过了系统实际内存容量。关于前一点的讨论更适合于操作系统设计的大学课程，但后一点在运行数据库系统时非常重要。
- en: The implications of this design are important, because an OS can’t just magically
    extend the capacity of the system’s memory. In fact, what happens is the OS uses
    disk storage to extend the amount of memory, and as we’ve mentioned, RAM is usually
    far more performant than even the fastest disk. Thus, as you can imagine, there’s
    a price to pay for this memory extension. *Paging* can occur in a few different
    ways and for different reasons. Most important for MySQL is the type of paging
    called *swapping*—writing out parts of memory into a dedicated place on disk.
    On Linux, that place can be a separate partition, or a file. On Windows, there’s
    a special file called *pagefile.sys* that has mostly the same use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的影响很重要，因为操作系统无法奇迹般地扩展系统内存容量。事实上，操作系统使用磁盘存储来扩展内存量，正如我们提到的，RAM 通常比最快的磁盘更有效率。因此，你可以想象，这种内存扩展是有代价的。*页面调度*可以以几种不同的方式发生，出于不同的原因。对
    MySQL 来说，最重要的是一种称为*交换*的页面调度类型——将内存的部分写入到磁盘上的一个专用位置。在 Linux 上，这个位置可以是一个单独的分区或文件。在
    Windows 上，有一个名为 *pagefile.sys* 的特殊文件，功能大致相同。
- en: Swapping is not bad per se, but it’s problematic for MySQL. The problem is that
    our database thinks it’s reading something from memory, whereas in reality the
    OS has paged out some of that data into the swap file and will actually read it
    from disk. MySQL cannot predict when this situation will happen and can do nothing
    to prevent it or optimize the access. For the end user, this can mean a sudden
    unexplained drop in query response times. Having *some* swap space, though, is
    an important protective measure, as we’ll show.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Swapping 本身并不是坏事，但对 MySQL 来说却是个问题。问题在于我们的数据库认为它正在从内存中读取某些数据，而实际上操作系统已经将部分数据换出到交换文件，并将从磁盘读取。MySQL
    无法预测这种情况何时发生，也无法防止或优化访问。对于最终用户来说，这可能意味着查询响应时间突然下降而无法解释。但是，有*一些*交换空间是一项重要的保护措施，我们将会展示。
- en: 'Let’s move on to answer the question of what really happens when you run out
    of memory. In short: nothing good. There are only a couple of general outcomes
    for MySQL when the system is running out of memory, so let’s talk through them:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续回答当内存耗尽时到底会发生什么这个问题。简而言之：情况不妙。当系统即将耗尽内存时，MySQL 只有几种一般的结果，所以让我们逐一讨论它们：
- en: MySQL requests more memory from the OS, but there’s none available—everything
    that could be paged out is not in memory, and the swap file is absent or already
    full. Usually, this situation results in a crash. That’s a really bad outcome.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL从操作系统请求更多内存，但没有可用的内存——所有可以页面出的内容都不在内存中，并且交换文件不存在或已满。通常情况下，这种情况会导致崩溃。这是一个非常糟糕的结果。
- en: On Linux, a variation of the preceding point is that the OS detects a situation
    where the system is close to running out of memory and forcefully terminates—in
    other words, kills one or more processes. Usually, the processes terminated will
    be the ones holding the most memory, and usually on a database server, MySQL will
    be the top memory consumer. This usually happens before the situation explained
    in the previous point.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上，前面一点的变化是，操作系统检测到系统接近耗尽内存并强制终止——换句话说，终止一个或多个进程。通常终止的进程将是占用最多内存的进程，在数据库服务器上，通常是MySQL是最大的内存消耗者。这通常发生在前一点解释的情况之前。
- en: MySQL, or some other program, fills up memory to a point where the OS has to
    start swapping. This assumes the swap space (or pagefile in Windows) is set up.
    As explained a few paragraphs back, MySQL’s performance will degrade unexpectedly
    and unpredictably when its memory is swapped out. This arguably is a better outcome
    than just a crash or MySQL being terminated, but nevertheless it’s something to
    avoid.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL或其他某个程序，将内存填充到操作系统必须开始交换的程度。这假设已设置交换空间（或Windows中的页面文件）。正如前面几段解释的那样，当MySQL的内存被交换出去时，其性能将意外地和不可预测地下降。这可以说是比仅仅崩溃或终止MySQL更好的结果，但仍然是需要避免的问题。
- en: So, MySQL will either get slower, crash, or get killed, as simple as that. You
    now should see clearly why monitoring available and used memory is *very* important.
    We also recommend leaving some memory headroom on your servers and having a swap/pagefile
    set up. For some advice on Linux swap setup, see [“Operating system best practices”](ch11.xhtml#opbest).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MySQL将变慢、崩溃或被终止，就是这么简单。现在你应该清楚地看到为什么监控可用和使用的内存非常重要了。我们也建议在服务器上留出一些内存余量，并设置好交换/页面文件。有关Linux交换设置的建议，请参阅[“操作系统最佳实践”](ch11.xhtml#opbest)。
- en: Network
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: 'Of all the OS resources, the network is probably the one most frequently blamed
    for random unexplained issues. There’s a good reason for that: monitoring the
    network is difficult. Understanding issues with the network sometimes requires
    a detailed analysis of the whole network stream. It’s a peculiar resource because,
    unlike CPU, disk, and memory, it is not contained within a single server. At the
    very least, you need two machines communicating with each other for “network”
    to even be a factor. Of course, there are local connections, but they are usually
    stable. And granted, disk storage may be shared, and CPU and memory in case of
    virtual machines can be shared, too, but networking is *always* about multiple
    machines.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有操作系统资源中，网络可能是被随机未解释问题指责最多的一个资源。这其中有很好的原因：监控网络是困难的。理解网络问题有时需要对整个网络流进行详细分析。这是一个特殊的资源，因为与CPU、磁盘和内存不同，它不局限于单个服务器。至少，你需要两台相互通信的机器才能谈论“网络”。当然，也有本地连接，但它们通常是稳定的。而且，可以共享磁盘存储，虚拟机的CPU和内存也可以共享，但网络总是涉及到多台机器。
- en: Since this chapter is about monitoring, we’re not going to cover connectivity
    issues here—yet a surprising number of issues with networking boil down to the
    simple problem of one computer not being able to talk to another. Do not take
    connectivity for granted. Network topologies are usually complex, with each packet
    following a complicated route through multiple machines. In cloud environments,
    the routes can be even more complex and less obvious. If you think you have some
    network issues, it’s wise to check that connections can be established at all.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章是关于监控，我们在这里不会涵盖连接性问题——然而，令人惊讶的是，许多网络问题归结为一个简单的问题，即一台计算机无法与另一台计算机通信。不要认为连接性是理所当然的。网络拓扑通常复杂，每个数据包都会经过多台计算机的复杂路径。在云环境中，路由可能更加复杂且不明显。如果您认为存在某些网络问题，检查能否建立连接是明智的。
- en: 'We’ll be touching on the following properties of any network:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涉及任何网络的以下属性：
- en: Bandwidth and its utilization (throughput)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 带宽及其利用率（吞吐量）
- en: This is similar to the same concept defined in [“Disk”](#MONITORING_OS_DISK).
    Every network connection has a maximum bandwidth capacity, usually expressed as
    some unit of volume of data per second. Internet connections usually use Mbps
    or megabits per second, but MBps, or megabytes per second, can also be used. Network
    links and equipment put a hard cap on maximum bandwidth. For example, currently,
    common household network equipment rarely exceeds 1 Gbps bandwidth. More advanced
    data center equipment regularly supports 10 Gbps. Special equipment exists that
    can drive bandwidth to hundreds of Gbps, but such connections are usually unrouted
    direct connections between two servers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于在[“Disk”](#MONITORING_OS_DISK)中定义的相同概念。每个网络连接都有一个最大带宽容量，通常以每秒数据量的某个单位表达。互联网连接通常使用Mbps或兆位每秒，但也可以使用MBps或兆字节每秒。网络链路和设备对最大带宽设置了硬限制。例如，目前，普通家用网络设备很少超过1
    Gbps带宽。更先进的数据中心设备通常支持10 Gbps。还有专门的设备可以将带宽提升到数百Gbps，但这类连接通常是两台服务器之间直连的未路由连接。
- en: Errors—their number and sources
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 错误—它们的数量和来源
- en: Network errors are unavoidable. In fact, the Transmission Control Protocol (TCP),
    a backbone of the internet and a protocol used by MySQL, is built around the premise
    that packets will be lost. You’ll undoubtedly see errors from time to time, but
    having a high rate of errors will cause connections to be slow, as communicating
    parties will need to resend packets over and over.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络错误是不可避免的。事实上，传输控制协议（TCP），作为互联网的支柱和MySQL使用的协议，建立在数据包丢失的前提下。你肯定会时不时地看到错误，但是如果错误率高，连接会变慢，因为通信双方需要反复重发数据包。
- en: Continuing the analogy with the disk, we could also include latency and number
    of packets sent and received (loosely resembling IOPS). However, packet transmission
    latency can be measured only by the application that’s doing the actual transmission.
    The OS can’t measure and show some average latency for a network. And the number
    of packets is usually redundant, as it follows the bandwidth and throughput figures.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 继续与磁盘的类比，我们还可以包括延迟和发送接收的数据包数量（类似于IOPS）。但是，数据包传输延迟只能由实际传输数据的应用程序进行测量。操作系统不能测量和显示网络的某种平均延迟。而数据包数量通常是多余的，因为它跟随带宽和吞吐量的数字。
- en: One particular metric that is useful to add when looking at networks is the
    number of *retransmitted* packets. Retransmission happens when a packet is lost
    or damaged. It is not an error, but is usually a result of some issues with the
    connection. Just like running out of bandwidth, an increased number of retransmissions
    will lead to choppy network performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 查看网络时，有一个特别有用的度量指标是*重传*数据包的数量。当数据包丢失或损坏时会发生重传。这不是一个错误，但通常是由连接问题引起的。与带宽耗尽类似，重传数据包数量的增加会导致网络性能不稳定。
- en: 'On Linux, we can start by looking at the network interface statistics. The
    easiest way to do this is to run the `ifconfig` command. Its output by default
    will include every network interface on a particular host. Since we know in this
    case all load comes through `eth1`, we can show only stats for that:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们可以从查看网络接口统计开始。最简单的方法是运行`ifconfig`命令。它的默认输出将包括特定主机上的每个网络接口。由于我们知道在这种情况下所有的负载都通过`eth1`，我们可以只显示该接口的统计信息：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can immediately see that the network is pretty healthy just by the fact
    that there are no errors receiving (RX) or sending (TX) packets. The RX and TX
    total data stats (701.0 MiB and 16.7 GiB, respectively) will grow each time you
    run `ifconfig`, so you can easily measure bandwidth utilization by running it
    over time. That’s not terribly convenient, and there are programs that show transmission
    rates in real time, but none of those ships by default in common Linux distributions.
    To see a history of the transmission rate and errors, you can use the `sar -n
    DEV` or `sar -n EDEV` command, respectively (`sar` is a part of the `sysstat`
    package we mentioned when talking about `iostat`):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到网络的状态相当良好，因为接收（RX）和发送（TX）数据包都没有错误。RX和TX的总数据统计（分别为701.0 MiB和16.7 GiB）每次运行`ifconfig`时都会增长，因此你可以通过随时间运行它来轻松测量带宽利用率。这并不是非常方便，而且常见的Linux发行版默认没有程序实时显示传输速率。要查看传输速率和错误的历史记录，可以使用`sar
    -n DEV`或`sar -n EDEV`命令，分别（`sar`是我们在谈论`iostat`时提到的`sysstat`软件包的一部分）：
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we see that in our example interface `eth1` is quite loaded, but there
    are no errors being reported. If we stay within bandwidth limits, network performance
    should be normal.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到，在我们的示例接口中 `eth1` 负载相当高，但没有报告错误。如果我们保持在带宽限制内，网络性能应该是正常的。
- en: 'To get a full detailed view of the various errors and issues that have happened
    within the network, you can use the `netstat` command. With the `-s` flag, it
    will report a lot of counters. To keep things basic, we will show just the `Tcp`
    section of the output, with a number of retransmits. For a more detailed overview,
    check the `TcpExt` section of the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取网络内发生的各种错误和问题的详细视图，可以使用 `netstat` 命令。使用 `-s` 标志，它会报告大量计数器。为了简化，我们只显示输出的 `Tcp`
    部分，其中包括一些重传。要获取更详细的概述，请查看输出的 `TcpExt` 部分：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Considering the sheer number of segments sent out, the retransmission rate is
    excellent. This network seems to be fine.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到发送的片段数量庞大，重传率非常优秀。这个网络看起来很好。
- en: On Windows, we again resort to checking the Resource Monitor, which provides
    most of the metrics we want, and more. [Figure 12-10](#MON-FIG-RESOURCE-MONITOR-NETWORK)
    shows network-related views the Resource Monitor has to offer on a host running
    a synthetic load against MySQL.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们再次借助资源监视器来检查，它提供了我们需要的大部分指标，甚至更多。[图 12-10](#MON-FIG-RESOURCE-MONITOR-NETWORK)
    展示了资源监视器在运行针对 MySQL 的合成负载的主机上提供的与网络相关的视图。
- en: '![lm2e 1210](Images/lm2e_1210.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1210](Images/lm2e_1210.png)'
- en: Figure 12-10\. Resource Monitor showing network utilization details
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-10\. 资源监视器显示网络利用率详细信息
- en: 'To get a reading on the number of errors on Windows, you can use the `netstat`
    command. Note that even though it has the same name as the Linux tool we used
    previously, they are slightly different. In this case, we have no errors:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Windows 上错误数量的读数，可以使用 `netstat` 命令。请注意，即使它与我们先前使用的 Linux 工具同名，它们也略有不同。在这种情况下，我们没有错误：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `-s` modifier for `netstat` exists on Windows, too. Again, we’re only showing
    a part of the output here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s` 修改符对于 `netstat` 在 Windows 上也是存在的。在这里我们只展示了部分输出：'
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Judging by the metrics we highlighted for monitoring—bandwidth utilization and
    errors—this system’s network is operating perfectly fine. We understand this is
    barely scratching the surface when it comes to the complexity of networking. However,
    this minimal set of tools can help you out immensely in understanding whether
    you should be blaming your network at all.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们强调的用于监控的指标——带宽利用率和错误——这个系统的网络运行完全正常。我们理解这仅仅触及了网络复杂性的表面。然而，这套最基本的工具可以极大地帮助你理解是否应该归咎于你的网络。
- en: 'That finishes a pretty lengthy overview of OS monitoring basics. We could probably
    have kept it shorter, and you may ask why we put all this in a book about MySQL.
    The answer is pretty simple: because it is important. Any program interacts with
    an OS and requires some of the system’s resources. MySQL, by nature, is usually
    going to be a very demanding program, which you expect to be performing well.
    For that, however, you need to make sure that you have the necessary resources
    and you’re not running out of a performance capacity for disk, CPU, or network,
    or just out of capacity for disk and memory. Sometimes, an issue with system resources
    caused by MySQL can also lead you to uncover issues within MySQL itself. For example,
    a badly written query may put a lot of load on the CPU and disk while causing
    a spike in memory usage. The next section shows some basic ways to monitor and
    diagnose a running MySQL server.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了对操作系统监控基础知识的相当长的概述。我们可能本可以更简洁一些，你可能会问为什么我们在一本关于 MySQL 的书中加入了这么多内容。答案很简单：因为这很重要。任何程序都与操作系统进行交互，并需要系统的一些资源。MySQL
    通常是一个非常要求性能良好的程序。然而，为此，你需要确保你拥有必要的资源，并且在磁盘、CPU 或网络的性能容量上不会耗尽，或者仅在磁盘和内存容量上不足。有时，由
    MySQL 导致的系统资源问题也可能导致你在 MySQL 本身内部发现问题。例如，一个编写不良的查询可能会在引起内存使用增加的同时，对 CPU 和磁盘造成大量负载。接下来的部分将展示一些监视和诊断运行中
    MySQL 服务器的基本方法。
- en: MySQL Server Observability
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 服务器可观察性
- en: Monitoring MySQL is simultaneously easy and difficult. It’s easy, because MySQL
    exposes almost 500 status variables, which allow you to see almost exactly what
    is going on inside your database. In addition to that, InnoDB has its own diagnostic
    output. Monitoring is hard, though, because it may be tricky to make sense of
    the data you have.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 监控MySQL既简单又困难。简单是因为MySQL公开了将近500个状态变量，允许你几乎完全了解数据库内部的运行情况。此外，InnoDB还有其自己的诊断输出。然而，监控是困难的，因为理解你所拥有的数据可能会有些棘手。
- en: In this section, we’re going to explain the basics of MySQL monitoring, starting
    with going over what the status variables are and how to get them, and moving
    on to InnoDB’s diagnostics. Once that’s covered, we’ll show a few basic recipes
    we believe should be a part of every MySQL database monitoring suite. With these
    recipes and what you learned about OS monitoring in the previous section, you
    should be able to understand what’s going on with your system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释MySQL监控的基础知识，首先介绍状态变量是什么，以及如何获取它们，然后进入InnoDB的诊断。一旦涵盖了这些内容，我们将展示一些基本的配方，我们认为应该成为每个MySQL数据库监控套件的一部分。有了这些配方和你在上一节中学到的操作系统监控知识，你应该能够理解系统的运行情况。
- en: Status Variables
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态变量
- en: 'We’ll start with MySQL’s *server status variables*. These variables, unlike
    configuration options, are read-only, and they show you information about the
    current state of the MySQL server. They vary in nature: most of them are either
    ever-increasing counters, or gauges with values moving up and down. Some, though,
    are static text fields, which are helpful to understand the current server configuration.
    All status variables can be accessed at the global server level and at the current
    session level. But not every variable makes sense on a session level, and some
    will show the same values on both levels.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从MySQL的*服务器状态变量*开始。这些变量与配置选项不同，是只读的，并且显示MySQL服务器当前状态的信息。它们的性质各不相同：大多数是递增计数器，或者值上下波动的仪表。但也有一些是静态文本字段，有助于理解当前服务器配置。所有状态变量都可以在全局服务器级别和当前会话级别访问。但并非每个变量在会话级别都有意义，有些变量在两个级别上显示相同的值。
- en: '`SHOW STATUS` is used to get the current status variable values. It has two
    optional modifiers, `GLOBAL` and `SESSION`, and defaults to `SESSION`. You can
    also specify the name of a variable, or a pattern, but that’s not mandatory. The
    command in the following example shows all the status variable values for the
    current session:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHOW STATUS`用于获取当前状态变量的值。它有两个可选修饰符，`GLOBAL`和`SESSION`，默认为`SESSION`。你也可以指定变量的名称或模式，但这不是必须的。以下示例命令显示当前会话的所有状态变量值：'
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Scrolling through hundreds of rows of output is suboptimal, so let’s instead
    use a wildcard to limit the number of variables we request. `LIKE` in `SHOW STATUS`
    works the same as it does for regular `SELECT` statements, as explained in [Chapter 3](ch03.xhtml#CH3_BASICS):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动浏览数百行输出是不理想的，因此让我们使用通配符来限制我们请求的变量数量。在`SHOW STATUS`中使用`LIKE`与常规`SELECT`语句中的用法相同，详细解释见[第三章](ch03.xhtml#CH3_BASICS)。
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now the output is much easier to read. To read the value of a single variable,
    just specify its full name within quotes without the wildcard, like so:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出变得更易于阅读了。要读取单个变量的值，只需在引号内指定其完整名称，不使用通配符，像这样：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You might notice in the output for the `Created%` status variables that MySQL
    showed a value of `7` for `Created_tmp_files`. Does that mean this session created
    seven temporary files, while creating zero temporary tables? No—in fact, the `Created_tmp_files`
    status variable has only a global scope. This is a known issue with MySQL at the
    moment: you always see all status variables, regardless of the requested scope,
    but their values will be properly scoped. The MySQL documentation includes a helpful
    [“Server Status Variable Reference”](https://oreil.ly/kgYBx) that can help you
    understand the scope of the different variables.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`Created%`状态变量的输出中，MySQL显示了`Created_tmp_files`为`7`的值。这意味着本次会话创建了七个临时文件，而没有创建临时表吗？实际上，`Created_tmp_files`状态变量只有全局范围。这是MySQL目前已知的问题：你总是看到所有状态变量，无论请求的范围如何，但它们的值将正确地限定在其作用域内。MySQL文档包含一个有用的[“服务器状态变量参考”](https://oreil.ly/kgYBx)，可以帮助你理解不同变量的范围。
- en: 'Unlike `Created_tmp_files`, the `Com_show_status` variable has scope “both,”
    meaning that you can get a global counter as well as a per-session value. Let’s
    see that in practice:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Created_tmp_files`不同，`Com_show_status`变量的范围是“both”，这意味着你可以得到全局计数器以及每个会话的值。让我们看看实际操作：
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another important thing to note when looking at the status variables is that
    it’s possible to reset most of them back to zero on a session level. That is achieved
    by running the `FLUSH STATUS` command. This command resets status variables within
    all connected sessions to zero, after adding their current values to the global
    counters. Thus, `FLUSH STATUS` operates on a session level, but for all sessions.
    To illustrate this, we’ll reset the status variable values in the session we used
    before:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看状态变量时，另一个重要的注意事项是，大多数状态变量可以在会话级别上重置为零。这可以通过运行`FLUSH STATUS`命令来实现。此命令将会话中的状态变量重置为零，然后将它们当前的值添加到全局计数器中。因此，`FLUSH
    STATUS`在会话级别上操作，但适用于所有会话。为了说明这一点，我们将在之前使用过的会话中重置状态变量的值：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Even though the global counter keeps on increasing, the session counter was
    reset to `0` and incremented to only `1` when we ran the `SHOW STATUS` command.
    This can be useful to see in isolation how, for example, running a single query
    changes the status variable values (in particular, the `Handler_*` family of status
    variables).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管全局计数器持续增加，但会话计数器在运行`SHOW STATUS`命令时被重置为`0`，并仅在运行时增加到`1`。例如，运行单个查询如何改变状态变量值（特别是`Handler_*`系列状态变量），这种隔离显示是有用的。
- en: Note that it’s impossible to reset global counters without a restart.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无法在不重新启动的情况下重置全局计数器。
- en: Basic Monitoring Recipes
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本监控方案
- en: You could monitor numerous metrics, in different combinations. We believe, however,
    that there are a few that must be in the toolbox of every database operator. While
    you are learning MySQL, these should be enough to give you a reasonable sense
    of how your database is doing. Most of the existing monitoring systems should
    have these covered and usually include many more metrics. You may never set up
    collection yourself, but our explanation should also allow you to get a better
    understanding of just what your monitoring system tells you.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以监控多种不同组合的指标。然而，我们认为每个数据库操作者的工具箱中必须包含一些指标。当您学习MySQL时，这些指标应该足以让您合理地了解数据库的运行情况。大多数现有的监控系统应该包括这些指标，并通常包括更多指标。您可能永远不会自己设置集合，但我们的解释也应该使您更好地理解监控系统向您报告的内容。
- en: We’re going to give few broad categories of metrics in the following subsections,
    within which we’ll detail what we think are some of the more important counters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的小节中列出几个广泛的指标类别，在其中详细说明我们认为的一些更重要的计数器。
- en: MySQL server availability
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL服务器的可用性
- en: This is the most important thing you should monitor. If MySQL Server is not
    accepting connections or is not running, all the other metrics don’t matter at
    all.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应该监控的最重要的事情。如果MySQL服务器不接受连接或不运行，那么所有其他指标都毫无意义。
- en: 'MySQL Server is a robust piece of software that’s capable of running with an
    uptime of months or years. Yet, there are situations that can lead to a premature
    unplanned shutdown (or, more plainly, a crash). For example, in [“Memory”](#MONITORING_OS_MEMORY)
    we discussed that out-of-memory conditions may lead to MySQL crashing or being
    killed. Other incidents happen, too. There are crashing bugs in MySQL, however
    rare they are nowadays. There are also operational mistakes: who hasn’t forgotten
    to bring up a database after planned maintenance? Hardware fails, servers restart—many
    things may compromise the availability of MySQL.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL服务器是一款强大的软件，可以运行数月甚至数年的时间。然而，有些情况可能导致提前非计划关闭（或者更直接地说，崩溃）。例如，在[“Memory”](#MONITORING_OS_MEMORY)中我们讨论了内存不足条件可能导致MySQL崩溃或被杀死。还会发生其他事故。虽然MySQL中的崩溃性错误现在很少见，但确实存在。还有操作失误：谁在计划维护后忘记启动数据库？硬件故障，服务器重启——许多因素都可能影响MySQL的可用性。
- en: There are a few approaches to monitoring MySQL availability, and there’s no
    single best one; it’s better to combine a few. A very simple basic approach is
    to check that the `mysqld` (or `mysqld.exe`) process is actually running and visible
    from the OS level. On Linux and Unix-like systems you can use the `ps` command
    for this, and on Windows, you can check the Task Manager or run the `Get-Service`
    PowerShell command. This is not a useless check, but it has its issues. For one,
    the fact that MySQL is running does not guarantee that it’s actually doing what
    it should be—that is, processing clients’ queries. MySQL could be swamped by load
    or suffering from a disk failure and running unbearably slowly. From the OS’s
    perspective, the process is running, but from the client’s perspective it’s as
    good as shut down anyway.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 MySQL 可用性有几种方法，没有单一的最佳方法；最好结合几种方法。一个非常简单的基本方法是检查 `mysqld`（或 `mysqld.exe`）进程是否实际在运行并在操作系统级别可见。在类
    Unix 系统上，您可以使用 `ps` 命令进行检查，在 Windows 上，您可以检查任务管理器或运行 `Get-Service` PowerShell
    命令。这不是一个无用的检查，但它也有其问题。首先，MySQL 正在运行并不意味着它确实在做它应该做的事情——即处理客户端的查询。MySQL 可能被负载淹没或受到磁盘故障的影响，运行速度非常慢。从操作系统的角度来看，进程正在运行，但从客户端的角度来看，它几乎就像已经关闭了一样。
- en: The second approach is to check MySQL’s availability from the application’s
    point of view. Usually, that’s achieved by running the MySQL monitor and executing
    some simple, short query. Unlike the previous check, this one makes sure that
    a new connection to MySQL can be established and that the database is processing
    queries. You can locate these checks on the application side to make them even
    closer to how apps see the database. Instead of setting up such checks as independent
    entities, applications can be adjusted to probe MySQL and report clear errors
    either to operators or to the monitoring system.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是从应用程序的角度检查 MySQL 的可用性。通常，通过运行 MySQL 监控器并执行一些简单的短查询来实现。与前一种检查不同，此方法确保可以建立新的
    MySQL 连接并且数据库正在处理查询。您可以将这些检查定位在应用程序端，使它们更接近应用程序看到的数据库。应用程序可以调整以探测 MySQL 并将明确的错误报告给操作员或监控系统。
- en: The third approach lies between the previous two and is concentrated on the
    DB side. While monitoring MySQL, you will at least need to execute simple queries
    against the database to check status variables. If those queries fail, your monitoring
    system should alert, as potentially MySQL is starting to have issues. A variation
    would be to check whether any data from the target instance has been received
    by your monitoring system in the last few minutes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法介于前两种之间，重点放在数据库端。在监控 MySQL 时，您至少需要对数据库执行简单的查询以检查状态变量。如果这些查询失败，您的监控系统应该发出警报，因为
    MySQL 可能开始出现问题。另一种方法是检查最近几分钟内目标实例是否向您的监控系统接收到任何数据。
- en: What ideally should come out of these checks is not only the alert “MySQL is
    down” at the appropriate time but also some clue as to why it is down. For example,
    if the second type of check cannot initiate a new connection because MySQL has
    run out of connections, then that should be a part of the alert. If the third
    type of check is failing, but the first type is okay, then it’s a different situation
    than a crash.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查的理想结果不仅仅是在适当时候发出“MySQL 已停止运行”的警报，还包括一些关于为何停止运行的线索。例如，如果第二种检查无法启动新连接，因为 MySQL
    连接已经用完，那么这应该成为警报的一部分。如果第三种检查失败，但第一种检查正常，则情况就不同于崩溃。
- en: Client connections
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端连接
- en: MySQL Server is a multithreaded program, as was laid out in depth in [“The MySQL
    Server Daemon”](ch11.xhtml#CH11_CONFIGURE_DAEMON_EXPLANATION). Every client connecting
    to a database causes a new thread to be spawned within the process of the MySQL
    server (`mysqld` or `mysqld.exe`). That thread will be responsible for executing
    statements sent by a client, and in theory there can be as many concurrent queries
    executing as there are client threads.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 服务器是一个多线程程序，正如在[“MySQL 服务器守护程序”](ch11.xhtml#CH11_CONFIGURE_DAEMON_EXPLANATION)中深入讲解的那样。每个连接到数据库的客户端都会在
    MySQL 服务器的进程中产生一个新线程（`mysqld` 或 `mysqld.exe`）。该线程将负责执行客户端发送的语句，理论上可以有多个并发查询正在执行，就像有多个客户端线程一样。
- en: 'Each connection and its thread put some low overhead on the MySQL server, even
    when they are idle. Apart from that, from the database’s point of view, each connection
    is a liability: the database cannot know when a connection will send a statement.
    *Concurrency*, or the number of simultaneously running transactions and queries,
    usually increases with an increase in the number of established connections. Concurrency
    is not bad in itself, but each system will have a limit of scalability. As you’ll
    remember from [“Operating System Metrics”](#MONITORING_OS), CPU and disk resources
    have performance limits, and it’s impossible to push past them. And even with
    an infinite amount of OS resources, MySQL itself has internal scalability limits.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接及其线程即使在空闲时也会对MySQL服务器产生一些低开销。除此之外，从数据库的角度来看，每个连接都是一个责任：数据库无法知道何时会发送语句。*并发性*，即同时运行的事务和查询的数量，通常随着建立连接数的增加而增加。并发性本身并不是坏事，但每个系统都有可扩展性的限制。正如您会从[“操作系统度量”](#MONITORING_OS)中记得的那样，CPU和磁盘资源有性能限制，超过这些限制是不可能的。即使具有无限的操作系统资源，MySQL本身也有内部的可扩展性限制。
- en: 'To put it simply: the number of connections, especially active connections,
    should ideally be kept minimal. From the MySQL side, no connections is the perfect
    situation, but from the application side that’s unacceptable. Some applications,
    though, make no attempt at limiting the number of connections they make and queries
    they send, assuming that the database will take care of the load. This can create
    a dangerous situation known as a *thundering herd*: for some reason, queries run
    longer, and the app reacts by sending more and more queries, overloading the database.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说：连接数，特别是活动连接数，理想情况下应该保持最小化。从MySQL方面来看，没有连接是完美的情况，但从应用程序方面来说这是不可接受的。一些应用程序尽管不会尝试限制它们建立和发送的连接数和查询数量，认为数据库会处理负载。这可能会产生一个危险的情况，被称为*雷鸣般的兽群*：由于某种原因，查询运行时间更长，应用程序反应是发送越来越多的查询，从而过载数据库。
- en: Finally, MySQL has an upper limit on the number of client connections, controlled
    by the system variable `max_connections`. Once the number of existing connections
    hits the value of that variable, MySQL will refuse to create new connections.
    That’s a bad thing. `max_connections` should be used as a protection from complete
    server meltdown if clients establish thousands of connections. But ideally, you
    should monitor the number of connections and work with the app teams to keep that
    number low.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，MySQL有一个客户端连接数的上限，由系统变量`max_connections`控制。一旦现有连接数达到该变量的值，MySQL将拒绝创建新连接。这是一个坏事情。`max_connections`应该被用作防止服务器完全崩溃的保护，如果客户端建立成千上万的连接。但理想情况下，您应该监控连接数，并与应用团队合作，保持该数字低。
- en: 'Let’s review the specific connection and thread counters that MySQL exposes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾MySQL公开的具体连接和线程计数器：
- en: '`Threads_connected`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Threads_connected`'
- en: Number of currently connected client threads, or in other words number of established
    client connections. We’ve been explaining the importance of this one for the last
    few paragraphs, so you should know why you have to check it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当前连接的客户端线程数，或者换句话说，已建立的客户端连接数。在过去的几段中，我们一直在解释这一点的重要性，所以您应该知道为什么必须检查它。
- en: '`Threads_running`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Threads_running`'
- en: Number of client threads that are currently executing a statement. Whereas `Threads_connected`
    indicates a potential for high concurrency, `Threads_running` actually shows the
    current measure of that concurrency. Spikes in this counter indicate either an
    increased load from the application or a slowness in the database leading to queries
    stacking up.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在执行语句的客户端线程数。而`Threads_connected`指示高并发的潜力，`Threads_running`实际上显示了并发的当前度量。此计数器的波动表明应用程序负载增加或数据库查询缓慢导致查询堆积。
- en: '`Max_used_connections`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Max_used_connections`'
- en: Maximum number of connections established that was recorded since the last MySQL
    server restart. If you suspect that a connection flood happened, but don’t have
    a recorded history of changes in `Threads_connected`, you can check this status
    variable to see the highest peak recorded.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 自MySQL服务器上次重启以来记录的建立的最大连接数。如果您怀疑发生了连接洪泛，但没有记录`Threads_connected`的变化历史，您可以检查此状态变量以查看记录的最高峰值。
- en: '`Max_used_connections_time`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Max_used_connections_time`'
- en: Date and time when MySQL Server saw the maximum number of connections since
    the last restart to date.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 自上次重启以来，MySQL服务器看到的连接数最大值的日期和时间。
- en: 'Another important metric to monitor about connections is their rate of failure.
    An increased rate of errors may indicate that your applications are having trouble
    communicating with your database. MySQL distinguishes between connections that
    clients failed to establish and existing connections that failed due to a timeout,
    for example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 关于连接的另一个重要指标是它们的失败率。错误率增加可能表明您的应用程序在与数据库通信时遇到问题。MySQL 区分了客户端未能建立的连接和由于超时等原因失败的现有连接，例如：
- en: '`Aborted_clients`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aborted_clients`'
- en: Number of already established connections that were aborted. The MySQL documentation
    mentions “the client died without closing the connection properly,” but this can
    also happen if there’s a network issue between the server and client. Frequent
    sources of increases in this counter are `max_allowed_packet` violations (see
    [“Scope of Options”](ch09.xhtml#CH-OPTIONS-FILE-SCOPE)) and session timeouts (see
    the `wait_timeout` and `interactive_timeout` system variables). Some errors are
    to be expected, but sharp spikes should be checked.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 已建立连接中被中止的数量。MySQL 文档提到“客户端未正确关闭连接而死亡”，但如果服务器和客户端之间存在网络问题，也会发生这种情况。此计数器增加的常见原因包括
    `max_allowed_packet` 违规（参见 [“Options 范围”](ch09.xhtml#CH-OPTIONS-FILE-SCOPE)）和会话超时（参见
    `wait_timeout` 和 `interactive_timeout` 系统变量）。某些错误是可以预期的，但应检查突然激增的情况。
- en: '`Aborted_connects`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aborted_connects`'
- en: Number of new connections that failed to be established. Causes include incorrect
    passwords, connecting to a database for which the user has no permission, protocol
    mismatches, `connect_timeout` violations, and reaching `max_connections`, among
    other things. They also include various network-related issues. There’s a family
    of status variables under the `Connection_errors_%` wildcard that look in more
    depth into some of the specific issues. An increase in `Aborted_connects` should
    be checked, as it can indicate an application configuration issue (wrong user/password)
    or a database issue (running out of connections).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 无法建立的新连接数量。导致此问题的原因包括密码错误、用户无权限连接到数据库、协议不匹配、`connect_timeout` 超时以及达到 `max_connections`
    等。还包括各种网络相关问题。在 `Connection_errors_%` 通配符下有一系列状态变量，可以更深入地了解一些特定问题。应检查 `Aborted_connects`
    的增加情况，因为它可能表明应用程序配置问题（错误的用户/密码）或数据库问题（连接用尽）。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: MySQL Enterprise Edition, Percona Server, and MariaDB offer a thread pool functionality.
    This changes the connection and thread accounting. With a thread pool, the number
    of connections stays the same, but the number of threads running within MySQL
    is limited by the size of the pool. When a connection needs to execute a statement,
    it will have to get an available thread from the pool and wait if such a thread
    is not available. Using a thread pool improves MySQL performance with hundreds
    or thousands of connections. Since this feature is not available in regular MySQL
    and we believe it’s an advanced one, we’re not covering it in this book.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Enterprise Edition、Percona Server 和 MariaDB 都提供了线程池功能。这改变了连接和线程计数。使用线程池后，连接数保持不变，但在
    MySQL 内运行的线程数受池大小限制。当连接需要执行语句时，它将从池中获取一个可用线程，并在没有可用线程时等待。使用线程池可以改善 MySQL 在数百或数千个连接时的性能。由于这个功能在常规
    MySQL 中不可用，我们认为它是高级功能，因此本书不涵盖这部分内容。
- en: Query counts
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询计数
- en: The next broad category of metrics is query-related metrics. Where `Threads_running`
    shows how many sessions are active at once, metrics in this category will show
    the quality of the load those sessions produce. Here, we’ll start by looking at
    the overall amount of queries, then move on to breaking down queries by type,
    and last but not least we’ll look into how the queries execute.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个广泛的指标类别是与查询相关的指标。`Threads_running` 显示同时活动的会话数量，而此类别中的指标将显示这些会话产生的负载质量。在这里，我们将首先查看总体查询量，然后逐步分析查询类型，并最后查看查询的执行方式。
- en: 'It’s important to monitor query counts. Thirty running threads may each be
    executing a single hour-long query, or a few dozen queries per second. The conclusions
    you make will be completely different in each case, and the load profile will
    likely change, too. These are the important metrics showing the number of queries
    executed:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 监控查询计数非常重要。30 个正在运行的线程可能每个执行一个时长为一小时的查询，或者每秒执行几十个查询。在每种情况下，您得出的结论完全不同，负载特性也可能发生变化。以下是显示执行查询数量的重要指标：
- en: '`Queries`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queries`'
- en: This global status variable, simply put, gives the number of statements executed
    by the server (excluding `COM_PING` and `COM_STATISTICS`). If you run `SHOW GLOBAL
    STATUS LIKE 'Queries'` on an idle server, you will see the counter value increasing
    with each execution of the `SHOW STATUS` command.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个全局状态变量，简单地说，提供了服务器执行的语句数量（不包括`COM_PING`和`COM_STATISTICS`）。如果您在空闲服务器上运行`SHOW
    GLOBAL STATUS LIKE 'Queries'`，您将看到每次执行`SHOW STATUS`命令时计数器值增加。
- en: '`Questions`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Questions`'
- en: 'Almost the same as `Queries`, but excludes statements executed within stored
    procedures, and also the following types of queries: `COM_PING`, `COM_STATISTICS`,
    `COM_STMT_PREPARE`, `COM_STMT_CLOSE`, or `COM_STMT_RESET`. Unless your database
    clients use stored procedures extensively, the `Questions` metric is closer to
    the amount of actual queries being executed by the server, compared to the amount
    of statements in `Queries`. In addition to that, `Questions` is both a session-level
    and a global status variable.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Queries`几乎相同，但不包括在存储过程中执行的语句，以及以下类型的查询：`COM_PING`、`COM_STATISTICS`、`COM_STMT_PREPARE`、`COM_STMT_CLOSE`或`COM_STMT_RESET`。除非您的数据库客户端广泛使用存储过程，否则`Questions`指标更接近服务器实际执行的查询量，与`Queries`中的语句数量相比。此外，`Questions`既是会话级别的全局状态变量。
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Both `Queries` and `Questions` are incremented when the query starts executing,
    so it’s necessary to also look at the `Threads_running` value to see how many
    queries are actually being executed right now.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询开始执行时，`Queries`和`Questions`都会增加，因此还需要查看`Threads_running`值，以了解当前实际执行的查询数量。
- en: QPS
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: QPS
- en: Queries per second. This is a synthetic metric that you can arrive at by looking
    at how the `Queries` variable changes over time. QPS based on `Queries` will include
    almost any statement that the server executes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒查询数。这是一个合成度量标准，您可以通过观察`Queries`变量随时间的变化来得出。基于`Queries`的QPS将包括服务器执行的几乎所有语句。
- en: The QPS metric does not tell us about the quality of queries executed—that is,
    the extent of their impact on the server—but it’s a useful gauge nevertheless.
    Usually, the load on a database from applications is regular. It may move in waves
    (more during the day, fewer at night), but over a week or a month a pattern of
    number of queries over time will show. When you get a report about a database
    being slow, looking at QPS may give you a quick indication of whether there’s
    been a sudden unexpected growth in application load. A drop in QPS, on the other
    hand, may indicate that issues are on the database side, as it cannot process
    as many queries as usual in the same time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: QPS指标并不告诉我们有关执行的查询质量的信息——即它们对服务器的影响程度——但它仍然是一个有用的衡量标准。通常，应用程序对数据库的负载是规律性的。它可能呈波浪形（白天更多，夜间更少），但在一周或一个月的时间内，随着时间的推移，查询数量的模式将显示出来。当您收到有关数据库变慢的报告时，查看QPS可能会快速指示是否在应用程序负载中突然出现了意外的增长。另一方面，QPS的下降可能表明问题出现在数据库端，因为它无法在相同的时间内处理与通常一样多的查询。
- en: Query types and quality
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询类型和质量
- en: The next logical step from knowing the QPS is understanding what types of queries
    are being executed by the clients, and the impact of those queries on the server.
    All queries are not equal, and some, you may say, are *bad*, or produce unnecessary
    load on the system. Looking for and catching such queries is an important part
    of monitoring. In this section we’re trying to answer the question “are there
    a lot of bad queries?” and in [“The Slow Query Log”](#MONITORING_MYSQL_SLOWLOG)
    we’ll show you how to catch the specific offenders.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从了解QPS的下一个逻辑步骤是理解客户端执行的查询类型以及这些查询对服务器的影响。并非所有查询都相同，有些可以说是*不好的*，或者对系统产生不必要的负载。查找和捕获这样的查询是监控的重要部分。在本节中，我们试图回答“是否有很多不良查询？”的问题，在[“慢查询日志”](#MONITORING_MYSQL_SLOWLOG)中，我们将向您展示如何捕获具体的违规行为。
- en: Types of queries
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询类型
- en: 'Each query MySQL executes has a type. What’s more, any *command* that you can
    execute has a type. MySQL keeps track of the different types of commands and queries
    executed with the `Com_%` family of status variables. There are 172 of these variables
    in MySQL 8.0.25, accounting for almost a third of all status variables. As you
    can guess from this number, MySQL counts a lot of commands that you perhaps wouldn’t
    even think of: for example, `Com_uninstall_plugin` counts the number of times
    `UNINSTALL PLUGIN` was called, and `Com_help` counts uses of the `HELP` statment.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL执行的每个查询都有一个类型。更重要的是，你可以执行的任何*命令*都有一个类型。MySQL使用`Com_%`系列状态变量跟踪执行的不同类型的命令和查询。在MySQL
    8.0.25中有172个这些变量，占所有状态变量的近三分之一。从这个数字可以看出，MySQL计数了许多你可能甚至不会考虑的命令：例如，`Com_uninstall_plugin`计算了调用`UNINSTALL
    PLUGIN`的次数，而`Com_help`计算了`HELP`语句的使用次数。
- en: Every `Com_%` status variable is available on both the global and session levels,
    as was shown with `Com_show_status` in [“Status Variables”](#MONITORING_MYSQL_STATUS_VARIABLES).
    However, MySQL doesn’t expose other threads’ counters for `Com_%` variables, so
    for monitoring purposes, global status variables are assumed here. It’s possible
    to get other sessions’ statement counters, but that’s achieved through the Performance
    Schema family of events, called `statement/sql/%`. That can be useful to attempt
    to find a thread that’s sending a disproportional amount of some type of statement,
    but it’s a bit advanced and falls under investigation rather than monitoring.
    You can find more details in the [“Performance Schema Status Variable Tables”
    section](https://oreil.ly/6wif5) of the MySQL documentation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Com_%`状态变量在全局和会话级别都可用，就像在[“状态变量”](#MONITORING_MYSQL_STATUS_VARIABLES)中展示的`Com_show_status`一样。然而，MySQL不会暴露其他线程的`Com_%`变量计数器，因此在监控目的上，这里假定为全局状态变量。可以通过性能模式事件系列`statement/sql/%`获取其他会话的语句计数器，但这需要一些高级操作，更多属于调查而非监控。你可以在MySQL文档的[“性能模式状态变量表”章节](https://oreil.ly/6wif5)中找到更多细节。
- en: Since there are so many `Com_%` status variables, monitoring every type of command
    would be both too noisy and unnecessary. You should, however, try to store the
    values of all of them. You can go two ways with looking at these counters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有这么多的`Com_%`状态变量，监控每种类型的命令既会引起太多噪音，又是不必要的。然而，你应该尝试存储它们的所有值。你可以通过两种方式来查看这些计数器。
- en: The first option is to pick the command types that are relevant for your database
    load profile, and monitor those. For example, if your database clients do not
    use stored procedures, then looking at `Com_call_procedure` is a waste of time.
    A good starting selection is to cover `SELECT` and basic DML statements, which
    usually comprise the bulk of any database system’s load—for example, `Com_select`,
    `Com_insert`, `Com_update`, and `Com_delete` (the status variables’ names are
    self-explanatory here). One interesting thing MySQL does is account for multitable
    updates and deletes (see [“Performing Updates and Deletes with Multiple Tables”](ch07.xhtml#ADV2-SEC-UPDEL))
    separately, under `Com_update_multi` and `Com_delete_multi`; these should also
    be monitored, unless you’re sure such statements are never run in your system.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是选择与你的数据库负载配置相关的命令类型，并对其进行监控。例如，如果你的数据库客户端不使用存储过程，那么查看`Com_call_procedure`就是浪费时间。一个好的起始选择是覆盖`SELECT`和基本的DML语句，这通常包括任何数据库系统负载的大部分内容，例如`Com_select`、`Com_insert`、`Com_update`和`Com_delete`（这些状态变量的名称在这里都很自解释）。MySQL的一件有趣的事情是单独计算多表更新和删除（参见[“使用多表进行更新和删除”](ch07.xhtml#ADV2-SEC-UPDEL)），分别使用`Com_update_multi`和`Com_delete_multi`；除非你确信系统中从不运行这些语句，否则也应该对其进行监控。
- en: You can then look at all of the `Com_%` status variables, see which ones are
    growing, and add those to your selection of monitored variables. Unfortunately,
    the flaw with this approach is that you can miss some unexpected spikes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看所有的`Com_%`状态变量，看看哪些在增长，并将它们添加到你监控的变量选择中。不幸的是，这种方法的缺陷在于可能会错过一些意外的峰值。
- en: Another way of looking at these counters could be to look at the top 5 or 10
    of them over time. This way, a sudden change of load pattern can be more difficult
    to miss.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查看这些计数器的方法是随时间查看前5或前10名。这样，负载模式的突然变化就更难被忽视了。
- en: Knowing what types of queries are running is important in shaping an overall
    understanding of the load on a given database. Moreover, it changes how you approach
    tuning the database, because, for example, an insert-heavy workload may require
    a different setup compared to a read-only or mostly-read workload. Changes in
    query load profile, like a sudden appearance of thousands of `UPDATE` statements
    executed per second, can indicate changes on the application side.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 了解正在运行的查询类型对于形成对给定数据库负载的整体理解非常重要。此外，它会改变您调整数据库的方式，例如，与只读或大部分读取负载相比，插入密集型工作负载可能需要不同的设置。查询负载配置的变化，例如每秒执行成千上万次`UPDATE`语句的突然出现，可能表明应用程序端发生了变化。
- en: Query quality
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查询质量
- en: 'The next step after knowing what queries are running is to understand their
    quality, or their impact on the system. We mentioned this, but it’s worth reiterating:
    all queries are not equal. Some will put more burden on the system than others.
    Looking at the overall query-related metrics may give you advance warning of problems
    growing in the database. You will learn that it’s possible to notice problematic
    behaviors by monitoring just a few counters.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 了解正在运行的查询后的下一步是了解它们的质量或对系统的影响。我们提到过这一点，但值得重申：并非所有查询都相同。有些查询会对系统施加更大的负担。查看整体与查询相关的指标可能会提前发现数据库中正在增加的问题。通过监控几个计数器，您可以注意到可能存在的问题行为。
- en: '`Select_scan` counts the number of queries that caused a full table scan, or
    in other words forced MySQL to read the whole table to form the result. Now, we
    should immediately acknowledge that full table scans are not always a problem.
    After all, sometimes just reading all of the data in a table is a viable query
    execution strategy, especially when the number of rows is low. You can also expect
    to always see some amount of full table scans happening, as a lot of MySQL catalog
    tables are read that way. For example, just running a `SHOW GLOBAL STATUS` query
    will cause `Select_scan` to increase by two. Often, however, full table scans
    imply that there are queries hitting the database that are performing suboptimally:
    either they are improperly written and don’t filter out data efficiently, or there
    are simply no indexes that the queries can use. We give more information about
    query execution details and plans in [“The EXPLAIN Statement”](ch07.xhtml#ADV1-SEC-EXPLAIN).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select_scan` 统计了导致全表扫描的查询次数，或者换句话说，强制 MySQL 读取整个表来形成结果的查询。现在，我们应该立即承认全表扫描并不总是问题。毕竟，有时只需读取表中的所有数据就是一种可行的查询执行策略，特别是当行数较少时。您还可以预期始终会看到某些全表扫描发生，因为许多
    MySQL 目录表都是以这种方式读取的。例如，仅运行 `SHOW GLOBAL STATUS` 查询将导致 `Select_scan` 增加两个。然而，通常情况下，全表扫描暗示存在影响数据库性能的查询：要么它们编写不当且不能有效过滤数据，要么根本没有可用于查询的索引。我们在[“解释语句”](ch07.xhtml#ADV1-SEC-EXPLAIN)中提供更多有关查询执行详细信息和计划的信息。'
- en: '`Select_full_join` is similar to `Select_scan`, but counts the number of queries
    that caused a full table scan on a referenced table within a `JOIN` query. The
    referenced table is the rightmost table in the `JOIN` condition—see [“Joining
    Two Tables”](ch03.xhtml#BAS-SEC-JOINS) for more information. Again, as with `Select_scan`,
    it’s hard to say that a high `Select_full_join` count is always bad. It’s common
    in large data warehouse systems, for example, to have compact dictionary tables,
    and reading those fully may not be a problem. Still, usually a high value for
    this status variable indicates the presence of badly behaving queries.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select_full_join` 类似于 `Select_scan`，但是统计了在 `JOIN` 查询中导致引用表进行全表扫描的查询次数。被引用的表是
    `JOIN` 条件中最右边的表，请参阅[“两个表的连接”](ch03.xhtml#BAS-SEC-JOINS)以获取更多信息。与 `Select_scan`
    类似，高 `Select_full_join` 次数并不总是坏事。例如，在大型数据仓库系统中，紧凑的字典表通常可以全表读取而不会出现问题。然而，通常情况下，这个状态变量的高值表明存在执行不良查询的可能性。'
- en: '`Select_range` counts the number of queries that scanned data with some range
    condition (covered in [“Selecting Rows with the WHERE Clause”](ch03.xhtml#BAS-SEC-WHERE)).
    Usually this is not a problem at all. If the range condition is not possible to
    satisfy using an index, then the value of `Select_scan` or `Select_full_join`
    will grow alongside this status variable. Probably the only time when this counter’s
    value may indicate an issue is when you see it growing even though you know that
    most of the queries running in the database in fact do not utilize ranges. As
    long as the associated table scan counters aren’t growing as well, the issue is
    likely still benign.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select_range` 计数了使用某些范围条件扫描数据的查询次数（在[“使用WHERE子句选择行”](ch03.xhtml#BAS-SEC-WHERE)中介绍）。通常情况下，这根本不是问题。如果范围条件无法利用索引满足，那么`Select_scan`或`Select_full_join`的值将与此状态变量同时增长。也许唯一可能表示问题的时候是当你看到该计数器的值在增长，尽管你知道数据库中运行的大多数查询实际上并不利用范围。只要相关的表扫描计数器没有增长，问题很可能仍然是良性的。'
- en: '`Select_full_range_join` combines `Select_range` and `Select_full_join`. This
    variable holds a counter for queries that caused a range scan on referenced tables
    in `JOIN` queries.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select_full_range_join` 结合了`Select_range`和`Select_full_join`。该变量统计了在`JOIN`查询中导致引用表上的范围扫描的查询次数。'
- en: So far, we’ve been counting individual queries, but MySQL also does a similar
    accounting for *every row* it reads from the storage engines! The family of status
    variables showing those counters are the `Handler_%` variables. Simply put, every
    row MySQL reads increments some `Handler_%` variable. Combining this information
    with the query type and query quality counters you’ve seen so far can tell you,
    for example, if full table scans that run in your database are a problem at all.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在计算单个查询，但 MySQL 也会对它从存储引擎中读取的*每一行*做类似的统计！显示这些计数器的状态变量家族是`Handler_%`变量。简单来说，MySQL
    读取的每一行都会增加一些`Handler_%`变量。将这些信息与你到目前为止看到的查询类型和查询质量计数器结合起来，可以告诉你，例如，在你的数据库中运行的全表扫描是否是一个问题。
- en: The first handler we’ll look at is `Handler_read_rnd_next`, which counts the
    number of rows read when a full or partial table scan is performed. Unlike the
    `Select_%` status variables, the `Handler_%` variables do not have nice, easy-to-remember
    names, so some memorization is necessary. High values in the `Handler_read_rnd_next`
    status variable in general indicate that either a lot of tables are not indexed
    properly or many queries do not utilize the existing indexes. Remember we mentioned
    when explaining `Select_scan` that some full table scans are not problematic.
    To see whether that’s true or not in your case, look at the ratio of `Handler_read_rnd_next`
    to other handlers. You want to see a low value for that counter. If your database
    returns on average a million rows per minute, then you probably want the number
    of rows returned by full scans to be in the thousands, not tens or hundreds of
    thousands.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要看的处理器是`Handler_read_rnd_next`，它统计了执行全表或部分表扫描时读取的行数。与`Select_%`状态变量不同，`Handler_%`变量没有简单易记的名称，因此需要一些记忆。通常情况下，`Handler_read_rnd_next`状态变量中的高值表明可能有许多表未正确建立索引，或者许多查询未利用现有的索引。请记住，在解释`Select_scan`时我们提到，有些全表扫描并不是问题。要查看在你的情况下是否属实，可以查看`Handler_read_rnd_next`与其他处理器的比例。你希望看到该计数器的值较低。如果你的数据库平均每分钟返回一百万行数据，那么你可能希望通过全扫描返回的行数是几千，而不是几万或几十万。
- en: '`Handler_read_rnd` counts the number of rows usually read when the sorting
    of a result set is performed. High values may indicate the presence of many full
    table scans and joins not using indexes. However, unlike with `Handler_read_rnd_next`,
    this is not a sure sign of problems.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler_read_rnd` 统计了在执行结果集排序时通常读取的行数。高值可能表明存在许多全表扫描和未使用索引的连接。然而，与`Handler_read_rnd_next`不同，这并不一定表示存在问题。'
- en: '`Handler_read_first` counts how many times the first index entry was read.
    A high value for this counter indicates that a lot of full index scans are occurring.
    This is better than full table scans, but still a problematic behavior. Likely,
    some of the queries are missing filters in their `WHERE` clauses. The value of
    this status variable should again be viewed in relation to the other handlers,
    as some full index scans are unavoidable.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler_read_first` 记录了读取第一个索引条目的次数。该计数器的高值表示正在发生大量的全索引扫描。这比全表扫描要好，但仍然是一个问题行为。很可能是一些查询在其`WHERE`子句中缺少过滤器。这个状态变量的值应该再次与其他处理器的值进行比较，因为一些全索引扫描是不可避免的。'
- en: '`Handler_read_key` counts the number of rows read by an index. You want this
    handler’s value to be high compared to other read-related handlers. In general,
    a high number here means your queries are using indexes properly.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler_read_key`计算通过索引读取的行数。您希望此处理程序的值相比其他读取相关处理程序高。一般来说，这里的高数字意味着您的查询正确使用了索引。'
- en: 'Note that handlers still can hide some issues. If a query only reads rows using
    indexes, but does so inefficiently, then `Select_scan` will not be increased,
    and `Handler_read_key`—our good read handler—will grow, but the end result will
    still be a slow query. We explain how to find specific slow queries in [“The Slow
    Query Log”](#MONITORING_MYSQL_SLOWLOG), but there’s also a special counter for
    them: `Slow_queries`. This status variable counts the queries that took longer
    than the value of `Long_query_time` to execute, regardless of whether the slow
    query log is enabled. You can gradually drop the value of `Long_query_time` and
    see when `Slow_queries` starts to approach the total number of queries executed
    by your server. This is a good way to assess how many queries in your system take,
    for example, longer than a second without actually turning on the slow query log,
    which has an overhead.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，处理程序仍然可能隐藏一些问题。如果一个查询仅使用索引读取行，但效率低下，那么`Select_scan`不会增加，而`Handler_read_key`——我们的好读取处理程序——将增加，但最终结果仍然是一个慢查询。我们将解释如何在[“慢查询日志”](#MONITORING_MYSQL_SLOWLOG)中找到特定的慢查询，但也有一个专门的计数器：`Slow_queries`。此状态变量计算执行时间超过`Long_query_time`值的查询次数，无论是否启用慢查询日志。您可以逐渐降低`Long_query_time`的值，并查看`Slow_queries`何时开始接近服务器执行的总查询数。这是一种评估系统中有多少查询，例如超过一秒钟的好方法，而不需要实际启用慢查询日志，因为这会增加开销。
- en: 'Not every query executed is read-only, and MySQL also counts the number of
    rows inserted, updated, or deleted under, respectively, the `Handler_insert`,
    `Handler_update`, and `Handler_delete` status variables. Unlike with `SELECT`
    queries, it’s hard to make conclusions about the quality of your write statements
    based on the status variables alone. However, you can monitor these to see if,
    for example, your database clients start updating more rows. Without a change
    in the number of `UPDATE` statements (the `Com_update` and `Com_update_multi`
    status variables), that may indicate a change in the parameters passed to the
    same queries: wider ranges, more items in the `IN` clauses, and so on. This may
    not indicate a problem on its own, but it may be used during investigation of
    slowness to see whether more strain is being put on the database.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个执行的查询都是只读的，MySQL还根据分别是`Handler_insert`、`Handler_update`和`Handler_delete`状态变量计算插入、更新或删除的行数。与`SELECT`查询不同，仅根据状态变量就很难对写入语句的质量做出结论。但是，您可以监视这些变量，以查看例如数据库客户端开始更新更多行是否有变化。如果没有`UPDATE`语句的数量变化（`Com_update`和`Com_update_multi`状态变量），这可能表明对相同查询传递的参数进行了更改：范围更广，在`IN`子句中的项目更多等等。这本身可能不表示问题，但在调查性能问题时可以使用它来查看数据库是否承受了更多的压力。
- en: 'Apart from `INSERT` statements, `UPDATE`, `DELETE`, and even `INSERT SELECT`
    statements have to look for rows to change. Thus, for example, a `DELETE` statement
    will increase read-related counters and may result in an unexpected situation:
    no `Select_scan` growth, but an increasing `Handler_read_rnd_next` value. Do not
    forget about this peculiarity if you see a discrepancy between status variables.
    The slow query log will include `SELECT` as well as DML statements.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`INSERT`语句外，`UPDATE`、`DELETE`，甚至`INSERT SELECT`语句都必须查找要更改的行。因此，例如，`DELETE`语句将增加与读相关的计数器，并可能导致意外情况：`Select_scan`不增长，但`Handler_read_rnd_next`值增加。如果在状态变量之间存在差异，请不要忘记这一特点。慢查询日志将包括`SELECT`以及DML语句。
- en: Temporary objects
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 临时对象
- en: 'Sometimes, when queries execute, MySQL needs to create and use temporary objects,
    which may reside in memory or on disk. Examples of reasons for temporary object
    creation include use of the `UNION` clause, derived tables, common table expressions,
    and some variations of `ORDER BY` and `GROUP BY` clauses, among other things.
    We’ve been saying this about almost everything in this chapter, but temporary
    objects are not a problem: some number of them is unavoidable and actually desired.
    Yet they do eat into your server’s resources: if temporary tables are small enough,
    they’ll be kept in memory and use it up, and if they grow large, MySQL will start
    offloading them to disk, using up both the disk space and affecting performance.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当执行查询时，MySQL 需要创建和使用临时对象，这些对象可能驻留在内存或磁盘上。创建临时对象的原因包括使用 `UNION` 子句、派生表、公共表达式以及某些
    `ORDER BY` 和 `GROUP BY` 子句的变体等。本章节几乎讨论了所有事物，但临时对象不是问题：某些数量的临时对象是不可避免的，实际上是期望的。然而，它们会消耗服务器资源：如果临时表足够小，它们将保留在内存中并使用它，如果它们增大，MySQL
    将开始将其卸载到磁盘，使用磁盘空间并影响性能。
- en: MySQL maintains three status variables related to temporary objects created
    during query execution. Note that this doesn’t include temporary tables created
    explicitly through the `CREATE TEMPORARY TABLE` statement; look for those under
    the `Com_create_table` counter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 维护了三个与查询执行期间创建的临时对象相关的状态变量。注意，这不包括通过 `CREATE TEMPORARY TABLE` 语句显式创建的临时表；这些请查看
    `Com_create_table` 计数器。
- en: '`Created_tmp_tables` counts the number of temporary tables created implicitly
    by MySQL server while executing various queries. You cannot know why or for which
    queries these were created, but every table will be accounted for here. Under
    a stable workload, you should see a uniform number of temporary tables created,
    as roughly the same queries run the same amount of times. Growth of this counter
    is usually associated with changing queries or their plans, for example due to
    growth of the database, and may be problematic. Although useful, creating temporary
    tables, even in memory, takes resources. You cannot completely avoid temporary
    tables, but you should check why their number is growing by performing a query
    audit with the slow query log, for example.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Created_tmp_tables` 计数 MySQL 服务器在执行各种查询时隐式创建的临时表数量。你不知道为什么或为哪些查询创建了这些表，但这里会统计每张表。在稳定的工作负载下，你应该看到创建的临时表数量基本一致，因为大致相同的查询运行相同次数。这个计数器的增长通常与查询或其执行计划的变化有关，例如数据库的增长，可能会带来问题。尽管有用，即使在内存中创建临时表也会消耗资源。你无法完全避免临时表的创建，但应该通过慢查询日志等手段，检查为何临时表数量增长，进行查询审计。'
- en: '`Created_tmp_disk_tables` counts the number of temporary tables that “spilled,”
    or were written to disk after their size surpassed the configured upper limits
    for in-memory temporary tables. With the older Memory engine, the limit was controlled
    by `tmp_table_size` or `max_heap_table_size`. MySQL 8.0 moved by default to a
    new TempTable engine for the temporary tables, which, by default, does not spill
    to disk in the same way Memory tables did. If the `temptable_use_mmap` variable
    is set to its default of `ON`, then TempTable temporary tables do not increase
    this variable even if they are written to disk.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Created_tmp_disk_tables` 计数临时表“溢出”或在其大小超过配置的内存临时表上限后写入磁盘的数量。使用旧版 Memory 引擎时，上限由
    `tmp_table_size` 或 `max_heap_table_size` 控制。MySQL 8.0 默认移动到新的 TempTable 引擎处理临时表，这种情况下，默认情况下不会像
    Memory 表那样溢出到磁盘。如果 `temptable_use_mmap` 变量设置为其默认值 `ON`，那么 TempTable 临时表即使写入磁盘也不会增加此变量。'
- en: '`Created_tmp_files` counts the number of temporary files created by MySQL.
    This is different from Memory engine temporary tables spilling to disk, but will
    account for TempTable tables being written out to disk. We understand that this
    may seem complicated, and it truly is, but major changes don’t usually come without
    some downsides.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Created_tmp_files` 计数 MySQL 创建的临时文件数量。这与 Memory 引擎临时表溢出到磁盘不同，但将会计入 TempTable
    表写入到磁盘的情况。我们理解这可能看起来复杂，确实如此，但主要变化通常不会没有一些缺点而来。'
- en: Whatever configuration you’re using, sizing the temporary tables is important,
    as is monitoring the rate of their creation and spillage. If a workload creates
    a lot of temporary tables of roughly 32 MB in size, but the upper limit for in-memory
    tables is 16 MB, then the server will see an increased rate of I/O due to those
    tables being written out to and read back from the disk. That’s fine for a server
    strapped for memory, but it’s a waste if you have memory available. Conversely,
    setting the upper limit too high may result in the server swapping or outright
    crashing, as explained in [“Memory”](#MONITORING_OS_MEMORY).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用何种配置，调整临时表的大小都很重要，监控它们的创建和溢出速率也很关键。如果工作负载创建了大量大约 32 MB 大小的临时表，但内存表的上限为
    16 MB，那么服务器将因为这些表被写入和从磁盘读取而增加 I/O 的速率。对于内存不足的服务器来说这是可以接受的，但如果有足够的内存则是浪费。相反，设置上限过高可能会导致服务器交换或直接崩溃，如
    [“Memory”](#MONITORING_OS_MEMORY) 中所述。
- en: We’ve seen servers brought down by memory spikes when lots of simultaneously
    open connections all ran queries requiring temporary tables. We’ve also seen servers
    where the bulk of I/O load was produced by temporary tables spilling to disk.
    As with most things related to operating databases, the table sizing decision
    is a balancing act. The three counters we’ve shown can help you make an informed
    choice.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经看到由于内存暴增导致服务器崩溃的情况，当大量同时打开的连接运行需要临时表的查询时。我们还见过大部分 I/O 负载是由临时表溢出到磁盘引起的服务器。与操作数据库相关的大多数事情一样，表大小决策是一个权衡考量。我们展示的这三个计数器可以帮助您做出明智的选择。
- en: InnoDB I/O and transaction metrics
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: InnoDB I/O 和事务指标
- en: So far, we’ve been mostly talking about overall MySQL metrics and ignoring the
    fact that there are things like transactions and locking. In this subsection we’ll
    take a look at some of the useful metrics the InnoDB storage engine exposes. Some
    of those metrics relate to how much data InnoDB reads and writes, and why. Some,
    however, can show important information on locking, which can be combined with
    MySQL-wide counters to get a solid grasp on the current locking situation in a
    database.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多数时间都在讨论总体 MySQL 指标，忽略了事务和锁定等内容。在这个小节中，我们将看一些 InnoDB 存储引擎提供的有用指标。其中一些指标涉及
    InnoDB 读写数据的量及原因。然而，有些指标可以显示有关锁定的重要信息，这些信息可以与 MySQL 全局计数器结合，以深入了解数据库中当前的锁定情况。
- en: The InnoDB storage engine provides 61 status variables showing various information
    about its internal state. By looking at their change over time you can see how
    loaded InnoDB is and how much load on the OS it produces. Given that InnoDB is
    the default storage engine, that will likely be most of the load MySQL produces.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 存储引擎提供了 61 个状态变量，显示关于其内部状态的各种信息。通过观察它们随时间的变化，您可以看到 InnoDB 的负载情况及其对操作系统产生的负载。鉴于
    InnoDB 是默认的存储引擎，这可能是 MySQL 所产生的大部分负载。
- en: We perhaps should’ve put these in the section about query quality, but InnoDB
    maintains its own counters for the number of rows it has read, inserted, updated,
    or deleted. The variables are, respectfully, `Inndb_rows_read`, `Inndb_rows_inserted`,
    `Inndb_rows_updated`, and `Inndb_rows_deleted`. Usually their values correspond
    pretty well to the values of the related `Handler_%` variables. If you primarily
    use InnoDB tables, it may be simpler to use the `Innodb_rows_%` counters instead
    of the `Handler_%` ones to monitor relative load from queries expressed in the
    number of rows processed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 或许我们应该把这些放在有关查询质量的部分中，但 InnoDB 维护其自己的计数器来统计已读取、插入、更新或删除的行数。相应的变量是 `Inndb_rows_read`、`Inndb_rows_inserted`、`Inndb_rows_updated`
    和 `Inndb_rows_deleted`。通常它们的值与相关的 `Handler_%` 变量的值相对应得很好。如果您主要使用 InnoDB 表，使用 `Innodb_rows_%`
    计数器而不是 `Handler_%` 计数器来监控查询处理的行数可能更简单。
- en: 'Other important and useful status variables InnoDB provides show the amount
    of data that the storage engine reads and writes. In [“Disk”](#MONITORING_OS_DISK)
    we saw how to check and monitor overall and per-process I/O utilization. InnoDB
    allows you to see exactly why it’s reading and writing data, and how much of it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 提供的其他重要且有用的状态变量显示存储引擎读取和写入的数据量。在 [“Disk”](#MONITORING_OS_DISK) 中，我们已经看到如何检查和监控总体和每个进程的
    I/O 利用率。InnoDB 允许您准确查看它读取和写入数据的原因及其数量：
- en: '`Innodb_data_read`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_data_read`'
- en: The amount of data expressed in bytes read from disk since server startup. If
    you take measurements of this variable’s value over time, you can translate it
    into bandwidth utilization in bytes/second. This metric is tightly related to
    InnoDB buffer pool sizing and its effectiveness, and we’ll get to that in a bit.
    All of this data can be assumed to be read from the data files to satisfy queries.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 自服务器启动以来从磁盘读取的数据量，以字节表示。如果你随时间测量此变量的值，可以将其转换为字节/秒的带宽利用率。这个指标与 InnoDB 缓冲池的大小及其效率密切相关，我们稍后会详细讨论。所有这些数据都可以假定是从数据文件中读取以满足查询。
- en: '`Innodb_data_written`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_data_written`'
- en: The amount of data expressed in bytes written to disk since server startup.
    This is the same as `Innodb_data_read`, but in the other direction. Usually, this
    value will account for a large portion of the overall amount of write bandwidth
    MySQL will generate. Unlike with reading data, InnoDB writes data out in a variety
    of situations; thus, there are additional variables specifying parts of this I/O,
    as well as other sources of I/O.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 自服务器启动以来写入磁盘的数据量，以字节表示。与 `Innodb_data_read` 相同，但方向相反。通常情况下，此值将占据 MySQL 生成的写入带宽的大部分。与读取数据不同，InnoDB
    在多种情况下写出数据；因此，有额外的变量指定这种 I/O 的部分，以及其他 I/O 的来源。
- en: '`Innodb_os_log_written`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_os_log_written`'
- en: The amount of data expressed in bytes written by InnoDB into its redo logs.
    This amount is also included in `Innodb_data_written`, but it’s worth monitoring
    individually to see if your redo logs may need a size change. See [“Redo log size”](ch11.xhtml#CH11_CONFIGURE_TUNE_REDO)
    for more details.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 写入其重做日志的数据量，以字节表示。这个量也包含在 `Innodb_data_written` 中，但单独监控它可以看出你的重做日志是否需要调整大小。详情请见
    [“重做日志大小”](ch11.xhtml#CH11_CONFIGURE_TUNE_REDO)。
- en: '`Innodb_pages_written`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_pages_written`'
- en: The amount of data expressed in pages (16 KiB by default) written by InnoDB
    during its operation. This is the second half of the `Innodb_data_written` status
    variable. It’s useful to see the amount of non-redo I/O that InnoDB generates.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB 操作期间写入的数据量，以页面（默认为 16 KiB）表示。这是 `Innodb_data_written` 状态变量的后半部分。查看 InnoDB
    生成的非重做 I/O 的量非常有用。
- en: '`Innodb_buffer_pool_pages_flushed`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_buffer_pool_pages_flushed`'
- en: The amount of data expressed in pages written by InnoDB due to flushing. Unlike
    the writes covered by two previous counters, writes caused by flushing do not
    happen immediately after an actual write is performed. Flushing is a complex background
    operation, the details of which are beyond the scope of our book. However, you
    should at least know that flushing exists and that it generates I/O independent
    of other counters.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于刷新而由 InnoDB 写入的页面数。与前两个计数器覆盖的写入不同，刷新引起的写入不会立即在执行实际写入后发生。刷新是一个复杂的后台操作，其详细信息超出了本书的范围。然而，你至少应该知道刷新的存在以及它会生成与其他计数器无关的
    I/O。
- en: By combining `Innodb_data_written` and `Innodb_buffer_pool_pages_flushed`, you
    should be able to come up with a pretty accurate figure for the disk bandwidth
    utilized by InnoDB and MySQL Server. Adding `Innodb_data_read` completes the I/O
    profile of InnoDB. MySQL doesn’t only use InnoDB, and there can be I/O from other
    parts of the system, like temporary tables spilling to disk, as we discussed earlier.
    Yet often InnoDB I/O matches that of MySQL Server observed from the OS.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 `Innodb_data_written` 和 `Innodb_buffer_pool_pages_flushed`，你应该能够得出 InnoDB
    和 MySQL 服务器使用的磁盘带宽利用率的相当准确的数据。加上 `Innodb_data_read` 完成 InnoDB 的 I/O 概况。MySQL 不仅使用
    InnoDB，系统的其他部分也可能有 I/O，例如我们之前讨论的临时表溢出到磁盘。然而，通常情况下，InnoDB 的 I/O 与从操作系统观察到的 MySQL
    服务器的 I/O 匹配。
- en: One use of this information is to see how close your MySQL Server is to hitting
    the limits of your storage system’s performance capacity. This is especially important
    in the cloud where storage often has strict limits. During incidents related to
    database performance, you can check the I/O-related counters to see if MySQL is
    writing or reading more, perhaps indicating increased load, or instead doing fewer
    actual I/O operations. The latter may mean that MySQL is currently limited by
    some other resource, like CPU, or suffers from other issues, like locking. Unfortunately,
    decreased I/O may also mean that the storage is having issues.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息的一个用途是查看 MySQL 服务器距离达到存储系统性能容量极限有多近。这在云环境中尤为重要，因为存储通常有严格的限制。在与数据库性能相关的事件期间，您可以检查与
    I/O 相关的计数器，以查看 MySQL 是否正在写入或读取更多数据，这可能表明负载增加，或者反而减少实际的 I/O 操作。后者可能意味着 MySQL 当前受到其他资源（如
    CPU）的限制，或者受到锁定等其他问题的影响。不幸的是，减少的 I/O 也可能意味着存储存在问题。
- en: 'There are some status variables in InnoDB that may help to find issues with
    storage or its performance: `Innodb_data_pending_fsyncs`, `Innodb_data_pending_reads`,
    `Innodb_data_pending_writes`, `Innodb_os_log_pending_fsyncs`, and `Innodb_os_​​log_pending_writes`.
    You can expect to see some amount of pending data reads and writes, though as
    always it’s helpful to look at the trends and previous data. The most important
    of all of these is `Innodb_os_log_pending_fsyncs`. Redo logs are synced often,
    and the performance of the syncing operation is extremely important for the overall
    performance and transaction throughput of InnoDB.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 InnoDB 中有一些状态变量可能有助于发现存储或其性能方面的问题：`Innodb_data_pending_fsyncs`、`Innodb_data_pending_reads`、`Innodb_data_pending_writes`、`Innodb_os_log_pending_fsyncs`
    和 `Innodb_os_log_pending_writes`。您可以预期会看到一定数量的挂起数据读取和写入，尽管像往常一样，查看趋势和先前的数据是有帮助的。其中最重要的是
    `Innodb_os_log_pending_fsyncs`。重做日志经常进行同步，同步操作的性能对 InnoDB 的整体性能和事务吞吐量非常重要。
- en: 'Unlike many other status variables, all of these are gauges, meaning that their
    values go up and down and don’t just increase. You should sample these variables
    and look at how often there are pending operations, in particular for the redo
    log sync. Even small increases in `Innodb_os_log_pending_fsyncs` may indicate
    serious issues with storage: either you’re running out of performance capacity
    or there are hardware issues.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他状态变量不同，所有这些都是计量器，即它们的值上升和下降，并不仅仅增加。您应该对这些变量进行采样，并查看有多少挂起的操作，特别是对于重做日志同步。即使是
    `Innodb_os_log_pending_fsyncs` 的微小增加也可能表明存储存在严重问题：要么是性能容量不足，要么是硬件问题。
- en: 'While writing about the `Innodb_data_read` variable, we mentioned that the
    amount of data that InnoDB reads is related to its buffer pool size and usage.
    Let’s elaborate on that. InnoDB caches pages it reads from disk inside its buffer
    pool. The larger the buffer pool is, the more pages will be stored there, and
    the less frequently pages will have to be read from disk. We talk about that in
    [“Buffer pool size”](ch11.xhtml#CH11_conf_IBP). Here, while discussing monitoring,
    let’s see how to monitor the effectiveness of the buffer pool. That’s easily done
    with just two status variables:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 `Innodb_data_read` 变量时，我们提到 InnoDB 读取的数据量与其缓冲池大小和使用情况有关。让我们详细说明一下。InnoDB
    将从磁盘读取的页面缓存在其缓冲池中。缓冲池越大，存储在其中的页面就越多，从磁盘读取页面的频率就越低。我们在 [“缓冲池大小”](ch11.xhtml#CH11_conf_IBP)
    中进行了讨论。在这里，讨论监视时，让我们看看如何监视缓冲池的效果。只需查看两个状态变量即可轻松完成：
- en: '`Innodb_buffer_pool_read_requests`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_buffer_pool_read_requests`'
- en: The MySQL documentation defines this as “the number of logical read requests.”
    Put simply, this is the number of pages that various operations within InnoDB
    wanted to read from the buffer pool. Usually most of the pages are read due to
    query activity.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 文档将其定义为“逻辑读取请求的数量”。简单来说，这是 InnoDB 内部各种操作希望从缓冲池中读取的页面数量。通常大部分页面是由于查询活动而读取的。
- en: '`Innodb_buffer_pool_reads`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_buffer_pool_reads`'
- en: This is the number of pages that InnoDB had to read from disk to satisfy the
    read requests by queries or other operations. The value of this counter is usually
    smaller than or equal to `Innodb_buffer_pool_read_requests` even in the very worst
    case with a completely empty (or “cold”) buffer pool, because reads from disk
    are performed to satisfy the read requests.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 InnoDB 为满足查询或其他操作的读取请求而必须从磁盘读取的页面数量。即使在完全空（或“冷”）的缓冲池中，此计数器的值通常也小于或等于 `Innodb_buffer_pool_read_requests`，因为从磁盘读取用于满足读取请求。
- en: Under normal conditions, even with a small buffer pool, you won’t get a 1:1
    ratio between these variables. That is, it will be possible to satisfy at least
    some reads from the buffer pool. Ideally, you should try keep the number of disk
    reads to a minimum. That may not always be possible, especially if the database
    size is much larger than server memory.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，即使缓冲池很小，这些变量之间也不会有1:1的比例。也就是说，至少可以从缓冲池中满足一些读取。理想情况下，您应该尽量将磁盘读取的数量保持在最低限度。这可能并非总是可能的，特别是如果数据库大小远大于服务器内存时。
- en: You may attempt estimating a buffer pool hit ratio, and there are formulas available
    online. However, comparing the two variables’ values is not exactly correct, like
    comparing apples and oranges. If you think that your `Innodb_buffer_pool_reads`
    is too high, it may be worth going through queries running on the system (for
    example, using slow query log) instead of trying to increase the buffer pool size.
    Of course, you should try to keep buffer pool as large as possible to cover most
    or all of the hot data in the database. However, there will still be queries that
    may cause high read I/O through getting pages from disk (and increasing `Innodb_buffer_pool_reads`
    while doing so), and attempting to fix them by increasing the buffer pool size
    even more will provide diminishing returns.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试估算缓冲池命中率，网上有公式可用。然而，比较这两个变量的值并不完全正确，就像比较苹果和橙子一样。如果您认为您的`Innodb_buffer_pool_reads`太高，可能值得检查系统上运行的查询（例如使用慢查询日志），而不是试图增加缓冲池的大小。当然，您应该尽量保持缓冲池尽可能大，以覆盖数据库中的大部分或全部热数据。然而，仍然会有一些查询可能会通过从磁盘获取页面（并增加`Innodb_buffer_pool_reads`）导致高读取I/O，并尝试通过进一步增加缓冲池大小来修复它们将带来递减的回报。
- en: 'Finally, to close our discussion of InnoDB, we’ll move on to transaction and
    locking. A lot of information on both topics was given in [Chapter 6](ch06.xhtml#CH6_TRANSACTION_LOCKING),
    so here we’ll do a brief overview of the related status variables:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们讨论完InnoDB之后，我们将继续讨论事务和锁定。在[第6章](ch06.xhtml#CH6_TRANSACTION_LOCKING)中提供了大量关于这两个主题的信息，因此在这里我们将对相关的状态变量进行简要概述：
- en: Transaction-related command counters
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与事务相关的命令计数器
- en: '`BEGIN`, `COMMIT`, and `ROLLBACK` are all special MySQL commands. Thus, MySQL
    will count the number of times they were executed with `Com_%` status variables:
    `Com_begin`, `Com_commit`, and `Com_rollback`. By looking at these counters you
    can see how many transactions are started explicitly and either committed or rolled
    back.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`BEGIN`、`COMMIT`和`ROLLBACK`都是特殊的MySQL命令。因此，MySQL将使用`Com_%`状态变量计算它们被执行的次数：`Com_begin`、`Com_commit`和`Com_rollback`。通过查看这些计数器，您可以看到显式启动的事务以及提交或回滚的次数。'
- en: Locking-related status variables
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与锁定相关的状态变量
- en: You know by now that InnoDB provides locking with row-level granularity. This
    is a huge improvement over MyISAM’s table-level locking, as the impact of each
    individual lock is minimized. Still, there can be an impact if transactions are
    waiting for each other even for a short time.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道InnoDB提供了以行级粒度的锁定。这是比MyISAM的表级锁定有了巨大的改进，因为每个单独锁的影响被最小化了。尽管如此，如果事务彼此等待甚至很短时间，仍然可能会有影响。
- en: 'InnoDB provides status variables that let you see just how many locks are being
    created and give you details on the lock waits that are happening:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB提供了一些状态变量，让您可以看到正在创建的锁的数量，并提供关于正在发生的锁等待的详细信息：
- en: '`Innodb_row_lock_current_waits` shows how many transactions operating on InnoDB
    tables are currently waiting for a lock to be released by some other transactions.
    The value of this variable will go up from zero when there are blocked sessions
    then go back to zero as soon as locking is resolved.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_row_lock_current_waits`显示目前正在等待由其他事务释放的锁的操作InnoDB表上的事务数。当有阻塞会话时，此变量的值会从零上升，然后在锁定解决后立即返回零。'
- en: '`Innodb_row_lock_waits` shows how many times since server startup transactions
    on InnoDB tables have waited for row-level locks. This variable is a counter and
    will continually increase until MySQL Server is restarted.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_row_lock_waits`显示自服务器启动以来，在InnoDB表上的事务等待行级锁的次数。此变量是一个计数器，将在MySQL服务器重新启动之前持续增加。'
- en: '`Innodb_row_lock_time` shows the total time in milliseconds spent by sessions
    trying to acquire locks on InnoDB tables.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_row_lock_time`显示了会话尝试在InnoDB表上获取锁所花费的总毫秒数。'
- en: '`Innodb_row_lock_time_avg` shows an average time in milliseconds that it takes
    for a session to acquire a row-level lock on an InnoDB table. You can arrive at
    the same value by dividing `Innodb_row_lock_time` by `Innodb_row_lock_waits`.
    This value may go up and down depending on how many lock waits are encountered
    and how much accumulated lock time grows.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_row_lock_time_avg` 显示会话在获取 InnoDB 表上行级锁定时的平均时间（以毫秒为单位）。您可以通过将`Innodb_row_lock_time`除以`Innodb_row_lock_waits`来得到相同的值。这个值可能会上下波动，这取决于遇到多少锁等待以及累积锁时间的增长。'
- en: '`Innodb_row_lock_time_max` shows the maximum time in milliseconds it took to
    obtain a lock on an InnoDB table. This value will go up only if the record is
    broken by some other unfortunate transaction.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Innodb_row_lock_time_max` 显示获取 InnoDB 表上锁的最长时间（以毫秒为单位）。只有在某些不幸的事务打破了记录时，这个值才会增加。'
- en: 'Here’s an example from a MySQL server running a moderate read/write load:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行中等读写负载的 MySQL 服务器的示例：
- en: '[PRE30]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There were 2,226 individual transactions waiting for locks, and it took 367,465
    milliseconds to obtain all of those locks, with an average lock acquisition duration
    of 165 milliseconds and a maximum duration of just over 51 seconds. There are
    currently no sessions waiting for locks. On its own this information doesn’t tell
    us much: it’s neither a lot nor a little. However, we know that at the same time
    more than 100,000 transactions were executed by this MySQL server. The resulting
    locking metric values are more than reasonable for the level of concurrency.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有 2,226 个单独的事务等待锁，获取所有这些锁共耗时 367,465 毫秒，平均锁获取持续时间为 165 毫秒，最长持续时间略超过 51 秒。当前没有会话在等待锁。单独这些信息并不能告诉我们太多：既不多也不少。但是，我们知道与此同时，这个
    MySQL 服务器执行了超过 100,000 个事务。由此产生的锁定度量值对并发级别来说是合理的。
- en: Locking issues are a frequent source of headache for database administrators
    and application developers alike. While these metrics, like everything we’ve discussed
    so far, are aggregated across every session running, deviation from the normal
    values may help you in pinning down some of the issues. To find and investigate
    individual locking situations, you may use the InnoDB status report; see [“InnoDB
    Engine Status Report”](#MONITORING_MYSQL_SEIS) for more details.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定问题是数据库管理员和应用程序开发人员头疼的常见来源。尽管这些指标，如我们迄今讨论的一切，都是跨每个正在运行的会话进行的汇总，但与正常值的偏差可能有助于您找出其中的一些问题。要查找和调查单个锁定情况，您可以使用
    InnoDB 状态报告；有关更多详细信息，请参阅 [“InnoDB 引擎状态报告”](#MONITORING_MYSQL_SEIS)。
- en: The Slow Query Log
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 慢查询日志
- en: 'In [“Query types and quality”](#MONITORING_MYSQL_RECIPES_QUERYTYPES) we showed
    how to look for tell-tale signs of unoptimized queries in MySQL. However, that’s
    not enough to start optimizing those queries. We need specific examples. There
    are few ways to do that, but probably the most robust one is using the slow query
    log facility. The slow query log is exactly what it sounds like: a special text
    log where MySQL puts information about *slow* queries. Just how slow those queries
    should be is controllable, and you can go as far as logging every query.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“查询类型和质量”](#MONITORING_MYSQL_RECIPES_QUERYTYPES) 中，我们展示了如何查找 MySQL 中未经优化的查询的显著标志。然而，这还不足以开始优化这些查询。我们需要具体的示例。有几种方法可以做到这一点，但可能最强大的方法是使用慢查询日志功能。慢查询日志正是其字面意思：MySQL
    将有关*慢*查询的信息放入一个特殊的文本日志中。可以控制这些查询的慢速程度，并且可以记录每个查询。
- en: To enable the slow query log, you must change the setting of the `slow_query_log`
    system variable to `ON` from its default of `OFF`. By default, when the slow query
    log is enabled, MySQL will log queries taking longer than 10 seconds. That’s configurable
    by changing the `long_query_time` variable, which has a minimum value of 0, meaning
    every query executed by the server will be logged. The log location is controlled
    by the `slow_query_log_file` variable, which defaults to a value of `*hostname*``-slow.log`.
    When the path to the slow query log is relative, meaning it doesn’t start from
    */* on Linux or, for example, *C:\* on Windows, then this file will be located
    in the MySQL data directory.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用慢查询日志，您必须将`slow_query_log`系统变量的设置从默认的`OFF`更改为`ON`。默认情况下，当启用慢查询日志时，MySQL 将记录执行时间超过
    10 秒的查询。这可以通过更改`long_query_time`变量来配置，其最小值为 0，意味着服务器执行的每个查询都将被记录。日志位置由`slow_query_log_file`变量控制，默认值为`*hostname*``-slow.log`。当慢查询日志的路径是相对路径时，即不以
    Linux 上的`/`或 Windows 上的`C:\`开头，那么该文件将位于 MySQL 数据目录中。
- en: You can also tell MySQL to log queries not using indexes regardless of the time
    they take to execute. To do so, the `log_queries_not_using_indexes` variable has
    to be set to `ON`. By default, DDL and administrative statements are not logged,
    but this behavior can be changed by setting `log_slow_admin_statements` to `ON`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以告诉MySQL记录不使用索引的查询，而不管它们执行的时间。为此，`log_queries_not_using_indexes`变量必须设置为`ON`。默认情况下，DDL和管理语句不会被记录，但可以通过将`log_slow_admin_statements`设置为`ON`来更改此行为。
- en: MariaDB and Percona Server expand the functionality of the slow query log by
    adding filtering capabilities, rate limiting, and enhanced verbosity. If you’re
    using those products, it’s worth reading their documentation on the subject to
    see if you can utilize the enhanced slow query log.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB和Percona Server通过添加过滤功能、速率限制和增强的详细性扩展了慢查询日志的功能。如果您正在使用这些产品，值得阅读有关此主题的文档，以查看是否可以利用增强的慢查询日志。
- en: 'Here’s an example from a record in the slow query log showing a `SELECT` statement
    taking longer than the configured `long_query_time` value of 1 second:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是慢查询日志中一条记录的示例，显示一个`SELECT`语句的执行时间超过了配置的`long_query_time`值1秒：
- en: '[PRE32]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By analyzing this output you can immediately start making conclusions about
    this query. This is much more descriptive than looking at server-wide metrics.
    For example, we can see that this query was executed at 17:21:12 UTC by user `root@localhost`
    in the `employees` database, took 1.88 seconds to run, and produced 9 rows but
    had to scan 3,473,725 rows to produce that result. That information on its own
    can tell you a whole lot about the query, especially once you’ve gained more experience
    with MySQL. You now also have the complete query text, which you can turn into
    execution plan information to see exactly how MySQL is executing this query. You
    can find more details on that process in [“The EXPLAIN Statement”](ch07.xhtml#ADV1-SEC-EXPLAIN).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析这个输出，您可以立即开始对这个查询做出结论。这比查看整个服务器的指标要详细得多。例如，我们可以看到这个查询在UTC时间17:21:12由用户`root@localhost`在`employees`数据库中执行，花费了1.88秒，并且生成了9行结果，但需要扫描3,473,725行才能得出这个结果。这些信息本身就可以告诉您很多关于查询的信息，特别是在您对MySQL有了更多经验之后。现在您也可以得到完整的查询文本，您可以将其转换为执行计划信息，以了解MySQL如何执行此查询。您可以在[“EXPLAIN语句”](ch07.xhtml#ADV1-SEC-EXPLAIN)中找到关于该过程的更多详细信息。
- en: 'If the `long_query_time` is set low, the slow query log may grow large. Sometimes
    this may be reasonable, but reading through the resulting log may be nearly impossible
    if the number of queries is high. There’s a tool called `mysqldumpslow` that solves
    this problem. It takes the path to the slow query log file as an argument and
    will summarize queries from that file and sort them (by default by time). In the
    following example, the command is run such that it will show the two top queries
    sorted by the number of rows returned:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`long_query_time`设置得很低，慢查询日志可能会变得很大。有时这可能是合理的，但如果查询数量很大，则阅读生成的日志几乎是不可能的。有一个名为`mysqldumpslow`的工具可以解决这个问题。它将慢查询日志文件的路径作为参数，并会总结和排序查询（默认按时间排序）。在以下示例中，命令被运行以显示按返回的行数排序的前两个查询：
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can see that these two queries alone were recorded in the slow query log
    5,565 times. Imagine trying to get that information without help! Another tool
    that can help with summarizing the information in the slow query log is `pt-query-digest`
    from Percona Toolkit. The tool is a bit more advanced and more difficult to use
    than `mysqldumpslow`, but gives a lot of information and has many features. The
    report it produces starts with a summary:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到仅这两个查询就在慢查询日志中记录了5,565次。试图在没有帮助的情况下获取这些信息的想象力！另一个可以帮助总结慢查询日志中信息的工具是Percona
    Toolkit中的`pt-query-digest`。这个工具更为先进，比`mysqldumpslow`更难使用，但提供了大量信息并具有许多功能。它生成的报告从一个总结开始：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And each query is then summarized as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个查询被总结如下：
- en: '[PRE37]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That’s a lot of valuable information in a dense format. One of the distinguishing
    features of this output is the query duration distribution visualization, which
    allows you to quickly see whether a query has parameter-dependent performance
    issues. Explaining every feature of `pt-query-digest` would take another chapter,
    and it’s an advanced tool, so we leave this for you to try once you’re done learning
    MySQL.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个密集格式中的大量有价值的信息。此输出的一个显著特征之一是查询持续时间分布的可视化，这使您可以快速查看查询是否存在依赖参数的性能问题。解释`pt-query-digest`的每个功能将需要另一章，这是一个高级工具，所以我们留给您在学习MySQL完成后尝试。
- en: 'The slow query log is a powerful tool that allows you to get a very detailed
    view of the queries executed by MySQL Server. We recommend using the slow query
    log like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 慢查询日志是一个强大的工具，可以让您详细查看MySQL服务器执行的查询。我们建议如下使用慢查询日志：
- en: Set `long_query_time` to a value large enough that it covers most of the queries
    normally running in your system, but small enough that you catch outliers. For
    example, in an OLTP system, where most of the queries are expected to complete
    in milliseconds, a value of `0.5` may be reasonable, only catching relatively
    slow queries. On the other hand, if your system has queries running in minutes,
    then `long_query_time` should be set accordingly.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`long_query_time`设置为一个足以覆盖系统中正常运行的大多数查询的值，但足够小以捕获异常情况。例如，在OLTP系统中，大多数查询预计在毫秒内完成，`0.5`可能是合理的值，仅捕获相对较慢的查询。另一方面，如果系统中的查询需要几分钟才能完成，那么应相应地设置`long_query_time`。
- en: Logging to the slow query log has some performance cost, and you should avoid
    logging more queries than you need. If you have the slow query log enabled, make
    sure you adjust the `long_query_time` setting if you find the log too noisy.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到慢查询日志会带来一定的性能成本，您应避免记录比需要的更多查询。如果启用了慢查询日志，请确保在日志过于喧闹时调整`long_query_time`设置。
- en: Sometimes you may want to perform a “query audit,” where you temporarily (for
    a few minutes) set `long_query_time` to `0` to catch every query. This is a good
    way to get a snapshot of your database load. Such snapshots may be saved and compared
    later. However, we recommend strongly against setting `long_query_time` too low.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时您可能想进行“查询审计”，在此期间（几分钟内）将`long_query_time`临时设置为`0`以捕获每个查询。这是获取数据库负载快照的好方法。这些快照可以保存并稍后进行比较。但我们强烈建议不要将`long_query_time`设置得太低。
- en: If you have the slow query log set up, we recommend running `mysqldumpslow`,
    `pt-query-digest`, or a similar tool on it periodically to see if there are new
    queries appearing or if existing ones start behaving worse than usual.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经设置了慢查询日志，我们建议定期运行`mysqldumpslow`、`pt-query-digest`或类似工具，以查看是否出现新查询或现有查询表现比平常更差。
- en: InnoDB Engine Status Report
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: InnoDB引擎状态报告
- en: The InnoDB storage engine has a built-in report that exposes deep technical
    details on the current state of the engine. A lot can be said about InnoDB load
    and performance from reading just this one report, ideally sampled over time.
    Reading the InnoDB status report is an advanced topic that requires more instruction
    than we can convey in our book, and also a lot of practice. Still, we believe
    you should know that this report exists, and we’ll give you some hints as to what
    to look for there.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB存储引擎具有内置报告，可以深入了解引擎的当前状态的技术细节。仅通过阅读此报告，就可以对InnoDB的负载和性能做出很多评价。阅读InnoDB状态报告是一个高级主题，需要比我们的书中能传达的更多指导，还需要大量实践。但我们仍然认为您应该知道此报告的存在，并为您提供一些查找内容的提示。
- en: 'To view the report, you need to run only a single command. We recommend using
    the vertical result display:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看报告，只需运行一个命令。我们建议使用垂直结果显示：
- en: '[PRE38]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output, which we’ve truncated here, is presented broken down in sections.
    At first, it may seem intimidating, but over time you will come to appreciate
    the details. For now, we’ll walk through a few sections that we believe provide
    information that will benefit operators of any experience level:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在此处被截断，以部分展示。它以各个部分的方式呈现。起初可能显得令人畏惧，但随着时间的推移，您将开始欣赏这些细节。现在，我们将逐步介绍几个部分，我们相信这些信息将使任何经验水平的操作者受益：
- en: Transactions
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 事务
- en: 'This section provides information about the transactions of every session,
    including duration, current query, number of locks held, and information on lock
    waits. You can also find some data here on transaction visibility, but that’s
    rarely required. Usually, you want to look at the transactions section to see
    the current state of transactions active within InnoDB. A sample record from this
    section looks like this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分提供有关每个会话的事务信息，包括持续时间、当前查询、持有的锁数以及锁等待信息。您还可以在此处找到一些关于事务可见性的数据，但这很少需要。通常，您希望查看事务部分，以查看InnoDB中活动事务的当前状态。此部分的示例记录如下：
- en: '[PRE40]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This tells us that the transaction is currently waiting for a `COMMIT` to finish
    it holds three row locks, and it’s pretty fast, likely to finish in under a second.
    Sometimes, you will see long transactions here: you should try to avoid those.
    InnoDB does not handle long transactions well, and even an idle transaction staying
    open for too long can cause a performance impact.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，事务当前正在等待 `COMMIT` 完成，它持有三个行锁，并且非常快，可能在一秒钟内就能完成。有时，在这里你会看到长时间的事务：你应该尽量避免这种情况。InnoDB
    无法很好地处理长时间的事务，即使是空闲事务保持打开状态太长时间也会对性能造成影响。
- en: 'This section will also show you information on the current locking behavior
    if there are transactions waiting to obtain locks. Here’s an example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有事务在等待获取锁，本节还会显示当前的锁定行为信息。这里有一个例子：
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Unfortunately, the status report doesn’t point at the lock holder directly,
    so you’ll need to look for blocking transactions separately. Some information
    on that is available in [Chapter 6](ch06.xhtml#CH6_TRANSACTION_LOCKING). Usually,
    if you see one transaction active while others are waiting, it’s a good indication
    that it’s that active transaction that’s holding the locks.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，状态报告并没有直接指出锁的持有者，因此你需要单独查找阻塞事务的信息。关于这方面的一些信息可以在 [第六章](ch06.xhtml#CH6_TRANSACTION_LOCKING)
    中找到。通常，如果你看到一个事务在活动，而其他事务在等待，这是一个很好的指示，表明是这个活动事务在持有锁。
- en: File I/O
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 I/O
- en: This section contains information on the current I/O operations, as well as
    aggregated summaries over time. We discussed this in more detail in [“InnoDB I/O
    and transaction metrics”](#innodb-subsection), but this is an additional way of
    checking whether InnoDB has pending data and log operations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含当前 I/O 操作的信息，以及随时间的汇总摘要。我们在 [“InnoDB I/O 和事务度量”](#innodb-subsection) 中详细讨论了这一点，但这是另一种检查
    InnoDB 是否有未决数据和日志操作的方式。
- en: Buffer pool and memory
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲池和内存
- en: 'In this section InnoDB prints information about its buffer pool and memory
    usage. If you have multiple buffer pool instances configured, then this section
    will show both totals and per-instance breakdowns. There’s a lot of information,
    including on the buffer pool size and the internal state of the buffer pool:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，InnoDB 打印关于其缓冲池和内存使用情况的信息。如果配置了多个缓冲池实例，那么这一部分将显示总量和每个实例的详细信息。这里有很多信息，包括缓冲池大小和缓冲池的内部状态：
- en: '[PRE42]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These are also exposed as `Innodb_buffer_pool_%` variables.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也作为 `Innodb_buffer_pool_%` 变量公开。
- en: Semaphores
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量
- en: This section includes information on internal InnoDB semaphores, or synchronization
    primitives. In basic terms, *semaphores* are special internal in-memory structures
    that allow multiple threads to operate without interfering with each other. You
    will rarely see anything of value in this section unless there’s semaphore contention
    on your system. Usually that happens when InnoDB is put under extreme load, so
    every operation takes longer, and there are more chances to see active semaphore
    waits in the status output.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括关于内部 InnoDB 信号量或同步原语的信息。简单来说，*信号量* 是允许多个线程在不相互干扰的情况下操作的特殊内部内存结构。除非系统存在信号量争用，否则在这一部分很少会看到有价值的内容。通常情况下，这种情况发生在
    InnoDB 承受极端负载时，因此每个操作都需要更长的时间，状态输出中有更多机会看到活跃的信号量等待。
- en: Investigation Methods
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查方法
- en: Having so many available metrics that need to be monitored, checked, and understood
    may cause your head to spin. You may notice that we haven’t defined a single metric
    that has a definite range from good to bad. Is the locking bad? Could be, but
    it’s also expected and normal. The same can be said about almost every aspect
    of MySQL, with the exception of server availability.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多可用的需要监控、检查和理解的度量标准，可能会让你头晕。你可能注意到，我们并没有定义一个单一的度量标准，从好到坏都有明确的范围。锁定是否不好？可能是，但这也是预期和正常的。关于
    MySQL 的几乎每个方面都可以这样说，除了服务器的可用性。
- en: This problem is not unique to MySQL server monitoring, and in fact it’s common
    for any complex system. There are a lot of metrics, complicated dependencies,
    and almost no strictly definable rules for whether something is good or bad. To
    solve this problem, we need some approach, some methodology that we can apply
    to abundant data to quickly and easily come to conclusions about current system
    performance.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题并不局限于 MySQL 服务器监控，事实上，任何复杂系统都存在类似的情况。有大量的度量标准、复杂的依赖关系，几乎没有严格可定义的规则来判断某些事物是好是坏。为了解决这个问题，我们需要一些方法，一些方法论，可以应用于丰富的数据，快速轻松地得出关于当前系统性能的结论。
- en: Luckily, such methodologies already exist. In this section, we will briefly
    describe two of them and give ideas on how to apply them to monitoring MySQL and
    OS metrics.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这样的方法论已经存在。在本节中，我们将简要描述其中的两种，并提出如何将它们应用于监控MySQL和操作系统指标的想法。
- en: The USE Method
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USE方法
- en: The Utilization, Saturation, and Errors (USE) method, popularized by Brendan
    Gregg, is a general-purpose methodology that can be applied to any system. Though
    better suited for resources with well-defined performance characteristics like
    CPU or disk, it can also be applied to some parts of MySQL.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 利用率、饱和度和错误（USE）方法由Brendan Gregg推广，是一种通用的方法论，可以应用于任何系统。虽然更适合具有明确定义性能特征的资源如CPU或磁盘，但也可以应用于MySQL的某些部分。
- en: 'The USE method is best used by creating a checklist for each individual part
    of the system. First, we need to define what metrics to use to measure utilization,
    saturation, and errors. Some example checklists for Linux can be found on the
    USE homepage: [Gregg’s website](https://oreil.ly/MeF2B).'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用USE方法最好通过为系统的每个独立部分创建检查表来实现。首先，我们需要定义用于衡量利用率、饱和度和错误的指标。Linux的一些示例检查表可以在USE首页找到：[Gregg的网站](https://oreil.ly/MeF2B)。
- en: 'Let’s look at the three different categories for the example of disk I/O:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看磁盘I/O示例的三个不同类别：
- en: Utilization
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 利用率
- en: 'For a disk subsystem, as we’ve laid out in [“Disk”](#MONITORING_OS_DISK), we
    might look at metrics for any:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对于磁盘子系统，正如我们在[“磁盘”](#MONITORING_OS_DISK)中所述，我们可能会查看任何以下指标：
- en: Overall storage bandwidth utilization
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体存储带宽利用率
- en: Per-process storage bandwidth utilization
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程的存储带宽利用率
- en: Current IOPS (where the upper IOPS limit for the device is known)
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前IOPS（已知设备的IOPS上限）
- en: Saturation
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和度
- en: We mentioned saturation when talking about the `iostat` output and disk metrics.
    It’s a measure of work that the resource cannot process and that is usually queued.
    For disk, this is expressed as the I/O request queue size (`avgqu-sz` in `iostat`
    output). On most systems, values >1 mean the disk is saturated, and thus some
    requests will be queued and waste time doing nothing.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论`iostat`输出和磁盘指标时提到了饱和度。这是资源无法处理的工作量的度量，并且通常是排队的。对于磁盘，这表现为I/O请求队列大小（`iostat`输出中的`avgqu-sz`）。在大多数系统上，值大于1意味着磁盘已饱和，因此某些请求将排队，并浪费时间无所作为。
- en: Errors
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: For disk devices, this may mean I/O errors due to hardware degradation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 对于磁盘设备，这可能意味着由于硬件退化导致的I/O错误。
- en: 'The problem with the USE method is that it’s difficult to apply to a complex
    system as a whole. Take MySQL, for example: what metrics could we use to measure
    overall utilization, saturation, and errors? Some attempts can be made to apply
    USE to MySQL as a whole, but it’s much better suited to use on some isolated parts
    of the system.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用USE方法的问题在于，将其应用于整个复杂系统是困难的。以MySQL为例：我们可以使用哪些指标来衡量总体利用率、饱和度和错误？可以尝试将USE方法应用于MySQL整体，但更适合用于系统的某些独立部分。
- en: 'Let’s take a look at some possible MySQL applications:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些可能的MySQL应用：
- en: USE method for client connections
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 用于客户端连接的USE方法
- en: A good fit for the USE method is making sense of the client connection metrics
    we discussed in [“Basic Monitoring Recipes”](#MONITORING_MYSQL_RECIPES).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 用于USE方法的一个很好的例子是理解我们在[“基本监控配方”](#MONITORING_MYSQL_RECIPES)中讨论的客户端连接指标。
- en: Utilization metrics include the `Threads_connected` and `Threads_running`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 利用率指标包括`Threads_connected`和`Threads_running`。
- en: Saturation can be defined arbitrarily based on `Threads_running`. For example,
    in an OLTP system that is read-heavy and doesn’t generate a lot of I/O, a saturation
    point for `Threads_running` will likely be around the number of available CPU
    cores. In a system that is mostly I/O-bound, a starting point could be twice the
    available CPU cores, but it’s much better to find what number of concurrently
    running threads start to saturate the storage subsystem.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和度可以根据`Threads_running`任意定义。例如，在读密集且不生成大量I/O的OLTP系统中，`Threads_running`的饱和点可能接近可用CPU核心数。在大多数I/O绑定系统中，起始点可能是两倍的可用CPU核心数，但最好找出同时运行的线程数量，开始饱和存储子系统。
- en: Errors are measured by the `Aborted_clients` and `Aborted_connects` metrics.
    Once the value of the `Threads_connected` status variable becomes equal to that
    of the `max_connections` system variable, requests to create new connections will
    be declined, and clients will get errors. Connections can also fail for other
    reasons, and existing clients may be terminating their connections uncleanly without
    waiting for MySQL to respond.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 错误通过 `Aborted_clients` 和 `Aborted_connects` 指标来衡量。一旦 `Threads_connected` 状态变量的值等于
    `max_connections` 系统变量的值，将拒绝创建新连接的请求，并且客户端将收到错误。连接也可能由于其他原因失败，并且现有客户端可能未等待 MySQL
    响应就不干净地终止其连接。
- en: USE method for transactions and locking
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 事务和锁定的 USE 方法
- en: Another example of how USE can be applied is to look at the InnoDB locking-related
    metrics relative to the number of queries processed by the system.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用 USE 方法的例子是查看与系统处理的查询数量相关的 InnoDB 锁定相关指标。
- en: Utilization can be measured using the synthetic QPS metric we defined earlier.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 利用率可以使用我们之前定义的合成 QPS 指标来衡量。
- en: Saturation can be the fact that there’s some number of lock waits occurring.
    Remember, by the USE definition, saturation is a measure of work that cannot be
    performed and has to wait in the queue. There’s no queue here, but transactions
    are waiting for locks to be acquired. Alternatively, the regular amount of lock
    waits can be multiplied twofold to construct an arbitrary threshold, or better
    yet, some experiments can be performed to find a number of lock waits relative
    to QPS that result in lock timeouts occurring.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 饱和度可能是一定数量的锁等待正在发生。请记住，根据 USE 定义，饱和度是无法执行的工作的衡量，并且必须在队列中等待。这里没有队列，但事务正在等待获取锁。或者，可以将常规锁等待量乘以两倍来构建任意阈值，或者更好地，可以执行一些实验，找出与
    QPS 相对应的锁等待数量，导致发生锁等待超时。
- en: Errors can be measured as the number of times sessions timed out waiting for
    locks or were terminated to resolve a deadlock situation. Unlike the previously
    mentioned metrics, these two are not exposed as global status variables, but can
    instead be found in the `information_schema.innodb_metrics` table under `lock_deadlocks`
    (number of deadlocks registered) and `lock_timeouts` (number of times lock waits
    timed out).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可以通过会话超时等待锁或终止以解决死锁情况的次数来衡量。与前面提到的指标不同，这两者不是作为全局状态变量公开的，而是可以在 `information_schema.innodb_metrics`
    表中找到，其中 `lock_deadlocks` 表示死锁注册数量，`lock_timeouts` 表示锁等待超时次数。
- en: Determining the rate of errors from monitoring metrics alone can be difficult,
    so frequently just the US part of USE is used. As you can see, this method allows
    us to look at the system from a predefined point of view. Instead of analyzing
    every possible metric when there’s an incident, an existing checklist can be reviewed,
    saving time and effort.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过监控指标确定错误率可能很困难，因此通常仅使用 USE 方法中的 US 部分。正如您所见，此方法允许我们从预定义的视角查看系统。在发生事件时，可以审查现有的检查表，而不是分析每个可能的指标，从而节省时间和精力。
- en: RED Method
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RED 方法
- en: The Rate, Errors, and Duration (RED) method was created to address the shortcomings
    of USE. The methodology is similar, but it’s is easier to apply to complex systems
    and services.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Rate, Errors, and Duration (RED) 方法是为了解决 USE 方法的缺点而创建的。该方法类似，但更容易应用于复杂的系统和服务。
- en: 'The logical application of RED to MySQL is done by looking at query performance:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RED 方法逻辑应用于 MySQL 是通过查看查询性能来完成的：
- en: Rate
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 速率
- en: QPS of the database
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的每秒查询率
- en: Errors
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: Number or rate of errors and failing queries
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和失败查询的数量或速率
- en: Duration
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间
- en: Average query latency
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 平均查询延迟
- en: One problem with RED in the context of this book and learning MySQL in general
    is that applying this method requires monitoring data that can’t be obtained just
    by reading status variables. Not every existing monitoring solution for MySQL
    can provide the necessary data, either, though you can see an example of how it’s
    done in the blog post [“RED Method for MySQL Performance Analyses”](https://oreil.ly/TVT2x)
    by Peter Zaitsev. One way to apply RED to MySQL or any other database system is
    by looking at the metrics from the application side instead of from the database
    side. Multiple monitoring solutions allow you to instrument (manually or automatically)
    your applications to capture data such as number of queries, rate of failures,
    and query latency. Just what’s needed for RED!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: RED在本书和一般MySQL学习的背景下的一个问题是，应用此方法需要监控无法仅通过读取状态变量获得的数据。尽管并非每个现有的MySQL监控解决方案都能提供所需的数据，您可以在Peter
    Zaitsev的博客文章[“RED方法用于MySQL性能分析”](https://oreil.ly/TVT2x)中看到其操作方法的示例。将RED应用于MySQL或任何其他数据库系统的一种方法是从应用程序的角度而不是数据库的角度查看度量指标。多种监控解决方案允许您手动或自动地为应用程序提供数据，例如查询数量、失败率和查询延迟。这正是RED所需的内容！
- en: 'You can, and should, use RED and USE together. In the article explaining RED,
    [The RED Method: How to Instrument Your Services](https://oreil.ly/dHHMS), its
    author Tom Wilkie mentions that “It’s really just two different views on the same
    system.”'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以同时使用RED和USE。在解释RED的文章中，[RED方法：如何为您的服务进行仪表化](https://oreil.ly/dHHMS)，其作者汤姆·威尔基提到：“这实际上只是同一系统的两种不同视角。”
- en: One perhaps unexpected benefit of applying RED, USE, or any other method is
    that you do so before an incident happens. Thus, you are forced to understand
    what it is you monitor and measure and how that relates to what actually matters
    for your system and its users.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 应用RED、USE或任何其他方法的一个可能意想不到的好处是，在事故发生之前就这样做。因此，您被迫理解您要监控和测量的内容，以及这与您的系统及其用户实际关心的内容的关系。
- en: MySQL Monitoring Tools
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL监控工具
- en: 'Throughout this chapter we’ve been talking about metrics and monitoring methodologies,
    but we haven’t mentioned a single actual tool that can turn those metrics into
    dashboards or alerts. In other words, we haven’t talked about the actual monitoring
    tools and systems. The first reason for that is simple enough: we believe that
    in the beginning it’s much more important for you to know *what* to monitor and
    *why*, rather than *how*. If we’d concentrated on the *how*, we could have spent
    this whole chapter talking about the peculiarities and differences of various
    monitoring tools. The second reason is that MySQL and OS metrics don’t change
    often, but if you’re reading this book in 2025, our choice of monitoring tools
    may already seem antiquated.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们一直在讨论度量和监控方法，但我们还没有提到可以将这些度量转化为仪表板或警报的任何实际工具。换句话说，我们还没有讨论实际的监控工具和系统。这其中的第一个原因很简单：我们认为在开始阶段，了解*什么*需要监控以及*为什么*比*如何*更为重要。如果我们集中讨论*如何*，我们可能会用整章的篇幅来讲解各种监控工具的特点和差异。第二个原因是，MySQL
    和操作系统的度量指标并不经常变化，但如果你在 2025 年阅读本书，我们选择的监控工具可能已经显得过时。
- en: 'Nevertheless, as a starting point we’ve put together a list of notable popular
    open source monitoring tools that can be used to monitor MySQL availability and
    performance. We’re not going to go too deep into the specifics of their setup
    or configuration, or into comparing them. We cannot also list every possible monitoring
    solution available: brief research shows us that almost anything that is a “monitoring
    tool” or “monitoring system” can monitor MySQL in some way. We’re also not covering
    non–open source and non-free monitoring solutions, with the one exception of the
    Oracle Enterprise Monitor. We hold nothing against such systems in general, and
    a lot of them are great. Most of them, though, have excellent documentation and
    support available, so you should be able to get familiar with them quickly.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，作为一个起点，我们已经整理了一个可以用于监控MySQL可用性和性能的知名开源监控工具列表。我们不会深入讨论其设置或配置的具体细节，也不会进行比较。我们也无法列出所有可能的监控解决方案：简短的研究显示，几乎所有被称为“监控工具”或“监控系统”的东西都可以以某种方式监控MySQL。我们也不涵盖非开源和非免费的监控解决方案，Oracle
    Enterprise Monitor是唯一的例外。总体而言，我们对这类系统并不持有任何成见，它们中的大多数都非常出色。但其中大多数都有出色的文档和支持可用，因此您应该能够迅速熟悉它们。
- en: 'The following monitoring systems will be mentioned here:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将提到以下监控系统：
- en: Prometheus
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: InfluxDB and TICK stack
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InfluxDB 和 TICK 堆栈
- en: Zabbix
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zabbix
- en: Nagios Core
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nagios 核心
- en: Percona Monitoring and Management
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Percona 监控与管理
- en: Oracle Enterprise Monitor
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle 企业监控
- en: 'We’ll start with Prometheus and InfluxDB and its TICK stack. Both of these
    systems are a modern take on monitoring, well suited to monitoring microservices
    and vast cloud deployments, but are also widely used as general-purpose monitoring
    solutions:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Prometheus 和 InfluxDB 及其 TICK 栈开始。这两个系统都是监控的现代化解决方案，非常适合监控微服务和广泛的云部署，但也广泛用作通用监控解决方案：
- en: Prometheus
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus
- en: Born out of Google’s internal monitoring system Borgmon, [Prometheus](https://oreil.ly/em47V)
    is an extremely popular general-purpose monitoring and alerting system. At its
    core is a time-series database and a data-gathering engine based around a pull
    model. What that means is that it’s the Prometheus server that actively gathers
    data from its monitoring targets.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 诞生于谷歌内部监控系统 Borgmon 的 [Prometheus](https://oreil.ly/em47V) 是一个极其流行的通用监控和警报系统。其核心是一个时间序列数据库和基于拉取模型的数据收集引擎。这意味着是
    Prometheus 服务器积极从其监控目标获取数据。
- en: 'Actual data gathering from Prometheus targets is performed by special programs
    called *exporters*. Exporters are purpose-built: there’s a dedicated MySQL exporter,
    a PostgreSQL exporter, a basic OS metrics/node exporter, and many more. What these
    programs do is collect metrics from the system they are written to monitor and
    present those metrics in a format suitable for the Prometheus server to consume.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 实际从 Prometheus 目标收集数据的是称为 *导出器* 的特殊程序。导出器专为特定用途构建：有专用的 MySQL 导出器、PostgreSQL
    导出器、基本的操作系统指标/节点导出器等。这些程序的功能是从它们被设计监控的系统收集指标，并以适合 Prometheus 服务器消费的格式呈现这些指标。
- en: MySQL monitoring with Prometheus is done by running the [`mysqld_exporter` program](https://oreil.ly/tvltY).
    Like most parts of Prometheus ecosystem, it’s written in Go and is available for
    Linux, Windows, and many other operating systems, making it a good choice for
    a heterogeneous environment.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prometheus 进行 MySQL 监控是通过运行 [`mysqld_exporter` 程序](https://oreil.ly/tvltY)
    完成的。像 Prometheus 生态系统的大多数部分一样，它是用 Go 编写的，并适用于 Linux、Windows 和许多其他操作系统，使其成为异构环境的良好选择。
- en: The MySQL exporter gathers all the metrics we’ve covered in this chapter (and
    many more!), and since it actively tries to get information from MySQL, it can
    also report on the MySQL server’s availability. In addition to standard metrics,
    it is possible to supply custom queries that exporter will execute, turning their
    results into additional metrics.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 导出器收集了本章涵盖的所有指标（以及更多！），由于它积极尝试从 MySQL 获取信息，因此它还可以报告 MySQL 服务器的可用性。除了标准指标外，还可以提供自定义查询，导出器将执行这些查询，并将结果转换为额外的指标。
- en: Prometheus offers only very basic visualization capabilities, so the [Grafana
    analytics and data visualization web application](https://oreil.ly/YAIpl) is usually
    added to the setup.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 提供的仅是非常基本的可视化功能，因此通常会添加 [Grafana 分析与数据可视化 Web 应用](https://oreil.ly/YAIpl)
    到设置中。
- en: InfluxDB and the TICK stack
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: InfluxDB 和 TICK 栈
- en: Built around the [InfluxDB time-series database](https://oreil.ly/jv0ZC), TICK,
    standing for Telegraf, InfluxDB, Chronograf, and Kapacitor, is a complete time-series
    and monitoring platform. Comparing this to Prometheus, Telegraf takes the place
    of the exporters; it’s a unified program that is capable of monitoring a multitude
    of targets. Unlike exporters, Telegraf actively pushes data to InfluxDB instead
    of data being pulled by the server. Chronograf is an administrative and data interface.
    Kapacitor is a data processing and alerting engine.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 [InfluxDB 时间序列数据库](https://oreil.ly/jv0ZC)，TICK，代表 Telegraf、InfluxDB、Chronograf
    和 Kapacitor，是一个完整的时间序列和监控平台。与 Prometheus 相比，Telegraf 取代了导出器；它是一个统一的程序，能够监控多种目标。与导出器不同，Telegraf
    将数据主动推送到 InfluxDB 而不是由服务器拉取数据。Chronograf 是管理和数据界面。Kapacitor 是数据处理和警报引擎。
- en: Where you had to install a dedicated exporter for MySQL, Telegraf is extended
    using plugins. The [MySQL plugin](https://oreil.ly/ciQVF) is part of a standard
    bundle and provides a detailed overview of MySQL database metrics. Unfortunately,
    it is not capable of running arbitrary queries, so extensibility is limited. As
    a workaround, the [`exec` plugin](https://oreil.ly/83QgS) can be used. Telegraf
    is also a multiplatform program, and it does support Windows among other OSs.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 需要安装专用导出器的情况下，Telegraf 使用插件进行扩展。[MySQL 插件](https://oreil.ly/ciQVF) 是标准捆绑包的一部分，提供了
    MySQL 数据库指标的详细概述。不幸的是，它不能运行任意查询，因此扩展性有限。作为一种变通方法，可以使用 [`exec` 插件](https://oreil.ly/83QgS)。Telegraf
    还是一个多平台程序，支持 Windows 等其他操作系统。
- en: The TICK stack is frequently used in part, with Grafana added to InfluxDB and
    Telegraf.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: TICK堆栈经常部分使用，与Grafana一起添加到InfluxDB和Telegraf。
- en: A common thread between Prometheus and TICK is that they are collections of
    building blocks allowing you to build your own monitoring solution. Neither of
    them offers any out-of-the-box recipes for dashboards, alerting, and so forth.
    They are powerful, but they may require some getting used to. Apart from that,
    they are very automation- and infrastructure-as-code-oriented. Prometheus especially,
    but TICK as well, provides a minimal GUI and was not initially conceived for data
    exploration and visualization. It’s monitoring as in reacting to metric value
    changes by alerting, not by visually inspecting various metrics. Adding Grafana
    to the equation, especially with either home-brewed or community dashboards for
    MySQL, makes visual inspection possible. Still, most of the configuration and
    setup will not be done in a GUI.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus和TICK的一个共同特点是它们是一组构建模块，允许您构建自己的监控解决方案。它们都没有提供现成的仪表板、警报等解决方案。它们非常强大，但可能需要一些时间适应。除此之外，它们都非常注重自动化和基础设施即代码。特别是Prometheus，但TICK同样如此，提供了一个简约的GUI，最初并不是为数据探索和可视化而设计。它的监控方式是通过警报来响应指标值的变化，而不是通过视觉检查各种指标。将Grafana加入其中，特别是使用自制或社区的MySQL仪表板，可以实现可视化检查。然而，大部分配置和设置并不在GUI中完成。
- en: Both of these systems saw an influx in popularity in the mid- and late-2010s,
    with the shift to running a multitude of small servers compared to running a few
    large servers. That shift required some changes in monitoring approaches, and
    these systems became almost the de facto standard monitoring solutions for a lot
    of companies.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统在2010年中后期迎来了流行度激增，随着从少数大型服务器转向运行大量小服务器的变化。这种转变要求调整监控方法，这些系统几乎成为了许多公司的事实标准监控解决方案。
- en: 'Next in our review are a couple of more “old-school” monitoring solutions:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来看几种更“老派”的监控解决方案：
- en: Zabbix
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Zabbix
- en: A completely free and open source monitoring system first released in 2001,
    [Zabbix](https://oreil.ly/ZLi1Q) is proven and powerful. It supports a wide range
    of monitored targets and advanced auto-discovery and alerting capabilities.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一款完全免费且开源的监控系统，于2001年首次发布，[Zabbix](https://oreil.ly/ZLi1Q)经过验证且功能强大。它支持广泛的监控目标、高级自动发现和警报功能。
- en: MySQL monitoring with Zabbix can be done by using plugins or with the official
    [MySQL templates](https://oreil.ly/GMgSo). Metrics coverage is quite good, with
    every recipe we defined available. However, both `mysqld_exporter` and Telegraf
    offer more data. The standard MySQL metrics Zabbix collects are sufficient to
    set up basic MySQL monitoring, but for deeper insight you will need to go custom
    or use some of the community templates and plugins.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Zabbix可以通过插件或官方[MySQL模板](https://oreil.ly/GMgSo)进行MySQL监控。Zabbix收集的标准MySQL指标覆盖范围相当广泛，包括我们定义的每个配置。然而，`mysqld_exporter`和Telegraf提供了更多数据。标准MySQL指标Zabbix收集足以设置基本的MySQL监控，但如需深入了解，则需要自定义或使用一些社区模板和插件。
- en: The Zabbix agent is cross-platform, so you can monitor MySQL running on almost
    any OS.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Zabbix代理是跨平台的，因此您可以监控几乎任何操作系统上运行的MySQL。
- en: While Zabbix offers quite powerful alerting, its visualization capabilities
    may feel slightly dated. It is possible to set up custom dashboards based on MySQL
    data, and it’s also possible to use Zabbix as a data source for Grafana.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Zabbix提供了相当强大的警报功能，但其可视化能力可能略显陈旧。可以基于MySQL数据设置自定义仪表板，并且可以将Zabbix用作Grafana的数据源。
- en: Zabbix is fully configurable through its GUI. The commercial offering includes
    various levels of support and consulting.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Zabbix可以通过其GUI进行完全配置。商业版提供了各种支持和咨询服务级别。
- en: Nagios Core
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios Core
- en: Like Zabbix, [Nagios](https://oreil.ly/jwE5S) is a veteran monitoring system,
    with its first release seeing light in 2002\. Unlike other systems we’ve seen
    so far, Nagios is an “open core” system. The Nagios Core distribution is free
    and open source, but there’s also a commercial Nagios system.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 与Zabbix类似，[Nagios](https://oreil.ly/jwE5S)是一款老牌的监控系统，首次发布于2002年。与迄今为止我们看到的其他系统不同，Nagios是一个“开放核心”系统。Nagios
    Core分发版是免费且开源的，但也有一个商业化的Nagios系统。
- en: Monitoring of MySQL is set up by use of plugins. They should provide enough
    data to set up basic monitoring similar to that of the official Zabbix templates.
    It is possible to extend the collected metrics if needed.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插件设置MySQL监控。它们应提供足够的数据来设置类似于官方Zabbix模板的基本监控。如有必要，可以扩展收集的指标。
- en: Alerting, visualizations, and configuration are similar to Zabbix. One notable
    feature of Nagios is that at its peak of popularity it was forked multiple times.
    Some of the most popular Nagios forks are Icinga and Shinken. Check_MK was also
    initially a Nagios extension that eventually moved on to become its own commercial
    product.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 告警、可视化和配置与Zabbix相似。Nagios的一个显著特点是在其流行高峰期间被多次分叉。一些最流行的Nagios分支包括Icinga和Shinken。Check_MK最初也是Nagios的扩展，最终发展成为独立的商业产品。
- en: Both Nagios and its forks and Zabbix can and are successfully used by many companies
    to monitor MySQL. Even though they may feel outdated in their architecture and
    data representation, they can get the job done. Their biggest problem is that
    the standard data they collect may feel limited compared with alternatives, and
    you’ll need to use community plugins and extensions. Percona used to maintain
    a set of [monitoring plugins for Nagios](https://oreil.ly/bocia), as well as for
    Zabbix, but has deprecated them and now concentrates on its own monitoring offering,
    Percona Monitoring and Management (PMM), which we’ll discuss shortly.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Nagios及其分支以及Zabbix都可以并且成功地被许多公司用来监控MySQL。尽管它们在架构和数据表示上可能显得过时，但它们可以完成任务。它们最大的问题是，它们收集的标准数据可能与替代方案相比感觉有限，并且您将需要使用社区插件和扩展。Percona曾经维护一组用于Nagios和Zabbix的[监控插件](https://oreil.ly/bocia)，但已经弃用，并且现在集中于自己的监控产品Percona
    Monitoring and Management（PMM），我们稍后将讨论。
- en: 'All the systems we’ve covered so far have one thing in common: they are general-purpose
    monitoring solutions, not tailor-made for database monitoring. It’s their power,
    and also their weakness. When it comes to monitoring and investigating deep database
    internals, you’ll often be forced to manually extend those systems’ capabilities.
    One feature, for example, that none of them have is storing individual query execution
    statistics. Technically, it’s possible to add that feature, but it may be cumbersome
    and problematic.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所涵盖的所有系统有一个共同点：它们都是通用的监控解决方案，而不是专为数据库监控量身定制的。这是它们的优势，也是它们的弱点。当涉及监控和调查深层数据库内部时，您经常会被迫手动扩展这些系统的功能。例如，其中没有一个系统具有存储个别查询执行统计信息的功能。从技术上讲，可以添加此功能，但可能会很麻烦和有问题。
- en: 'We will finish this section by looking at two database-oriented monitoring
    solutions, MySQL Enterprise Monitor from Oracle and Percona Monitoring and Management.
    As you’ll see, they are similar in the functionality they provide, and both are
    big improvements over nonspecialized monitoring systems:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看两个面向数据库的监控解决方案来完成本节，分别是来自Oracle的MySQL企业监控器和Percona Monitoring and Management。正如您将看到的那样，它们在提供的功能上非常相似，并且都比非专业化的监控系统有了很大的改进：
- en: MySQL Enterprise Monitor
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL企业监控器
- en: Part of MySQL Enterprise Edition, [Enterprise Monitor](https://oreil.ly/cQ8tQ)
    is a complete monitoring and management platform for MySQL databases.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 作为MySQL企业版的一部分，[企业监控器](https://oreil.ly/cQ8tQ)是一个完整的MySQL数据库监控和管理平台。
- en: In terms of monitoring, MySQL Enterprise Monitor extends the usual metrics gathered
    by monitoring systems by adding details on MySQL memory utilization, per-file
    I/O details, and a wide variety of dashboards based on InnoDB’s status variables.
    The data is taken from MySQL itself without any agents involved. Theoretically,
    all the same data can be gathered and visualized by any other monitoring system,
    but here it’s tightly packed with well-thought-out dashboards and categories.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控方面，MySQL企业监控器通过添加关于MySQL内存利用率、每个文件I/O详情以及基于InnoDB状态变量的各种仪表板，扩展了监控系统收集的常规指标。数据是直接从MySQL获取，不需要任何代理程序。从理论上讲，任何其他监控系统也可以收集和可视化相同的数据，但这里的数据被紧密地整合在精心设计的仪表板和类别中。
- en: Enterprise Monitor includes the Events subsystem, which is a set of predefined
    alerts. Adding to the database-specific features, the Enterprise Monitor includes
    a replication topology overview for regular and multisource replication, Group
    Replication, and NDB Cluster. Another feature is monitoring of backup execution
    status (for backups done with MySQL Enterprise Backup).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 企业监控器包括事件子系统，这是一组预定义的警报。除了特定于数据库的功能外，企业监控器还包括用于常规和多源复制、组复制和NDB集群的复制拓扑概述的监控。另一个特性是监控使用MySQL企业备份进行的备份执行状态。
- en: We mentioned that individual query execution statistics and query history are
    usually missing in the general-purpose monitoring systems. MySQL Enterprise Monitor
    includes a Query Analyzer that provides insight into the history of queries executed
    over time, as well as statistics gathered about the queries. It’s possible to
    view information like the average numbers of rows read and returned and a duration
    distribution, and even see the execution plans of the queries.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到通常通用监控系统中缺少单个查询执行统计和查询历史记录。MySQL Enterprise Monitor包括一个查询分析器，提供有关随时间执行的查询历史的洞察，以及收集的有关查询的统计信息。可以查看诸如平均读取和返回行数以及持续时间分布的信息，甚至可以查看查询的执行计划。
- en: Enterprise Monitor is a good database monitoring system. Its biggest downside,
    really, is that it’s only available in the Enterprise Edition of MySQL. Unfortunately,
    most MySQL installations cannot benefit from the Enterprise Monitor and the level
    of insight it provides into the database and OS metrics. It’s also not suitable
    for monitoring anything apart from MySQL, the queries it’s executing, and the
    OS it’s running on, and MySQL monitoring is limited in scope to Oracle’s products.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Enterprise Monitor是一个优秀的数据库监控系统。它最大的缺点实际上是它仅在MySQL的企业版中可用。不幸的是，大多数MySQL安装无法从Enterprise
    Monitor及其提供的对数据库和操作系统指标的深入洞察中受益。它也不适合监控除MySQL之外的任何内容，包括其执行的查询和其运行的操作系统，而且MySQL监控的范围仅限于Oracle的产品。
- en: There’s a 30-day trial of MySQL Enterprise Edition available, which includes
    the Enterprise Monitor, and Oracle also maintains a list of [visual demos of the
    system](https://oreil.ly/AC58l).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Enterprise Edition提供了30天的试用期，其中包括Enterprise Monitor，Oracle还维护有系统的[视觉演示列表](https://oreil.ly/AC58l)。
- en: Percona Monitoring and Management
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Percona监控与管理
- en: Percona’s monitoring solution, [PMM](https://oreil.ly/3cu2k), is similar in
    functionality to Oracle’s Enterprise Monitor, but is fully free and open source.
    Intended to be a “single pane of glass,” it tries to provide deep insight into
    MySQL and OS performance and can also be used to monitor MongoDB and PostgreSQL
    databases.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Percona的监控解决方案，[PMM](https://oreil.ly/3cu2k)，在功能上类似于Oracle的Enterprise Monitor，但完全免费且开源。旨在成为“单一视图”，它试图提供对MySQL和操作系统性能的深入洞察，并可用于监控MongoDB和PostgreSQL数据库。
- en: PMM is built on top of existing open source components like the already reviewed
    Prometheus and its exporters, and Grafana. Percona maintains forks of the database
    exporters it uses, including the one for MySQL, and adds functionality and metrics
    that were lacking in the original versions. In addition to that, PMM hides complexity
    usually associated with deploying and configuring those tools and instead provides
    its own bundled package and configuration interface.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: PMM基于现有的开源组件构建，如已审查的Prometheus及其导出器和Grafana。Percona维护了它使用的数据库导出器的分支，包括MySQL的导出器，并添加了在原始版本中缺少的功能和指标。除此之外，PMM隐藏了通常与部署和配置这些工具相关的复杂性，而是提供了自己的捆绑软件包和配置界面。
- en: Like Enterprise Monitor, PMM offers a selection of dashboards visualizing pretty
    much every aspect of MySQL’s and InnoDB’s operation, as well as giving a lot of
    details on the underlying OS state. This has been extended to include technologies
    like PXC/Galera, discussed in [Chapter 13](ch13.xhtml#CH13_HA), and ProxySQL,
    discussed in [Chapter 15](ch15.xhtml#CH15_LOAD_BAlANCERS). As PMM uses Prometheus
    and exporters, it’s possible to extend the range of monitored databases by adding
    external exporters. In addition to that, PMM supports DBaaS systems like RDS and
    CloudSQL.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 像Enterprise Monitor一样，PMM提供了一系列仪表板，可视化MySQL和InnoDB运作的几乎每个方面，并提供了关于底层操作系统状态的大量细节。这已扩展到包括像PXC/Galera（见[第13章](ch13.xhtml#CH13_HA)）和ProxySQL（见[第15章](ch15.xhtml#CH15_LOAD_BAlANCERS)）等技术。由于PMM使用Prometheus和导出器，可以通过添加外部导出器扩展监控的数据库范围。除此之外，PMM还支持像RDS和CloudSQL这样的DBaaS系统。
- en: PMM ships with a custom application called Query Analytics (QAN), which is a
    query monitoring and metrics system. Like the Enterprise Monitor’s Query Analyzer,
    QAN shows the overall history of queries executed in a given system, as well as
    information about the individual queries. That includes a history of the number
    of executions of the query over time, rows read and sent, locking, and temporary
    tables created, among other things. QAN allows you to view the query plan and
    structures of the involved tables.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: PMM配备了一个名为查询分析（QAN）的自定义应用程序，这是一个查询监控和指标系统。与企业监视器的查询分析器类似，QAN显示了在给定系统中执行的查询的整体历史，以及有关单个查询的信息。其中包括查询随时间执行次数的历史记录，读取和发送的行数，锁定以及创建的临时表等信息。QAN允许您查看查询计划和涉及表的结构。
- en: The *Management* part of PMM for now exists only in its name, as at the time
    of writing it is purely a monitoring system. PMM supports alerting through Prometheus’s
    standard AlertManager or through the use of internal templates.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，PMM的*管理*部分仅存在于其名称中，因为在撰写本文时，它仅仅是一个监控系统。PMM支持通过Prometheus的标准AlertManager或通过内部模板进行警报。
- en: One significant problem with PMM is that out of the box it only supports targets
    running on Linux. Since Prometheus exporters are cross-platform, you can add Windows
    (or other OS) targets to PMM, but you won’t be able to utilize some of the benefits
    of the tool, like simplified exporter configuration and bundled installation of
    the client software.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: PMM的一个显著问题是，它默认仅支持运行在Linux上的目标。由于Prometheus导出器是跨平台的，您可以将Windows（或其他操作系统）目标添加到PMM中，但您将无法利用该工具的某些好处，例如简化的导出器配置和客户端软件的捆绑安装。
- en: Both authors of this book are currently employed by Percona, so you may be tempted
    to dismiss our description of PMM as an advertisement. However, we’ve tried to
    give a fair overview of a few monitoring systems, and we don’t claim that PMM
    is perfect. If your company is already using the Enterprise version of MySQL,
    then you should absolutely first see what MySQL Enterprise Monitor has to offer.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的两位作者目前都在Percona工作，因此您可能会认为我们对PMM的描述是广告。然而，我们尝试公正地概述了几个监控系统，并不断言PMM是完美的。如果您的公司已经使用MySQL企业版，则应该首先了解MySQL企业监视器提供了什么。
- en: Before we close this section, we want to note that in many cases the actual
    monitoring system you use doesn’t matter much. Every system we’ve mentioned provides
    MySQL availability monitoring, as well as some level of insight into the internal
    metrics—enough for the selection of recipes we gave earlier. Especially while
    you’re learning your way around MySQL, and perhaps starting to operate its installations
    in production, you should try to leverage existing monitoring infrastructure.
    Rushing to change everything to the best often leads to unsatisfactory results.
    As you get more experienced, you will see more and more data missing in the tools
    you have and will be able to make an informed decision on which new tool to choose.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一部分之前，我们想指出，在许多情况下，您使用的实际监控系统并不太重要。我们提到的每个系统都提供MySQL可用性监控，以及对内部指标的某种程度的洞察力，足以选择我们之前提供的配方。特别是在您学习MySQL的使用方式，并且可能开始在生产中操作其安装时，您应该尝试利用现有的监控基础设施。仓促地改变一切去追求最好的往往会导致不尽如人意的结果。随着您变得更有经验，您将看到现有工具中缺少的更多数据，并能够就选择新工具做出明智的决策。
- en: Incident/Diagnostic and Manual Data Collection
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件/诊断和手动数据收集
- en: 'Sometimes, you may not have a monitoring system set up for a database, or you
    may not trust it to contain all the information you might need to investigate
    some issue. Or you may have a DBaaS instance running and want to get more data
    than your cloud provider gives you. In such situations, manual data collection
    can be a viable option in the short term to quickly get some data out of the system.
    We will show you few tools you can use to do just that: quickly gather a lot of
    diagnostic information from any MySQL instance.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能没有为数据库设置监控系统，或者您可能不信任它包含您可能需要调查的所有信息。或者您可能正在运行一个DBaaS实例，并希望获取比您的云提供商给出的更多数据。在这种情况下，手动数据收集可能是短期内快速获取系统中一些数据的可行选项。我们将向您展示几种工具，您可以使用这些工具快速地从任何MySQL实例中收集大量诊断信息。
- en: The following sections are short, useful recipes that you can take away and
    use in your day-to-day work with MySQL databases.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节是简短而有用的配方，您可以带走并在日常使用MySQL数据库工作中使用。
- en: Gathering System Status Variable Values Periodically
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定期收集系统状态变量值
- en: In [“Status Variables”](#MONITORING_MYSQL_STATUS_VARIABLES) and [“Basic Monitoring
    Recipes”](#MONITORING_MYSQL_RECIPES) we talked a lot about looking at how different
    status variables’ values change over time. Every monitoring tool mentioned in
    the previous section does that to accumulate data, which is then used for plots
    and alerting. The same sampling of status variables can be performed manually
    if you want to look at raw data or simply sample at an interval lower than your
    monitoring system uses.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“状态变量”](#MONITORING_MYSQL_STATUS_VARIABLES)和[“基本监控配方”](#MONITORING_MYSQL_RECIPES)中，我们详细讨论了如何查看不同状态变量的值随时间的变化。前一节提到的每个监控工具都会累积数据，然后用于绘图和警报。如果您想查看原始数据或者只是按比监控系统使用的间隔取样，可以手动执行相同的状态变量取样。
- en: You could write a simple script that runs the MySQL monitor in a loop, but the
    better approach is to use the built-in `mysqladmin` utility. This program can
    be used to perform a wide range of administrative operations on a running MySQL
    server, though we should note that every one of those can also be done through
    the regular `mysql`. `mysqladmin` can, however, be used to sample global status
    variables easily, which is exactly how we’re going to use it here.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写一个简单的脚本，在循环中运行MySQL监视器，但更好的方法是使用内置的`mysqladmin`实用程序。该程序可以对运行中的MySQL服务器执行各种管理操作，尽管我们应该注意，这些操作也可以通过常规的`mysql`完成。然而，`mysqladmin`可以轻松地取样全局状态变量，这正是我们在这里要使用它的方式。
- en: '`mysqladmin` includes two status outputs: regular and extended. The regular
    one is less informative:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysqladmin`包含两种状态输出：常规和扩展。常规输出信息较少：'
- en: '[PRE43]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The extended output will be familiar to you at this point. It’s the same as
    the output of `SHOW GLOBAL STATUS`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展输出在此时对您来说已经很熟悉了。它与`SHOW GLOBAL STATUS`的输出相同：
- en: '[PRE44]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Conveniently, `mysqladmin` is capable of repeating the commands it runs at
    a given interval a given number of times. For example, the following command will
    cause `mysqladmin` to print status variable values every second for a minute (`ext`
    is a shorthand for *extended-status*):'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，`mysqladmin`能够在给定间隔内重复运行特定命令的功能。例如，以下命令将导致`mysqladmin`每秒打印一次状态变量值，持续一分钟（`ext`是*extended-status*的缩写）：
- en: '[PRE46]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By redirecting its output to a file, you can get a minute-long sample of database
    metric changes. Text files are not as nice to work with as proper monitoring systems,
    but again, this is usually done under special circumstances. For a long time,
    gathering information about MySQL like this with `mysqladmin` was standard practice,
    so there’s a tool called [`pt-mext`](https://oreil.ly/6MnC5) that can turn plain
    `SHOW GLOBAL STATUS` outputs into a format better suited for consumption by humans.
    Unfortunately, the tool is available only on Linux. Here’s an example of its output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其输出重定向到文件，您可以获得数据库指标变化的一分钟样本。与正规的监控系统相比，文本文件不太易于处理，但通常是在特殊情况下执行的操作。长期以来，像这样使用`mysqladmin`收集MySQL信息是标准做法，因此有一个称为[`pt-mext`](https://oreil.ly/6MnC5)的工具，可以将普通的`SHOW
    GLOBAL STATUS`输出转换为更适合人类消费的格式。不幸的是，该工具仅适用于Linux。这里是它输出的一个示例：
- en: '[PRE47]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The initial large number is the status variable value at the first sample, and
    values after that represent the change to the initial number. If the value were
    to decrease, a negative number would be shown.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的大数字是第一次取样时的状态变量值，之后的数值表示相对于初始数值的变化。如果数值减少，则显示负数。
- en: Using pt-stalk to Collect MySQL and OS Metrics
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`pt-stalk`收集MySQL和操作系统指标
- en: '[`pt-stalk`](https://oreil.ly/SU9bG) is a part of Percona Toolkit and is normally
    run alongside MySQL and used to continuously check for some specified condition.
    Once that condition is met—for example, the value of `Threads_running` is larger
    than 15—`pt-stalk` triggers a data collection routine gathering extensive information
    on MySQL and the operating system. However, it is possible to utilize the data
    collection part without actually stalking the MySQL server. Although it’s not
    a correct way to use `pt-stalk`, it’s a useful method to quickly glance at an
    unknown server or try to gather as much information as possible on a misbehaving
    server.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pt-stalk`](https://oreil.ly/SU9bG)是Percona Toolkit的一部分，通常与MySQL一起运行，并用于持续检查指定条件。一旦满足条件，例如`Threads_running`的值大于15，`pt-stalk`会触发数据收集例程，收集有关MySQL和操作系统的详尽信息。但是，可以利用数据收集部分，而不实际跟踪MySQL服务器。虽然这不是使用`pt-stalk`的正确方式，但这是快速查看未知服务器或尝试在表现不佳的服务器上收集尽可能多信息的有用方法。'
- en: '`pt-stalk`, like other tools in the Percona Toolkit, is available only for
    Linux, even though the target MySQL server can run on any OS. The basic invocation
    of `pt-stalk` to achieve that is simple:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-stalk`，像Percona Toolkit中的其他工具一样，仅适用于Linux，即使目标MySQL服务器可以在任何操作系统上运行。要实现这一点的基本调用`pt-stalk`是简单的：'
- en: '[PRE48]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The utility will run two data collection rounds, each of which will span a
    minute, and will sleep for 30 seconds between them. In case you don’t need OS
    information, or can’t get it because your target is a DBaaS instance, you can
    use the `--mysql-only` flag:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序将运行两轮数据收集，每轮持续一分钟，它们之间将休眠30秒。如果你不需要操作系统信息，或者因为目标是DBaaS实例而无法获取它们，你可以使用`--mysql-only`标志：
- en: '[PRE49]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is the list of files created by a single collection round. We’ve omitted
    the OS-related files deliberately, but there are quite a lot of them:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单次收集生成的文件列表。我们有意省略了与操作系统相关的文件，但这些文件确实有相当多：
- en: '[PRE50]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Extended Manual Data Collection
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展手动数据收集
- en: '`pt-stalk` is not always available, and it doesn’t run on all platforms. Sometimes,
    you may also want to add to (or remove some of) the data it gathers. You can use
    the `mysqladmin` command introduced earlier to gather a bit more data and wrap
    it all up in a simple script. A version of this script is frequently used by authors
    of this book in their daily work.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`pt-stalk`并非始终可用，并且并非在所有平台上都可以运行。有时，您可能还想添加（或删除）它收集的一些数据。您可以使用此前介绍的`mysqladmin`命令收集更多数据，并将其整合到一个简单的脚本中。本书作者在日常工作中经常使用此脚本的一个版本。'
- en: 'This script, which should run on any Linux or Unix-like system, will execute
    continuously either until terminated or until the */tmp/exit-flag* file is found
    to be present. You can run `touch /tmp/exit-flag` to gracefully finish the execution
    of this script. We recommend putting it into a file and running it through `nohup`
    … `&` or executing it within a `screen` or `tmux` session. If you’re unfamiliar
    with the terms we’ve just mentioned, they are all ways to make sure a script continues
    to execute when your session disconnects. Here’s the script:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本应在任何Linux或类Unix系统上运行，将持续执行，直到被终止或者发现`/tmp/exit-flag`文件存在为止。您可以运行`touch /tmp/exit-flag`来优雅地结束此脚本的执行。我们建议将其放入文件中，并通过`nohup`
    … `&`运行，或在`screen`或`tmux`会话中执行。如果您对我们刚提到的术语不熟悉，它们都是确保脚本在会话断开时继续执行的方法。以下是脚本内容：
- en: '[PRE51]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Warning
  id: totrans-499
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Do not forget to adjust user credentials in these scripts before executing.
    Note that output files scripts produce may take a substantial amount of disk space.
    Always test any scripts in a safe environment before executing on critical servers.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这些脚本之前，不要忘记调整用户凭据。请注意，脚本生成的输出文件可能占用大量磁盘空间。在关键服务器上执行之前，请务必在安全环境中测试所有脚本。
- en: 'We’ve also created a Windows version of the same script written in PowerShell.
    It behaves exactly in the same way as the previous script and will terminate on
    its own as soon as the file *C:\tmp\exit-flag* is found:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个基于PowerShell的Windows版本的相同脚本。它与之前的脚本行为完全相同，并将在发现*C:\tmp\exit-flag*文件时自行终止。
- en: '[PRE52]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You should remember that script-based data collection is not a substitute for
    proper monitoring. It has its uses, which we described at the start of this section,
    but it should always be an addition to what you already have, not the only way
    to look at MySQL metrics.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，基于脚本的数据收集不能替代适当的监控。它有其用处，我们在本节开头描述了它的用途，但它应始终作为您已有监控的补充，而不是查看MySQL指标的唯一方式。
- en: By now, after reading through this chapter, you should have a pretty good idea
    of how to approach MySQL monitoring. Remember that issues, incidents, and outages
    will happen—they are unavoidable. With proper monitoring, however, you can make
    sure that the same issue doesn’t happen twice, as you’ll be able to find the root
    cause after the first occurrence. Of course, you’ll also be able to avoid some
    issues by changing your system to fix the problems revealed by your MySQL monitoring
    efforts.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你现在应该对如何进行MySQL监控有了很好的理解。请记住，问题、事故和停机是不可避免的。然而，通过适当的监控，你可以确保同样的问题不会再次发生，因为你可以在第一次发生后找到根本原因。当然，通过改变系统来解决MySQL监控揭示的问题，你也可以避免一些问题。
- en: 'We’ll leave you with a closing thought: perfect monitoring is unattainable,
    but even pretty basic monitoring is better than no monitoring at all.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们留给你一个思考：完美的监控是不可达到的，但即使是相当基本的监控也比没有监控好。
