- en: Chapter 16\. Miscellaneous Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。杂项主题
- en: The idea of this chapter is to go beyond troubleshooting a query, or an overloaded
    system, or setting up different MySQL topologies. We want to show you the arsenal
    of tools available for you to make daily tasks easier or investigate complex issues.
    Let’s start with MySQL Shell.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是超越故障排除查询、过载系统或设置不同的MySQL拓扑结构。我们希望向您展示可用于使日常任务更轻松或调查复杂问题的工具库。让我们从MySQL
    Shell开始。
- en: MySQL Shell
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL Shell
- en: MySQL Shell is an advanced client and code editor for MySQL. It expands the
    functionality of the traditional MySQL client that most DBAs worked with in MySQL
    5.6 and 5.7\. MySQL Shell supports programming languages such as Python, JavaScript,
    and SQL. It also extends functionalities using an API command syntax. For example,
    it is possible to customize scripts to administer an InnoDB Cluster. From MySQL
    Shell, you can also start and configure MySQL sandbox instances.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell是MySQL的高级客户端和代码编辑器。它扩展了传统MySQL客户端的功能，大多数DBA在MySQL 5.6和5.7中使用过。MySQL
    Shell支持Python、JavaScript和SQL等编程语言。它还通过API命令语法扩展功能。例如，可以定制脚本以管理InnoDB Cluster。通过MySQL
    Shell，还可以启动和配置MySQL沙盒实例。
- en: Installing MySQL Shell
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装MySQL Shell
- en: For supported Linux distributions, the easiest way to install MySQL Shell is
    to use the MySQL *yum* or *apt* repository. Let’s see how to install it on Ubuntu
    and CentOS.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于支持的Linux发行版，安装MySQL Shell的最简单方法是使用MySQL *yum*或*apt*仓库。让我们看看如何在Ubuntu和CentOS上安装它。
- en: Installing MySQL Shell on Ubuntu 20.04 Focal Fossa
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Ubuntu 20.04 Focal Fossa上安装MySQL Shell
- en: Installing MySQL Shell in Ubuntu is relatively easy since it is part of the
    regular repositories.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu中安装MySQL Shell相对简单，因为它是常规仓库的一部分。
- en: 'First, we need to configure the MySQL repository. We can use these commands
    to [download](https://oreil.ly/K7eq8) the *apt* repository to our server and install
    it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要配置MySQL仓库。我们可以使用这些命令将*apt*仓库[下载](https://oreil.ly/K7eq8)到我们的服务器并安装它：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, update our package information:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，更新我们的软件包信息：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then execute the `install` command to install MySQL Shell:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行`install`命令安装MySQL Shell：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now start MySQL Shell using the command line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用命令行启动MySQL Shell：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Installing MySQL Shell on CentOS 8
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CentOS 8上安装MySQL Shell
- en: 'To install MySQL Shell in CentOS 8, we follow the same steps as described for
    Ubuntu—but first we need to make sure the default MySQL package present in CentOS
    8 is disabled:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要在CentOS 8中安装MySQL Shell，我们需要遵循与Ubuntu描述相同的步骤，但首先需要确保CentOS 8中存在的默认MySQL软件包被禁用：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we are going to configure our *yum* repository. We need to get the correct
    OS version from the [download page](https://oreil.ly/YvW74):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置我们的*yum*仓库。我们需要从[下载页面](https://oreil.ly/YvW74)获取正确的操作系统版本：
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the repository installed, we will install the MySQL Shell binary:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了仓库后，我们将安装MySQL Shell二进制文件：
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And we can validate that the installation worked by running it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行它来验证安装是否成功：
- en: '[PRE11]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Deploying a Sandbox InnoDB Cluster with MySQL Shell
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MySQL Shell部署Sandbox InnoDB Cluster
- en: MySQL Shell automates the deployment of sandbox instances with AdminAPI, which
    provides the `dba.deploySandboxInstance(`*`port_number`*`)` command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell通过提供`dba.deploySandboxInstance(`*`port_number`*`)`命令自动化部署沙盒实例。
- en: 'By default, the sandbox instances are placed in a directory named *$HOME/mysql-sandboxes/port*.
    Let’s see how to change the directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，沙盒实例放置在名为*$HOME/mysql-sandboxes/port*的目录中。让我们看看如何更改目录：
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A prerequiste to deploy a sandbox instance is to install the MySQL binaries.
    If necessary, review [Chapter 1](ch01.xhtml#CH1_INSTALL) for details. You’ll need
    to enter a password for the `root` user in order to complete the deployment:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 部署沙盒实例的先决条件是安装MySQL二进制文件。如果需要，详细信息请查看[第1章](ch01.xhtml#CH1_INSTALL)。您需要输入`root`用户的密码以完成部署：
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are going to deploy two more instances:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算部署另外两个实例：
- en: '[PRE18]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The next step is to create the InnoDB Cluster while connected to the seed MySQL
    Server instance. The *seed* instance is the instance we are connected to via MySQL
    Shell and that we want to replicate to the other instances. In this example the
    sandbox instances are all blank instances, so we can choose any instance. In a
    production setup the seed instance would be the one that contains the existing
    dataset to be replicated to the other instances in the cluster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在连接到种子MySQL服务器实例时创建InnoDB集群。*种子*实例是我们通过MySQL Shell连接的实例，我们希望将其复制到其他实例。在此示例中，沙盒实例都是空白实例，因此我们可以选择任何实例。在生产设置中，种子实例将是包含要复制到集群中其他实例的现有数据集的实例。
- en: 'We use this command to connect MySQL Shell to the seed instance, in this case
    the one at port 3310:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此命令将MySQL Shell连接到种子实例，本例中的端口为3310：
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Subsequently, we will use the `createCluster()` method to create the InnoDB
    Cluster with the currently connected instance as the seed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**接下来，我们将使用`createCluster()`方法创建InnoDB集群，当前连接的实例将作为种子：**'
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see in the output, three instances are capable of keeping the database
    online with one server failure, which is why we deployed three sandbox instances.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在输出中所看到的，三个实例能够在一台服务器故障时保持数据库在线，这就是为什么我们部署了三个沙盒实例。
- en: The next step is to add secondary instances to our `learning_mysql` InnoDB Cluster.
    Any transactions that were executed by the seed instance are reexecuted by each
    secondary instance as it is added.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将次要实例添加到我们的`learning_mysql` InnoDB集群中。由种子实例执行的任何事务都将在添加每个次要实例时重新执行。
- en: The seed instance in this example was recently created, so it is nearly empty.
    Therefore, there is little data that needs to be replicated from the seed instance
    to the secondary instances. If it’s necessary to replicate data, MySQL will use
    the [clone plugin](https://oreil.ly/VUASS) (discussed in [“Creating a Replica
    Using the Clone Plugin”](ch13.xhtml#clone_plugin)) to configure the instances
    automatically.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的种子实例最近创建，因此几乎为空。因此，需要从种子实例复制的数据很少。如果需要复制数据，MySQL将使用[克隆插件](https://oreil.ly/VUASS)（在[“使用克隆插件创建副本”](ch13.xhtml#clone_plugin)中讨论）自动配置实例。
- en: 'Let’s add one secondary to see the process in action. To add the second instance
    to the InnoDB Cluster:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个次要实例来看看实际操作过程。要将第二个实例添加到InnoDB集群中：
- en: '[PRE23]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then add the third instance:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加第三个实例：
- en: '[PRE25]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point we have created a cluster with three instances: a primary and
    two secondaries. We can see the status by running the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已创建了一个包含三个实例的集群：一个主实例和两个次要实例。我们可以通过运行以下命令来查看状态：
- en: '[PRE26]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Assuming MySQL Router is already installed (see [“MySQL Router”](ch15.xhtml#MYSQL_ROUTER)),
    the only required step is to bootstrap it with the location of the InnoDB Cluster
    metadata server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设MySQL Router已安装（请参阅[“MySQL Router”](ch15.xhtml#MYSQL_ROUTER)），唯一需要的步骤是使用InnoDB集群元数据服务器的位置引导它。
- en: 'We observe the router being bootstrapped:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到路由器正在引导启动：
- en: '[PRE28]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]**  **## MySQL Shell Utilities'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]**  **## MySQL Shell工具'
- en: As we’ve said, MySQL Shell is a powerful, advanced client and code editor for
    MySQL. Among its many functionalities are utilities to create a logical dump and
    do a logical restore for the entire database instance, including users. The advantage,
    compared to `mysqldump`, for example, is that the utility has parallelization
    capacity, greatly improving the dump and restore speed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，MySQL Shell是MySQL的强大高级客户端和代码编辑器。在其众多功能中，包括创建整个数据库实例的逻辑转储和逻辑恢复以及用户。与例如`mysqldump`相比，其优势在于具有并行化能力，极大地提高了转储和恢复速度。
- en: 'Here are the utilities to execute the dump and restore process:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行转储和恢复过程的工具：
- en: '`util.dumpInstance()`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.dumpInstance()`'
- en: Dump an entire database instance, including users
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 转储整个数据库实例，包括用户
- en: '`util.dumpSchemas()`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.dumpSchemas()`'
- en: Dump a set of schemas
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 转储一组模式
- en: '`util.loadDump()`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.loadDump()`'
- en: Load a dump into a target database
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将转储加载到目标数据库
- en: '`util.dumpTables()`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.dumpTables()`'
- en: Load specific tables and views
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 加载特定的表和视图
- en: Let’s take a closer look at each of these in turn.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次更仔细地看看每一个。
- en: util.dumpInstance()
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: util.dumpInstance()
- en: The `dumpInstance()` utility will dump all the databases that are present in
    the MySQL data directory (see [“The Contents of the MySQL Directory”](ch01.xhtml#MYSQL_DIRECTORY_CONTENT)).
    It will exclude the `information_schema`, `mysql_`, `ndbinfo`, `performance_schema`,
    and `sys` schemas while taking the dump.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumpInstance()` 实用工具将导出MySQL数据目录中存在的所有数据库（参见 [“MySQL目录的内容”](ch01.xhtml#MYSQL_DIRECTORY_CONTENT)）。在导出时，将排除
    `information_schema`、`mysql_`、`ndbinfo`、`performance_schema` 和 `sys` 这些模式。'
- en: There’s also a dry-run option that allows you to inspect the schemas and view
    the compatibility issues and then run the dump with the appropriate compatibility
    options applied to remove the issues. Let’s try this now—we’ll examine the possible
    errors and see the options for the dump utility.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个干运行选项，允许您检查模式并查看兼容性问题，然后运行导出并应用适当的兼容性选项以消除问题。现在让我们尝试一下——我们将检查可能的错误并查看导出实用程序的选项。
- en: 'To start the dump, run the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 若要开始导出，请执行以下命令：
- en: '[PRE30]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the `ocimds` option set to `true`, the dump utility will check the data
    dictionary and index dictionary. Encryption options in `CREATE TABLE` statements
    are commented out in the DDL files, to ensure that all tables are located in the
    MySQL data directory and use the default schema encryption. `strip_restricted_grants`
    removes specific privileges that are restricted by MySQL Database Service that
    would cause an error during the user creation process. `dryRun` is self-explanatory:
    it will perform validation only, and no data will be actually dumped.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置 `ocimds` 选项为 `true` 时，导出实用程序将检查数据字典和索引字典。DDL文件中的 `CREATE TABLE` 语句中的加密选项已被注释，以确保所有表位于MySQL数据目录中，并使用默认模式加密。`strip_restricted_grants`
    删除由MySQL数据库服务限制的特定权限，这些权限在用户创建过程中可能导致错误。`dryRun` 是不言自明的：它仅执行验证，实际上不会导出任何数据。
- en: So, we have a MyISAM table in the `test` database. The dry-run option clearly
    throws the error.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 `test` 数据库中有一个MyISAM表。干运行选项明显会抛出错误。
- en: 'To fix this error, we are going to use the `force_innodb` option, which will
    convert all unsupported engines to InnoDB in the `CREATE TABLE` statement:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，我们将使用 `force_innodb` 选项，在 `CREATE TABLE` 语句中将所有不受支持的引擎转换为InnoDB：
- en: '[PRE32]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now the dry run does not throw any errors, and there are no exceptions. Let’s
    run the `dumpInstance()` command to take an instance backup. The target directory
    must be empty before the export takes place. If the directory does not yet exist
    in its parent directory, the utility creates it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在干运行不会抛出任何错误，也没有异常。让我们运行 `dumpInstance()` 命令来备份一个实例。在执行导出之前，目标目录必须为空。如果父目录中的目录尚不存在，则实用程序会创建它。
- en: 'We are going to process the dump in parallel. For this, we will use the option
    `threads` and set a value of 10 threads:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将并行处理导出。为此，我们将使用 `threads` 选项并设置10个线程：
- en: '[PRE33]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we observe the last part of the output, we’ll see:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们观察输出的最后部分，我们会看到：
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we were using `mysqldump`, we would have a single file. As we can see here,
    there are multiple files in the backup directory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `mysqldump`，我们会得到一个单一的文件。正如我们在这里看到的，备份目录中有多个文件：
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s take a look at these:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这些内容：
- en: The *@.json* file contains server details and lists of users, database names,
    and their character sets.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@.json* 文件包含服务器详细信息以及用户列表、数据库名称及其字符集。'
- en: The *@.post.sql* and *@.sql* files contain MySQL Server version details.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@.post.sql* 和 *@.sql* 文件包含MySQL服务器版本详细信息。'
- en: The *test.json* file contains view, stored procedure, and function names along
    with a list of tables.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*test.json* 文件包含视图、存储过程和函数名称以及表格列表。'
- en: The *@.users.sql* file (not shown) contains a list of database users.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@.users.sql* 文件（未显示）包含数据库用户列表。'
- en: The *test@sbtest10.json* file contains column names and character sets. There
    will be a similiarly named file for each dumped table.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*test@sbtest10.json* 文件包含列名称和字符集。每个导出的表都会有一个类似命名的文件。'
- en: The *test@sbtest1.sql* file contains a table structure. There will be one for
    each dumped table.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*test@sbtest1.sql* 文件包含表结构。每个导出的表都会有一个这样的文件。'
- en: The *test@sbtest10@@0.tsv.zst* file is a binary file. It stores data. There
    will be a similarly named file for each dumped table.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*test@sbtest10@@0.tsv.zst* 文件是一个二进制文件。它存储数据。每个导出的表格都会有一个同样命名的文件。'
- en: The *test@sbtest10@@0.tsv.zst.idx* file is a binary file. It stores table index
    stats. There will be a similarly named file for each dumped table.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*test@sbtest10@@0.tsv.zst.idx* 文件是一个二进制文件。它存储表索引统计信息。每个导出表格都会有一个同名文件。'
- en: The *@.done.json* file contains the backup end time and data file sizes in KB.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*@.done.json* 文件包含备份结束时间和数据文件大小（KB）。'
- en: The *test.sql* file contains a database statement.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*test.sql* 文件包含数据库语句。'
- en: util.dumpSchemas()
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: util.dumpSchemas()
- en: 'This utility is similar to `dumpInstance()`, but it allows us to specify schemas
    to dump. It supports the same options:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此实用程序类似于`dumpInstance()`，但允许我们指定要转储的模式。它支持相同的选项：
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we want to specify multiple schemas, we can do that by running:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要指定多个模式，可以通过运行以下命令实现：
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: util.dumpTables()
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: util.dumpTables()
- en: 'If we want to extract more granular data, like specific tables, we can use
    the `dumpTables()` utility. Again, the big advantage compared to `mysqldump` is
    the potential to extract data from MySQL in parallel:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要提取更精细的数据，比如特定表格，我们可以使用`dumpTables()`工具。与`mysqldump`相比，其主要优势是可以并行从MySQL中提取数据：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: util.loadDump(url[, options])
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: util.loadDump(url[, options])
- en: 'We’ve seen all the utilities to extract data, but there is one remaining: the
    one to load data into MySQL.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了所有提取数据的工具，但还有一个剩下的：将数据加载到MySQL的工具。
- en: The `loadDump()` enables provides data streaming to remote storage, parallel
    loading of tables or table chunks, and progress state tracking. It also provides
    resume and reset capabilities and the option of concurrent loading while the dump
    is still taking place.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadDump()` 提供数据流式传输到远程存储，表或表块的并行加载，进度状态跟踪。它还提供了恢复和重置功能，并在转储仍在进行时提供并发加载选项。'
- en: Note that this utility uses the `LOAD DATA LOCAL INFILE` statement, so we need
    to enable the [`local_infile`](https://oreil.ly/vm445) parameter globally while
    importing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此实用程序使用`LOAD DATA LOCAL INFILE`语句，因此我们需要在导入时全局启用[`local_infile`](https://oreil.ly/vm445)参数。
- en: 'The `loadDump()` utility checks whether the [`sql_require_primary_key` system
    variable](https://oreil.ly/2Si8y) is set to `ON`, and if it is, returns an error
    if there is a table in the dump files with no primary key:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadDump()` 实用程序检查是否设置了[`sql_require_primary_key`系统变量](https://oreil.ly/2Si8y)为`ON`，如果是，则在转储文件中存在无主键的表时返回错误：'
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last part of the output will be similar to this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后部分将类似于这样：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Be sure to check the warnings reported at the end in case any show up.**  **#
    Flame Graphs
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要检查最后报告的警告，以防有任何出现。**  **# 火焰图
- en: Quoting [Brendan Gregg](https://oreil.ly/STGxb), determining why CPUs are busy
    is a routine task for performance analysis, which often involves profiling *stack
    traces*. Profiling by sampling at a fixed rate is a coarse but effective way to
    see which code paths are *hot* (busy on the CPU). It usually works by creating
    a timed interrupt that collects the current program counter, function address,
    or entire stack trace, and translates these to something human-readable when printing
    a summary report. *Flame graphs* are a type of visualization for sampled stack
    traces that allow hot code paths to be identified quickly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 [Brendan Gregg](https://oreil.ly/STGxb)，确定CPU为何繁忙是性能分析的日常任务，通常涉及对*堆栈跟踪*进行分析。通过固定采样率进行分析是查看哪些代码路径*热点*（CPU繁忙）的粗略但有效的方法。通常通过创建定时中断来收集当前程序计数器、函数地址或整个堆栈跟踪，并在打印摘要报告时将其转换为可读的内容。*火焰图*是一种可视化采样堆栈跟踪的方式，可以快速识别热门代码路径。
- en: A *stack trace* (also called *stack backtrace* or *stack traceback*) is a report
    of the active stack frames at a certain point in time during the execution of
    a program. There are many tools available to collect stack traces. These tools
    are also known as *CPU profilers*. The CPU profiler we are going to use is [`perf`](https://oreil.ly/T7qZl).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈跟踪*（又称*堆栈回溯*或*堆栈追踪*）是程序执行过程中某一时刻活动的堆栈帧报告。有许多工具可用于收集堆栈跟踪。这些工具也被称为*CPU分析器*。我们将使用的CPU分析器是[`perf`](https://oreil.ly/T7qZl)。'
- en: '`perf` is a profiler tool for Linux 2.6+–based systems that abstracts away
    CPU hardware differences in Linux performance measurements and presents a simple
    command-line interface. `perf` is based on the `perf_events` interface exported
    by recent versions of the Linux kernel.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf` 是针对基于 Linux 2.6+ 的系统的性能分析工具，它在 Linux 性能测量中抽象了CPU硬件差异，并提供了简单的命令行接口。`perf`
    基于Linux内核最新版本导出的`perf_events`接口。'
- en: '`perf_events` is an event-oriented observability tool that can help solve advanced
    performance and troubleshooting tasks. Questions that can be answered include:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf_events` 是一个面向事件的可观测性工具，可以帮助解决高级性能和故障排除任务。可以回答的问题包括：'
- en: Why is the kernel on-CPU so much? What code paths are hot?
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么内核在CPU上运行得这么多？哪些代码路径是热点？
- en: Which code paths are causing CPU level 2 cache misses?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些代码路径导致 CPU 二级缓存未命中？
- en: Are the CPUs stalled on memory I/O?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 是否因内存 I/O 而停滞？
- en: Which code paths are allocating memory, and how much?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些代码路径在分配内存，分别分配了多少？
- en: What is triggering TCP retransmits?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是什么触发了 TCP 重传？
- en: Is a certain kernel function being called, and how often?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某个内核函数是否被调用，以及调用频率？
- en: Why are threads leaving the CPU?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么线程会离开 CPU？
- en: Note that in this book, we are only scratching the surface of `perf`’s capabilities.
    We highly recommend checking out [Brendan Gregg’s website](https://oreil.ly/STGxb),
    which contains much more detailed information about `perf` and other CPU profilers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本书中，我们只是浅尝 `perf` 的功能。我们强烈建议查看 [Brendan Gregg 的网站](https://oreil.ly/STGxb)，那里有关于
    `perf` 和其他 CPU 分析工具更详细的信息。
- en: 'To produce flame graphs, we need to start collecting the stack trace report
    with `perf` in the MySQL server. This operation needs to be done on the MySQL
    host. We will collect data for 60 seconds:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成火焰图，我们需要在 MySQL 服务器上使用 `perf` 开始收集堆栈跟踪报告。此操作需要在 MySQL 主机上完成。我们将收集 60 秒的数据：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And if we check the */tmp* directory, we will see `perf` files:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查 */tmp* 目录，我们会看到 `perf` 文件：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The next step doesn’t need to be executed on the MySQL host; we can copy the
    files to another Linux host or even macOS.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步不需要在 MySQL 主机上执行；我们可以将文件复制到另一个 Linux 主机，甚至是 macOS。
- en: 'To produce the flame graphs we can use [Brendan’s GitHub repository](https://oreil.ly/llqVS).
    For this example, we will clone the Flame Graph repository in the directory where
    our `perf` report is located:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成火焰图，我们可以使用 [Brendan 的 GitHub 仓库](https://oreil.ly/llqVS)。在这个示例中，我们将 Flame
    Graph 仓库克隆到包含我们 `perf` 报告的目录中：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ve produced a file named *perf.report.out.svg*. This file can be opened in
    any browser to be visualized. [Figure 16-1](#FIG-MYSQL-FLAME) is an example of
    a flame graph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了一个名为 *perf.report.out.svg* 的文件。此文件可以在任何浏览器中打开进行可视化。[图 16-1](#FIG-MYSQL-FLAME)
    是火焰图的一个示例。
- en: Flame graphs show the sample population across the x-axis, and stack depth on
    the y-axis. Each function (stack frame) is drawn as a rectangle, with the width
    relative to the number of samples; so the bigger the bar, the more CPU time was
    spent on that function. The x-axis spans the stack trace collection but does not
    show the passage of time, so the left-to-right ordering has no special meaning.
    The ordering is done alphabetically based on the function names, from the root
    to the leaf of each stack.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图显示了样本在 x 轴上的分布，堆栈深度在 y 轴上。每个函数（堆栈帧）都显示为一个矩形，宽度相对于样本数；因此，条形越大，花费在该函数上的 CPU
    时间越多。x 轴跨越堆栈跟踪收集，但不显示时间的流逝，因此左到右的顺序没有特殊含义。按字母顺序对函数名称进行排序，从根到每个堆栈的叶子。
- en: The file that’s created is interactive, so we can explore where kernel CPU time
    is spent. In the previous example an `INSERT` operation is consuming 44% of the
    CPU time, as you can see in [Figure 16-2](#FIG-MYSQL-INSERT-FLAME).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件是交互式的，因此我们可以探索内核 CPU 时间花在哪里。在前面的示例中，`INSERT` 操作消耗了 44% 的 CPU 时间，正如您可以在
    [图 16-2](#FIG-MYSQL-INSERT-FLAME) 中看到的。
- en: '![lm2e 1601](Images/lm2e_1601.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1601](Images/lm2e_1601.png)'
- en: Figure 16-1\. An example of a flame graph
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-1\. 火焰图示例
- en: '![lm2e 1602](Images/lm2e_1602.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![lm2e 1602](Images/lm2e_1602.png)'
- en: Figure 16-2\. 44% of CPU time is used for an `INSERT` operation
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 16-2\. **44%** 的 CPU 时间用于 `INSERT` 操作
- en: Building MySQL from Source
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码构建 MySQL
- en: As [Chapter 1](ch01.xhtml#CH1_INSTALL) explained, MySQL has a distribution available
    for most common operating systems. Some companies have also compiled their own
    MySQL versions, such as Facebook, which worked on the RocksDB engine and integrated
    it into MySQL. RocksDB is an embeddable, persistent key/value store for fast storage
    that has several advantages compared with InnoDB with regard to space efficiency.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.xhtml#CH1_INSTALL) 所述，MySQL 在大多数常见操作系统上都有可用的发行版。一些公司也编译了自己的 MySQL
    版本，例如 Facebook，他们在 RocksDB 引擎上工作，并将其集成到 MySQL 中。RocksDB 是一个嵌入式持久键值存储，用于快速存储，与
    InnoDB 相比在空间效率上有几个优点。
- en: Despite its advantages, RocksDB does not support replication or a SQL layer.
    This led the Facebook team to build MyRocks, an open source project that integrates
    RocksDB as a MySQL storage engine. With MyRocks, it is possible to use RocksDB
    as backend storage and still benefit from all the features of MySQL. Facebook’s
    project is open source and available on [GitHub](https://oreil.ly/ssWon).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 RocksDB 具有其优点，但不支持复制或 SQL 层。这促使 Facebook 团队构建了 MyRocks，一个将 RocksDB 集成为 MySQL
    存储引擎的开源项目。使用 MyRocks，可以将 RocksDB 作为后端存储，并仍然享受 MySQL 的所有功能。Facebook 的项目是开源的，可以在
    [GitHub](https://oreil.ly/ssWon) 上找到。
- en: Another motivation to compile MySQL is the ability to customize its build. For
    example, for a very specific problem, we can always try to debug MySQL to gather
    extra information. To do this, we need to configure MySQL with the `-DWITH_DEBUG=1`
    option.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个编译 MySQL 的动机是能够定制其构建。例如，针对一个非常特定的问题，我们总是可以尝试调试 MySQL 来收集额外信息。为此，我们需要使用 `-DWITH_DEBUG=1`
    选项配置 MySQL。
- en: Building MySQL for Ubuntu Focal Fossa and ARM Processors
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Ubuntu Focal Fossa 和 ARM 处理器构建 MySQL
- en: Because ARM processors are currently gaining traction (particularly thanks to
    Apple’s M1 chip), we will show you how to compile MySQL for Ubuntu Focal Fossa
    running on ARM.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ARM 处理器目前正在流行（尤其是由于苹果的 M1 芯片），我们将展示如何在运行 ARM 的 Ubuntu Focal Fossa 上编译 MySQL。
- en: 'First, we are going to create our directories. We will create one directory
    that will be for the source code, another one for the compiled binaries, and a
    third for the `boost` library:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们的目录。我们将创建一个用于源代码的目录，另一个用于编译二进制文件的目录，以及一个用于 `boost` 库的目录：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we need to install the additional Linux packages required to compile
    MySQL:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要安装编译 MySQL 所需的额外 Linux 包：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These packages are related to the [CMake flags](https://oreil.ly/GOnBJ) that
    we will run. If we remove or add certain flags, some packages are not necessary
    to install (for example, if we don’t want to compile with Valgrind, we don’t need
    this package).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包与我们将运行的 [CMake 标志](https://oreil.ly/GOnBJ) 相关。如果我们删除或添加某些标志，某些包可能就不再需要安装（例如，如果我们不想使用
    Valgrind 进行编译，那么这个包就不需要了）。
- en: 'Next, we will download the source code. For this, we will use [MySQL repository](https://oreil.ly/6Jb4c)
    on GitHub:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将下载源代码。为此，我们将使用 [MySQL 仓库](https://oreil.ly/6Jb4c) 在 GitHub 上：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will be similar to this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To check which version we will compile, we can run the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们将编译哪个版本，可以运行以下命令：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we will go to our *build* directory and run `CMake` with our chosen flags:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进入我们的 *build* 目录，并使用我们选择的标志运行 `CMake`：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here’s what each of these does:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些各自是做什么的：
- en: '`DBUILD_CONFIG` configures a source distribution with the same build options
    as for MySQL releases (we are going to override some of them).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBUILD_CONFIG` 配置一个与 MySQL 发行版相同的源代码分发，我们将覆盖其中的一些选项。'
- en: '`DCMake_BUILD_TYPE` with `RelWithDebInfo` enables optimizations and generates
    debugging information.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DCMake_BUILD_TYPE` 使用 `RelWithDebInfo` 选项启用优化并生成调试信息。'
- en: '`DWITH_DEBUG` enables the use of the `--debug="d,parser_debug"` option when
    MySQL is started. This causes the Bison parser used to process SQL statements
    to dump a parser trace to the server’s standard error output. Typically, this
    output is written to the error log.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWITH_DEBUG` 在启动 MySQL 时启用 `--debug="d,parser_debug"` 选项。这会导致用于处理 SQL 语句的
    Bison 解析器将解析跟踪转储到服务器的标准错误输出。通常，此输出会写入错误日志。'
- en: '`DFEATURE_SET` indicates we are going to install community features.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DFEATURE_SET` 表示我们将安装社区功能。'
- en: '`DENABLE_DTRACE` includes support for DTrace probes. The DTrace probes in the
    MySQL server are designed to provide information about the execution of queries
    within MySQL and the different areas of the system being utilized during that
    process.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DENABLE_DTRACE` 包括对 DTrace 探针的支持。MySQL 服务器中的 DTrace 探针旨在提供有关 MySQL 中查询执行及其过程中使用的系统不同区域的信息。'
- en: The `DWITH_SSL` option adds support for encrypted connections, entropy for random
    number generation, and other encryption-related operations.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWITH_SSL` 选项添加了对加密连接、生成随机数熵和其他加密相关操作的支持。'
- en: '`DWITH_ZLIB` enables compression library support for the `COMPRESS()` and `UNCOMPRESS()`
    functions, and compression of the client/server protocol.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWITH_ZLIB` 启用压缩库支持 `COMPRESS()` 和 `UNCOMPRESS()` 函数，以及客户端/服务器协议的压缩。'
- en: '`DCMake_INSTALL_PREFIX` sets the location of our installation base directory.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DCMake_INSTALL_PREFIX` 设置我们安装基础目录的位置。'
- en: '`DINSTALL_LIBDIR` indicates where to install the library files.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DINSTALL_LIBDIR` 指示库文件的安装位置。'
- en: '`DINSTALL_SBINDIR` specifies where to install `mysqld`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DINSTALL_SBINDIR`指定安装`mysqld`的位置。'
- en: '`DWITH_INNODB_MEMCACHED` generates memcached shared libraries (*libmemcached.so*
    and *innodb_engine.so*).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWITH_INNODB_MEMCACHED`生成memcached共享库（*libmemcached.so*和*innodb_engine.so*）。'
- en: '`DDOWNLOAD_BOOST` makes CMake download the `boost` library and place it in
    the location specified with `DWITH_BOOST`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DDOWNLOAD_BOOST`让CMake下载`boost`库，并将其放置在`DWITH_BOOST`指定的位置。'
- en: '`DWITH_VALGRIND` enables Valgrind, exposing the Valgrind API to MySQL code.
    This is useful for analyzing memory leaks.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWITH_VALGRIND`启用Valgrind，将Valgrind API暴露给MySQL代码。这对于分析内存泄漏很有用。'
- en: '`DINSTALL_PLUGINDIR` defines where the compiler will place the plugin libraries.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DINSTALL_PLUGINDIR`定义编译器将放置插件库的位置。'
- en: '`DMYSQL_DATADIR` defines the location of the MySQL data directory.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMYSQL_DATADIR`定义MySQL数据目录的位置。'
- en: '`DWITH_BOOST` defines the directory where CMake will download the `boost` library.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DWITH_BOOST`定义CMake将下载`boost`库的目录。'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If by mistake you miss a step and the CMake process fails, to prevent old object
    files or configuration information from being used in the next attempt you’ll
    need to clean up the build directory and the previous configuration. That is,
    you’ll need to run the following commands in the build directory on Unix before
    rerunning CMake:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在CMake过程中错误地错过了一个步骤，并且为了防止旧的对象文件或配置信息在下一次尝试中被使用，你需要清理构建目录和先前的配置。也就是说，在Unix上重新运行CMake之前，你需要在构建目录中运行以下命令：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After we run CMake, we are going to compile MySQL using the `make` command.
    To optimize the compiling process we will use the `-j` option, which specifies
    how many threads we are going to use to compile MySQL. Since in our instance we
    have 16 ARM cores, we are going to use 15 threads (leaving one for OS activities):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: CMake运行后，我们将使用`make`命令编译MySQL。为了优化编译过程，我们将使用`-j`选项，指定编译MySQL时要使用的线程数。因为我们的实例有16个ARM核心，我们将使用15个线程（留一个用于操作系统活动）：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This process may take a while, and it is very verbose. After it’s finished,
    we can see the binaries in the *basedir* directory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能需要一段时间，并且非常冗长。完成后，我们可以在*basedir*目录中看到二进制文件：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that we are not going to find a *mysqld* binary in the */compile/build/bin/*
    directory, but instead we will see *mysqld-debug*. This is because of the `DWITH_DEBUG`
    option we set previously:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在*/compile/build/bin/*目录中找不到*mysqld*二进制文件，而是会看到*mysqld-debug*。这是由于我们之前设置的`DWITH_DEBUG`选项：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we can test our binary. For this we are going to manually create the directories
    and configure the permissions:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试我们的二进制文件。为此，我们将手动创建目录并配置权限：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then add these settings to */etc/my.cnf*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这些设置添加到*/etc/my.cnf*中：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we are going to initialize the MySQL data dictionary:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化MySQL数据字典：
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, MySQL is ready to be started:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，MySQL已准备好启动：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A temporary password will be created, and we can extract it from the error
    log:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个临时密码，我们可以从错误日志中提取它：
- en: '[PRE59]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we can connect using the MySQL client of our preference:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们喜欢的MySQL客户端连接：
- en: '[PRE61]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Analyzing a MySQL Crash
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析MySQL崩溃
- en: 'We say that MySQL *crashes* when the `mysqld` process dies without the proper
    shutdown command. MySQL can crash for a variety of reasons, including these:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当*mysqld*进程在没有正确关闭命令的情况下死掉时，我们称MySQL发生*崩溃*。MySQL可能因多种原因而崩溃，包括以下几种：
- en: Hardware failure (memory, disk, processor)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件故障（内存、磁盘、处理器）
- en: Segmentation faults (invalid memory access)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分段错误（无效内存访问）
- en: Bugs
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bugs
- en: Being killed by the `OOM` process
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被`OOM`进程杀死
- en: Various other causes, such as [cosmic rays](https://oreil.ly/Lq09r).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他各种原因，如[宇宙射线](https://oreil.ly/Lq09r)。
- en: 'The MySQL process can receive a number of signals from Linux. The following
    are among the most common:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL进程可以从Linux接收多种信号。以下是最常见的几种：
- en: Signal 15 (`SIGTERM`)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 信号15 (`SIGTERM`)
- en: 'Causes the server to shut down. This is like executing a `SHUTDOWN` statement
    without having to connect to the server (which for shutdown requires an account
    that has the `SHUTDOWN` privilege). For example, the following two commands result
    in a regular shutdown:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 导致服务器关闭。这就像执行`SHUTDOWN`语句而无需连接服务器（用于关闭需要具有`SHUTDOWN`权限的帐户）。例如，以下两个命令会导致常规关闭：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Signal 1 (`SIGHUP`)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 信号1 (`SIGHUP`)
- en: 'Causes the server to reload the grant tables and to flush tables, logs, the
    thread cache, and the host cache. These actions are like various forms of the
    `FLUSH` statement:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 导致服务器重新加载授权表并刷新表、日志、线程缓存和主机缓存。这些操作类似于各种形式的`FLUSH`语句：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'or:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Signal 6 (`SIGABRT`)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 信号6 (`SIGABRT`)
- en: 'Happens because something went wrong. It is commonly used by `libc` and other
    libraries to abort the program in case of critical errors. For example, `glibc`
    sends a `SIGABRT` if it detects a double free or other heap corruption. `SIGABRT`
    will write the crash details in the MySQL error log, like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于出现了问题而导致的。这通常由 `libc` 和其他库在遇到严重错误时使用。例如，如果检测到双重释放或其他堆内存损坏，`glibc` 将发送 `SIGABRT`。如果
    MySQL 检测到 `SIGABRT`，它将在错误日志中写入崩溃详细信息，如下所示：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Signal 11 (`SIGSEGV`)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 信号 11 (`SIGSEGV`)
- en: Indicates a segmentation fault, bus error, or access violation issue. This is
    generally an attempt to access memory that the CPU cannot physically address,
    or an access violation. When MySQL receives a `SIGSEGV`, a core dump will be created
    if the `core-file` parameter is configured.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 表示分段错误、总线错误或访问违规问题。这通常是尝试访问 CPU 无法物理寻址的内存，或者是访问违规。当 MySQL 收到 `SIGSEGV` 时，如果配置了
    `core-file` 参数，将创建核心转储文件。
- en: Signal 9 (`SIGKILL`)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 信号 9 (`SIGKILL`)
- en: 'Causes a process to terminate immediately (kills it). This is probably the
    most famous signal. In contrast to `SIGTERM` and `SIGINT`, this signal cannot
    be caught or ignored, and the receiving process cannot perform any cleanup upon
    receiving this signal. Besides the chance of corrupting MySQL data, `SIGKILL`
    will also force MySQL to perform a recovery process when restarted to bring it
    to an operational state. The following example shows how to send a `SIGKILL` manually
    to the MySQL process:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 导致进程立即终止（杀死）。这可能是最著名的信号。与 `SIGTERM` 和 `SIGINT` 不同，该信号无法被捕获或忽略，并且接收进程在收到此信号后无法执行任何清理操作。除了可能损坏
    MySQL 数据的机会外，`SIGKILL` 还将在重新启动时强制 MySQL 执行恢复过程，使其恢复到可操作状态。以下示例显示如何手动向 MySQL 进程发送
    `SIGKILL`：
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Also, the Linux `OOM` process executes a `SIGKILL` to terminate with the MySQL
    process.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Linux 的 `OOM` 进程执行 `SIGKILL` 来终止 MySQL 进程。
- en: 'Let’s try to analyze a crash where MySQL got a signal 11:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试分析 MySQL 收到信号 11 导致崩溃的情况：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes stack may not contain fully resolved symbols or may only have addresses.
    That depends on whether the mysqld binary is stripped and whether the debug symbols
    are available. As a rule of thumb, we recommend installing debug symbols, as that
    has no disadvantage other than using up some disk space. Having debug symbols
    installed doesn’t make your MySQL server run in some slow debug mode. Official
    MySQL 8.0 builds are always symbolized, however, so you don’t need to worry.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有时堆栈可能不包含完全解析的符号或仅包含地址。这取决于 mysqld 二进制文件是否经过剥离以及调试符号是否可用。作为经验法则，我们建议安装调试符号，因为这除了占用一些磁盘空间外没有任何缺点。但是，官方的
    MySQL 8.0 构建始终是带有符号的，因此您无需担心。
- en: 'The stack trace is analyzed from top to bottom. We can see from the crash that
    this is a Percona Server v8.0.22\. Next, we see the thread being created at the
    OS level at this point:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆栈跟踪的顶部到底部进行分析。从崩溃中可以看出，这是 Percona Server v8.0.22。接下来，我们看到在此时在操作系统级别创建了一个线程：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Continuing up through the stack, the code path enters MySQL and starts executing
    a command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 继续沿着堆栈向上，代码路径进入 MySQL 并开始执行命令：
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And the code path that crashes is the `Item_splocal` function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 引起崩溃的代码路径是 `Item_splocal` 函数：
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With a bit of investigation in the [MySQL code](https://oreil.ly/OjTUs), we
    discover that `Item_splocal` is part of the stored procedure code. If we look
    at the end of the stack trace, we will see a query:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对[MySQL 代码](https://oreil.ly/OjTUs)的稍加调查，我们发现 `Item_splocal` 是存储过程代码的一部分。如果我们查看堆栈跟踪的末尾，我们会看到一个查询：
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*Triggers* can also use the stored procedure path when they contain variables.
    If we check whether this table has triggers, we see this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*触发器* 也可以在包含变量的存储过程路径中使用。如果我们检查这个表是否有触发器，我们会看到这个：'
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With all this information, we can create a test case and report the bug:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些信息，我们可以创建一个测试案例并报告这个 Bug：
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To reproduce it, we run multiple commands simultaneously in the same table
    until the error happens:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要复现它，我们在同一表中同时运行多个命令，直到发生错误：
- en: '[PRE75]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This bug is relatively easy to reproduce, and we recommend you test it. You
    can find more details about this bug in Percona’s [Jira system](https://oreil.ly/cAWbG).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Bug 相对容易复现，我们建议您进行测试。您可以在 Percona 的 [Jira 系统](https://oreil.ly/cAWbG) 中找到有关此
    Bug 的更多详细信息。
- en: 'Also, we can see that Oracle fixed the bug at version 8.0.23 thanks to the
    [release notes](https://oreil.ly/izg4K):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 在版本 8.0.23 中修复了该 Bug，详情请参阅[发布说明](https://oreil.ly/izg4K)：
- en: 'Prepared statements involving stored programs could cause heap-use-after-free
    memory problems (Bug #32131022, Bug #32045681, Bug #32051928).'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '涉及存储程序的预编译语句可能会导致堆使用后释放内存问题（Bug #32131022，Bug #32045681，Bug #32051928）。'
- en: Sometimes bugs are not easy to reproduce and can be really frustrating to investigate.
    Even experienced engineers have problems with this, especially when investigating
    memory leaks. We hope we have sparked your curiosity to investigate crashes.**
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，bug 不容易重现，调查起来真的很让人沮丧。即使是有经验的工程师，在调查内存泄漏时也会遇到问题。希望我们激发了你对调查崩溃的好奇心。
