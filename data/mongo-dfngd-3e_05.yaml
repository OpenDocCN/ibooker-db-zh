- en: Chapter 4\. Querying
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。查询
- en: 'This chapter looks at querying in detail. The main areas covered are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细讨论了查询。主要涵盖的主题如下：
- en: You can query for ranges, set inclusion, inequalities, and more by using `$`
    conditionals.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `$` 条件来查询范围、集合包含、不等式等更多内容。
- en: Queries return a database cursor, which lazily returns batches of documents
    as you need them.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回一个数据库游标，它在需要时惰性地返回文档批次。
- en: There are a lot of metaoperations you can perform on a cursor, including skipping
    a certain number of results, limiting the number of results returned, and sorting
    results.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在游标上执行许多元操作，包括跳过一定数量的结果、限制返回的结果数量和对结果进行排序。
- en: Introduction to find
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找入门
- en: The `find` method is used to perform queries in MongoDB. Querying returns a
    subset of documents in a collection, from no documents at all to the entire collection.
    Which documents get returned is determined by the first argument to `find`, which
    is a document specifying the query criteria.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 方法用于在 MongoDB 中执行查询。查询返回集合中的文档子集，从不返回文档到返回整个集合。哪些文档被返回由 `find` 的第一个参数决定，该参数是指定查询条件的文档。'
- en: 'An empty query document (i.e., `{}`) matches everything in the collection.
    If `find` isn’t given a query document, it defaults to `{}`. For example, the
    following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 空查询文档（即 `{}`）匹配集合中的所有内容。如果没有给定查询文档，则 `find` 默认为 `{}`。例如，以下示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: matches every document in the collection *c* (and returns these documents in
    batches).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配集合中的每个文档 *c*（并以批量返回这些文档）。
- en: 'When we start adding key/value pairs to the query document, we begin restricting
    our search. This works in a straightforward way for most types: numbers match
    numbers, booleans match booleans, and strings match strings. Querying for a simple
    type is as easy as specifying the value that you are looking for. For example,
    to find all documents where the value for `"age"` is `27`, we can add that key/value
    pair to the query document:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始向查询文档添加键值对时，我们开始限制我们的搜索范围。这对大多数类型都很直接：数字匹配数字，布尔值匹配布尔值，字符串匹配字符串。查询简单类型的方式就像指定您要查找的值一样简单。例如，要查找所有
    `"age"` 值为 `27` 的文档，我们可以将该键值对添加到查询文档中：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we have a string we want to match, such as a `"username"` key with the value
    `"joe"`, we use that key/value pair instead:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要匹配一个字符串，例如具有值 `"joe"` 的 `"username"` 键，我们可以改为使用该键值对：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Multiple conditions can be strung together by adding more key/value pairs to
    the query document, which gets interpreted as “*`condition1`* AND *`condition2`*
    AND … AND *`conditionN`*.” For instance, to get all users who are 27-year-olds
    with the username “joe,” we can query for the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多个条件可以通过向查询文档添加更多键值对来串联在一起，这些条件被解释为“*`condition1`* AND *`condition2`* AND …
    AND *`conditionN`*。” 例如，要获取所有年龄为27岁且用户名为“joe”的用户，我们可以查询如下：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Specifying Which Keys to Return
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定要返回的键
- en: Sometimes you do not need all of the key/value pairs in a document returned.
    If this is the case, you can pass a second argument to `find` (or `findOne`) specifying
    the keys you want. This reduces both the amount of data sent over the wire and
    the time and memory used to decode documents on the client side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您不需要文档中返回的所有键值对。如果是这种情况，可以将第二个参数传递给 `find`（或 `findOne`），指定您想要的键。这不仅减少了通过网络发送的数据量，还减少了客户端解码文档所需的时间和内存。
- en: 'For example, if you have a user collection and you are interested only in the
    `"username"` and `"email"` keys, you could return just those keys with the following
    query:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个用户集合，只对 `"username"` 和 `"email"` 键感兴趣，可以使用以下查询仅返回这些键：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see from the previous output, the `"_id"` key is returned by default,
    even if it isn’t specifically requested.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一输出所示，默认情况下会返回 `"_id"` 键，即使没有显式请求它。
- en: 'You can also use this second parameter to exclude specific key/value pairs
    from the results of a query. For instance, you may have documents with a variety
    of keys, and the only thing you know is that you never want to return the `"fatal_weakness"`
    key:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用第二个参数来排除查询结果中特定的键值对。例如，可能有包含各种键的文档，但您只知道绝对不希望返回 `"fatal_weakness"` 键：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can also prevent `"_id"` from being returned:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以防止返回 `"_id"`：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Limitations
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: 'There are some restrictions on queries. The value of a query document must
    be a constant as far as the database is concerned. (It can be a normal variable
    in your own code.) That is, it cannot refer to the value of another key in the
    document. For example, if we were keeping inventory and we had both `"in_stock"`
    and `"num_sold"` keys, we couldn’t compare their values by querying the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查询存在一些限制。就数据库而言，查询文档的值必须是一个常量。（在您自己的代码中可能是一个普通变量。）也就是说，它不能引用文档中另一个键的值。例如，如果我们正在管理库存，有`"in_stock"`和`"num_sold"`两个键，我们不能通过以下查询来比较它们的值：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are ways to do this (see [“$where Queries”](#sect1_d1e4429)), but you
    will usually get better performance by restructuring your document slightly, such
    that a “normal” query will suffice. In this example, we could instead use the
    keys `"initial_stock"` and `"in_stock"`. Then, every time someone buys an item,
    we decrement the value of the `"in_stock"` key by one. Finally, we can do a simple
    query to check which items are out of stock:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以实现这一点（参见[“$where Queries”](#sect1_d1e4429)），但通常通过稍微重组文档来实现更好的性能，例如使用`"initial_stock"`和`"in_stock"`键。然后，每当有人购买物品时，我们将`"in_stock"`键的值减少一个。最后，我们可以执行简单的查询来检查哪些物品已经售罄：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Query Criteria
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询条件
- en: Queries can go beyond the exact matching described in the previous section;
    they can match more complex criteria, such as ranges, OR-clauses, and negation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 查询可以超出上一节描述的精确匹配，还可以匹配更复杂的条件，例如范围、OR子句和否定。
- en: Query Conditionals
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询条件运算符
- en: '`"$lt"`, `"$lte"`, `"$gt"`, and `"$gte"` are all comparison operators, corresponding
    to <, <=, >, and >=, respectively. They can be combined to look for a range of
    values. For example, to look for users who are between the ages of 18 and 30,
    we can do this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$lt"`、`"$lte"`、`"$gt"`和`"$gte"`都是比较运算符，分别对应于 <、<=、> 和 >=。它们可以组合使用来查找一系列的值。例如，要查找年龄在18到30岁之间的用户，我们可以这样做：'
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This would find all documents where the `"age"` field was greater than or equal
    to `18` AND less than or equal to `30`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将查找所有`"age"`字段大于或等于`18`且小于或等于`30`的文档。
- en: 'These types of range queries are often useful for dates. For example, to find
    people who registered before January 1, 2007, we can do this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的范围查询通常对日期非常有用。例如，要找到在2007年1月1日之前注册的人员，我们可以这样做：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Depending on how you create and store dates, an exact match might be less useful,
    since dates are stored with millisecond precision. Often you want a whole day,
    week, or month, making a range query necessary.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您如何创建和存储日期，精确匹配可能不太有用，因为日期是以毫秒精度存储的。通常情况下，您可能需要整天、整周或整月，因此需要进行范围查询。
- en: 'To query for documents where a key’s value is not equal to a certain value,
    you must use another conditional operator, `"$ne"`, which stands for “not equal.”
    If you want to find all users who do not have the username “joe,” you can query
    for them using this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询键值不等于某个值的文档，必须使用另一个条件运算符`"$ne"`，它代表“不等于”。如果您想找到所有没有用户名为“joe”的用户，可以使用以下查询：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`"$ne"` can be used with any type.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$ne"`可以与任何类型一起使用。'
- en: OR Queries
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OR查询
- en: There are two ways to do an OR query in MongoDB. `"$in"` can be used to query
    for a variety of values for a single key. `"$or"` is more general; it can be used
    to query for any of the given values across multiple keys.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中有两种方法进行OR查询。`"$in"`可以用来查询单个键的多个值。`"$or"`更通用；它可以用来查询多个键中给定值的任何一个。
- en: 'If you have more than one possible value to match for a single key, use an
    array of criteria with `"$in"`. For instance, suppose we’re running a raffle and
    the winning ticket numbers are 725, 542, and 390\. To find all three of these
    documents, we can construct the following query:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个键有多个可能的匹配值，请使用`"$in"`的数组条件。例如，假设我们正在进行抽奖，获奖的票号分别是725、542和390。为了找到所有这三个文档，我们可以构建以下查询：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`"$in"` is very flexible and allows you to specify criteria of different types
    as well as values. For example, if we are gradually migrating our schema to use
    usernames instead of user ID numbers, we can query for either by using this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$in"`非常灵活，允许您指定不同类型和值的条件。例如，如果我们正在逐步迁移我们的模式以使用用户名而不是用户ID号码，我们可以通过以下方式查询：'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This matches documents with a `"user_id"` equal to `12345` and documents with
    a `"user_id"` equal to `"joe"`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配`"user_id"`等于`12345`和`"user_id"`等于`"joe"`的文档。
- en: 'If `"$in"` is given an array with a single value, it behaves the same as directly
    matching the value. For instance, `{ticket_no : {$in : [725]}}` matches the same
    documents as `{ticket_no : 725}`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `"$in"` 提供的是一个包含单个值的数组，则其行为与直接匹配该值相同。例如，`{ticket_no: {$in: [725]}}` 与 `{ticket_no:
    725}` 匹配相同的文档。'
- en: 'The opposite of `"$in"` is `"$nin"`, which returns documents that don’t match
    any of the criteria in the array. If we want to return all of the people who didn’t
    win anything in the raffle, we can query for them with this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$in"` 的反义是 `"$nin"`，它返回不匹配数组中任何条件的文档。如果我们想要返回在抽奖中没有赢得任何东西的所有人，我们可以用这个查询：'
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This query returns everyone who did not have tickets with those numbers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回那些没有具有这些号码的票的人。
- en: '`"$in"` gives you an OR query for a single key, but what if we need to find
    documents where `"ticket_no"` is `725` or `"winner"` is `true`? For this type
    of query, we’ll need to use the `"$or"` conditional. `"$or"` takes an array of
    possible criteria. In the raffle case, using `"$or"` would look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$in"` 为单个键提供了 OR 查询，但如果我们需要找到 `"ticket_no"` 是 `725` 或 `"winner"` 是 `true`
    的文档，我们需要使用 `"$or"` 条件。`"$or"` 接受一个可能条件的数组。在抽奖案例中，使用 `"$or"` 如下所示：'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`"$or"` can contain other conditionals. If, for example, we want to match any
    of the three `"ticket_no"` values or the `"winner"` key, we can use this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$or"` 可以包含其他条件。例如，如果我们想匹配任意三个 `"ticket_no"` 值或 `"winner"` 键，则可以使用以下方式：'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With a normal AND-type query, you want to narrow down your results as far as
    possible in as few arguments as possible. OR-type queries are the opposite: they
    are most efficient if the first arguments match as many documents as possible.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通的 AND 类型查询，你希望尽可能少的参数尽可能缩小结果范围。OR 类型查询则相反：如果第一个参数匹配尽可能多的文档，则效率最高。
- en: While `"$or"` will always work, use `"$in"` whenever possible as the query optimizer
    handles it more efficiently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `"$or"` 总是有效，但尽可能使用 `"$in"`，因为查询优化器处理它更有效率。
- en: $not
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $not
- en: '`"$not"` is a metaconditional: it can be applied on top of any other criteria.
    As an example, let’s consider the modulus operator, `"$mod"`. `"$mod"` queries
    for keys whose values, when divided by the first value given, have a remainder
    of the second value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$not"` 是一种元条件：它可以应用在任何其他条件之上。例如，让我们考虑模数运算符 `"$mod"`。`"$mod"` 查询的是其值除以给定的第一个值后余数为第二个值的键：'
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous query returns users with `"id_num"`s of `1`, `6`, `11`, `16`,
    and so on. If we want, instead, to return users with `"id_num"`s of `2`, `3`,
    `4`, `5`, `7`, `8`, `9`, `10`, `12`, etc., we can use `"$not"`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询返回了 `"id_num"` 为 `1`、`6`、`11`、`16` 等的用户。如果我们想要返回 `"id_num"` 为 `2`、`3`、`4`、`5`、`7`、`8`、`9`、`10`、`12`
    等的用户，可以使用 `"$not"`：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`"$not"` can be particularly useful in conjunction with regular expressions
    to find all documents that don’t match a given pattern (regular expression usage
    is described in the section [“Regular Expressions”](#sect2_d1e4085)).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$not"` 结合正则表达式特别有用，用于查找所有不匹配给定模式的文档（正则表达式的使用在章节 [“Regular Expressions”](#sect2_d1e4085)
    中描述）。'
- en: Type-Specific Queries
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型特定查询
- en: As covered in [Chapter 2](ch02.xhtml#chapter-2), MongoDB has a wide variety
    of types that can be used in a document. Some of these types have special behavior
    when querying.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 2 章](ch02.xhtml#chapter-2) 中所述，MongoDB 具有多种可以在文档中使用的类型。某些类型在查询时具有特殊行为。
- en: 'null'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'null'
- en: '`null` behaves a bit strangely. It does match itself, so if we have a collection
    with the following documents:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: null 的行为有些奇怪。它确实匹配自身，因此如果我们有一个包含以下文档的集合：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'we can query for documents whose `"y"` key is `null` in the expected way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按预期的方式查询 `"y"` 键为 `null` 的文档：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, `null` also matches “does not exist.” Thus, querying for a key with
    the value `null` will return all documents lacking that key:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`null` 也匹配“不存在”。因此，查询具有值为 `null` 的键将返回所有缺少该键的文档：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we only want to find keys whose value is `null`, we can check that the key
    is `null` and exists using the `"$exists"` conditional:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想找到值为 `null` 的键，我们可以检查该键是否为 `null` 并存在，使用 `"$exists"` 条件：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Regular Expressions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: '`"$regex"` provides regular expression capabilities for pattern matching strings
    in queries. Regular expressions are useful for flexible string matching. For example,
    if we want to find all users with the name “Joe” or “joe,” we can use a regular
    expression to do case-insensitive matching:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$regex"` 提供了正则表达式功能，用于在查询中匹配字符串模式。正则表达式对于灵活的字符串匹配非常有用。例如，如果我们想找到所有名为“Joe”或“joe”的用户，可以使用正则表达式进行大小写不敏感匹配：'
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Regular expression flags (e.g., `i`) are allowed but not required. If we want
    to match not only various capitalizations of “joe,” but also “joey,” we can continue
    to improve our regular expression:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式标志（例如 `i`）是允许的但不是必需的。如果我们想匹配不仅是“joe”不同大小写形式，还包括“joey”，我们可以继续改进我们的正则表达式：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: MongoDB uses the Perl Compatible Regular Expression (PCRE) library to match
    regular expressions; any regular expression syntax allowed by PCRE is allowed
    in MongoDB. It is a good idea to check your syntax with the JavaScript shell before
    using it in a query to make sure it matches what you think it matches.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 使用 Perl 兼容正则表达式（PCRE）库来匹配正则表达式；任何 PCRE 允许的正则表达式语法在 MongoDB 中都是允许的。在使用查询之前，建议在
    JavaScript shell 中检查您的语法，以确保它匹配您认为的内容。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB can leverage an index for queries on prefix regular expressions (e.g.,
    `/^joey/`). Indexes *cannot* be used for case-insensitive searches (`/^joey/i`).
    A regular expression is a “prefix expression” when it starts with either a caret
    (`^`) or a left anchor (`\A`). If the regular expression uses a case-sensitive
    query, then if an index exists for the field, the matches can be conducted against
    values in the index. If it also is a prefix expression, then the search can be
    limited to the values within the range created by that prefix from the index.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 可以利用前缀正则表达式（例如 `/^joey/`）的索引进行查询。索引 *不能* 用于不区分大小写的搜索（`/^joey/i`）。当正则表达式以插入符号
    (`^`) 或左锚点 (`\A`) 开头时，它被称为“前缀表达式”。如果正则表达式使用区分大小写的查询，那么如果字段存在索引，匹配可以针对索引中的值进行。如果它也是前缀表达式，那么搜索可以限制在索引中由该前缀创建的范围内的值。
- en: 'Regular expressions can also match themselves. Very few people insert regular
    expressions into the database, but if you insert one, you can match it with itself:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式也可以匹配自身。很少有人将正则表达式插入到数据库中，但如果您插入一个，可以与其本身匹配：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Querying Arrays
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数组
- en: 'Querying for elements of an array is designed to behave the way querying for
    scalars does. For example, if the array is a list of fruits, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数组元素的行为设计得与标量查询相同。例如，如果数组是像这样的水果列表：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'the following query will successfully match the document:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询将成功匹配文档：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can query for it in much the same way as we would if we had a document that
    looked like the (illegal) document `{"fruit" : "apple", "fruit" : "banana", "fruit"
    : "peach"}`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以像查询类似于（非法）文档 `{"fruit" : "apple", "fruit" : "banana", "fruit" : "peach"}`
    的方式来查询它。'
- en: “$all”
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “$all”
- en: 'If you need to match arrays by more than one element, you can use `"$all"`.
    This allows you to match a list of elements. For example, suppose we create a
    collection with three elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要通过多个元素匹配数组，可以使用 `"$all"`。这允许您匹配一个元素列表。例如，假设我们创建一个包含三个元素的集合：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we can find all documents with both `"apple"` and `"banana"` elements
    by querying with `"$all"`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过使用 `"$all"` 查询来找到所有包含 `"apple"` 和 `"banana"` 元素的文档：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Order does not matter. Notice `"banana"` comes before `"apple"` in the second
    result. Using a one-element array with `"$all"` is equivalent to not using `"$all"`.
    For instance, `{fruit : {$all : [''apple'']}` will match the same documents as
    `{fruit : ''apple''}`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '顺序不重要。请注意，第二个结果中 `"banana"` 出现在 `"apple"` 之前。使用带有 `"$all"` 的单元素数组等同于不使用 `"$all"`。例如，`{fruit
    : {$all : [''apple'']}` 将与 `{fruit : ''apple''}` 匹配相同的文档。'
- en: 'You can also query by exact match using the entire array. However, exact match
    will not match a document if any elements are missing or superfluous. For example,
    this will match the first of our three documents:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过整个数组进行精确匹配查询。但是，如果任何元素缺失或多余，精确匹配将不会匹配文档。例如，这将匹配我们三个文档中的第一个：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But this will not:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'and neither will this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这也不会：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to query for a specific element of an array, you can specify an
    index using the syntax *`key`*.*`index`*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查询数组的特定元素，可以使用 *`key`*.*`index`* 的语法指定索引：
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Arrays are always 0-indexed, so this would match the third array element against
    the string `"peach"`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数组始终从 0 开始索引，因此这将使第三个数组元素与字符串 `"peach"` 匹配。
- en: “$size”
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “$size”
- en: 'A useful conditional for querying arrays is `"$size"`, which allows you to
    query for arrays of a given size. Here’s an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数组的一个有用的条件是 `"$size"`，它允许您查询特定大小的数组。以下是一个示例：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One common query is to get a range of sizes. `"$size"` cannot be combined with
    another `$` conditional (in this example, `"$gt"`), but this query can be accomplished
    by adding a `"size"` key to the document. Then, every time you add an element
    to the array, increment the value of `"size"`. If the original update looked like
    this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的查询是获取一系列大小。 `"$size"` 不能与另一个 `$` 条件结合使用（在这个例子中是 `"$gt"`），但可以通过向文档添加 `"size"`
    键来实现此查询。然后，每次向数组添加元素时，增加 `"size"` 的值。如果原始更新看起来像这样：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'it can simply be changed to this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以简单地更改为这样：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Incrementing is extremely fast, so any performance penalty is negligible. Storing
    documents like this allows you to do queries such as this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 自增非常快，因此任何性能损失都可以忽略不计。像这样存储文档允许你执行这样的查询：
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Unfortunately, this technique doesn’t work as well with the `"$addToSet"` operator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种技术与 `"$addToSet"` 运算符的结合效果不佳。
- en: “$slice”
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`"$slice"`'
- en: As mentioned earlier in this chapter, the optional second argument to `find`
    specifies the keys to be returned. The special `"$slice"` operator can be used
    to return a subset of elements for an array key.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的，`find` 的可选第二个参数指定要返回的键。特殊的 `"$slice"` 运算符可以用来返回数组键的子集。
- en: 'For example, suppose we had a blog post document and we wanted to return the
    first 10 comments:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个博客文章文档，并且想返回前10条评论：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, if we wanted the last 10 comments, we could use `−10`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想要最后10条评论，我们可以使用 `-10`：
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`"$slice"` can also return pages in the middle of the results by taking an
    offset and the number of elements to return:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$slice"` 也可以通过指定偏移量和要返回的元素数量返回结果中的页面中的页面：'
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This would skip the first 23 elements and return the 24th through 33rd. If there
    were fewer than 33 elements in the array, it would return as many as possible.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将跳过前23个元素，并返回第24到33个元素。如果数组中的元素少于33个，它将返回尽可能多的元素。
- en: 'Unless otherwise specified, all keys in a document are returned when `"$slice"`
    is used. This is unlike the other key specifiers, which suppress unmentioned keys
    from being returned. For instance, if we had a blog post document that looked
    like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，使用 `"$slice"` 时文档中的所有键都会被返回。这与其他键规范不同，其他键规范会抑制未提及的键的返回。例如，如果我们有一个博客文章文档如下所示：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and we did a `"$slice"` to get the last comment, we’d get this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `"$slice"` 来获取最后一条评论，我们将得到以下内容：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both `"title"` and `"content"` are still returned, even though they weren’t
    explicitly included in the key specifier.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有显式包含在键规范中，`"title"` 和 `"content"` 仍然会被返回。
- en: Returning a matching array element
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回匹配的数组元素
- en: '`"$slice"` is helpful when you know the index of the element, but sometimes
    you want whichever array element matched your criteria. You can return the matching
    element with the `$` operator. Given the previous blog example, you could get
    Bob’s comment back with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$slice"` 在你知道元素索引时非常有用，但有时你希望返回任何与你的条件匹配的数组元素。你可以使用 `$` 运算符返回匹配的元素。给定前面的博客示例，你可以通过以下方式获取Bob的评论：'
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that this only returns the first match for each document: if Bob had left
    multiple comments on this post, only the first one in the `"comments"` array would
    be returned.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只返回每个文档的第一个匹配项：如果Bob在这篇文章上留了多条评论，只返回在 `"comments"` 数组中的第一条。
- en: Array and range query interactions
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和范围查询的交互
- en: 'Scalars (nonarray elements) in documents must match each clause of a query’s
    criteria. For example, if you queried for `{"x" : {"$gt" : 10, "$lt" : 20}}`,
    `"x"` would have to be both greater than 10 and less than 20\. However, if a document’s
    `"x"` field is an array, the document matches if there is an element of `"x"`
    that matches each part of the criteria *but each query clause can match a different
    array element*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '文档中的标量（非数组元素）必须符合查询条件的每个子句。例如，如果你查询 `{"x" : {"$gt" : 10, "$lt" : 20}}`，`"x"`
    必须同时大于10和小于20。然而，如果文档的 `"x"` 字段是一个数组，那么文档匹配的条件是 `"x"` 中有一个元素满足每个查询子句 *但每个查询子句可以匹配不同的数组元素*。'
- en: 'The best way to understand this behavior is to see an example. Suppose we have
    the following documents:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种行为的最佳方法是看一个例子。假设我们有以下文档：
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we wanted to find all documents where `"x"` is between 10 and 20, we might
    naively structure a query as `db.test.find({"x" : {"$gt" : 10, "$lt" : 20}})`
    and expect to get back one document: `{"x" : 15}`. However, running this, we get
    two:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们想找到所有 `"x"` 在10到20之间的文档，我们可能会天真地将查询结构化为 `db.test.find({"x" : {"$gt" : 10,
    "$lt" : 20}})`，并期望得到一个文档： `{"x" : 15}`。然而，运行此查询，我们得到了两个文档：'
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Neither 5 nor 25 is between 10 and 20, but the document is returned because
    25 matches the first clause (it is greater than 10) and 5 matches the second clause
    (it is less than 20).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 既不是 5 也不是 25 在 10 和 20 之间，但是文档被返回，因为 25 匹配了第一个子句（它大于 10），而 5 匹配了第二个子句（它小于 20）。
- en: 'This makes range queries against arrays essentially useless: a range will match
    any multielement array. There are a couple of ways to get the expected behavior.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得对数组进行范围查询基本无效：范围将匹配任何多元素数组。有几种方法可以获得预期的行为。
- en: 'First, you can use `"$elemMatch"` to force MongoDB to compare both clauses
    with a single array element. However, the catch is that `"$elemMatch"` won’t match
    nonarray elements:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用 `"$elemMatch"` 强制 MongoDB 将两个子句与单个数组元素进行比较。然而，问题在于 `"$elemMatch"` 不会匹配非数组元素：
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The document `{"x" : 15}` no longer matches the query, because the `"x"` field
    is not an array. That said, you should have a good reason for mixing array and
    scalar values in a field. Many uses cases do not require mixing. For those, `"$elemMatch"`
    provides a good solution for range queries on array elements.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '文档 `{"x" : 15}` 不再与查询匹配，因为 `"x"` 字段不是数组。也就是说，在字段中混合使用数组和标量值时，你应该有充分的理由。许多用例不需要混合使用。对于这些情况，`"$elemMatch"`
    为数组元素的范围查询提供了一个很好的解决方案。'
- en: 'If you have an index over the field that you’re querying on (see [Chapter 5](ch05.xhtml#chapter_d1e5128)),
    you can use `min` and `max` to limit the index range traversed by the query to
    your `"$gt"` and `"$lt"` values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在查询字段上有索引（参见[第 5 章](ch05.xhtml#chapter_d1e5128)），你可以使用 `min` 和 `max` 限制查询遍历的索引范围到
    `"$gt"` 和 `"$lt"` 的值：
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now this will only traverse the index from 10 to 20, missing the 5 and 25 entries.
    You can only use `min` and `max` when you have an index on the field you are querying
    for, though, and you must pass all fields of the index to `min` and `max`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这将仅遍历从 10 到 20 的索引，忽略了 5 和 25 的条目。你只能在查询字段上有索引时使用 `min` 和 `max`，并且必须将索引的所有字段传递给
    `min` 和 `max`。
- en: Using `min` and `max` when querying for ranges over documents that may include
    arrays is generally a good idea. The index bounds for a `"$gt"`/`"$lt"` query
    over an array is inefficient. It basically accepts any value, so it will search
    every index entry, not just those in the range.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询可能包含数组的文档上使用 `min` 和 `max` 通常是个好主意。对数组的 `"$gt"`/`"$lt"` 查询的索引边界是低效的。它基本上接受任何值，因此将搜索每个索引条目，而不仅仅是在范围内的条目。
- en: Querying on Embedded Documents
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询嵌入文档
- en: 'There are two ways of querying for an embedded document: querying for the whole
    document or querying for its individual key/value pairs.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种查询嵌入文档的方法：查询整个文档或查询其各个键/值对。
- en: 'Querying for an entire embedded document works identically to a normal query.
    For example, if we have a document that looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个嵌入文档的查询与普通查询完全相同。例如，如果我们有一个看起来像这样的文档：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'we can query for someone named Joe Schmoe with the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查询名为 Joe Schmoe 的人如下：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, a query for a full subdocument must exactly match the subdocument.
    If Joe decides to add a middle name field, suddenly this query won’t work anymore;
    it doesn’t match the entire embedded document! This type of query is also order-sensitive:
    `{"last" : "Schmoe", "first" : "Joe"}` would not be a match.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，完整子文档的查询必须完全匹配子文档。如果 Joe 决定添加一个中间名字段，突然这个查询就不再起作用了；它不匹配整个嵌入文档！这种查询也是有序敏感的：`{"last"
    : "Schmoe", "first" : "Joe"}` 不会匹配。'
- en: 'If possible, it’s usually a good idea to query for just a specific key or keys
    of an embedded document. Then, if your schema changes, all of your queries won’t
    suddenly break because they’re no longer exact matches. You can query for embedded
    keys using dot notation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，通常最好只查询嵌入文档的特定键或键。然后，如果你的模式发生变化，你所有的查询不会突然因为它们不再是精确匹配而断开。你可以使用点符号来查询嵌入键：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, if Joe adds more keys, this query will still match his first and last names.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 Joe 添加了更多的键，这个查询仍然可以匹配他的姓和名。
- en: This dot notation is the main difference between query documents and other document
    types. Query documents can contain dots, which mean “reach into an embedded document.”
    Dot notation is also the reason that documents to be inserted cannot contain the
    `.` character. Oftentimes people run into this limitation when trying to save
    URLs as keys. One way to get around it is to always perform a global replace before
    inserting or after retrieving, substituting a character that isn’t legal in URLs
    for the dot character.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此点符号标记是查询文档与其他文档类型之间的主要区别。查询文档可以包含点号，表示“进入嵌入文档”。点符号也是插入时不能包含`.`字符的原因。人们在尝试将URL保存为键时经常遇到此限制的情况。解决办法之一是在插入或检索之前始终执行全局替换，将不合法的URL字符替换为点字符。
- en: 'Embedded document matches can get a little tricky as the document structure
    gets more complicated. For example, suppose we are storing blog posts and we want
    to find comments by Joe that were scored at least a 5\. We could model the post
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着文档结构变得更加复杂，嵌入文档的匹配可能会变得有些棘手。例如，假设我们存储博客文章，并且想要找到Joe发表的评分至少为5的评论。我们可以如下建模：
- en: '[PRE51]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can’t query using `db.blog.find({"comments" : {"author" : "joe", "score"
    : {"$gte" : 5}}})`. Embedded document matches have to match the whole document,
    and this doesn’t match the `"comment"` key. It also wouldn’t work to do `db.blog.find({"comments.author"
    : "joe", "comments.score" : {"$gte" : 5}})`, because the author criterion could
    match a different comment than the score criterion. That is, it would return the
    document shown above: it would match `"author" : "joe"` in the first comment and
    `"score" : 6` in the second comment.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们不能使用`db.blog.find({"comments" : {"author" : "joe", "score" : {"$gte" :
    5}}})`进行查询。嵌入文档匹配必须匹配整个文档，而这不匹配`"comment"`键。同样也不能这样做`db.blog.find({"comments.author"
    : "joe", "comments.score" : {"$gte" : 5}})`，因为作者条件可能与评分条件匹配不同的评论。也就是说，它会返回上述文档：它会匹配第一个评论中的`"author"
    : "joe"`和第二个评论中的`"score" : 6`。'
- en: 'To correctly group criteria without needing to specify every key, use `"$elemMatch"`.
    This vaguely named conditional allows you to partially specify criteria to match
    a single embedded document in an array. The correct query looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确分组条件，而不需要指定每个键，请使用`"$elemMatch"`。这个名称模糊的条件允许您部分指定匹配数组中单个嵌入文档的条件。正确的查询如下：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`"$elemMatch"` allows you to “group” your criteria. As such, it’s only needed
    when you have more than one key you want to match on in an embedded document.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$elemMatch"`允许您“分组”您的条件。因此，只有当您在嵌入文档中有多个键需要匹配时才需要它。'
- en: $where Queries
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`$where` 查询'
- en: Key/value pairs are a fairly expressive way to query, but there are some queries
    that they cannot represent. For queries that cannot be done any other way, there
    are `"$where"` clauses, which allow you to execute arbitrary JavaScript as part
    of your query. This allows you to do (almost) anything within a query. For security,
    use of `"$where"` clauses should be highly restricted or eliminated. End users
    should never be allowed to execute arbitrary `"$where"` clauses.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值对是一种相当表达力强的查询方式，但有些查询无法表示。对于无法通过其他方式完成的查询，有`"$where"`子句可以使用，允许您在查询中执行任意JavaScript。这允许您在查询中执行（几乎）任何操作。为了安全起见，应该严格限制或消除`"$where"`子句的使用。终端用户不应被允许执行任意`"$where"`子句。
- en: 'The most common case for using `"$where"` is to compare the values for two
    keys in a document. For instance, suppose we have documents that look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"$where"`最常见的情况是比较文档中两个键的值。例如，假设我们有这样的文档：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We’d like to return documents where any two of the fields are equal. For example,
    in the second document, `"spinach"` and `"watermelon"` have the same value, so
    we’d like that document returned. It’s unlikely MongoDB will ever have a `$` conditional
    for this, so we can use a `"$where"` clause to do it with JavaScript:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望返回任意两个字段相等的文档。例如，在第二个文档中，`"spinach"`和`"watermelon"`具有相同的值，因此我们希望返回该文档。MongoDB不太可能会有一个`$`条件来处理这个问题，所以我们可以使用`"$where"`子句在JavaScript中执行它：
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the function returns `true`, the document will be part of the result set;
    if it returns `false`, it won’t be.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数返回`true`，则该文档将成为结果集的一部分；如果返回`false`，则不会。
- en: '`"$where"` queries should not be used unless strictly necessary: they are much
    slower than regular queries. Each document has to be converted from BSON to a
    JavaScript object and then run through the `"$where"` expression. Indexes cannot
    be used to satisfy a `"$where"` either. Hence, you should use `"$where"` only
    when there is no other way of doing the query. You can cut down on the penalty
    by using other query filters in combination with `"$where"`. If possible, an index
    will be used to filter based on the non-`$where` clauses; the `"$where"` expression
    will be used only to fine-tune the results. MongoDB 3.6 added the `$expr` operator
    which allows the use of aggregation expressions with the MongoDB query language.
    It is faster than `$where` as it does not execute JavaScript and is recommended
    as a replacement to this operator where possible.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除非绝对必要，否则不应使用`"$where"`查询：它们比常规查询慢得多。每个文档都必须从BSON转换为JavaScript对象，然后通过`"$where"`表达式运行。索引也不能用于满足`"$where"`条件。因此，只有在没有其他方法可以执行查询时才应使用`"$where"`。通过与`"$where"`结合使用其他查询过滤器可以减少惩罚。如果可能，将使用索引根据非`$where`子句进行过滤；`"$where"`表达式将仅用于微调结果。MongoDB
    3.6添加了`$expr`运算符，允许在MongoDB查询语言中使用聚合表达式。它比`$where`更快，因为不执行JavaScript，并建议在可能的情况下使用它来替换此运算符。
- en: Another way of doing complex queries is to use one of the aggregation tools,
    which are covered in [Chapter 7](ch07.xhtml#chapter_d1e6036).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 进行复杂查询的另一种方式是使用聚合工具之一，这在[第7章](ch07.xhtml#chapter_d1e6036)中有所涵盖。
- en: Cursors
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游标
- en: The database returns results from `find` using a *cursor*. The client-side implementations
    of cursors generally allow you to control a great deal about the eventual output
    of a query. You can limit the number of results, skip over some number of results,
    sort results by any combination of keys in any direction, and perform a number
    of other powerful operations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库使用*游标*从`find`返回结果。游标的客户端实现通常允许您控制查询的最终输出的很多方面。您可以限制结果的数量，跳过一些结果，按任意键的任意组合和方向对结果进行排序，并执行许多其他强大的操作。
- en: 'To create a cursor with the shell, put some documents into a collection, do
    a query on them, and assign the results to a local variable (variables defined
    with `"var"` are local). Here, we create a very simple collection and query it,
    storing the results in the `cursor` variable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要在shell中创建游标，请将一些文档放入集合中，对它们进行查询，并将结果分配给一个本地变量（使用`"var"`定义的变量是局部的）。在这里，我们创建一个非常简单的集合并查询它，将结果存储在`cursor`变量中：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The advantage of doing this is that you can look at one result at a time. If
    you store the results in a global variable or no variable at all, the MongoDB
    shell will automatically iterate through and display the first couple of documents.
    This is what we’ve been seeing up until this point, and it is often the behavior
    you want for seeing what’s in a collection but not doing actual programming with
    the shell.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的优点是您可以一次查看一个结果。如果将结果存储在全局变量或根本不存储变量中，MongoDB shell将自动迭代并显示前几个文档。这是我们到目前为止看到的行为，并且通常是您查看集合内容而不是使用shell进行实际编程时想要的行为。
- en: 'To iterate through the results, you can use the `next` method on the cursor.
    You can use `hasNext` to check whether there is another result. A typical loop
    through result looks like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历结果，您可以使用游标的`next`方法。您可以使用`hasNext`检查是否有另一个结果。典型的遍历结果的循环如下所示：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`cursor.hasNext()` checks that the next result exists, and `cursor.next()`
    fetches it.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`cursor.hasNext()`检查是否存在下一个结果，`cursor.next()`获取下一个结果。'
- en: 'The `cursor` class also implements JavaScript’s iterator interface, so you
    can use it in a `forEach` loop:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`cursor`类还实现了JavaScript的迭代器接口，因此您可以在`forEach`循环中使用它：'
- en: '[PRE57]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When you call `find`, the shell does not query the database immediately. It
    waits until you start requesting results to send the query, which allows you to
    chain additional options onto a query before it is performed. Almost every method
    on a `cursor` object returns the cursor itself, so that you can chain options
    in any order. For instance, all of the following are equivalent:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`find`时，shell不会立即查询数据库。它会等到您开始请求结果时才发送查询，这使您可以在执行查询之前对查询进行附加选项的链式调用。几乎`cursor`对象上的每个方法都返回游标本身，因此您可以按任意顺序链式调用选项。例如，以下所有方式都是等效的：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At this point, the query has not been executed yet. All of these functions
    merely build the query. Now, suppose we call the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，查询还没有执行。所有这些函数只是构建查询而已。现在，假设我们调用以下内容：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: At this point, the query will be sent to the server. The shell fetches the first
    100 results or first 4 MB of results (whichever is smaller) at once so that the
    next calls to `next` or `hasNext` will not have to make trips to the server. After
    the client has run through the first set of results, the shell will again contact
    the database and ask for more results with a `getMore` request. `getMore` requests
    basically contain an identifier for the cursor and ask the database if there are
    any more results, returning the next batch if there are. This process continues
    until the cursor is exhausted and all results have been returned.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，查询将被发送到服务器。Shell一次获取前100个结果或前4 MB的结果（以较小者为准），这样下一次调用`next`或`hasNext`就不必再次与服务器通信。客户端浏览了第一批结果后，Shell将再次联系数据库，并通过`getMore`请求获取更多结果。`getMore`请求基本上包含一个游标标识符，并询问数据库是否还有更多结果，如果有，则返回下一批。这个过程持续到游标耗尽并返回所有结果为止。
- en: Limits, Skips, and Sorts
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制、跳过和排序
- en: The most common query options are limiting the number of results returned, skipping
    a number of results, and sorting. All these options must be added before a query
    is sent to the database.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的查询选项包括限制返回的结果数量、跳过一定数量的结果以及排序。所有这些选项必须在向数据库发送查询之前添加。
- en: 'To set a limit, chain the `limit` function onto your call to `find`. For example,
    to only return three results, use this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置限制，请将`limit`函数链接到`find`的调用中。例如，要仅返回三个结果，请使用：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If there are fewer than three documents matching your query in the collection,
    only the number of matching documents will be returned; `limit` sets an upper
    limit, not a lower limit.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在集合中查询的匹配文档少于三个，则只返回匹配文档的数量；`limit`设置的是上限，而不是下限。
- en: '`skip` works similarly to `limit`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`的工作方式类似于`limit`：'
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This will skip the first three matching documents and return the rest of the
    matches. If there are fewer than three documents in your collection, it will not
    return any documents.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将跳过前三个匹配的文档并返回其余的匹配项。如果集合中的文档少于三个，则不会返回任何文档。
- en: '`sort` takes an object: a set of key/value pairs where the keys are key names
    and the values are the sort directions. The sort direction can be `1` (ascending)
    or `−1` (descending). If multiple keys are given, the results will be sorted in
    that order. For instance, to sort the results by `"username"` ascending and `"age"`
    descending, we do the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`接受一个对象：一组键/值对，其中键是键名，值是排序方向。排序方向可以是`1`（升序）或`−1`（降序）。如果给定多个键，则结果将按顺序排序。例如，要按`"username"`升序和`"age"`降序排序结果，我们这样做：'
- en: '[PRE62]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'These three methods can be combined. This is often handy for pagination. For
    example, suppose that you are running an online store and someone searches for
    *mp3*. If you want 50 results per page sorted by price from high to low, you can
    do the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法可以结合使用。这对分页非常方便。例如，假设你运营一个在线商店，有人搜索*mp3*。如果你想每页显示50个结果，并按价格从高到低排序，可以这样做：
- en: '[PRE63]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If that person clicks Next Page to see more results, you can simply add a skip
    to the query, which will skip over the first 50 matches (which the user already
    saw on page 1):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击“下一页”查看更多结果，则可以简单地在查询中添加一个skip，这将跳过前50个匹配项（用户在第一页上已经看过的）：
- en: '[PRE64]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However, large skips are not very performant; there are suggestions for how
    to avoid them in the next section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大的跳过并不太高效；在下一节中有建议如何避免它们。
- en: Comparison order
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较顺序
- en: 'MongoDB has a hierarchy as to how types compare. Sometimes you will have a
    single key with multiple types: for instance, integers and booleans, or strings
    and nulls. If you do a sort on a key with a mix of types, there is a predefined
    order that they will be sorted in. From least to greatest value, this ordering
    is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有一套类型比较的层次结构。有时你会有一个单一的键包含多种类型：例如整数和布尔值，或字符串和null值。如果对混合类型的键进行排序，则会按预定义的顺序进行排序。从最小到最大的值，这个排序顺序如下：
- en: Minimum value
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最小值
- en: 'Null'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Null'
- en: Numbers (integers, longs, doubles, decimals)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字（整数、长整数、双精度、小数）
- en: Strings
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串
- en: Object/document
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象/文档
- en: Array
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组
- en: Binary data
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制数据
- en: Object ID
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象ID
- en: Boolean
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Date
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期
- en: Timestamp
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 时间戳
- en: Regular expression
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Maximum value
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大值
- en: Avoiding Large Skips
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免大跳过
- en: Using `skip` for a small number of documents is fine. But for a large number
    of results, `skip` can be slow, since it has to find and then discard all the
    skipped results. Most databases keep more metadata in the index to help with skips,
    but MongoDB does not yet support this, so large skips should be avoided. Often
    you can calculate the results of the next query based on the previous one.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对少量文档使用`skip`是可以接受的。但是对于大量结果，由于需要找到并且丢弃所有被跳过的结果，`skip`可能会很慢。大多数数据库在索引中保留更多元数据以帮助处理跳过，但MongoDB目前不支持此功能，因此应避免大量跳过。通常可以基于前一个查询计算下一个查询的结果。
- en: Paginating results without skip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无`skip`分页结果
- en: 'The easiest way to do pagination is to return the first page of results using
    `limit` and then return each subsequent page as an offset from the beginning:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 分页的最简单方法是使用`limit`返回第一页结果，然后从开头返回每个后续页：
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'However, depending on your query, you can usually find a way to paginate without
    skips. For example, suppose we want to display documents in descending order based
    on `"date"`. We can get the first page of results with the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据您的查询，通常可以找到一种方法进行分页而无需跳过。例如，假设我们想按照`"date"`降序显示文档，我们可以通过以下方式获取第一页结果：
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, assuming the date is unique, we can use the `"date"` value of the last
    document as the criterion for fetching the next page:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设日期是唯一的，我们可以使用最后一个文档的`"date"`值作为获取下一页的条件：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now the query does not need to include a skip.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查询不需要包括跳过。
- en: Finding a random document
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找随机文档
- en: 'One fairly common problem is how to get a random document from a collection.
    The naive (and slow) solution is to count the number of documents and then do
    a `find`, skipping a random number of documents between zero and the size of the
    collection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当常见的问题是如何从集合中获取一个随机文档。天真（并且缓慢）的解决方案是计算文档数，然后进行`find`，跳过从零到集合大小之间的随机数量的文档：
- en: '[PRE68]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It is actually highly inefficient to get a random element this way: you have
    to do a count (which can be expensive if you are using criteria), and skipping
    large numbers of elements can be time-consuming.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式获取随机元素实际上效率非常低：您必须进行计数（如果使用条件可能会很昂贵），并且跳过大量元素可能会耗时。
- en: 'It takes a little forethought, but if you know you’ll be looking up a random
    element in a collection, there’s a much more efficient way to do so. The trick
    is to add an extra random key to each document when it is inserted. For instance,
    if we’re using the shell, we could use the `Math.random()` function (which creates
    a random number between 0 and 1):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些预见性，但如果您知道您将在集合中查找随机元素，有一种更有效的方法。诀窍是在插入每个文档时添加额外的随机键。例如，如果我们正在使用Shell，我们可以使用`Math.random()`函数（生成0到1之间的随机数）：
- en: '[PRE69]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, when we want to find a random document from the collection, we can calculate
    a random number and use that as a query criterion, instead of using `skip`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想要从集合中找到一个随机文档时，我们可以计算一个随机数，并将其用作查询条件，而不是使用`skip`：
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There is a slight chance that `random` will be greater than any of the `"random"`
    values in the collection, and no results will be returned. We can guard against
    this by simply returning a document in the other direction:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有一定几率`random`大于集合中任何`"random"`值，并且不会返回结果。我们可以通过简单地返回另一方向的文档来防范这种情况：
- en: '[PRE71]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If there aren’t any documents in the collection, this technique will end up
    returning `null`, which makes sense.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合中没有任何文档，这种技术最终会返回`null`，这是有道理的。
- en: 'This technique can be used with arbitrarily complex queries; just make sure
    to have an index that includes the random key. For example, if we want to find
    a random plumber in California, we can create an index on `"profession"`, `"state"`,
    and `"random"`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以用于任意复杂的查询；只需确保有一个包含随机键的索引即可。例如，如果我们想在加州找到一个随机的水管工，我们可以在`"profession"`、`"state"`和`"random"`上创建一个索引：
- en: '[PRE72]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This allows us to quickly find a random result (see [Chapter 5](ch05.xhtml#chapter_d1e5128)
    for more information on indexing).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以快速找到随机结果（详见[第5章](ch05.xhtml#chapter_d1e5128)了解更多关于索引的信息）。
- en: Immortal Cursors
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永存的游标
- en: 'There are two sides to a cursor: the client-facing cursor and the database
    cursor that the client-side one represents. We have been talking about the client-side
    one up until now, but we are going to take a brief look at what’s happening on
    the server.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 游标有两个方面：面向客户端的游标和客户端代表的数据库游标。到目前为止，我们一直在谈论客户端的那个，但我们将简要看看服务器上发生了什么。
- en: On the server side, a cursor takes up memory and resources. Once a cursor runs
    out of results or the client sends a message telling it to die, the database can
    free the resources it was using. Freeing these resources lets the database use
    them for other things, which is good, so we want to make sure that cursors can
    be freed quickly (within reason).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，游标占用内存和资源。一旦游标耗尽了结果或客户端发送消息告知其终止，数据库可以释放其正在使用的资源。释放这些资源使得数据库可以用于其他事务，这是好的，因此我们希望确保游标可以迅速释放（在合理范围内）。
- en: There are a couple of conditions that can cause the death (and subsequent cleanup)
    of a cursor. First, when a cursor finishes iterating through the matching results,
    it will clean itself up. Another way is that, when a cursor goes out of scope
    on the client side, the drivers send the database a special message to let it
    know that it can kill that cursor. Finally, even if the user hasn’t iterated through
    all the results and the cursor is still in scope, after 10 minutes of inactivity,
    a database cursor will automatically “die.” This way, if a client crashes or is
    buggy, MongoDB will not be left with thousands of open cursors.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况可能会导致游标的“死亡”（及随后的清理）。首先，当游标完成对匹配结果的迭代时，它将自我清理。另一种方式是，当客户端上的游标超出作用域时，驱动程序会向数据库发送特殊消息，告知可以终止该游标。最后，即使用户尚未遍历所有结果且游标仍在作用域内，数据库游标在10分钟的不活动后也会自动“死亡”。这样，如果客户端崩溃或存在错误，MongoDB
    将不会留下成千上万个开放的游标。
- en: 'This “death by timeout” is usually the desired behavior: very few applications
    expect their users to sit around for minutes at a time waiting for results. However,
    sometimes you might know that you need a cursor to last for a long time. In that
    case, many drivers have implemented a function called `immortal`, or a similar
    mechanism, which tells the database not to time out the cursor. If you turn off
    a cursor’s timeout, you must iterate through all of its results or kill it to
    make sure it gets closed. Otherwise, it will sit around in the database hogging
    resources until the server is restarted.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“超时死亡”通常是期望的行为：很少有应用程序希望用户坐在那里等待几分钟才能得到结果。然而，有时你可能知道需要一个长时间保持的游标。在这种情况下，许多驱动程序已经实现了一个名为`immortal`或类似机制的函数，告诉数据库不要超时游标。如果关闭游标的超时时间，你必须迭代其所有结果或将其终止，以确保它被关闭。否则，它将继续留在数据库中占用资源，直到服务器重新启动。
