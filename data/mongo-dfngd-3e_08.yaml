- en: Chapter 6\. Special Index and Collection Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。特殊索引和集合类型
- en: 'This chapter covers the special collections and index types MongoDB has available,
    including:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了MongoDB提供的特殊集合和索引类型，包括：
- en: Capped collections for queue-like data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有队列特性的有上限的集合
- en: TTL indexes for caches
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于缓存的TTL索引
- en: Full-text indexes for simple string searching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单字符串搜索的全文索引
- en: Geospatial indexes for 2D and spherical geometries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于2D和球形几何的地理空间索引
- en: GridFS for storing large files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储大文件的GridFS
- en: Geospatial Indexes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理空间索引
- en: 'MongoDB has two types of geospatial indexes: `2dsphere` and `2d`. `2dsphere`
    indexes work with spherical geometries that model the surface of the earth based
    on the WGS84 datum. This datum models the surface of the earth as an oblate spheroid,
    meaning that there is some flattening at the poles. Distance calculations using
    `2sphere` indexes, therefore, take the shape of the earth into account and provide
    a more accurate treatment of distance between, for example, two cities, than do
    `2d` indexes. Use `2d` indexes for points stored on a two-dimensional plane.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有两种类型的地理空间索引：`2dsphere`和`2d`。`2dsphere`索引使用球形几何模型化地球表面，基于WGS84数据。此数据模型将地球表面建模为一个扁球体，这意味着在极点有一些扁平化。因此，使用`2sphere`索引进行距离计算可以考虑地球的形状，并提供比`2d`索引更准确的城市间距离处理，例如两个城市之间的距离。对于存储在二维平面上的点，请使用`2d`索引。
- en: '`2dsphere` allows you to specify geometries for points, lines, and polygons
    in the [GeoJSON format](http://www.geojson.org/). A point is given by a two-element
    array, representing [*`longitude`*, *`latitude`*]:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`2dsphere`允许您在[GeoJSON格式](http://www.geojson.org/)中指定点、线和多边形的几何形状。一个点由一个表示[*`经度`*，*`纬度`*]的两元素数组给出：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A line is given by an array of points:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线由一系列点组成：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A polygon is specified the same way a line is (an array of points), but with
    a different `"type"`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的指定方式与线相同（一个点数组），但具有不同的`"type"`：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The field that we are naming, `"loc"` in this example, can be called anything,
    but the field names in the embedded object are specified by GeoJSON and cannot
    be changed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此示例中命名的字段`"loc"`可以是任何名称，但嵌入对象中的字段名称由GeoJSON指定，不可更改。
- en: 'You can create a geospatial index using the `"2dsphere"` type with `` `createIndex`
    ``:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"`2dsphere`"`类型和`` `createIndex` ``可以创建地理空间索引：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To create a `2dsphere` index, pass a document to `createIndex` that specifies
    the field containing geometries you want to index for the collection in question
    and specify `"2dsphere"` as the value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`2dsphere`索引，请向`createIndex`传递一个文档，该文档指定要为特定集合中的几何图形创建索引的字段，并将`"2dsphere"`指定为值。
- en: Types of Geospatial Queries
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理空间查询类型
- en: 'There are three types of geospatial queries that you can perform: intersection,
    within, and nearness. You specify what you’re looking for as a GeoJSON object
    that looks like ``{"$geometry" : *`geoJsonDesc`*}``.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以执行三种类型的地理空间查询：交集、包含和邻近。您可以指定要查找的内容作为一个类似于``{"$geometry" : *`geoJsonDesc`*}``的GeoJSON对象。'
- en: 'For example, you can find documents that intersect the query’s location using
    the `"$geoIntersects"` operator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用`"$geoIntersects"`操作符找到与查询位置相交的所有文档：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would find all point-, line-, and polygon-containing documents that had
    a point in the East Village in New York City.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将查找所有包含东村点的点、线和多边形文档。
- en: 'You can use `"$geoWithin"` to query for things that are completely contained
    in an area (for instance, “What restaurants are in the East Village?”):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`"$geoWithin"`查询完全包含在区域内的事物（例如，“东村有哪些餐馆？”）：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike our first query, this will not return things that merely pass through
    the East Village (such as streets) or partially overlap it (such as a polygon
    describing Manhattan).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的第一个查询不同，这不会返回仅通过东村的事物（例如街道）或部分重叠它的事物（例如描述曼哈顿的多边形）。
- en: 'Finally, you can query for nearby locations with `"$near"`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`"$near"`查询附近的位置：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that `"$near"` is the only geospatial operator that implies a sort: results
    from `"$near"` are always returned in order of distance, from closest to farthest.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`"$near"`是唯一一个暗示排序的地理空间操作符：`"$near"`的结果始终按距离从近到远返回。
- en: Using Geospatial Indexes
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地理空间索引
- en: MongoDB’s geospatial indexing allows you to efficiently execute spatial queries
    on a collection that contains geospatial shapes and points. To showcase the capabilities
    of geospatial features and compare different approaches, we will go through the
    process of writing queries for a simple geospatial application. We’ll go a little
    deeper into a few concepts central to geospatial indexes and then demonstrate
    their use with `"$geoWithin"`, `"$geoIntersects"`, and `"$geoNear"`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的地理空间索引允许您在包含地理空间形状和点的集合上高效执行空间查询。为展示地理空间特性的能力并比较不同的方法，我们将逐步编写一个简单地理空间应用的查询过程。我们将深入介绍几个地理空间索引的核心概念，并展示它们如何与
    `"$geoWithin"`、`"$geoIntersects"` 和 `"$geoNear"` 一起使用。
- en: 'Suppose we are designing a mobile application to help users find restaurants
    in New York City. The application must:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在设计一个移动应用程序，帮助用户在纽约市找到餐馆。该应用程序必须：
- en: Determine the neighborhood the user is currently in.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定用户当前所在的社区。
- en: Show the number of restaurants in that neighborhood.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示该社区内的餐馆数量。
- en: Find restaurants within a specified distance.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指定距离内查找餐馆。
- en: We will use a `2dsphere` index to query on this spherical geometry data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `2dsphere` 索引在这些球形几何数据上进行查询。
- en: 2D versus spherical geometry in queries
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询中的 2D 对比球形几何。
- en: Geospatial queries can use either spherical or 2D (flat) geometries, depending
    on both the query and the type of index in use. [Table 6-1](#table0601) shows
    what kind of geometry each geospatial operator uses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 地理空间查询可以根据查询和索引类型使用球形或 2D（平面）几何。[表 6-1](#table0601) 显示了每个地理空间操作符使用的几何类型。
- en: Table 6-1\. Query types and geometries in MongoDB
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. MongoDB 中的查询类型和几何形状
- en: '| Query type | Geometry type |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 查询类型 | 几何类型 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$near` (GeoJSON point, `2dsphere` index) | Spherical |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `$near`（GeoJSON 点，`2dsphere` 索引） | 球面 |'
- en: '| `$near` (legacy coordinates, `2d` index) | Flat |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `$near`（旧版坐标，`2d` 索引） | 平面 |'
- en: '| `$geoNear` (GeoJSON point, `2dsphere` index) | Spherical |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `$geoNear`（GeoJSON 点，`2dsphere` 索引） | 球面 |'
- en: '| `$geoNear` (legacy coordinates, `2d` index) | Flat |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `$geoNear`（旧版坐标，`2d` 索引） | 平面 |'
- en: '| `$nearSphere` (GeoJSON point, `2dsphere` index) | Spherical |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `$nearSphere`（GeoJSON 点，`2dsphere` 索引） | 球面 |'
- en: '| `$nearSphere` (legacy coordinates, `2d` index)^([a](ch06.xhtml#idm45882368776472))
    | Spherical |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `$nearSphere`（旧版坐标，`2d` 索引）^([a](ch06.xhtml#idm45882368776472)) | 球面 |'
- en: '| `$geoWithin : { $geometry: ... }` | Spherical |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `$geoWithin : { $geometry: ... }` | 球面 |'
- en: '| `$geoWithin: { $box: ... }` | Flat |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `$geoWithin: { $box: ... }` | 平面 |'
- en: '| `$geoWithin: { $polygon: ... }` | Flat |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `$geoWithin: { $polygon: ... }` | 平面 |'
- en: '| `$geoWithin : { $center: ... }` | Flat |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `$geoWithin : { $center: ... }` | 平面 |'
- en: '| `$geoWithin : { $centerSphere: ... }` | Spherical |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `$geoWithin : { $centerSphere: ... }` | 球面 |'
- en: '| `$geoIntersects` | Spherical |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `$geoIntersects` | 球面 |'
- en: '| ^([a](ch06.xhtml#idm45882368776472-marker)) Use GeoJSON points instead. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch06.xhtml#idm45882368776472-marker)) 使用 GeoJSON 点代替。 |'
- en: Note also that `2d` indexes support both flat geometries and distance-only calculations
    on spheres (i.e., using `$nearSphere`). However, queries using spherical geometries
    will be more performant and accurate with a `2dsphere` index.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意，`2d` 索引支持平面几何和仅在球面上进行距离计算（即使用 `$nearSphere`）。然而，使用球形几何的查询在 `2dsphere` 索引下性能更佳且更精确。
- en: Note also that the `$geoNear` operator is an aggregation operator. The aggregation
    framework is discussed in [Chapter 7](ch07.xhtml#chapter_d1e6036). In addition
    to the `$near` query operation, the `$geoNear` aggregation operator and the special
    command `geoNear` enable us to query for nearby locations. Keep in mind that the
    `$near` query operator will not work on collections that are distributed using
    sharding, MongoDB’s scaling solution (see [Chapter 15](ch15.xhtml#chapter-shard-config)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意，`$geoNear` 操作符是一个聚合操作符。聚合框架在 [第 7 章](ch07.xhtml#chapter_d1e6036) 中进行了讨论。除了
    `$near` 查询操作外，`$geoNear` 聚合操作符和特殊命令 `geoNear` 还能让我们查询附近位置。请记住，`$near` 查询操作符无法在使用分片的集合上工作，MongoDB
    的分片解决方案（参见 [第 15 章](ch15.xhtml#chapter-shard-config)）。
- en: The `geoNear` command and the `$geoNear` aggregation operator require that a
    collection have at most one `2dsphere` index and at most one `2d` index, whereas
    geospatial query operators (e.g., `$near` and `$geoWithin`) permit collections
    to have multiple geospatial indexes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`geoNear` 命令和 `$geoNear` 聚合操作要求集合最多只能有一个 `2dsphere` 索引和一个 `2d` 索引，而地理空间查询操作符（如
    `$near` 和 `$geoWithin`）允许集合拥有多个地理空间索引。'
- en: The geospatial index restriction for the `geoNear` command and the `$geoNear`
    aggregation operator exists because neither the `geoNear` command nor the `$geoNear`
    syntax includes the location field. As such, index selection among multiple `2d`
    indexes or `2dsphere` indexes is ambiguous.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`geoNear`命令和`$geoNear`聚合运算符的地理空间索引限制存在，因为`geoNear`命令和`$geoNear`语法都不包括位置字段。因此，在多个`2d`索引或`2dsphere`索引中选择索引是不明确的。'
- en: No such restriction applies for geospatial query operators; these operators
    take a location field, eliminating the ambiguity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于地理空间查询操作符，不存在此类限制；这些操作符需要一个位置字段，从而消除了歧义。
- en: Distortion
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扭曲
- en: Spherical geometry will appear distorted when visualized on a map due to the
    nature of projecting a three-dimensional sphere, such as the earth, onto a flat
    plane.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将三维球体（例如地球）投影到平面上的性质，球形几何在地图上显示时会出现扭曲。
- en: For example, take the specification of the spherical square defined by the longitude,
    latitude points (0,0), (80,0), (80,80), and (0,80). [Figure 6-1](#fig0601) depicts
    the area covered by this region.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑由经度、纬度点（0,0）、（80,0）、（80,80）和（0,80）定义的球形广场的规范。[图6-1](#fig0601)描述了该区域的覆盖区域。
- en: '![](Images/mdb3_0601.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/mdb3_0601.png)'
- en: Figure 6-1\. The spherical square defined by the points (0,0), (80,0), (80,
    80), and (0,80)
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 由点（0,0）、（80,0）、（80,80）和（0,80）定义的球形广场
- en: Searching for restaurants
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索餐馆
- en: In this example, we will work with [neighborhood](https://oreil.ly/rpGna) and
    [restaurant](https://oreil.ly/JXYd-) datasets based in New York City. You can
    download the example datasets from GitHub.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用基于纽约市的[社区](https://oreil.ly/rpGna)和[餐馆](https://oreil.ly/JXYd-)数据集进行操作。您可以从GitHub下载示例数据集。
- en: 'We can import the datasets into our database using the `mongoimport` tool as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`mongoimport`工具将数据集导入数据库，方法如下：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can create a `2dsphere` index on each collection using the `createIndex`
    command in the [*mongo* shell](https://oreil.ly/NMUhn):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[*mongo* shell](https://oreil.ly/NMUhn)中使用`createIndex`命令在每个集合上创建`2dsphere`索引。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exploring the data
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索数据
- en: 'We can get a sense for the schema used for documents in these collections with
    a couple of quick queries in the *mongo* shell:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在*mongo* shell中执行一些快速查询来了解这些集合中文档的模式使用。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The neighborhood document in the previous code corresponds to the area of New
    York City shown in [Figure 6-2](#fig0602).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的社区文档对应于[图6-2](#fig0602)中显示的纽约市地区。
- en: '![](Images/mdb3_0602.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/mdb3_0602.png)'
- en: Figure 6-2\. The Hell’s Kitchen (Clinton) neighborhood of New York City
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 纽约市的Hell's Kitchen（克林顿）社区
- en: The bakery corresponds to the location shown in [Figure 6-3](#fig0603).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 面包店对应于[图6-3](#fig0603)中所示的位置。
- en: '![](Images/mdb3_0603.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/mdb3_0603.png)'
- en: Figure 6-3\. The Little Pie Company at 424 West 43rd Street
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3\. 位于西43街424号的小派公司
- en: Finding the current neighborhood
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找当前社区
- en: Assuming the user’s mobile device can give a reasonably accurate location user,
    it is simple to find the user’s current neighborhood with `$geoIntersects`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户的移动设备可以提供一个相当精确的位置信息，使用`$geoIntersects`可以简单地找到用户当前的社区。
- en: 'Suppose the user is located at −73.93414657 longitude and 40.82302903 latitude.
    To find the current neighborhood (Hell’s Kitchen), we can specify a point using
    the special `$geometry` field in GeoJSON format:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户位于经度-73.93414657和纬度40.82302903。要找到当前社区（Hell's Kitchen），我们可以使用GeoJSON格式中的特殊`$geometry`字段指定一个点：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This query will return the following result:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将返回以下结果：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finding all restaurants in the neighborhood
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找社区内所有餐馆
- en: 'We can also query to find all restaurants contained in a given neighborhood.
    To do so, we can execute the following in the *mongo* shell to find the neighborhood
    containing the user, and then count the restaurants within that neighborhood.
    For example, to find all the restaurants in the Hell’s Kitchen neighborhood:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以查询以查找包含在特定社区内的所有餐馆。为此，我们可以在*mongo* shell中执行以下操作，以查找包含用户的社区，并计算该社区内的餐馆数量。例如，要查找Hell's
    Kitchen社区中的所有餐馆：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This query will tell you that there are 127 restaurants in the requested neighborhood
    that have the following names:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将告诉您，在请求的社区中有127家餐馆，这些餐馆的名称如下：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finding restaurants within a distance
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一定距离内找到餐馆
- en: To find restaurants within a specified distance of a point, you can use either
    `"$geoWithin"` with `"$centerSphere"` to return results in unsorted order, or
    `"$nearSphere"` with `"$maxDistance"` if you need results sorted by distance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到距某点指定距离内的餐厅，可以使用`"$geoWithin"`和`"$centerSphere"`来返回无序结果，或者使用`"$nearSphere"`和`"$maxDistance"`来按距离排序需要结果。
- en: To find restaurants within a circular region, use `"$geoWithin"` with `"$centerSphere"`.
    `"$centerSphere"` is a MongoDB-specific syntax to denote a circular region by
    specifying the center and the radius in radians. `"$geoWithin"` does not return
    the documents in any specific order, so it might return the furthest documents
    first.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在圆形区域内查找餐厅，请使用`"$geoWithin"`和`"$centerSphere"`。`"$centerSphere"`是MongoDB特定的语法，用于通过指定中心和弧度半径来表示圆形区域。`"$geoWithin"`不会以任何特定顺序返回文档，因此可能首先返回最远的文档。
- en: 'The following will find all restaurants within five miles of the user:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将查找用户五英里范围内的所有餐厅：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`"$centerSphere"`’s second argument accepts the radius in radians. The query
    converts the distance to radians by dividing by the approximate equatorial radius
    of the earth, 3963.2 miles.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$centerSphere"`的第二个参数接受以弧度表示的半径。该查询通过将距离除以地球的近似赤道半径3963.2英里来转换为弧度。'
- en: Applications can use `"$centerSphere"` without having a geospatial index. However,
    geospatial indexes support much faster queries than the unindexed equivalents.
    Both `2dsphere` and `2d` geospatial indexes support `"$centerSphere"`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用`"$centerSphere"`而不需要地理空间索引。但是，地理空间索引支持比未索引的等效操作更快的查询。`2dsphere`和`2d`地理空间索引均支持`"$centerSphere"`。
- en: 'You may also use `"$nearSphere"` and specify a `"$maxDistance"` term in meters.
    This will return all restaurants within five miles of the user in sorted order
    from nearest to farthest:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`"$nearSphere"`并指定`"$maxDistance"`项以米为单位。这将按从最近到最远的顺序返回所有距离用户五英里范围内的餐厅：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compound Geospatial Indexes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合地理空间索引
- en: 'As with other types of indexes, you can combine geospatial indexes with other
    fields to optimize more complex queries. A possible query mentioned earlier was:
    “What restaurants are in Hell’s Kitchen?” Using only a geospatial index, we could
    narrow the field to everything in Hell’s Kitchen, but narrowing it down to only
    “restaurants” or “pizza” would require another field in the index:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的索引一样，可以将地理空间索引与其他字段结合使用，以优化更复杂的查询。前面提到的一个可能的查询是：“Hell’s Kitchen里有什么餐厅？”仅使用地理空间索引，我们可以将范围缩小到Hell’s
    Kitchen内的所有内容，但将其缩小到仅“餐厅”或“披萨”则需要索引中的另一个字段：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we can quickly find a pizza place in Hell’s Kitchen:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以快速找到Hell’s Kitchen的披萨店：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can have the “vanilla” index field either before or after the `"2dsphere"`
    field, depending on whether we’d like to filter by the vanilla field or the location
    first. Choose whichever is more selective (i.e., will filter out more results
    as the first index term).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`"2dsphere"`字段之前或之后有“普通”的索引字段，这取决于我们想先按照哪个字段过滤，是按照普通字段还是位置。选择更具选择性的项（即作为第一个索引项将过滤掉更多结果）。
- en: 2d Indexes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2d索引
- en: 'For nonspherical maps (videogame maps, time series data, etc.) you can use
    a `"2d"` index instead of `"2dsphere"`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非球形地图（视频游戏地图、时间序列数据等），可以使用`"2d"`索引代替`"2dsphere"`：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`2d` indexes assume a perfectly flat surface, instead of a sphere. Thus, `2d`
    indexes should not be used with spheres unless you don’t mind massive distortion
    around the poles.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`2d`索引假设一个完全平坦的表面，而不是一个球体。因此，除非不介意极点周围的严重畸变，否则不应将`2d`索引与球体一起使用。'
- en: 'Documents should use a two-element array for their `"2d"` indexed field. The
    elements in this array should reflect the longitude and lattitude coordinates,
    respectively. A sample document might look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文档应使用两元素数组作为其`"2d"`索引字段。该数组中的元素应分别反映经度和纬度坐标。示例文档可能如下所示：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Do not use a `2d` index if you plan to store GeoJSON data—they can only index
    points. You can store an array of points, but it will be stored as exactly that:
    an array of points, not a line. This is an important distinction for `"$geoWithin"`
    queries, in particular. If you store a street as an array of points, the document
    will match `"$geoWithin"` if one of those points is within the given shape. However,
    the line created by those points might not be wholly contained in the shape.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计划存储GeoJSON数据，请勿使用`2d`索引——它们只能索引点。您可以存储一个点数组，但它将被完全存储为一个点数组，而不是一条线。这对于`"$geoWithin"`查询尤为重要。如果将街道存储为点数组，则文档将在给定形状内的点匹配`"$geoWithin"`。但是，由这些点创建的线可能不完全包含在形状内。
- en: 'By default, `2d` indexes assume that your values are going to range from −180
    to 180\. If you are expecting larger or smaller bounds, you can specify what the
    minimum and maximum values will be as options to `createIndex`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`2d` 索引假定您的值将在从−180到180的范围内。如果您期望较大或较小的边界，则可以将最小值和最大值作为 `createIndex`
    的选项进行指定：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will create a spatial index calibrated for a 2,000 × 2,000 square.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个适用于 2,000 × 2,000 正方形的空间索引。
- en: '`2d` indexes support the `"$geoWithin"`, `"$nearSphere"`, and `"$near"` query
    selectors. Use `"$geoWithin"` to query for points within a shape defined on a
    flat surface. `"$geoWithin"` can query for all points within a rectangle, polygon,
    circle, or sphere; it uses the `"$geometry"` operator to specify the GeoJSON object.
    Returning to our grid indexed as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`2d` 索引支持 `"$geoWithin"`, `"$nearSphere"`, 和 `"$near"` 查询选择器。使用 `"$geoWithin"`
    查询在平面上定义的形状内的点。`"$geoWithin"` 可以查询矩形、多边形、圆或球内的所有点；它使用 `"$geometry"` 运算符来指定 GeoJSON
    对象。回到我们的网格索引如下：'
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'the following queries for documents within a rectangle defined by [10, 10]
    at the bottom-left corner and by [100, 100] at the top-right corner:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询用于文档位于由底部左下角 [10, 10] 和顶部右上角 [100, 100] 定义的矩形内：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`$box` takes a two-element array: the first element specifies the coordinates
    of the lower-left corner and the second element the upper right.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`$box` 接受一个两元素数组：第一个元素指定左下角的坐标，第二个元素指定右上角的坐标。'
- en: 'To query for documents that are within the circle centered on [−17 , 20.5]
    and with a radius of 25 we can issue the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询位于以 [−17 , 20.5] 为中心且半径为25的圆内的文档，可以执行以下命令：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following query returns all documents with coordinates that exist within
    the polygon defined by [0, 0], [3, 6], and [6 , 0]:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询返回所有坐标位于由 [0, 0], [3, 6], 和 [6 , 0] 定义的多边形内的文档：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You specify a polygon as an array of points. The final point in the list will
    be “connected to” the first point to form the polygon. This example would locate
    all documents containing points within the given triangle.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将多边形定义为点数组。列表中的最后一个点将与第一个点“连接”，形成多边形。此示例将定位包含在给定三角形内的所有文档。
- en: 'MongoDB also supports rudimentary spherical queries on flat `2d` indexes for
    legacy reasons. In general, spherical calculations should use a 2dsphere index,
    as described in [“2D versus spherical geometry in queries”](#twod_vs_sgq). However,
    to query for legacy coordinate pairs within a sphere, use `"$geoWithin"` with
    the “`$centerSphere”` operator. Specify an array that contains:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，MongoDB 还支持对平面 `2d` 索引进行基本的球面查询。一般来说，球面计算应使用如 [“2D versus spherical geometry
    in queries”](#twod_vs_sgq) 中所述的 2dsphere 索引。然而，要查询球内的传统坐标对，请使用带有 “`$centerSphere”`
    运算符的 `"$geoWithin"`。指定一个包含以下内容的数组：
- en: The grid coordinates of the circle’s center point
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆心点的网格坐标
- en: The circle’s radius measured in radians
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以弧度测量的圆的半径
- en: 'For example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To query for nearby points, use `"$near"`. Proximity queries return the documents
    with coordinate pairs closest to the defined point and sort the results by distance.
    This finds all of the documents in the *hyrule* collection in order by distance
    from the point (20, 21):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询附近的点，请使用 `"$near"`。接近查询返回与定义点最接近的坐标对应的文档，并按距离排序。这将从点 (20, 21) 开始按距离从近到远返回
    *hyrule* 集合中的所有文档：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A default limit of 100 documents is applied if no limit is specified. If you
    don’t need that many results, you should set a limit to conserve server resources.
    For example, the following code returns the 10 documents nearest to (20, 21):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定限制，则默认应用 100 个文档的限制。如果您不需要那么多结果，应设置一个限制以节省服务器资源。例如，以下代码返回最接近 (20, 21) 的
    10 个文档：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Indexes for Full Text Search
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全文搜索索引
- en: '`text` indexes in MongoDB support full-text search requirements. This type
    of `text` index should not be confused with the MongoDB Atlas Full-Text Search
    Indexes, which utilize Apache Lucene for additional text search capabilities when
    compared to MongoDB text indexes. Use a `text` index if your application needs
    to enable users to submit keyword queries that should match titles, descriptions,
    and text in other fields within a collection.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，`text` 索引支持全文搜索要求。这种类型的 `text` 索引不应与 MongoDB Atlas 全文搜索索引混淆，后者利用
    Apache Lucene 进行附加文本搜索能力，与 MongoDB text 索引相比具有更多的功能。如果您的应用程序需要允许用户提交关键字查询以匹配集合中标题、描述和其他字段中的文本，则应使用
    `text` 索引。
- en: In previous chapters, we’ve queried for strings using exact matches and regular
    expressions, but these techniques have some limitations. Searching a large block
    of text for a regular expression is slow, and it’s tough to take morphology (e.g.,
    that “entry” should match “entries”) and other challenges presented by human language
    into account. `text` indexes give you the ability to search text quickly and provide
    support for common search engine requirements such as language-appropriate tokenization,
    stop words, and stemming.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用精确匹配和正则表达式来查询字符串，但是这些技术有一些限制。使用正则表达式搜索大文本块速度较慢，并且难以考虑人类语言的形态（例如，“entry”应该匹配“entries”）和其他挑战。`text`索引使您能够快速搜索文本，并提供对语言适当的分词、停用词和词干提取等常见搜索引擎要求的支持。
- en: '`text` indexes require a number of keys proportional to the words in the fields
    being indexed. As a consequence, creating a `text` index can consume a large amount
    of system resources. You should create such an index at a time when it will not
    negatively impact the performance of your application for users or build the index
    in the background, if possible. To ensure good performance, as with all indexes,
    you should also take care that any `text` index you create fits in RAM. See [Chapter 19](ch19.xhtml#chapter-data-admin)
    for more information on creating indexes with minimal impact on your application.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`索引需要的键数量与索引字段中的单词数成正比。因此，创建`text`索引可能会消耗大量系统资源。您应在不会对用户应用程序性能造成负面影响的时间创建此类索引，或者如果可能的话在后台构建索引。与所有索引一样，为了确保良好的性能，您还应注意任何创建的`text`索引是否适合RAM。有关在不影响应用程序的情况下创建索引的更多信息，请参阅[第19章](ch19.xhtml#chapter-data-admin)。'
- en: 'Writes to a collection require that all indexes are updated. If you are using
    text search, strings will be tokenized and stemmed and the index updated in, potentially,
    many places. For this reason, writes involving `text` indexes are usually more
    expensive than writes to single-field, compound, or even multikey indexes. Thus,
    you will tend to see poorer write performance on `text`-indexed collections than
    on others. They will also slow down data movement if you are sharding: all text
    must be reindexed when it is migrated to a new shard.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 写入集合需要更新所有索引。如果您使用文本搜索，字符串将被分词和词干提取，并在多个位置更新索引。因此，与单字段、复合字段甚至多键索引相比，涉及`text`索引的写入通常更昂贵。因此，您会发现`text`索引的写入性能较差。如果您进行分片，它们还会减慢数据移动：在迁移到新的分片时，所有文本都必须重新建立索引。
- en: Creating a Text Index
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文本索引
- en: 'Suppose we have a collection of Wikipedia articles that we want to index. To
    run a search over the text, we first need to create a `text` index. The following
    call to `createIndex` will create the index based on the terms in both the `"title"`
    and `"body"` fields:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一组维基百科文章需要索引。要在文本上运行搜索，我们首先需要创建一个`text`索引。以下对`createIndex`的调用将基于`"title"`和`"body"`字段中的术语创建索引：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is not like a “normal” compound index where there is an ordering on the
    keys. By default, each field is given equal consideration in a `text` index. You
    can control the relative importance MongoDB attaches to each field by specifying
    weights:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这不像“普通”的复合索引，其中键有顺序。默认情况下，`text`索引中每个字段都被赋予相等的考虑权重。您可以通过指定权重来控制MongoDB赋予每个字段的相对重要性：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This would weight the `"title"` field at a ratio of 3:2 in comparison to the
    `"body"` field.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以3:2的比例权重`"title"`字段相对于`"body"`字段。
- en: You cannot change field weights after index creation (without dropping the index
    and recreating it), so you may want to play with weights on a sample dataset before
    creating the index on your production data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引创建后无法更改字段权重（除非删除索引并重新创建），因此您可能希望在生产数据上创建索引之前在样本数据集上调整权重。
- en: 'For some collections, you may not know which fields a document will contain.
    You can create a full-text index on all string fields in a document by creating
    an index on `"$**"`—this not only indexes all top-level string fields, but also
    searches embedded documents and arrays for string fields:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些集合，您可能不知道文档将包含哪些字段。您可以通过在`"$**"`上创建索引来在文档中的所有字符串字段上创建全文索引——这不仅索引所有顶级字符串字段，还搜索嵌入文档和数组中的字符串字段：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Text Search
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本搜索
- en: 'Use the `"$text"` query operator to perform text searches on a collection with
    a `text` index. `"$text"` will tokenize the search string using whitespace and
    most punctuation as delimiters, and perform a logical OR of all such tokens in
    the search string. For example, you could use the following query to find all
    articles containing any of the terms “impact,” “crater,” or “lunar.” Note that
    because our index is based on terms in both the title and body of an article,
    this query will match documents in which those terms are found in either field.
    For the purposes of this example, we will project the title so that we can fit
    more results on the page:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"$text"`查询运算符在具有`text`索引的集合上执行文本搜索。`"$text"`将使用空格和大多数标点符号作为分隔符对搜索字符串进行标记，并对搜索字符串中的所有这些标记执行逻辑OR操作。例如，您可以使用以下查询查找包含术语“impact”，“crater”或“lunar”的所有文章。请注意，因为我们的索引基于文章标题和正文中的术语，此查询将匹配那些术语在任一字段中找到的文档。为了本示例的目的，我们将投影标题，以便我们可以在页面上放置更多结果：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see that the results with our initial query are not terribly relevant.
    As with all technologies, it’s important to have a good grasp of how `text` indexes
    work in MongoDB in order to use them effectively. In this case, there are two
    problems with the way we’ve issued the query. The first is that our query is pretty
    broad, given that MongoDB issues the query using a logical OR of “impact,” “crater,”
    and “lunar.” The second problem is that, by default, a text search does not sort
    the results by relevance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们初始查询的结果并不是非常相关。像所有技术一样，了解MongoDB中`text`索引的工作原理是使用它们有效的关键。在这种情况下，我们发出查询存在两个问题。首先是，我们的查询相当广泛，因为MongoDB使用“impact”，“crater”和“lunar”的逻辑OR发出查询。第二个问题是，默认情况下，文本搜索不会按相关性排序。
- en: 'We can begin to address the problem of the query itself by using a phrase in
    our query. You can search for exact phrases by wrapping them in double quotes.
    For example, the following will find all documents containing the phrase “impact
    crater.” Possibly surprising is that MongoDB will issue this query as “impact
    crater” AND “lunar”:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在查询中使用短语来解决查询本身的问题。您可以通过用双引号括起来来搜索精确短语。例如，以下查询将找到所有包含短语“impact crater”的文档。也许令人惊讶的是，MongoDB将此查询发布为“impact
    crater” AND “lunar”：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make sure the semantics of this are clear, let’s look at an expanded example.
    For the following query, MongoDB will issue the query as “impact crater” AND (“lunar”
    OR “meteor”). MongoDB performs a logical AND of the phrase with the individual
    terms in the search string and a logical OR of the individual terms with one another:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这一语义清楚，让我们看一个扩展的例子。对于以下查询，MongoDB将作为“impact crater” AND (“lunar” OR “meteor”)发布查询。MongoDB对搜索字符串中的短语与搜索字符串中的各个术语进行逻辑AND操作，并对各个术语与彼此进行逻辑OR操作：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you want to issue a logical AND between individual terms in a query, treat
    each term as a phrase by wrapping it in quotes. The following query will return
    documents containing “impact crater” AND “lunar” AND “meteor”:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在查询中的各个术语之间发出逻辑AND，请将每个术语视为短语并用引号括起来。以下查询将返回包含“impact crater” AND “lunar”
    AND “meteor”的文档：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that you have a better understanding of using phrases and logical ANDs in
    your queries, let’s return to the problem of the results not being sorted by relevance.
    While the preceding results are certainly relevant, this is mostly due to the
    fairly strict query we’ve issued. We can do better by sorting for relevance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对在查询中使用短语和逻辑AND有了更好的理解，让我们回到结果没有按相关性排序的问题。虽然前面的结果确实相关，但这主要是因为我们发出了相当严格的查询。我们可以通过按相关性排序来做得更好。
- en: 'Text queries cause some metadata to be associated with each query result. The
    metadata is not displayed in the query results unless we explicitly project it
    using the `$meta` operator. So, in addition to the title, we will project the
    relevance score calculated for each document. The relevance score is stored in
    the metadata field named `"textScore"`. For this example, we’ll return to our
    query of “impact crater” AND “lunar”:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 文本查询会导致与每个查询结果相关联的一些元数据。除非我们使用`$meta`运算符显式投影它，否则这些元数据不会显示在查询结果中。因此，除了标题之外，我们还将投影每个文档计算的相关性分数。相关性分数存储在名为`"textScore"`的元数据字段中。对于本示例，我们将返回我们的“impact
    crater” AND “lunar”的查询：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now you can see the relevance score projected with the title for each result.
    Note that they are not sorted. To sort the results in order of relevance score,
    we must add a call to `sort`, again using `$meta` to specify the `"textScore"`
    field value. Note that we must use the same field name in our sort as we used
    in our projection. In this case, we used the field name `"score"` for the relevance
    score value displayed in our search results. As you can see, the results are now
    sorted in decreasing order of relevance:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到每个结果的标题与相关性分数的投影。请注意它们没有排序。要按相关性分数的顺序对结果进行排序，我们必须添加一个`sort`调用，再次使用`$meta`来指定`"textScore"`字段的值。请注意，我们在排序中必须使用与投影中使用的字段名称相同的字段名称。在这种情况下，我们在搜索结果中显示的相关性分数值的字段名称为`"score"`。正如您所见，结果现在按相关性的降序排序：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Text search is also available in the aggregation pipeline. We discuss the aggregation
    pipeline in [Chapter 7](ch07.xhtml#chapter_d1e6036).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 文本搜索也可以在聚合管道中使用。我们在[第7章](ch07.xhtml#chapter_d1e6036)讨论了聚合管道。
- en: Optimizing Full-Text Search
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化全文搜索
- en: 'There are a couple of ways to optimize full-text searches. If you can first
    narrow your search results by other criteria, you can create a compound index
    with a prefix of those criteria and then the full-text fields:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种优化全文搜索的方法。如果您可以首先通过其他条件缩小搜索结果，那么可以创建一个带有这些条件前缀的复合索引，然后是全文字段：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is referred to as *partitioning* the full-text index, as it breaks it into
    several smaller trees based on `"date"` (in this example). This makes full-text
    searches for a specific date or date range much faster.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为将全文索引*分区*，因为它将其分解为基于`"date"`（在此示例中）的多个较小的树。这使得针对特定日期或日期范围的全文搜索速度更快。
- en: 'You can also use a postfix of other criteria to cover queries with the index.
    For example, if we were only returning the `"author"` and `"post"` fields, we
    could create a compound index on both:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用其他条件的后缀来覆盖索引查询。例如，如果我们只返回`"author"`和`"post"`字段，我们可以在这两个字段上创建一个复合索引：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These prefix and postfix forms can be combined:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些前缀和后缀形式可以结合使用：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Searching in Other Languages
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在其他语言中搜索
- en: When a document is inserted (or the index is first created), MongoDB looks at
    the index’s fields and stems each word, reducing it to an essential unit. However,
    different languages stem words in different ways, so you must specify what language
    the index or document is in. `text` indexes allow a `"default_language"` option
    to be specified, which defaults to `"english"` but can be set to a number of other
    languages (see the [online documentation](https://oreil.ly/eUt0Z) for an up-to-date
    list).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入文档（或首次创建索引）时，MongoDB会查看索引字段并对每个单词进行词干处理，将其缩减为基本单位。然而，不同语言以不同方式处理单词的词干，因此必须指定索引或文档所在的语言。`text`索引允许指定`"default_language"`选项，默认为`"english"`，但可以设置为多种其他语言（详见[在线文档](https://oreil.ly/eUt0Z)获取最新列表）。
- en: 'For example, to create a French-language index, we could say:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个法语索引，我们可以这样说：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then French would be used for stemming, unless otherwise specified. You can,
    on a per-document basis, specify another stemming language by having a `"language"`
    field that describes the document’s language:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有规定，否则将使用法语进行词干处理。您可以在每个文档上指定另一种词干处理语言，方法是具有描述文档语言的`"language"`字段：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Capped Collections
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容量限制集合
- en: “Normal” collections in MongoDB are created dynamically and automatically grow
    in size to fit additional data. MongoDB also supports a different type of collection,
    called a *capped collection*, which is created in advance and is fixed in size
    (see [Figure 6-4](#figure_d1e7559)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，“普通”集合是动态创建的，并自动增长以适应额外数据。MongoDB还支持一种称为*容量限制集合*的不同类型集合，它是预先创建的并且大小固定（见[图6-4](#figure_d1e7559)）。
- en: '![](Images/mdb3_0604.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/mdb3_0604.png)'
- en: Figure 6-4\. New documents are inserted at the end of the queue
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4\. 新文档插入队列末尾
- en: 'Having fixed-size collections brings up an interesting question: what happens
    when we try to insert into a capped collection that is already full? The answer
    is that capped collections behave like circular queues: if we’re out of space,
    the oldest document will be deleted, and the new one will take its place (see
    [Figure 6-5](#figure_d1e7572)). This means that capped collections automatically
    age out the oldest documents as new documents are inserted.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有固定大小的集合提出了一个有趣的问题：当我们尝试向已满的限制集合插入数据时会发生什么？答案是，限制集合表现得像循环队列：如果空间不足，最旧的文档将被删除，新文档将占据其位置（见[图 6-5](#figure_d1e7572)）。这意味着，随着插入新文档，限制集合会自动使最老的文档过时。
- en: Certain operations are not allowed on capped collections. Documents cannot be
    removed or deleted (aside from the automatic age-out described earlier), and updates
    that would cause documents to grow in size are disallowed. By preventing these
    two operations, we guarantee that documents in a capped collection are stored
    in insertion order and that there is no need to maintain a free list for space
    from removed documents.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作在限制集合上是不允许的。文档不能被移除或删除（除了前面描述的自动过时），并且不允许导致文档增长大小的更新操作。通过阻止这两个操作，我们保证限制集合中的文档按插入顺序存储，并且不需要维护从删除文档中的空闲列表的需求。
- en: '![](Images/mdb3_0605.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/mdb3_0605.png)'
- en: Figure 6-5\. When the queue is full, the oldest element will be replaced by
    the newest
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5. 当队列满时，最老的元素将被最新元素替换
- en: 'Capped collections have a different access pattern than most MongoDB collections:
    data is written sequentially over a fixed section of disk. This makes them tend
    to perform writes quickly on spinning disks, especially if they can be given their
    own disk (so as not to be “interrupted” by other collections’ random writes).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 限制集合与大多数MongoDB集合具有不同的访问模式：数据按顺序写入固定的磁盘部分。这使它们倾向于在旋转磁盘上快速执行写入操作，特别是如果它们可以获得自己的磁盘（以免受其他集合随机写入的“干扰”）。
- en: In general, MongoDB TTL indexes are recommended over capped collections because
    they perform better with the WiredTiger storage engine. TTL indexes expire and
    remove data from normal collections based on the value of a date-typed field and
    a TTL value for the index. These are covered in more depth later in this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，推荐使用MongoDB TTL索引而不是限制集合，因为它们在使用WiredTiger存储引擎时性能更好。 TTL索引根据日期类型字段的值和索引的TTL值在普通集合中过期并删除数据。这些内容稍后在本章节中会更深入地介绍。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Capped collections cannot be sharded. If an update or a replacement operation
    changes the document size in a capped collection, the operation will fail.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 限制集合无法分片。如果更新或替换操作在限制集合中改变了文档大小，该操作将失败。
- en: 'Capped collections tend to be useful for logging, although they lack flexibility:
    you cannot control when data ages out, other than setting a size when you create
    the collection.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 限制集合通常用于日志记录，尽管它们缺乏灵活性：除了在创建集合时设置大小外，无法控制数据何时过时。
- en: Creating Capped Collections
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建限制集合
- en: 'Unlike normal collections, capped collections must be explicitly created before
    they are used. To create a capped collection, use the `create` command. From the
    shell, this can be done using `createCollection`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于普通集合，必须在使用之前显式地创建限制集合。要创建一个限制集合，可以使用`create`命令。在Shell中，可以使用`createCollection`来完成：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The previous command creates a capped collection, *my_collection*, that has
    a fixed size of 100,000 bytes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令创建了一个名为*my_collection*的限制集合，其固定大小为100,000字节。
- en: '`createCollection` can also specify a limit on the number of documents in a
    capped collection:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`createCollection`还可以指定限制集合中文档的数量限制：'
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You could use this to keep, say, the latest 10 news articles or limit a user
    to 1,000 documents.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它来保留最新的10篇新闻文章或限制用户为1,000个文档。
- en: Once a capped collection has been created, it cannot be changed (it must be
    dropped and recreated if you wish to change its properties). Thus, you should
    think carefully about the size of a large collection before creating it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了限制集合，就无法更改它（如果希望更改其属性，必须删除并重新创建）。因此，在创建大型集合之前，应仔细考虑其大小。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'When limiting the number of documents in a capped collection, you must specify
    a size limit as well. Age-out will be based on whichever limit is reached first:
    it can neither hold more than `"max"` documents nor take up more than `"size"`
    space.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当限制限制集合中文档的数量时，必须同时指定大小限制。根据首先达到的限制，自动使过期取决于它可以"最大"文档数量不能持有，以及不能多于"大小"空间。
- en: 'Another option for creating a capped collection is to convert an existing regular
    collection into a capped collection. This can be done using the `convertToCapped`
    command—in the following example, we convert the *test* collection to a capped
    collection of 10,000 bytes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建固定大小的集合的另一种选择是将现有的常规集合转换为固定大小的集合。可以使用`convertToCapped`命令来完成这个操作——在下面的示例中，我们将
    *test* 集合转换为一个固定大小为 10,000 字节的集合：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There is no way to “uncap” a capped collection (other than dropping it).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无法“取消”固定大小的集合（除非删除它）。
- en: Tailable Cursors
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可追溯的游标
- en: Tailable cursors are a special type of cursor that are not closed when their
    results are exhausted. They were inspired by the `tail -f` command and, similar
    to that command, will continue fetching output for as long as possible. Because
    the cursors do not die when they run out of results, they can continue to fetch
    new results as documents are added to the collection. Tailable cursors can be
    used only on capped collections, since insert order is not tracked for normal
    collections. For the vast majority of uses, change streams, covered in [Chapter 16](ch16.xhtml#chapter-shardkey),
    are recommended over tailable cursors as they offer vastly more control and configuration
    plus they work with normal collections.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可追溯的游标是一种特殊类型的游标，当其结果耗尽时不会关闭。它们受`tail -f`命令启发，并且类似于该命令，会尽可能地持续获取输出。由于游标在耗尽结果后不会终止，它们可以在向集合添加文档时继续获取新结果。只能在固定大小的集合上使用可追溯的游标，因为普通集合不追踪插入顺序。对于绝大多数用途，建议使用第
    16 章中介绍的变更流，因为它们提供更多控制和配置选项，并且适用于普通集合。
- en: 'Tailable cursors are often used for processing documents as they are inserted
    onto a “work queue” (the capped collection). Because tailable cursors will time
    out after 10 minutes of no results, it is important to include logic to requery
    the collection if they die. The *mongo* shell does not allow you to use tailable
    cursors, but using one in PHP looks something like the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可追溯的游标经常用于处理文档，因为它们被插入到“工作队列”（固定大小的集合）。因为可追溯的游标在没有结果的情况下会在 10 分钟后超时，所以重要的是在逻辑中包含重新查询集合的步骤，以防它们中断。*mongo*
    shell 不允许使用可追溯的游标，但在 PHP 中使用类似以下内容：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The cursor will process results or wait for more results to arrive until it
    times out or someone kills the query operation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 游标将处理结果或等待更多结果到达，直到超时或有人终止查询操作。
- en: Time-To-Live Indexes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期索引
- en: As mentioned in the previous section, capped collections give you limited control
    over when their contents are overwritten. If you need a more flexible age-out
    system, TTL indexes allow you to set a timeout for each document. When a document
    reaches a preconfigured age, it will be deleted. This type of index is useful
    for caching use cases such as session storage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节所述，固定大小的集合对于其内容何时被覆盖具有有限的控制能力。如果需要更灵活的过期系统，TTL 索引允许您为每个文档设置超时时间。当文档达到预配置的年龄时，将会删除它。这种索引类型对于缓存用例（如会话存储）非常有用。
- en: 'You can create a TTL index by specifying the `"expireAfterSeconds"` option
    in the second argument to `createIndex`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`createIndex`的第二个参数中指定`"expireAfterSeconds"`选项来创建 TTL 索引：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This creates a TTL index on the `"lastUpdated"` field. If a document’s `"lastUpdated"`
    field exists and is a date, the document will be removed once the server time
    is `"expireAfterSeconds"` seconds ahead of the document’s time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`"lastUpdated"`字段上创建一个 TTL 索引。如果文档的`"lastUpdated"`字段存在且为日期，则一旦服务器时间比文档时间晚`"expireAfterSeconds"`秒，文档将被删除。
- en: To prevent an active session from being removed, you can update the `"lastUpdated"`
    field to the current time whenever there is activity. Once `"lastUpdated"` is
    24 hours old, the document will be removed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止活动会话被删除，可以在有活动时将`"lastUpdated"`字段更新为当前时间。一旦`"lastUpdated"`超过 24 小时，文档将被移除。
- en: 'MongoDB sweeps the TTL index once per minute, so you should not depend on to-the-second
    granularity. You can change the `"expireAfterSeconds"` using the `collMod` command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 每分钟扫描一次 TTL 索引，因此不应依赖于到秒的精度。可以使用`collMod`命令更改`"expireAfterSeconds"`：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can have multiple TTL indexes on a given collection. They cannot be compound
    indexes but can be used like “normal” indexes for the purposes of sorting and
    query optimization.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定集合上可以有多个 TTL 索引。它们不能是复合索引，但可以像“普通”索引一样用于排序和查询优化。
- en: Storing Files with GridFS
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GridFS 存储文件
- en: 'GridFS is a mechanism for storing large binary files in MongoDB. There are
    several reasons why you might consider using GridFS for file storage:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS 是在 MongoDB 中存储大型二进制文件的机制。以下是您考虑使用 GridFS 进行文件存储的几个原因：
- en: Using GridFS can simplify your stack. If you’re already using MongoDB, you might
    be able to use GridFS instead of a separate tool for file storage.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GridFS 可以简化您的堆栈。如果您已经在使用 MongoDB，则可能可以使用 GridFS 而不是单独的文件存储工具。
- en: GridFS will leverage any existing replication or autosharding that you’ve set
    up for MongoDB, so getting failover and scale-out for file storage is easier.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GridFS 将利用您为 MongoDB 设置的任何现有复制或自动分片，因此更容易实现文件存储的故障转移和扩展。
- en: GridFS can alleviate some of the issues that certain filesystems can exhibit
    when being used to store user uploads. For example, GridFS does not have issues
    with storing large numbers of files in the same directory.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GridFS 可以减轻某些文件系统在用于存储用户上传时可能出现的问题。例如，GridFS 不会在同一目录中存储大量文件时出现问题。
- en: 'There are some downsides, too:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然也有一些缺点：
- en: Performance is slower. Accessing files from MongoDB will not be as fast as going
    directly through the filesystem.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能较慢。从 MongoDB 访问文件不会像直接通过文件系统那样快。
- en: You can only modify documents by deleting them and resaving the whole thing.
    MongoDB stores files as multiple documents, so it cannot lock all of the chunks
    in a file at the same time.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只能通过删除并重新保存整个文档来修改文档。MongoDB 将文件存储为多个文档，因此无法同时锁定文件中的所有块。
- en: GridFS is generally best when you have large files you’ll be accessing in a
    sequential fashion that won’t be changing much.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有大型文件需要按顺序访问且不会经常更改时，通常最适合使用 GridFS。
- en: 'Getting Started with GridFS: mongofiles'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门 GridFS：mongofiles
- en: The easiest way to try out GridFS is by using the *mongofiles* utility. *mongofiles*
    is included with all MongoDB distributions and can be used to upload, download,
    list, search for, or delete files in GridFS.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 GridFS 最简单的方法是使用 *mongofiles* 实用程序。*mongofiles* 包含在所有 MongoDB 发行版中，并可用于上传、下载、列出、搜索或删除
    GridFS 中的文件。
- en: As with any of the other command-line tools, run `mongofiles --help` to see
    the options available for *mongofiles*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他命令行工具一样，运行 `mongofiles --help` 查看 *mongofiles* 的可用选项。
- en: 'The following session shows how to use *mongofiles* to upload a file from the
    filesystem to GridFS, list all of the files in GridFS, and download a file that
    we’ve previously uploaded:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下会话显示了如何使用 *mongofiles* 将文件从文件系统上传到 GridFS，列出 GridFS 中的所有文件，并下载先前上传的文件：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the previous example, we perform three basic operations using *mongofiles*:
    `put`, `list`, and `get`. The `put` operation takes a file in the filesystem and
    adds it to GridFS. `list` will list any files that have been added to GridFS.
    `get` does the inverse of `put`: it takes a file from GridFS and writes it to
    the filesystem. *mongofiles* also supports two other operations: `search` for
    finding files in GridFS by filename and `delete` for removing a file from GridFS.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 *mongofiles* 执行了三个基本操作：`put`、`list` 和 `get`。`put` 操作将文件从文件系统添加到
    GridFS。`list` 将列出已添加到 GridFS 的任何文件。`get` 的作用与 `put` 相反：它从 GridFS 中取出文件并将其写入文件系统。*mongofiles*
    还支持另外两个操作：`search` 用于按文件名在 GridFS 中查找文件，`delete` 用于从 GridFS 中删除文件。
- en: Working with GridFS from the MongoDB Drivers
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MongoDB 驱动程序操作 GridFS
- en: 'All the client libraries have GridFS APIs. For example, with PyMongo (the Python
    driver for MongoDB) you can perform the same series of operations (this assumes
    Python 3 and a locally running *mongod* on port 27017) as we did with *mongofiles*
    as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所有客户端库都有 GridFS API。例如，使用 PyMongo（MongoDB 的 Python 驱动程序），您可以执行与我们使用 *mongofiles*
    相同的一系列操作（假设使用 Python 3 并在端口 27017 上本地运行 *mongod*）。
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The API for working with GridFS from PyMongo is very similar to that of *mongofiles*:
    you can easily perform the basic `put`, `get`, and `list` operations. Almost all
    the MongoDB drivers follow this basic pattern for working with GridFS, while often
    exposing more advanced functionality as well. For driver-specific information
    on GridFS, please check out the documentation for the specific driver you’re using.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PyMongo 使用 GridFS 的 API 与 *mongofiles* 非常相似：您可以轻松执行基本的 `put`、`get` 和 `list`
    操作。几乎所有 MongoDB 驱动程序都遵循此基本模式来处理 GridFS，通常还公开更高级的功能。有关特定驱动程序的 GridFS 信息，请查阅您正在使用的特定驱动程序的文档。
- en: Under the Hood
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在幕后
- en: GridFS is a lightweight specification for storing files that is built on top
    of normal MongoDB documents. The MongoDB server actually does almost nothing to
    “special-case” the handling of GridFS requests; all the work is handled by the
    client-side drivers and tools.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS是建立在普通MongoDB文档之上的轻量级文件存储规范。MongoDB服务器实际上几乎不进行任何“特殊处理”来处理GridFS请求；所有工作都由客户端驱动程序和工具处理。
- en: The basic idea behind GridFS is that we can store large files by splitting them
    up into *chunks* and storing each chunk as a separate document. Because MongoDB
    supports storing binary data in documents, we can keep the storage overhead for
    chunks to a minimum. In addition to storing each chunk of a file, we store a single
    document that groups the chunks together and contains metadata about the file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS的基本思想是，通过将大文件分割成*块*并将每个块存储为单独的文档，我们可以存储大文件。由于MongoDB支持在文档中存储二进制数据，我们可以将块的存储开销降到最低。除了存储文件的每个块外，我们还存储一个单独的文档，将这些块组合在一起，并包含有关文件的元数据。
- en: 'The chunks for GridFS are stored in their own collection. By default chunks
    will use the collection *fs.chunks*, but this can be overridden. Within the chunks
    collection the structure of the individual documents is pretty simple:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: GridFS的块存储在它们自己的集合中。默认情况下，块将使用*fs.chunks*集合，但可以进行覆盖。在块集合中，各个文档的结构非常简单：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Like any other MongoDB document, a chunk has its own unique `"_id"`. In addition,
    it has a couple of other keys:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他MongoDB文档一样，一个块有其自己独特的`"_id"`。此外，它还有几个其他键：
- en: '`"files_id"`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`"files_id"`'
- en: The `"_id"` of the file document that contains the metadata for the file this
    chunk is from
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 包含该块所属文件元数据的文件文档的`"_id"`。
- en: '`"n"`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`"n"`'
- en: The chunk’s position in the file, relative to the other chunks
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在文件中的位置，相对于其他文件块
- en: '`"data"`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`"data"`'
- en: The bytes in this chunk of the file
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 文件块中的字节。
- en: 'The metadata for each file is stored in a separate collection, which defaults
    to *fs.files*. Each document in the files collection represents a single file
    in GridFS and can contain any custom metadata that should be associated with that
    file. In addition to any user-defined keys, there are a couple of keys that are
    mandated by the GridFS specification:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件的元数据存储在单独的集合中，默认为*fs.files*。文件集合中的每个文档代表GridFS中的单个文件，并可以包含应与该文件关联的任何自定义元数据。除了任何用户定义的键之外，还有几个由GridFS规范强制的键：
- en: '`"_id"`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`"_id"`'
- en: A unique ID for the file—this is what will be stored in each chunk as the value
    for the `"files_id"` key.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的唯一ID —— 这是将作为`"files_id"`键的值存储在每个块中的内容。
- en: '`"length"`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`"length"`'
- en: The total number of bytes making up the content of the file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 构成文件内容的总字节数。
- en: '`"chunkSize"`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`"chunkSize"`'
- en: The size of each chunk comprising the file, in bytes. The default is 255 KB,
    but this can be adjusted if needed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 构成文件的每个块的大小（以字节为单位）。默认值为255 KB，但可以根据需要进行调整。
- en: '`"uploadDate"`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`"uploadDate"`'
- en: A timestamp representing when this file was stored in GridFS.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 表示此文件存储在GridFS中的时间戳。
- en: '`"md5"`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`"md5"`'
- en: An MD5 checksum of this file’s contents, generated on the server side.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端生成的此文件内容的MD5校验和。
- en: Of all the required keys, perhaps the most interesting (or least self-explanatory)
    is `"md5"`. The value for `"md5"` is generated by the MongoDB server using the
    `filemd5` command, which computes the MD5 checksum of the uploaded chunks. This
    means that users can check the value of the `"md5"` key to ensure that a file
    was uploaded correctly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在所需的所有键中，也许最有趣（或者说最不容易理解）的是`"md5"`。`"md5"`键的值是由MongoDB服务器使用`filemd5`命令生成的，该命令计算上传块的MD5校验和。这意味着用户可以检查`"md5"`键的值，以确保文件已正确上传。
- en: 'As mentioned previously, you are not limited to the required fields in *fs.files*:
    feel free to keep any other file metadata in this collection as well. You might
    want to keep information such as download count, MIME type, or user rating with
    a file’s metadata.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，*fs.files*中并不限于所需字段：可以随意在此集合中保留任何其他文件元数据。您可能希望在文件的元数据中保留下载次数、MIME类型或用户评分等信息。
- en: 'Once you understand the underlying GridFS specification, it becomes trivial
    to implement features that the driver you’re using might not provide helpers for.
    For example, you can use the `distinct` command to get a list of unique filenames
    stored in GridFS:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了底层的GridFS规范，就可以轻松地实现您使用的驱动程序可能没有提供帮助器的功能。例如，您可以使用`distinct`命令获取存储在GridFS中的唯一文件名列表：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This allows your application a great deal of flexibility in loading and collecting
    information about files. We’ll change direction slightly in the next chapter,
    as we introduce the aggregation framework. It offers a range of data analytic
    tools to process the data in your database.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得您的应用程序在加载和收集文件信息时具有很大的灵活性。在接下来的一章中，我们将稍作调整，介绍聚合框架。它提供了一系列数据分析工具，用于处理数据库中的数据。
