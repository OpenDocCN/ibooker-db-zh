- en: Chapter 2\. Using MySQL Shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 使用MySQL Shell
- en: 2.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.0 简介
- en: We discussed the mysql Client Program in [Chapter 1](ch01.xhtml#nch-mysql).
    MySQL Shell is modern alternative client. In addition to SQL, it supports non-relational
    syntax for the database queries, also known as NoSQL, via JavaScript or Python
    programming interface and provides reach set of features to automate routine tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第一章](ch01.xhtml#nch-mysql)讨论了mysql客户端程序。MySQL Shell是现代的替代客户端。除了SQL外，它还通过JavaScript或Python编程接口支持非关系型数据库查询语法，也称为NoSQL，并提供丰富的功能集来自动化常规任务。
- en: 'In this chapter we will discuss how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何：
- en: Connect to MySQL Shell and select the right protocol.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到MySQL Shell并选择正确的协议。
- en: Select SQL, JavaScript or Python interface.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择SQL、JavaScript或Python接口。
- en: Use both SQL and NoSQL syntax.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL和NoSQL语法。
- en: Control output format.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制输出格式。
- en: Use MySQL Shell built-in utilities.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MySQL Shell内置工具。
- en: Script to automate your custom needs.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写脚本以自动化您的自定义需求。
- en: Use Admin API.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管理API。
- en: Re-use your scripts.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用您的脚本。
- en: Although MySQL Shell is a standard tool for certain tasks, it is not included
    in MySQL packages and needs to be installed separately. You can download it from
    the [MySQL Shell download page](https://dev.mysql.com/downloads/shell/) or install
    using the standard package manager of your operating system. We will not cover
    MySQL Shell installation in this book, because it is straight forward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MySQL Shell是某些任务的标准工具，但它不包含在MySQL软件包中，需要单独安装。您可以从[MySQL Shell下载页面](https://dev.mysql.com/downloads/shell/)下载它，或者使用操作系统的标准软件包管理器进行安装。本书不涵盖MySQL
    Shell的安装过程，因为它非常简单。
- en: The MySQL Shell’s command name is *mysqlsh*. You can invoke it by typing *mysqlsh*
    in the terminal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell的命令名为*mysqlsh*。您可以在终端中输入*mysqlsh*来调用它。
- en: 'MySQL Shell supports two protocols: the classic MySQL protocol (similar to
    the one that the *mysql* client uses), and the new X protocol. X protocol is a
    modern protocol that communicates with the MySQL server on a separate port (default
    is 33060). It supports both SQL and NoSQL APIs, and provides asynchronous API,
    allowing clients to send multiple queries to the server without waiting for the
    result from the previous ones. X protocol is preferred way to work with MySQL
    Shell. It is especially important if you want to use NoSQL features.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell支持两种协议：经典的MySQL协议（类似于*mysql*客户端使用的协议）和新的X协议。X协议是一种现代协议，通过单独的端口（默认为33060）与MySQL服务器通信。它支持SQL和NoSQL
    API，并提供异步API，允许客户端发送多个查询到服务器而无需等待先前查询的结果。使用X协议是使用MySQL Shell的首选方式，特别是如果您想使用NoSQL功能。
- en: 2.1 Connecting to MySQL Server with MySQL Shell
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 使用MySQL Shell连接到MySQL服务器
- en: Problem
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: When you invoke *mysqlsh* it opens new session, but does not connect to any
    MySQL Server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用*mysqlsh*时，它会打开一个新的会话，但不会连接到任何MySQL服务器。
- en: Solution
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use command *\connect* inside MySQL Shell or provide your MySQL server URI at
    startup.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL Shell内部使用*\connect*命令或在启动时提供您的MySQL服务器URI。
- en: Discussion
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: MySQL Shell allows you to connect to MySQL server after you started the tool
    by providing connections options as a command line parameter. You may also put
    default connection parameters in a startup script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动工具后，MySQL Shell允许您通过命令行参数提供连接选项来连接到MySQL服务器。您也可以将默认连接参数放在启动脚本中。
- en: MySQL Shell is flexible regarding connection options. You can supply them as
    a URI or name-value pairs, similar to one that *mysql* client accepts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于连接选项，MySQL Shell非常灵活。您可以将它们作为URI或名称-值对提供，类似于*mysql*客户端接受的方式。
- en: 'URI uses this format:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: URI使用以下格式：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where meanings of the parameters explained in the [Table 2-1](#nch-mysqlshell-mysqlshell-connecting-uri).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的含义在[表格 2-1](#nch-mysqlshell-mysqlshell-connecting-uri)中有解释。
- en: Table 2-1\. Connection Options in URI
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-1\. URI连接选项
- en: '| Parameter | Explanation | Default |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 解释 | 默认值 |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `scheme` | A protocol to use. Could be one of `mysql` if you want to use
    Classic protocol or `mysqlx` for X protocol. | `mysqlx` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `scheme` | 要使用的协议。可以是`mysql`（如果要使用经典协议）或`mysqlx`（如果要使用X协议）。 | `mysqlx` |'
- en: '| `user` | User name to connect as. | Your operating system account. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 要连接的用户名。 | 您的操作系统帐户。 |'
- en: '| `password` | Password | Asks for a password. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `password` | 密码 | 请求密码。 |'
- en: '| `host` | Host to connect to. | No default. This is the only **required**
    parameter unless option `socket` is specified. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `host` | 要连接的主机。 | 没有默认值。这是唯一的**必需**参数，除非指定了`socket`选项。 |'
- en: '| `port` | Port to connect to. | 3306 for the Classic protocol and 33060 for
    the X protocol. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `port` | 要连接的端口。 | 经典协议为 3306，X 协议为 33060。 |'
- en: '| `socket` | Socket, used for the localhost connection. | You must provide
    this or the `host` parameter. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `socket` | 用于本地主机连接的套接字。 | 您必须提供此参数或`host`参数。 |'
- en: '| `schema` | Database schema to connect to. | No value. Do not select any schema.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `schema` | 要连接的数据库模式。 | 无值。不要选择任何模式。 |'
- en: '| `option` | Any additional option you want to use. | No value. Choose any
    or no option. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `option` | 您想要使用的任何其他选项。 | 无值。选择任何或不选择任何选项。 |'
- en: 'So, to connect to MySQL server on your local machine using interactive interface,
    type *\connect 127.0.0.1*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使用交互界面连接到本地机器上的 MySQL 服务器，请键入 *\connect 127.0.0.1*：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create a connection using X protocol.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个使用 X 协议的连接。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When connecting without specifying user name MySQL Shell uses the operating
    system login. This is why connection is created for user `sveta` and not for the
    user `cbuser` we used everywhere else in the book. We will cover how to specify
    MySQL user account when connecting later.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在不指定用户名连接时，MySQL Shell 使用操作系统登录。这就是为什么连接是为用户`sveta`创建的，而不是我们在本书中到处使用的用户`cbuser`。我们将在稍后讨论如何在连接时指定
    MySQL 用户帐户。
- en: To exit from the MySQL Shell session use command `\exit` or `\quit` and its
    short form `\q`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 MySQL Shell 会话，请使用命令 `\exit` 或 `\quit` 及其简写形式 `\q`。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To connect interactively using a socket, type *\c (/var/run/mysqld/mysqld.sock)*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用套接字进行交互连接，请键入 *\c (/var/run/mysqld/mysqld.sock)*：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will create connection using Classic protocol. If you want to connect via
    socket with X protocol use `mysqlx_socket`. You will find value of the `mysqlx_socket`
    if run query
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建使用经典协议的连接。如果要使用 X 协议通过套接字连接，请使用 `mysqlx_socket`。如果运行查询，您将找到`mysqlx_socket`的值。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Command *\connect* has shorter version *\c* that we used in the connection
    via socket example. Note parentheses in the command argument. Without parentheses
    the command will fail with syntax error. Alternatively you can replace all following
    slash symbols with their URI encoded value `%2F`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 *\connect* 有一个更短的版本 *\c*，我们在通过套接字连接的示例中使用了它。请注意命令参数中的括号。如果没有括号，命令将因语法错误而失败。或者，您可以用其
    URI 编码值 `%2F` 替换所有后续的斜杠符号：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To connect using URI when opening a MySQL Shell session, use the command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开 MySQL Shell 会话时使用 URI 进行连接，使用以下命令：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case we specified a user name and a password via command line and selected
    `cookbook` as a default database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过命令行指定了用户名和密码，并选择了`cookbook`作为默认数据库。
- en: When connecting while invoking *mysqlsh* command you can also specify connection
    credentials separately, similar to when you connected with the *mysql* client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 *mysqlsh* 命令时连接时，您还可以单独指定连接凭据，类似于使用 *mysql* 客户端连接时的方式。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you want to specify default schema, you need to pass it as a parameter to
    the configuration option `schema`. Otherwise *mysqlsh* will treat it as a host
    name and fail with an error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要指定默认模式，请将其作为参数传递给配置选项`schema`。否则，*mysqlsh* 将将其视为主机名并因错误而失败。
- en: Inside MySQL Shell you can also specify options via named parameters. First
    you need to create a dictionary with connection parameters, then pass it as an
    option to the *connect()* method of the built-in automatically created `shell`
    object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL Shell 中，您还可以通过命名参数指定选项。首先，您需要创建一个包含连接参数的字典，然后将其作为选项传递给内置的自动创建的`shell`对象的*connect()*方法。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See Also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about how to connect to MySQL Server via MySQL Shell,
    see [MySQL Shell Connections](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-connections.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何通过 MySQL Shell 连接到 MySQL 服务器的更多信息，请参阅[MySQL Shell Connections](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-connections.html)。
- en: 2.2 Selecting the Protocol
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 选择协议
- en: Problem
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You don’t want to use MySQL Shell’s default, and you want to select either the
    X protocol or the classic protocol yourself.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您不想使用 MySQL Shell 的默认设置，并且希望自己选择 X 协议或经典协议。
- en: Solution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To select X protocol: use one of options `mysqlx`, `mx`, `sqlx`. To select
    classic protocol: use one of options `mysql`, `mc` and `sqlc`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择 X 协议：使用选项之一 `mysqlx`、`mx`、`sqlx`。要选择经典协议：使用选项之一 `mysql`、`mc` 和 `sqlc`。
- en: Discussion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: MySQL Shell selects protocol automatically using connection options and server
    response. If a port or socket option is not used, it tries to connect using a
    default portor socket for the X protocol. If that’s not available, it defaults
    to the classic protocol. If this is not a desired behavior or you simply want
    to control which protocol to use explicitly, you can specify it by passing options
    `mysqlx`, `mx`, `sqlx` when starting the *mysqlsh* client to select X protocol
    and options `mysql`, `mc` and `sqlc` to select classic protocol.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 使用连接选项和服务器响应自动选择协议。如果未使用端口或套接字选项，则尝试使用 X 协议的默认端口或套接字。如果不可用，则默认使用经典协议。如果这不是预期的行为或者您想要显式控制使用哪种协议，可以在启动
    *mysqlsh* 客户端时通过传递选项 `mysqlx`、`mx` 和 `sqlx` 来选择 X 协议，并通过选项 `mysql`、`mc` 和 `sqlc`
    来选择经典协议。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Inside MySQL Shell, when opening a new connection, specify value for the `scheme`
    key when passing options to the `connectionData` dictionary:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL Shell 内部，当打开新连接时，通过将选项传递给 `connectionData` 字典的 `scheme` 键来指定值：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In both cases, when specifying a URI, you can prefix connection options by
    the `scheme`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定 URI 时，可以通过 `scheme` 前缀连接选项：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the specified protocol could not be used MySQL Shell will fail with an error:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定的协议无法使用，MySQL Shell 将失败并显示错误：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can find details of your current MySQL Shell connection by running command
    *shell.status()*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行命令 *shell.status()* 查找当前 MySQL Shell 连接的详细信息：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: MySQL Shell, like MySQL CLI, allows to customize its prompt. To do it you need
    to edit file `prompt.json`, located in the configuration home of MySQL Shell.
    This is a file in JSON format. MySQL Shell comes with good number of custom templates
    of the prompt and the `README.prompt` file, explaining how to modify the prompt.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 允许像 MySQL CLI 一样自定义其提示符。要实现这一点，需要编辑位于 MySQL Shell 配置主目录中的 `prompt.json`
    文件。这是一个 JSON 格式的文件。MySQL Shell 提供了大量自定义提示符模板和解释如何修改提示的 `README.prompt` 文件。
- en: We will not cover in detail how to customize the MySQL Shell user prompt, but
    will remove the host, port, and protocol information from the default prompt,
    so our examples will take less space in the book.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何自定义 MySQL Shell 用户提示符，但会从默认提示中移除主机、端口和协议信息，这样我们的示例在书中占用的空间将更少。
- en: Configuration home of the MySQL Shell is either `~/.mysqlsh/` on Unix or `%AppData%\MySQL\mysqlsh\`
    on Windows. You can overwrite this location if set variable `MYSQLSH_USER_CONFIG_HOME`.
    `README.prompt` and examples are located in the `share/mysqlsh/prompt/` directory
    under MySQL Shell installation root.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 的配置主目录在 Unix 上是 `~/.mysqlsh/`，在 Windows 上是 `%AppData%\MySQL\mysqlsh\`。如果设置了变量
    `MYSQLSH_USER_CONFIG_HOME`，可以覆盖此位置。`README.prompt` 和示例位于 MySQL Shell 安装根目录下的 `share/mysqlsh/prompt/`
    目录中。
- en: See Also
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: See Also
- en: For additional information about *mysqlsh* command options, see [A.1 mysqlsh
    — The MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysqlsh.html).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 获取关于 *mysqlsh* 命令选项的更多信息，请参阅 [A.1 mysqlsh — The MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysqlsh.html)。
- en: 2.3 Selecting SQL, JavaScript or Python Mode
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 选择 SQL、JavaScript 或 Python 模式
- en: Problem
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Problem
- en: MySQL Shell starts in the wrong mode, and you want to select a different mode
    than the default.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 启动时选择了错误的模式，您希望选择与默认模式不同的模式。
- en: Solution
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use options `sql`, `js` or `py` or switch the mode after starting *mysqlsh*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动 *mysqlsh* 后，可以使用 `sql`、`js` 或 `py` 选项或切换模式。
- en: Discussion
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'By default MySQL Shell starts in JavaScript mode. You can see it by looking
    at the prompt string:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MySQL Shell 以 JavaScript 模式启动。您可以通过查看提示字符串来确认：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can change default mode if start the tool with the option `--sql` to select
    SQL mode or `--py` to select Python mode. To select JavaScript mode explicitly
    at startup use option `--js`. You will see that the prompt message of the MySQL
    Shell client will change to the selected mode. Here, we select the Python mode.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动工具时使用 `--sql` 选项选择 SQL 模式或 `--py` 选项选择 Python 模式，则可以更改默认模式。要显式选择 JavaScript
    模式，请使用 `--js` 选项。您将看到 MySQL Shell 客户端的提示消息会更改为所选模式。在此处，我们选择 Python 模式。
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: For SQL mode you can explicitly instruct the tool to use not only desired mode,
    but also a desired protocol with option `sqlx` to select X protocol and option
    `sqlc` to select Classic protocol. This could be handy when you connect via default
    TCP/IP port.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQL 模式，您可以明确指示工具使用所需的模式，并使用选项 `sqlx` 选择 X 协议以及选项 `sqlc` 选择经典协议。当您通过默认 TCP/IP
    端口连接时，这可能非常方便。
- en: Inside *mysqlsh* you can change the processing mode with commands *\js*, *\py*,
    and *\sql* to switch to Javascript, Python, and SQL modes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在*mysqlsh*中，您可以使用命令*\js*、*\py*和*\sql*更改处理模式，分别切换到JavaScript、Python和SQL模式。
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 2.4 Running SQL Session
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 运行SQL会话
- en: Problem
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to have functionality that’s a *mysql* client has, but you do not want
    to leave MySQL Shell.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望具有类似*mysql*客户端的功能，但又不想离开MySQL Shell。
- en: Solution
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use SQL mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL模式。
- en: Discussion
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: With SQL mode MySQL Shell behaves exactly the same as the *mysql* client that
    we describe in [Chapter 1](ch01.xhtml#nch-mysql). You can run queries, control
    output using *\pager* command, edit SQL in the system editor with *\edit* command,
    execute SQL from a file with *\source* command and execute a system shell commands
    with *\system*. You can view and edit the command line history.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL模式，MySQL Shell的行为与我们在[第1章](ch01.xhtml#nch-mysql)中描述的*mysql*客户端完全相同。您可以运行查询，使用*\pager*命令控制输出，在系统编辑器中使用*\edit*命令编辑SQL，在文件中使用*\source*命令执行SQL，并使用*\system*执行系统shell命令。您可以查看和编辑命令行历史记录。
- en: There is no shortcut `\d` for the *delimiter* command, but the command itself
    works.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 没有*\d*作为*delimiter*命令的快捷方式，但命令本身是有效的。
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no *tee* command. If you want to log query results into a file, set
    the pager to `tee -a <DESIRED LOG FILE LOCATION>`. However, it will not log SQL
    statements. They are available only in the history file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有*tee*命令。如果要将查询结果记录到文件中，请将分页器设置为`tee -a <DESIRED LOG FILE LOCATION>`。但它不会记录SQL语句，它们仅在历史文件中可用。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'By default MySQL Shell does not save history between client sessions. This
    means that you cannot access your previous commands once you exit the shell. You
    can overwrite this behavior if enable option `history.autoSave`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MySQL Shell不会在客户端会话之间保存历史记录。这意味着一旦退出Shell，您无法访问先前的命令。如果启用选项`history.autoSave`，可以覆盖此行为：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 2.5 Running SQL in JavaScript Mode
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 在JavaScript模式中运行SQL
- en: Problem
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are in JavaScript mode, but want to execute traditional SQL
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您处于JavaScript模式，但想执行传统SQL
- en: Solution
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the command *\sql*, or use the methods `sql()` and `runSQL()` that belong
    to the class `Session`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令*\sql*，或使用属于`Session`类的`sql()`和`runSQL()`方法，在JavaScript模式中执行传统SQL。
- en: Discussion
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: JavaScript mode supports the object-oriented style of querying your database.
    Or, you can run plain SQL.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript模式支持面向对象的数据库查询风格。或者，您可以运行纯SQL。
- en: 'If you want to run single SQL statement and get results like you can in the
    MySQL client without leaving JavaScript mode use command *\sql*. In the example
    below we run plain SQL statement, selecting data from the table `limbs` for things
    that have two or more arms:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在不离开JavaScript模式的情况下运行单个SQL语句并获取结果，可以使用命令*\sql*。在下面的示例中，我们运行了一条普通SQL语句，从表`limbs`中选择具有两个或更多手臂的数据：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The object-oriented style of running SQL is more flexible and provides more
    options. To run single statement use method *runSQL* of the class `Session`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以面向对象的方式运行SQL更加灵活，并提供更多选项。要运行单个语句，请使用`Session`类的*runSQL*方法。
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When you connect to MySQL Shell it creates a default instance of the class `Session`.
    It is accessible via global object `session`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到MySQL Shell时，它会创建`Session`类的默认实例。可以通过全局对象`session`访问它。
- en: 'Method *runSQL* supports placeholders: just replace variable values with `?`
    sign and pass parameters as an array.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*runSQL*支持占位符：只需用`?`符号替换变量值，并将参数作为数组传递。
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can combine this method with standard JavaScript syntax and create a script
    that can do more than just running SQL queries:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此方法与标准JavaScript语法结合，创建一个能够执行更多操作而不仅限于运行SQL查询的脚本：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](Images/1.png)](#co_select_max_co)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_select_max_co)'
- en: Select maximum number of arms, stored in the `limbs` table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 选择存储在`limbs`表中的最大手臂数。
- en: '[![2](Images/2.png)](#co_fetch_one_co)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_fetch_one_co)'
- en: Method *session.sql.execute()* returns a `SqlResult` object that has a method,
    called *fetchOne*, returning the first row of the result set.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*session.sql.execute()*返回一个`SqlResult`对象，其中有一个名为*fetchOne*的方法，返回结果集的第一行。
- en: '[![3](Images/3.png)](#co_get_field_co)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_get_field_co)'
- en: Since our query is supposed to return one row we did not traverse the result
    set, but simply called a method *getField* that takes a column name or its alias
    as a parameter, to get maxium number of arms, stored in the table `limbs`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的查询应返回一行，我们没有遍历结果集，而只是调用了一个名为*getField*的方法，该方法以列名或其别名作为参数，以获取存储在`limbs`表中的最大手臂数。
- en: '[![4](Images/4.png)](#co_for_loop_co)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_for_loop_co)'
- en: We used this number as a stopping condition for the *for* loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此数字用作*for*循环的停止条件。
- en: '[![5](Images/5.png)](#co_bind_co)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_bind_co)'
- en: In the loop we executed queries to get number of the species with the specified
    number of arms. We used method *sql* and its method *bind* to bind value of the
    loop iterator `i` to the query.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们执行了查询以获取指定手臂数量的物种数量。我们使用了*sql*方法及其*bind*方法，将循环迭代器`i`的值绑定到查询中。
- en: '[![6](Images/6.png)](#co_result_co)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_result_co)'
- en: Check if we received a result and if number of arms is greater than 0.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否收到了结果，以及手臂数量是否大于0。
- en: '[![7](Images/7.png)](#co_print_co)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_print_co)'
- en: 'If both conditions are true: print the result.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个条件都为真：打印结果。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you execute *sql* or *runSQL* methods separately MySQL Shell calls method
    *execute* for them automatically. But if using these methods in more complicated
    code, like in the loops or multiple-statements blocks you need to call method
    *execute* explicitly. Otherwise only last statement will be executed and all previous
    invocations will be ignored.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单独执行*sql*或*runSQL*方法时，MySQL Shell会自动为它们调用*execute*方法。但是，如果在更复杂的代码中使用这些方法，如在循环或多语句块中，您需要显式调用*execute*方法。否则，只有最后一个语句会被执行，而所有之前的调用将被忽略。
- en: See Also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about MySQL Shell API, see the [ShellAPI in the advanced
    MySQL User Reference Manual](https://dev.mysql.com/doc/dev/mysqlsh-api-javascript/8.0/group___shell_a_p_i.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MySQL Shell API的更多信息，请参阅[高级MySQL用户参考手册中的ShellAPI](https://dev.mysql.com/doc/dev/mysqlsh-api-javascript/8.0/group___shell_a_p_i.html)。
- en: 2.6 Running SQL in Python Mode
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 在Python模式下运行SQL
- en: Problem
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You are in Python mode, but want to execute traditional SQL
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在Python模式下，但希望执行传统SQL。
- en: Solution
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the command *\sql*, or the methods `sql`, `run_sql` of the class `Session`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令*\sql*或类`Session`的方法`sql`、`run_sql`。
- en: Discussion
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Just as we saw with JavaScript mode, the Python mode also supports the *\sql*
    command. You can use it if you want to execute a SQL statement and do not want
    to do anything with its result. The following code selects all rows from the table
    `movies`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在JavaScript模式中看到的那样，Python模式也支持*\sql*命令。如果您要执行SQL语句而不想处理其结果，可以使用它。以下代码从表`movies`中选择所有行。
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Method names in Python mode are slightly different from those in JavaScript
    mode. Thus, to run SQL statement, using `Session` object and bind parameters to
    it as an array use method *run_sql*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Python模式中的方法名称与JavaScript模式稍有不同。因此，要运行SQL语句，请使用`Session`对象并将参数绑定为数组，使用方法*run_sql*。
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example selects all movies, created before 2000.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例选择了所有在2000年之前创建的电影。
- en: You can program in Python as well as in JavaScript. For example, if you want
    to know the number of movies each actor was featured in as well as years when
    they were starred, join table `movies` with table `movies_actors`, then print
    result using Python code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Python或JavaScript进行编程。例如，如果要知道每位演员出演的电影数量以及出演年份，请将表`movies`与表`movies_actors`连接，然后使用Python代码打印结果。
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](Images/1.png)](#co_query_co)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_query_co)'
- en: Run the query and fetch all the rows that it returns into a variable `myres`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询并将其返回的所有行提取到变量`myres`中。
- en: '[![2](Images/2.png)](#co_loop_co)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_loop_co)'
- en: Traverse this variable in a *for ... in* loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在*for ... in*循环中遍历此变量。
- en: '[![3](Images/3.png)](#co_print_py_co)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_print_py_co)'
- en: Print result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you are not familiar with the query syntax yet, do not worry: we will discuss
    ways of querying data in [Chapter 5](ch05.xhtml#nch-select) and how to join two
    or more tables in [Recipe 16.0](ch16.xhtml#nch-multi-multi-intro).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对查询语法尚不熟悉，不用担心：我们将在[第5章](ch05.xhtml#nch-select)讨论数据查询的方法，以及在[配方16.0](ch16.xhtml#nch-multi-multi-intro)中如何连接两个或多个表。
- en: See Also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about Python MySQL Shell API, use command *\? mysqlx*
    inside the Python shell session.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取有关Python MySQL Shell API的额外信息，请在Python shell会话内使用命令*\? mysqlx*。
- en: 2.7 Working with Tables in JavaScript Mode
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.7 在JavaScript模式下使用表格
- en: Problem
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to query your tables using object-oriented style in JavaScript mode.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在JavaScript模式中使用面向对象的方式查询您的表。
- en: Solution
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use method *getTable* to select a table, then methods *select*, *count*, *insert*,
    *update*, *delete* to select, retrieve number of rows, insert, update or delete
    from the table.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法*getTable*选择表，然后使用方法*select*、*count*、*insert*、*update*、*delete*从表中选择、检索行数、插入、更新或删除。
- en: Discussion
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: MySQL Shell supports object-oriented syntax for querying and modifying database
    objects. Thus, to select all rows from the table `limbs` we can use *select* method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell支持面向对象的语法来查询和修改数据库对象。因此，要从表`limbs`中选择所有行，我们可以使用*select*方法。
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the listing above we firstly selected schema using *getDefaultSchema* method,
    then selected a table with method *getTable* and, finally, retrieved all rows
    with *select*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的清单中，我们首先使用*getDefaultSchema*方法选择模式，然后用*getTable*方法选择表，最后用*select*检索所有行。
- en: 'Method *select* returns `TableSelect` object that supports methods allowing
    to specify `WHERE` condition, `ORDER BY`, `GROUP BY` clauses and other features
    that SQL `SELECT` has. It also supports prepared statements and parameters binding.
    Thus, to select only those species from the table `limbs` that have four or more
    legs and order them by number of legs try the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*select*返回`TableSelect`对象，支持允许指定`WHERE`条件、`ORDER BY`、`GROUP BY`子句和SQL `SELECT`具有的其他功能的方法。它还支持准备语句和参数绑定。因此，要仅选择表`limbs`中具有四条或更多腿的物种并按腿数排序，请尝试以下代码：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Warning
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Notice that here we are using named parameters for placeholders instead of question
    marks like we did when queried database with SQL.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们使用了命名参数作为占位符，而不是像在SQL查询数据库时使用问号。
- en: MySQL Shell API also supports methods to insert, update and delete data in the
    object-oriented style as well as starting and finishing transactions. Like, if
    we want to experiment with `cookbook` database without actually modifying data
    we can do it inside a transaction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell API还支持以面向对象的方式插入、更新和删除数据，以及启动和完成事务。例如，如果我们想在不实际修改数据的情况下对`cookbook`数据库进行实验，我们可以在事务内进行。
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](Images/1.png)](#co_jst_limbs_co)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_jst_limbs_co)'
- en: Save the table object for the table `limbs` into a variable `limbs`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将表`limbs`的表对象保存到变量`limbs`中。
- en: '[![2](Images/2.png)](#co_jst_transaction_co)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_jst_transaction_co)'
- en: Start a transaction, so we can rollback our experiments.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个事务，这样我们就可以回滚我们的实验。
- en: '[![3](Images/3.png)](#co_jst_insert_co)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_jst_insert_co)'
- en: Insert two rows into table `limbs` using method *insert* that takes list of
    columns as a parameter and method *values* that takes list of values to be inserted
    as a parameter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*insert*方法将两行插入表`limbs`，该方法将列列表作为参数，并将要插入的值列表作为参数。
- en: '[![4](Images/4.png)](#co_jst_count_co)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_jst_count_co)'
- en: Check the number of rows that now exist in the table.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 检查现在表中存在的行数。
- en: '[![5](Images/5.png)](#co_jst_update_co)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_jst_update_co)'
- en: If look back to the rows that we inserted you may notice an error. A dog actually
    has four legs and not two legs and two arms. To fix this mistake call method *update*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回顾我们插入的行，您可能会注意到一个错误。实际上，狗有四条腿，而不是两条腿和两只手臂。要纠正这个错误，请调用*update*方法。
- en: '[![6](Images/6.png)](#co_jst_select_co)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_jst_select_co)'
- en: Following *select* call confirmed that our changes were applied to the table
    `limbs`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随*select*调用确认我们的更改已应用于表`limbs`。
- en: '[![7](Images/7.png)](#co_jst_delete_co)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](Images/7.png)](#co_jst_delete_co)'
- en: Then we figured out that cats and dogs are not always friends with each other
    and removed a cat from the table with method *delete*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现猫和狗并不总是彼此的朋友，于是用*delete*方法从桌子上移除了一只猫。
- en: '[![8](Images/8.png)](#co_jst_count2_co)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](Images/8.png)](#co_jst_count2_co)'
- en: Confirm that the cat was successfully removed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 确认猫已成功移除。
- en: '[![9](Images/9.png)](#co_jst_rollback_co)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](Images/9.png)](#co_jst_rollback_co)'
- en: Roll back the transaction to restore the table to its initial state.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚事务以将表恢复到初始状态。
- en: '[![10](Images/10.png)](#co_jst_confirm_co)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](Images/10.png)](#co_jst_confirm_co)'
- en: Methods *count* and *select* confirm that the table is in its initial state.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*count*和*select*确认表处于初始状态。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Since we executed all statements one-by-one in the interactive session we ommitted
    method *execute*. This method required if you are executing SQL commands in loops
    or program scripts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在交互式会话中逐条执行了所有语句，我们省略了*execute*方法。如果您在循环或程序脚本中执行SQL命令，则需要该方法。
- en: See Also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about how to work with tables in JavaScript mode,
    see [User Reference Manual for the object `Table`](https://dev.mysql.com/doc/dev/mysqlsh-api-javascript/8.0/classmysqlsh_1_1mysqlx_1_1_table.html).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在JavaScript模式下处理表的更多信息，请参见[对象`Table`的用户参考手册](https://dev.mysql.com/doc/dev/mysqlsh-api-javascript/8.0/classmysqlsh_1_1mysqlx_1_1_table.html)。
- en: 2.8 Working with Tables in Python Mode
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.8在Python模式下处理表
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have tables in your database and want to work with them in Python mode.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据库中有表格，并希望在 Python 模式下使用它们。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the method *get_table* to get the Table object, then the methods *select*,
    *count*, *insert*, *update*, *delete* to select, retrieve number of rows, insert,
    update or delete from the table.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法 *get_table* 获取表对象，然后使用方法 *select*、*count*、*insert*、*update*、*delete* 来从表中选择、检索行数、插入、更新或删除。
- en: Discussion
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Like JavaScript, Python supports working with tables in object-oriented style.
    Thus, to select all rows from the table `movies` try method *select* of the class
    `Table`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 像 JavaScript 一样，Python 支持以面向对象的方式处理表格。因此，要从表 `movies` 中选择所有行，请尝试类 `Table` 的方法
    *select*：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example we used the method *get_schema* that allows us to select any
    schema stored in the database to which the session user has been granted access.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了方法 *get_schema*，允许我们选择数据库中存储的任何模式。
- en: Python mode supports methods, allowing to modify data in the tables as well
    as transaction statements.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Python 模式支持方法，允许修改表中的数据以及事务语句。
- en: 'For our examples we will save tables `movies` and `movies_actors` into the
    variables first:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的示例，我们将表 `movies` 和 `movies_actors` 保存到变量中：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we will open a transaction, so our changes will appy either to both tables
    or to none at all, and we will insert a movie *“Darkest Hour”* starring Gary Oldman.
    Finally, we will commit the transaction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开启一个事务，以便我们的更改将应用到两个表或完全不应用，然后我们将插入一部由 Gary Oldman 主演的电影 *“最黑暗的时刻”*。最后，我们会提交事务：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To find all movies, starring Gary Oldman, we will use SQL query, because X
    API does not support joins:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出所有由 Gary Oldman 主演的电影，我们将使用 SQL 查询，因为 X API 不支持连接：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Oops! The year for the movie *“Darkest Hour”* is not correct in one of tables.
    Let’s update it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！电影 *“最黑暗的时刻”* 的年份在一个表中不正确。让我们更新它：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](Images/1.png)](#co_pyt_begin_co)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_pyt_begin_co)'
- en: Start a transaction, so we update either all tables, or no tables.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个事务，以便我们要么更新所有表，要么不更新任何表。
- en: '[![2](Images/2.png)](#co_pyt_update_movies_co)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_pyt_update_movies_co)'
- en: Update table `movies`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 更新表 `movies`。
- en: '[![3](Images/3.png)](#co_pyt_update_movies_actors_co)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_pyt_update_movies_actors_co)'
- en: Update table `movies_actors`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 更新表 `movies_actors`。
- en: '[![4](Images/4.png)](#co_pyt_commit_co)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_pyt_commit_co)'
- en: Commit the changes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改。
- en: '[![5](Images/5.png)](#co_pyt_confirm_co)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_pyt_confirm_co)'
- en: Confirm that the changes were applied to the table.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 确认更改已应用到表格。
- en: 'If we want to remove our newly inserted movie we can use method *delete*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除我们新插入的电影，我们可以使用方法 *delete*：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example we also started transaction first, then called method *delete*
    on two tables and, finally, committed the transaction.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先启动了事务，然后在两个表上调用了方法 *delete*，最后提交了事务。
- en: See Also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about accessing tables in object-oriented style while
    in Python mode, see interactive help of the MySQL Shell that could be invoked
    by a command *\?*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 Python 模式下以面向对象的方式访问表格的更多信息，请参阅 MySQL Shell 的交互式帮助，可以通过命令 *\?* 调用。
- en: 2.9 Working with Collections in JavaScript Mode
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.9 在 JavaScript 模式下使用集合
- en: Problem
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have semi-structured data and want to use MySQL as a Document Store. You
    also want to query your data with NoSQL, without leaving programming style of
    your preferred language.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您有半结构化数据，并希望将 MySQL 用作文档存储。您还希望使用 NoSQL 查询数据，同时不离开您喜欢的编程语言的编程风格。
- en: Solution
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `Collection` object and its methods.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Collection` 对象及其方法。
- en: Discussion
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'MySQL supports not only SQL syntax, but also NoSQL. When you use SQL you query
    tables and when you use NoSQL you query collections. Physically such collections
    are stored in tables that have three columns: generated unique identifier that
    is also a primary key, a `JSON` column that stores the document and an internal
    column that stores JSON schema. You can create a collection by using the method
    *createCollection* of the class `Schema`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 不仅支持 SQL 语法，还支持 NoSQL。当您使用 SQL 时，您查询表格；当您使用 NoSQL 时，您查询集合。这些集合在物理上存储在具有三列的表格中：生成的唯一标识符，也是主键，一个存储文档的
    `JSON` 列，以及一个存储 JSON 模式的内部列。您可以通过使用类 `Schema` 的方法 *createCollection* 来创建集合：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code above creates NoSQL collection `CollectionLimbs`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了 NoSQL 集合 `CollectionLimbs`。
- en: 'Collections support schema validation. There is no method to add a schema validation
    for the existent collection, but we can add schema when creating the collection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 集合支持模式验证。虽然没有方法可以为现有集合添加模式验证，但我们可以在创建集合时添加模式：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once NoSQL collection is created you can insert, update, delete and search documents.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了NoSQL集合，您可以插入、更新、删除和搜索文档。
- en: 'For example, to insert documents from the table `limbs` into collection `CollectionLimbs`
    we can use the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将表`limbs`中的文档插入到集合`CollectionLimbs`中，可以使用以下代码：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](Images/1.png)](#co_jsc_select_co)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_jsc_select_co)'
- en: Select all rows from the table `limbs`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从表`limbs`中选择所有行。
- en: '[![2](Images/2.png)](#co_jsc_fetch_co)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_jsc_fetch_co)'
- en: Method *fetchOneObject* returns a dictionary object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*fetchOneObject*返回一个字典对象。
- en: '[![3](Images/3.png)](#co_jsc_convert_co)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_jsc_convert_co)'
- en: A dictionary object cannot be saved in the collection without converting it
    to the proper JSON object. Therefore we converted it into JSON string first, then
    created an expression out of this string that could be inserted into the collection.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字典对象如果没有转换为适当的JSON对象就无法保存在集合中。因此，我们先将其转换为JSON字符串，然后创建一个表达式，可以将其插入到集合中。
- en: '[![4](Images/4.png)](#co_jsc_add_co)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_jsc_add_co)'
- en: Method *add* inserts a document into the collection.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*add*将文档插入集合中。
- en: '[![5](Images/5.png)](#co_jsc_execute_co)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_jsc_execute_co)'
- en: Method *execute* is required all the time when we update a database inside script
    blocks.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本块内更新数据库时，始终需要*execute*方法。
- en: We enclosed the code into curly braces, because otherwise, if code put on the
    multiple lines, MySQL Shell will output result of *session.getCurrentSchema().getTable('limbs').select().execute()*
    and variable `limbs` will contain only diagnostic message about the number of
    rows affected.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用花括号括起代码，因为如果代码跨多行放置，MySQL Shell将输出*session.getCurrentSchema().getTable('limbs').select().execute()*的结果，并且变量`limbs`只包含关于受影响行数的诊断消息。
- en: 'Finally, we can examine data, just inserted into the collection `CollectionLimbs`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查刚刚插入到集合`CollectionLimbs`中的数据：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can also modify and remove documents from your collections. We will show
    examples on how to do it in [Recipe 2.10](#nch-mysqlshell-mysqlshell-python-collections)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以修改和删除集合中的文档。我们将展示如何在[Recipe 2.10](#nch-mysqlshell-mysqlshell-python-collections)中执行此操作的示例。
- en: See Also
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about how to use MySQL with JSON documents and NoSQL,
    see [Chapter 19](ch19.xhtml#nch-json).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用JSON文档和NoSQL与MySQL的更多信息，请参阅[第19章](ch19.xhtml#nch-json)。
- en: 2.10 Working with Collections in Python Mode
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.10 在Python模式下使用集合
- en: Problem
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use DocumentStore and NoSQL in Python mode.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要在Python模式下使用DocumentStore和NoSQL。
- en: Solution
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `Collection` object and its methods.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Collection`对象及其方法。
- en: Discussion
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Just as you can do in the JavaScript mode, you can also work with NoSQL in Python
    mode. Syntax is also similar to JavaScript mode. However, method names follow
    naming style, recommended for the programs, written in Python.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以在JavaScript模式中做的那样，您也可以在Python模式中处理NoSQL。语法也类似于JavaScript模式。但是，方法名称遵循推荐用于Python编写的程序的命名风格。
- en: 'Thus, to assign a collection to a variable use method *get_collection* of the
    class `Schema`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将集合分配给变量，请使用类`Schema`的*get_collection*方法：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To select documents use method *find*:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择文档，请使用*find*方法：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Method *find* supports arguments, allowing to search for specific documents,
    similarly to the syntax of the clause `WHERE` in SQL. It also allows to aggregate
    results, sort them and select specific fields. It does not support joining of
    the collections.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*find*支持参数，允许按照类似SQL中`WHERE`子句的语法搜索特定文档。它还允许聚合结果、排序和选择特定字段。它不支持集合的连接。
- en: 'To insert a new document use method *add*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入新文档，请使用*add*方法：
- en: '[PRE43]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To modify existing row use either method *add_or_replace_one* or *modify*:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改现有行，请使用*add_or_replace_one*或*modify*方法之一：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Method *add_or_replace_one* takes document `_id` as the first parameter and
    a JSON document as the second one. If a document with specified `_id` is not found,
    it inserts new document. If found: replaces existing one.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*add_or_replace_one*将文档`_id`作为第一个参数，JSON文档作为第二个参数。如果找不到指定`_id`的文档，则插入新文档。如果找到，则替换现有文档。
- en: 'Method *modify* takes a search condition as an argument and returns an object
    of the class `CollectionModify` that supports methods, allowing to modify parameters
    such as *set*. You can chain calls to method `set` as many times as needed:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 方法*modify*以搜索条件作为参数，并返回一个支持方法的`CollectionModify`类对象，允许修改参数如*set*。您可以链式调用方法`set`，按需调用多次：
- en: '[PRE45]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To check if we successfully changed quantity of arms and legs for the newly
    inserted documents `cat` and `dog` we can use method *find*:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否成功更改了新插入文档 `cat` 和 `dog` 的手臂和腿的数量，可以使用 *find* 方法：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Method *remove* deletes documents from the collection:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 *remove* 从集合中删除文档：
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Method *remove* supports searching condition similarly to the *modify* and *find*
    methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 *remove* 支持与 *modify* 和 *find* 方法类似的搜索条件。
- en: See Also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For additional information about using MySQL with JSON documents and NoSQL,
    see [Chapter 19](ch19.xhtml#nch-json).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在 MySQL 中使用 JSON 文档和 NoSQL 的更多信息，请参见 [第 19 章](ch19.xhtml#nch-json)。
- en: 2.11 Controlling the Output Format
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.11 控制输出格式
- en: Problem
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to print results in a format, different from the default.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以与默认格式不同的格式打印结果。
- en: Solution
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the configuration option `resultFormat`, or the command-line parameters
    `--result-format`, `--table`, `--tabbed`, `--vertical`, or `--json`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置选项 `resultFormat` 或命令行参数 `--result-format`、`--table`、`--tabbed`、`--vertical`
    或 `--json`。
- en: Discussion
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: By default MySQL Shell prints result in a table format, similar to the default
    one of the *mysql* client. However, this format could be customized.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MySQL Shell 以类似于 *mysql* 客户端的默认表格式打印结果。但是，此格式可以进行自定义。
- en: Inside MySQL Shell you can do it with help of the command *\option* or the method
    *set* of the `shell.options` member of the class `Shell`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL Shell 内，您可以借助命令 *\option* 或 `Shell` 类的 `shell.options` 成员的 *set* 方法来完成。
- en: 'Thus, to print content of the table `artist` in tabbed format run:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要以制表符格式打印表 `artist` 的内容，请运行：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To switch to the vertical format run:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到垂直格式，请运行：
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'JSON format supports few options. By default, if the value of the option `resultFormat`
    is set to `json` or MySQL Shell started with option `--json` it is same as `json/pretty`
    or `--json=pretty` that means that the result printed as a JSON, formatted for
    better readability:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 格式支持少量选项。默认情况下，如果选项 `resultFormat` 的值设置为 `json` 或 MySQL Shell 使用选项 `--json`
    启动，它等同于 `json/pretty` 或 `--json=pretty`，这意味着结果以 JSON 格式输出，格式化以提高可读性：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Options `ndjson`, `json/raw` or `--json=raw` produce more compact raw JSON output.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `ndjson`，`json/raw` 或 `--json=raw` 生成更紧凑的原始 JSON 输出。
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Option `json/array` represents result as an array of JSON documents.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `json/array` 将结果表示为 JSON 文档数组。
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: That could be especially useful if selecting the data from the command line
    and later passing it to another program.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从命令行选择数据并稍后将其传递给另一个程序，则这将特别有用。
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the code above we started *mysqlsh* with the option `-i` that enables interative
    mode, so MySQL Shell behaves like if it was run interactively and option `--quiet-start=2`
    that disables all welcome messages. Then we set option `--result-format` to `json/array`
    to enable JSON array output, used option `--execute` to select from the table
    `artist` and passed output to the *jq* command that removed all metadata information
    and printed only names of artists.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用选项 `-i` 启动了 *mysqlsh*，启用了交互模式，因此 MySQL Shell 的行为类似于交互式运行，并使用选项 `--quiet-start=2`
    禁用了所有欢迎消息。然后我们将选项 `--result-format` 设置为 `json/array` 以启用 JSON 数组输出，使用选项 `--execute`
    从表 `artist` 中选择，并将输出传递给 *jq* 命令，该命令删除了所有元数据信息并仅打印了艺术家的名称。
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Command *head -n -1* removes last line from the result that shows number of
    rows, returned by the method *select*. Note that specifying negative number as
    a command *head -n* parameter may not work everywhere. If you or on such a system
    you can ignore error message that the command *jq* will print or redirect it somewhere
    else:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 *head -n -1* 从结果中删除显示 *select* 方法返回的行数的最后一行。请注意，指定负数作为 *head -n* 参数的命令可能无法在所有系统上正常工作。如果您在此类系统上，可以忽略
    *jq* 命令将打印的错误消息或将其重定向到其他地方：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When JSON wrapping is enabled at the MySQL Shell startup with option `--json[=pretty|raw]`
    it will also print diagnostic information in the resulting JSON output.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 MySQL Shell 启动时启用 JSON 包装并使用选项 `--json[=pretty|raw]` 时，它还将在生成的 JSON 输出中打印诊断信息。
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you enabled JSON output using command-line option `--result-format=json[/pretty|/raw|/array]`
    this additional information is not printed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用命令行选项 `--result-format=json[/pretty|/raw|/array]` 启用了 JSON 输出，则不会打印此额外信息。
- en: All output formats are independent from how you select data and available in
    all modes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 所有输出格式与数据选择方式无关，并且在所有模式下均可用。
- en: See Also
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For additional information about MySQL Shell output formats, see [MySQL User
    Reference Manual](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-output-formats.html).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 MySQL Shell 输出格式的更多信息，请参见 [MySQL 用户参考手册](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-output-formats.html)。
- en: 2.12 Running Reports with MySQL Shell
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.12 使用 MySQL Shell 运行报告
- en: Problem
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run periodic reports.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定期生成报告。
- en: Solution
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the commands *\show* and *\watch*.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 *\show* 和 *\watch*。
- en: Discussion
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: MySQL Shell commands *\show* and *\watch* execute reports, both built-in and
    user-defined. *\show* executes a report once while *\watch* runs the report continiously,
    until interrupted.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 命令 *\show* 和 *\watch* 执行报告，包括内置和用户定义的。*\show* 一次执行报告，而 *\watch*
    持续运行报告，直到被中断。
- en: Report is a pre-defined sequence of commands. Reports may support arguments.
    For example, the built-in report `query` takes SQL query as an argument. Built-in
    report `thread` reports details about a specific thread. By default it reports
    details about the current thead.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 报告是一系列预定义的命令。报告可能支持参数。例如，内置报告 `query` 接受 SQL 查询作为参数。内置报告 `thread` 报告特定线程的详细信息。默认情况下，它报告当前线程的详细信息。
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Warning
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Built-in report `thread` queries tables in `performance_schema` and `sys`, therefore
    you should connect as a user that has `SELECT` privilege on `performance_schema`
    and `sys` schemas and `EXECUTE` privilege on `sys` schema. Otherwise the report
    will fail with an <q>Access denied</q> error.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 内置报告 `thread` 查询 `performance_schema` 和 `sys` 中的表，因此您应作为具有 `performance_schema`
    和 `sys` 模式上的 `SELECT` 权限以及 `sys` 模式上的 `EXECUTE` 权限的用户连接。否则，报告将因为 <q>拒绝访问</q> 错误而失败。
- en: But report `thread` supports arguments, so you can specify, for example, `Connection
    ID` of the thread and output information about the specific one.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但是报告 `thread` 支持参数，因此您可以指定例如线程的 `Connection ID` 并输出关于特定线程的信息。
- en: '[PRE57]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The output of the `thread` report is similar to the stdandard `PROCESSLIST`
    output, but contains additional information, such as `Transaction state` and `Previous
    statement`. The latter could be especially useful when you are figuring out what
    is preventing your transaction from finishing. For example, if one of the transactions
    runs in multiple statements and locks a record, it may cause other transactions
    to wait until the lock is released. But since the statement was already executed
    it would not be visible in the regular `PROCESSLIST` output.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread` 报告的输出类似于标准的 `PROCESSLIST` 输出，但包含额外的信息，如 `Transaction state` 和 `Previous
    statement`。当您试图弄清楚是什么阻止了您的事务完成时，后者尤其有用。例如，如果其中一个事务运行多个语句并锁定记录，它可能会导致其他事务等待直到锁被释放。但由于该语句已经执行，因此在常规的
    `PROCESSLIST` 输出中是看不到的。'
- en: Even more useful information could be found in the `threads` report that by
    default outputs information about all threads belong to the current user. It runs
    the MySQL Shell session, but can print information about all the threads running
    on the server and also fiter them and define output format.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在 `threads` 报告中也可以找到更多有用的信息，默认情况下输出当前用户所属的所有线程的信息。它运行 MySQL Shell 会话，但可以打印服务器上所有线程的信息，并且可以过滤它们并定义输出格式。
- en: For example, to find all blocked and blocking transactions you can define option
    `--where "nblocked > 0 or nblocking > 0"`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查找所有被阻塞和阻塞事务，可以定义选项 `--where "nblocked > 0 or nblocking > 0"`。
- en: '[PRE58]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Thus in the example above thread with `Connection ID 3268` is trying to execute
    an update
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上面的示例中，具有 `Connection ID 3268` 的线程正在尝试执行更新操作。
- en: '[PRE59]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ', but is blocked by another transcation. Otherwise, the thread with `Connection
    ID 1386` is not executing anything, but blocks a thread. Its previous statement
    was'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ，但受到另一个事务的阻塞。否则，具有 `Connection ID 1386` 的线程没有执行任何操作，但阻止了一个线程。它的上一个语句是
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: that blocks all rows in the table `adcount` for writing. This way we easily
    found why the *UPDATE* in the connection 3268 cannot finish at the moment.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止写入表 `adcount` 中的所有行。这样，我们很容易找到为什么连接 3268 中的 *UPDATE* 目前无法完成的原因。
- en: The report *threads* has more options. You can find all of them if run *\show*
    command with the report name, followed by the option `--help`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 报告 *threads* 具有更多选项。如果使用报告名称运行 *\show* 命令，然后跟随选项 `--help`，您可以找到它们的所有内容。
- en: '[PRE61]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: All MySQL Shell commands support help options. For built-in commands run *\?
    COMMAND*, *\help COMMAND* or *\h COMMAND*. For commands with parameters additionally
    try option *--help*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 MySQL Shell 命令都支持帮助选项。对于内置命令，运行 *\? COMMAND*，*\help COMMAND* 或 *\h COMMAND*。对于带参数的命令，另外尝试选项
    *--help*。
- en: 'Command *\watch* not only executes report, but does it repeatedly, with certain
    intervals. It could be very useful when you want to watch changes of the certain
    parameter. For example, to watch number of internal temporary tables, created
    to resolve queries, run command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 *\watch* 不仅执行报告，还会以一定间隔重复执行。当您想要监视某个参数的变化时，它非常有用。例如，要监视解析查询创建的内部临时表的数量，请运行以下命令：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The query uses operator `LIKE` and patterns to much names of two system variables.
    We discuss how operator `LIKE` works and matches patterns at [Recipe 7.10](ch07.xhtml#nch-strings-strings-pat-sql)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 查询使用 `LIKE` 运算符和模式来匹配两个系统变量的名称。我们讨论了 `LIKE` 运算符如何工作，并在[Recipe 7.10](ch07.xhtml#nch-strings-strings-pat-sql)中讨论了如何匹配模式。
- en: The query runs with a default interval 2 seconds. The parameter `--nocls` instructs
    the command to not clear the screen before printing the latest result. To stop
    watching issue termination command *Ctrl+C*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 查询默认间隔为 2 秒。参数 `--nocls` 指示命令在打印最新结果之前不清除屏幕。要停止监视，请发出终止命令 *Ctrl+C*。
- en: Tip
  id: totrans-357
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 2.13 Using MySQL Shell Utilities
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.13 使用 MySQL Shell 实用工具
- en: Problem
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use MySQL Shell utilities.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要使用 MySQL Shell 实用工具。
- en: Solution
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'In JavaScript or Python modes: use the methods of the global `util` object
    interactively or pass the method via the command line.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 或 Python 模式中：可以通过交互方式使用全局 `util` 对象的方法，或通过命令行传递方法。
- en: Discussion
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: MySQL Shell comes with a number of the built-in utilities that allows you to
    perform common adminstrative tasks, such as checking if your MySQL Server could
    be safely updated to the new version or making a reserve copy of the data. These
    utilities could be called as methods of the global object `util` in JavaScript
    and Python modes or specified as a command line option.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 提供了多个内置实用工具，可用于执行常见的管理任务，例如检查您的 MySQL 服务器是否可以安全更新到新版本或备份数据。在 JavaScript
    和 Python 模式中，可以将这些实用工具作为全局对象 `util` 的方法调用，或作为命令行选项指定。
- en: To find out which utilities MySQL Shell supports run the command *\? util*.
    The names of methods are different in JavaScript and Python modes and follow naming
    best practices for each of languages. Global object `util` is not available in
    the SQL mode, as well as utilities.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 MySQL Shell 支持哪些实用工具，请运行命令 *\? util*。在 JavaScript 和 Python 模式下，方法的名称不同，并遵循各自语言的最佳实践命名。在
    SQL 模式中，全局对象 `util` 不可用，也无法使用实用程序。
- en: To figure out how one or another utility works use the help command with the
    name of the utility as an argument. For example, *\? checkForServerUpgrade* will
    print exhausted help for the upgrade checker utility in JavaScript mode. *\? dump_instance*
    will print detailed usage instructions for the utility that dumps the instance
    in Python mode.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解某个实用工具的工作原理，请使用带有实用工具名称作为参数的帮助命令。例如，*\? checkForServerUpgrade* 将在 JavaScript
    模式下打印升级检查实用程序的详尽帮助信息。*\? dump_instance* 将在 Python 模式下打印转储实用程序的详细用法说明。
- en: Calling utility methods is no different than calling any other method. For example,
    the following code exports table limbs into file `limbs.csv` in fully-quoted CSV
    format.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 调用实用程序方法与调用任何其他方法没有区别。例如，以下代码以完全引用的 CSV 格式将表 `limbs` 导出到文件 `limbs.csv` 中。
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You need to create directory `BACKUP/cookbook` before running this command or
    use different location.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此命令之前，您需要创建目录 `BACKUP/cookbook` 或使用其他位置。
- en: 'This Python code restores the table into the table limbs in the database test:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将 Python 代码恢复到数据库测试中的表 `limbs` 的示例：
- en: '[PRE64]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We omitted all but necessary options for the import example to make it shorter.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了导入示例中除了必要选项之外的所有内容，以缩短文本。
- en: 'In order to use *import_table* you need to be in the Classic protocol session.
    Otherwise the command will fail with an error:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *import_table*，您需要处于经典协议会话中。否则，命令将因错误而失败：
- en: '[PRE65]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Tip
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It is always good to read error messages, because they clearly show what is
    wrong and often contain instructions on how to fix the failure.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读错误消息总是很有帮助，因为它们清楚地显示了问题所在，并经常包含如何修复故障的说明。
- en: 'Another error you can hit is:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能遇到的错误是：
- en: '[PRE66]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To bypass this error enable `local_infile` option with the command:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要绕过此错误，请使用以下命令启用 `local_infile` 选项：
- en: '[PRE67]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Or leave this example until you get to the [Chapter 13](ch13.xhtml#nch-xfer)
    that covers export and import of the MySQL database objects.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等到你到达[第13章](ch13.xhtml#nch-xfer)，该章节涵盖了 MySQL 数据库对象的导出和导入。
- en: Tip
  id: totrans-382
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you do not understand what the utility is doing in these examples: do not
    worry. We will cover export and import of the MySQL database objects in [Chapter 13](ch13.xhtml#nch-xfer).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不理解这些示例中实用程序的作用：不要担心。我们将在[第13章](ch13.xhtml#nch-xfer)中涵盖MySQL数据库对象的导出和导入。
- en: 'If you want to run utilities without entering interactive mode you may specify
    them after the two dashes, following standard *mysqlsh* options:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在不进入交互模式的情况下运行实用程序，可以在两个破折号之后指定它们，遵循标准的 *mysqlsh* 选项：
- en: '[PRE68]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this example we first specified the command name, then added two dashes,
    followed by the global object name, the method we wanted to use, the connection
    string and, finally, the method arguments.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们首先指定了命令名称，然后添加了两个破折号，接着是全局对象名称、我们想要使用的方法、连接字符串，最后是方法参数。
- en: 'The command line uses the method names of either JavaScript mode Camel case
    syntax: *checkForServerUpgrade*, the Kebab case syntax: *check-for-server-upgrade*,
    or the Snake case syntax: *check_for_server_upgrade*. For more information on
    how to use global objects without entering interactive mode use command *\? cmdline*
    interactively.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行使用 JavaScript 模式的方法名，即驼峰命名法：*checkForServerUpgrade*，烤肉串命名法：*check-for-server-upgrade*，或蛇形命名法：*check_for_server_upgrade*。有关如何在不进入交互模式的情况下使用全局对象的更多信息，请交互式地使用命令
    *\? cmdline*。
- en: Tip
  id: totrans-388
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can use `--` syntax to call methods of other global objects on the command
    line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `--` 语法在命令行上调用其他全局对象的方法：
- en: '[PRE69]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: However, not all global objects are supported. Check *\? cmdline* for the list
    of supported objects.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，并非所有全局对象都受支持。在交互模式下使用命令 *\? cmdline* 查看支持的对象列表。
- en: See Also
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about MySQL Shell utilities, see [MySQL Shell Utilities](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities.html).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 MySQL Shell 实用程序的其他信息，请参阅[MySQL Shell 实用程序](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities.html)。
- en: 2.14 Using the Admin API to Automate Replication Management
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.14 使用 Admin API 自动化复制管理
- en: Problem
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to automate routine DBA tasks, such as deploying MySQL servers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要自动化例行的 DBA 任务，例如部署 MySQL 服务器。
- en: Solution
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use AdminAPI.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AdminAPI。
- en: Discussion
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'MySQL Shell supports not only the X Dev API for querying the database, but
    also the AdminAPI allowing you to manage InnoDB ReplicaSet and InnoDB Cluster.
    AdminAPI consists of three classes: `Dba`, `Cluster` and `ReplicaSet`.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 不仅支持 X Dev API 用于查询数据库，还支持 AdminAPI，允许您管理 InnoDB ReplicaSet 和 InnoDB
    Cluster。AdminAPI 由三个类组成：`Dba`、`Cluster` 和 `ReplicaSet`。
- en: AdminAPI is accessible from the global object `dba` of class `DBA`. It allows
    you to configure MySQL instances and start either a standalone sandbox, or ReplicaSet,
    or Cluster.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: AdminAPI 可从类为 `DBA` 的全局对象 `dba` 访问。它允许您配置 MySQL 实例并启动独立沙盒、复制集或集群。
- en: 'To configure a standalone sandbox use the method *deploySandboxInstance* in
    the JavaScript mode or *deploy_sandbox_instance* in Python mode. This method takes
    a port number and a dicitionary of parameters as arguments:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置独立的沙盒，请在 JavaScript 模式中使用 *deploySandboxInstance* 方法，或在 Python 模式中使用 *deploy_sandbox_instance*。此方法将一个端口号和一个参数字典作为参数：
- en: '[PRE70]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will create a sandbox instance with X port 13010 and enabled binary log
    with a name, starting from *cookbook*:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有名称、从 *cookbook* 开始的二进制日志已启用的沙盒实例，端口为 X 端口 13010：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To stop the instance use method *stopSandboxInstance* in JavaScript mode or
    *stop_sandbox_instance* in Python mode:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止实例，请在 JavaScript 模式下使用 *stopSandboxInstance* 方法，或在 Python 模式下使用 *stop_sandbox_instance*：
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To destroy the instance use method *deleteSandboxInstance* in JavaScript mode
    or *delete_sandbox_instance* in Python mode:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁实例，请在 JavaScript 模式下使用 *deleteSandboxInstance* 方法，或在 Python 模式下使用 *delete_sandbox_instance*：
- en: '[PRE73]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Global object `dba` is accessible from the command line:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象 `dba` 可从命令行访问：
- en: '[PRE74]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Global object `dba` is not available in SQL mode.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 模式下，全局对象 `dba` 不可用。
- en: See Also
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about using AdminApi to create and manage a ReplicaSet,
    see [Recipe 3.17](ch03.xhtml#nch-replication-replication-automation). For additional
    information about using AdminApi to create and manage InnoDB Cluster, see [“InnoDB
    Cluster”](ch03.xhtml#nch-replication-replication-automation-innodbcluster)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用 AdminApi 创建和管理 ReplicaSet 的其他信息，请参阅[食谱 3.17](ch03.xhtml#nch-replication-replication-automation)。有关使用
    AdminApi 创建和管理 InnoDB Cluster 的其他信息，请参阅[“InnoDB Cluster”](ch03.xhtml#nch-replication-replication-automation-innodbcluster)
- en: 2.15 Working with JavaScript Objects
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.15 使用 JavaScript 对象
- en: Problem
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to work with your documents as objects, and you want to modify them
    and store them in the database using own methods and properties.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将文档作为对象进行操作，并且希望使用自己的方法和属性修改它们，并将它们存储在数据库中。
- en: Solution
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create an object that will have all necessary methods to communicate with the
    database and use it as a prototype of your data objects.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个对象，该对象具有与数据库通信的所有必要方法，并将其用作数据对象的原型。
- en: Discussion
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'JavaScript is an object-oriented programming language and it is easy to create
    objects, modify them, and store them in the database. Sometimes it maybe easier
    to simply write *myObject.save()* instead of calling the full chain of methods
    of the X DevAPI Collection class. For example you may want to replace the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种面向对象的编程语言，您可以轻松创建对象、修改对象并将其存储在数据库中。有时，直接编写 *myObject.save()* 可能比调用完整的
    X DevAPI Collection 类方法链更简单。例如，您可能希望替换以下内容：
- en: '[PRE75]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: with single
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个
- en: '[PRE76]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: call.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 调用。
- en: JavaScript supports inheritance, therefore you can create an object that will
    have all necessary methods, working with the `Collection` class methods, and use
    it as a prototype of the object, containing your business logic.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 支持继承，因此您可以创建一个对象，该对象具有所有必要的方法，这些方法使用 `Collection` 类的方法，并将其用作包含业务逻辑的对象的原型。
- en: Let’s create as en example a `CookbookCollection` object that will have the
    methods *find*, *save* and *remove*. They will search for an object in the collection,
    save it after modification and remove from the database if necessary. The `CookbookCollection`
    object will also have a property `collection` that will store an object, representing
    collection where our object is stored.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `CookbookCollection` 的对象作为示例，它将具有 *find*、*save* 和 *remove* 方法。它们将在集合中搜索对象，在修改后保存它，并在必要时从数据库中删除。`CookbookCollection`
    对象还将具有一个名为 `collection` 的属性，用于存储表示存储我们对象的集合的对象。
- en: In order to make our methods very simple for clarity, we will not add error
    handling. You can add this functionality yourself. For example, if a user forgets
    to set a collection property, you can throw a custom exception or have a default
    collection that will be used instead. We are relying on JavaScript built-in exceptions.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的方法更简单以增加清晰度，我们不会添加错误处理。您可以自行添加此功能。例如，如果用户忘记设置集合属性，您可以抛出自定义异常或使用默认集合替代。我们依赖于
    JavaScript 内置异常。
- en: 'Let’s get started and create our object:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的对象：
- en: '[PRE77]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'First we define the property collection where the object is stored. We do not
    set the name of the collection here, because want our prototype to work with any
    collection:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义属性集合，存储对象。我们不在此处设置集合的名称，因为我们希望我们的原型可以与任何集合一起使用：
- en: '[PRE78]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Function *find* searches the collection using any search condition. It could
    be `''_id = "00006002f0650000000000000061"''` or `''thing="human"''`. In other
    words: any condition, that the method *Collection.find* accepts. Then we fetch
    one document and return it as a result. We intentionally did not add any unique
    check code or any other way to ensure that there is only one document, satisfying
    our condition, because wanted to make the example as simple as possible and have
    it working with any collection:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 *find* 使用任何搜索条件搜索集合。可以是 `'_id = "00006002f0650000000000000061"'` 或 `'thing="human"'`。换句话说，任何
    *Collection.find* 方法接受的条件。然后，我们获取一个文档并将其作为结果返回。我们故意没有添加任何唯一性检查代码或任何其他方式来确保只有一个满足我们条件的文档，因为我们希望尽可能简单地进行示例，并使其可以与任何集合一起使用：
- en: '[PRE79]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The method *save* stores the object in the database. If there is no `_id` field
    in the object that usually means that there is no such object yet in the database.
    So, we use the method *add* to insert it into the database and set the property
    `_id` of the object to the value, generated by MySQL. If such a property already
    exists that either means that such object is already in the database or we want
    to set `_id` explicitly. In this case we use method *addOrReplaceOne* that either
    adds new object with the specified unique identifier or replaces existing one:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 *save* 将对象存储在数据库中。如果对象中没有 `_id` 字段，通常意味着数据库中还没有此对象。因此，我们使用方法 *add* 将其插入到数据库中，并将对象的
    `_id` 属性设置为由 MySQL 生成的值。如果已经存在这样的属性，这意味着该对象已经在数据库中或者我们希望显式设置 `_id`。在这种情况下，我们使用方法
    *addOrReplaceOne*，它将添加具有指定唯一标识符的新对象或替换现有对象：
- en: '[PRE80]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The method *remove* deletes the record from the database and additionally deletes
    property `_id` of our object, so that, in case we want to store it in the database
    again, it will be considered as a new one and new unique identifier will be generated.
    We remove property `_id` from both prototype and the object.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*remove*方法从数据库中删除记录，并额外删除我们对象的属性`_id`，因此，如果我们想要再次将其存储在数据库中，它将被视为新的对象，并生成新的唯一标识符。我们从原型和对象中删除属性`_id`。'
- en: Let’s take the collection `CollectionLimbs` that we created in the [Recipe 2.9](#nch-mysqlshell-mysqlshell-js-collections)
    as an example. First, we retrieve it from the current `session` and set as a `collection`
    property of the `CookbookCollection` object.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们在[Recipe 2.9](#nch-mysqlshell-mysqlshell-js-collections)中创建的`CollectionLimbs`集合为例。首先，我们从当前的`session`中检索它，并将其设置为`CookbookCollection`对象的`collection`属性。
- en: '[PRE81]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Tip
  id: totrans-440
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'In [Recipe 2.9](#nch-mysqlshell-mysqlshell-js-collections) we rolled back all
    our modifications to the `CollectionLimbs`. If you continued your own experiments
    further before running examples in this recipe, execute:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Recipe 2.9](#nch-mysqlshell-mysqlshell-js-collections)中，我们回滚了所有对`CollectionLimbs`的修改。如果您在运行本章示例之前继续进行自己的实验，请执行：
- en: '[PRE82]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then let’s create an object `cat` with 2 arms and 2 legs:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们创建一个有两只手臂和两条腿的`cat`对象：
- en: '[PRE83]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To be able to store our cat in the database we need to assign object `CookbookCollection`
    as a prototype of the object `cat`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够将我们的猫存储在数据库中，我们需要将对象`CookbookCollection`指定为对象`cat`的原型：
- en: '[PRE84]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now we can save our object in the database:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的对象保存在数据库中：
- en: '[PRE85]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can check if we can retrieve such an object with method *find*:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查是否可以使用*find*方法检索这样的对象：
- en: '[PRE86]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can also confirm that our object now has `_id` property:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以确认我们的对象现在具有`_id`属性：
- en: '[PRE87]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Do you see anything wrong here? Yes! The cat has two arms and two legs while
    usually cats have no arms and four legs. Let’s fix it:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这里有什么问题吗？是的！这只猫有两只手臂和两条腿，而通常猫没有手臂而是四条腿。让我们修正一下：
- en: '[PRE88]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now our cat is in good shape.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的猫状态良好。
- en: 'If we want to clean up the collection and leave it in a state as it was before
    our experiments we can remove document `cat` from the database:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要清理集合并将其保留在我们的实验之前的状态，我们可以从数据库中删除文档`cat`：
- en: '[PRE89]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We may also notice that the property `cat._id` does not exist in our object
    anymore:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到`cat._id`属性在我们的对象中不再存在：
- en: '[PRE90]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: If we decide to store the object in the database again new unique identifier
    will be generated.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定再次将对象存储在数据库中，将生成新的唯一标识符。
- en: You will find `CookbookCollection` code in the file *mysql_shell/CookbookCollection.js*
    of the `recipes` distribution.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`recipes`分发中的文件*mysql_shell/CookbookCollection.js*中找到`CookbookCollection`的代码。
- en: 2.16 Filling Test Data Using Python’s Data Science Modules
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.16 使用Python的数据科学模块填充测试数据
- en: Problem
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to fill a test table with partially random data. For example, you need
    IDs to follow a sequence. You also want them to have realistic names and surnames.
    The rest of values in the table could be random, but index should have certain
    cardinality.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 您想用部分随机数据填充测试表。例如，您需要ID按顺序排列。您还希望它们具有真实的名字和姓氏。表中的其余值可以是随机的，但索引应具有特定的基数。
- en: Solution
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Script data population using Python and its specific data science modules.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python及其特定的数据科学模块进行脚本数据填充。
- en: Discussion
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: We often are in a situation when it is necessary to fill a table with fake data
    that mimics real world data for testing purposes. For example, when you develop
    an application and want to check what happens if the volume of data stored in
    it will increase. Or you hit a situation where a particular query works slow in
    production and you want to experiment on the test server, but do not want to copy
    production data due to security or performance reasons. This task may also be
    required when you want to ask third-party consultants for help.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常处于需要用模拟真实世界数据的假数据填充表格的情况。例如，当您开发一个应用程序并想要检查如果存储在其中的数据量增加会发生什么时。或者您遇到一个特定查询在生产中运行缓慢的情况，希望在测试服务器上进行实验，但不希望由于安全或性能原因复制生产数据。当您想要向第三方顾问寻求帮助时，可能还需要此任务。
- en: 'One such example is the table `patients` that we use in [Recipe 24.12](ch24.xhtml#nch-security-security-views).
    This is a table, storing patients records that spent more than one day in a hospital.
    It stores such data as national ID, name, surname, gender, diagnosis of the person
    and outcome, such as dates that this patient spent in the hospital and if they
    were recovered, checked out with same symphtoms or even died. You can find details
    if run *SHOW CREATE TABLE* command:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个示例是表`patients`，我们在[Recipe 24.12](ch24.xhtml#nch-security-security-views)中使用它。这是一张表，存储了在医院里待了一天以上的病人记录。它存储了国民身份证号、名字、姓氏、性别、人的诊断和结果，例如病人在医院里的停留日期以及他们是否康复、以相同症状退房，甚至死亡。如果你运行
    *SHOW CREATE TABLE* 命令，你可以找到详细信息：
- en: '[PRE91]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Of course, we could not even think about using real data for examples with this
    table. However, we still want to pretend that the data is real. For example, names
    and surnames should be ones that are popular. Like someone named John Doe or Ann
    Smith, genders should correspond to right names. E.g. John is, likely, a male
    and Ann is, likely, a female. Ages should fail in realistic range, departure date
    should be greater than the date when the patient arrived to the hospital, and
    it is unlikely that a patient would spend 10 years there. So we need a smart way
    to fill the table with fake values.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这张表的示例，我们不能想象使用真实数据。然而，我们仍然希望假装数据是真实的。例如，名字和姓氏应该是流行的名字，像一个叫 John Doe 或
    Ann Smith 的人，性别应该对应正确的名字。例如，John 很可能是男性，Ann 很可能是女性。年龄应该在合理的范围内，离开日期应该大于病人到达医院的日期，而一个病人在那里待上10年是不太可能的。因此，我们需要一种聪明的方法来填充表格的虚假值。
- en: Python is a programming language often used for data analysis and statistics.
    It has libraries, such as `pandas`, that help to manipulate with large data sets.
    It has convenient methods to read and generate data. This is why Python is one
    of the ideal ways to perform our task.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种常用于数据分析和统计的编程语言。它有像 `pandas` 这样的库，帮助操作大型数据集。它有方便的方法来读取和生成数据。这就是为什么
    Python 是执行我们任务的理想方式之一。
- en: To use module `pandas` in MySQL Shell you need to have it installed on your
    machine and add the path where the library is located, into MySQL Shell’s `sys.path`.
    Here are the steps that will help you to perform this task.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 MySQL Shell 中使用 `pandas` 模块，你需要在你的机器上安装它，并将库所在的路径添加到 MySQL Shell 的 `sys.path`
    中。以下是帮助你执行此任务的步骤。
- en: 'First check which version of Python MySQL Shell is running. In our case this
    is version 3.7.7:'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先检查 MySQL Shell 运行的 Python 版本。在我们的情况下，这是版本 3.7.7：
- en: '[PRE92]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'MySQL Shell does not come with *python* executable and *pip* that you can run
    from outside MySQL Shell. Therefore you need to install the same version as the
    MySQL Shell’s Python. We preferred to keep system-wide installed version 3.8.5
    untouched and install the same version which our MySQL Shell instance used: 3.7.7
    into a local directory from the source code. You may decide to have the same version
    system-wide.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL Shell 不带有 *python* 可执行文件和 *pip*，你不能在 MySQL Shell 外部运行它们。因此，你需要安装与 MySQL
    Shell 的 Python 版本相同的版本。我们选择保持系统范围内已安装的版本 3.8.5 不变，并从源代码安装与我们的 MySQL Shell 实例使用的相同版本
    3.7.7 到本地目录中。你可能决定在系统范围内使用相同的版本。
- en: 'Once the necessary version of Python is installed check where it stores its
    modules and add this directory to the `sys.path` of the MySQL Shell:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦安装了必要版本的 Python，请检查它存储模块的位置，并将此目录添加到 MySQL Shell 的 `sys.path` 中：
- en: '[PRE93]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Tip
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To avoid typing this command each time when you want to use modules that are
    not part of the MySQL Shell distribution, add this command to the Python mode
    configuration file. This file, by default, is located at `~/.mysqlsh/mysqlshrc.py`
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要避免每次想要使用不是 MySQL Shell 发行版的模块时都输入此命令，请将此命令添加到 Python 模式配置文件中。默认情况下，此文件位于 `~/.mysqlsh/mysqlshrc.py`。
- en: Install necessary packages. For our example we used `numpy`, `pandas`, `random`,
    `string` and `datetime`.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装必要的软件包。例如，我们使用了`numpy`、`pandas`、`random`、`string`和`datetime`。
- en: Once these prerequisites are met we are ready to fill our table with example
    data.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦满足这些先决条件，我们就准备好用示例数据填充我们的表格了。
- en: Data filling step-by-step
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逐步填充数据
- en: 'First, we need to import all necessary packages. Type the following in the
    MySQL Shell Python protocol session:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要导入所有必要的软件包。在 MySQL Shell 的 Python 协议会话中输入以下内容：
- en: '[PRE94]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Now we are ready to generate data.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备生成数据了。
- en: For names and surnames we decided to use real names found in the datasets, available
    on the Internet. You will find datasets we used, their licenses and distribution
    rights in the directory *datasets* of the `recipes` distribution. For diagnoses
    we also used publicly available data of the top 8 diagnosises with their frequency,
    and fake diagnose “Data Phobia” with even higher frequency. Data for genders is
    stored together with names. All other values are generated. We did not care if
    this data looks real. For example, we may end up with a 16-year-old patient dying
    from Alcoholic liver disease that will unlikely happen in real life, but for demonstrating
    purposes that should be enough. However, Python allows to solve such collisions.
    You may change our example, so it will create even more realistic data.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 对于姓名和姓氏，我们决定使用在数据集中找到的真实姓名，这些数据集可以在互联网上找到。您可以在`recipes`分发的*datasets*目录中找到我们使用的数据集、它们的许可和分发权利。对于诊断，我们还使用了公开可用的前8个诊断数据及其频率，以及虚假的诊断“数据恐惧症”，其频率更高。性别数据与姓名一起存储。所有其他值都是生成的。我们并不在乎这些数据看起来是否真实。例如，我们可能会得到一个16岁的患者死于酒精性肝病，这在现实生活中不太可能发生，但是为了演示目的，这应该足够了。然而，Python允许解决这类冲突。您可以更改我们的示例，以便创建更真实的数据。
- en: 'It is convenient to have a variable, defining the final number of rows in the
    table:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 定义最终表中行数的变量会很方便：
- en: '[PRE95]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Now, once we are ready, let’s discuss how we will process each of the table
    `patients` column.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们准备好了，让我们讨论一下我们将如何处理表`patients`的每一列。
- en: Names and genders
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名和性别
- en: 'Names and genders are stored in file `top-350-male-and-female-names-since-1848-2019-02-26.csv`
    in the following format:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名和性别存储在文件`top-350-male-and-female-names-since-1848-2019-02-26.csv`中，格式如下：
- en: '[PRE96]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: That means each row contains a rank from 1 to 350, one name that is traditionally
    female, and one name that is traditionally male of this rank and count of such
    names. We are not interested in the rank and count. We just need female and male
    names with gender information. Therefore we need to perform slight manipulation
    on this dataset after reading.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每一行包含一个排名从1到350的名字，一个传统上是女性的名字和一个传统上是男性的名字以及这些名字的数量。我们对排名和数量不感兴趣。我们只需要带有性别信息的女性和男性名字。因此，在读取此数据集后，我们需要对该数据集进行轻微的操作。
- en: 'First, we read the file using *read_csv* method of `pandas`. We will read the
    file twice: once for traditional female names and once for traditional male names.
    We will use only the `Female Name` column in the first attempt and only `Male
    Name` column in the second attempt. We will also rename this column, so it corresponds
    name of the column in our database:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`pandas`的*read_csv*方法读取文件。我们将读取文件两次：第一次是传统女性名字，第二次是传统男性名字。我们将仅在第一次尝试中使用`Female
    Name`列，并仅在第二次尝试中使用`Male Name`列。我们还将重命名此列，使其与我们数据库中的列名对应：
- en: '[PRE97]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Once done add a `gender` column to our datasets:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，向我们的数据集添加一个`gender`列：
- en: '[PRE98]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'And, finally, concatenate two datasets into one:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将两个数据集连接成一个：
- en: '[PRE99]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In order to read file `top-350-male-and-female-names-since-1848-2019-02-26.csv`
    it should be either in current working directory or you need to provide absolute
    path to this file. To find your current working directory, run:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取文件`top-350-male-and-female-names-since-1848-2019-02-26.csv`，它应该在当前工作目录中，或者您需要提供此文件的绝对路径。要找到当前工作目录，请运行：
- en: '[PRE100]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To change the working directory, run:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改工作目录，请运行：
- en: '[PRE101]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This will allow to read files, located in `/mysqlcookbook/recipes/datasets`.
    Adjust directory path to reflect your environment.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许读取位于`/mysqlcookbook/recipes/datasets`中的文件。调整目录路径以反映您的环境。
- en: Tip
  id: totrans-506
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Method `concat` of the Python module `pandas` works similarly to SQL `UNION`
    clause.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块`pandas`的方法`concat`类似于SQL的`UNION`子句。
- en: 'We can examine content of our dataset that uses `pandas` data structure `DataFrame`
    by typing its name:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过键入其名称来检查使用`pandas`数据结构`DataFrame`的数据集内容：
- en: '[PRE102]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Number of rows in the DataFrame is smaller than the number of rows we want to
    have in our table, so we need to generate more. We also want to shuffle the data,
    so we have random distribution of names. We will use method *sample* for this
    purpose. Since we are creating a set, larger than the initial one, we need to
    specify an option `replace=True`. We will also re-create index for the new DataFrame
    using method *pandas.Series*, so it will be ordered.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 数据帧中的行数少于我们在表中想要的行数，因此我们需要生成更多的行。我们还希望对数据进行洗牌，以获得姓名的随机分布。为此，我们将使用*sample*方法。由于我们正在创建一个比初始数据集更大的集合，因此我们需要指定选项`replace=True`。我们还将使用*pandas.Series*方法重新创建新数据帧的索引，使其有序。
- en: '[PRE103]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Surnames
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 姓氏
- en: 'For surnames we will use a dataset, stored in the file `Names_2010Census.csv`.
    It has multiple columns, such as a rank, the number of surnames and so on. But
    we are only interested in the first column: `name`. We also do not need last row
    of this file, containing a record for `ALL OTHER NAMES`. Surnames in this file
    are stored in uppercase. We could format them differently, but we decided to leave
    them as is. We will also rename column `name` to `surname`, so it is a same as
    in our table definition.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 对于姓氏，我们将使用存储在文件 `Names_2010Census.csv` 中的数据集。它有多列，如排名、姓氏数量等等。但我们只关心第一列：`name`。我们也不需要文件的最后一行，其中包含对
    `ALL OTHER NAMES` 的记录。该文件中的姓氏以大写字母存储。我们可以以不同的格式进行格式化，但我们决定保留原样。我们还将列 `name` 重命名为
    `surname`，以便与我们的表定义一致。
- en: '[PRE104]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '*pandas* prints a warning that it will use slower, but more powerful `python`
    engine to process the file, but this warning can be ignored.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '*pandas* 打印一个警告，它将使用更慢但更强大的 `python` 引擎来处理文件，但可以忽略这个警告。'
- en: We will shuffle surnames using the same method that we used for the names.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与姓名相同的方法对姓氏进行洗牌。
- en: '[PRE105]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Diagnoses
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断
- en: We manually prepared file `diagnosis.csv` that is just of 9 diagnosises, therefore
    we only need to read it and do not need to specify any option.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手动准备了文件 `diagnosis.csv`，仅包含9个诊断，因此我们只需要读取它，不需要指定任何选项。
- en: '[PRE106]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Diagnoses are different from the names and surnames, because they have different
    frequency and we want them distributed in our final dataset according to those
    frequencies. Therefore we will pass parameter `weights` to the method `sample`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断与姓名和姓氏不同，因为它们具有不同的频率，并且我们希望它们按照这些频率在我们的最终数据集中分布。因此，我们将向方法 `sample` 传递参数 `weights`。
- en: '[PRE107]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Results
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: 'Data type for results is `ENUM` that could contain only three possible values:
    `R` for recovered, `N` for not recovered and `D` for dead. We would not use any
    source for such results, but generate a DataFrame interactively.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的数据类型是 `ENUM`，只能包含三个可能的值：`R` 表示康复，`N` 表示未康复，`D` 表示死亡。我们不会使用任何来源来获取这样的结果，而是交互式地生成一个
    DataFrame。
- en: '[PRE108]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We added a frequency to our results. These frequencies have nothing to do with
    reality: we only need them to distribute our results differently.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的结果添加了频率。这些频率与现实无关：我们只需要它们以不同的方式分配我们的结果。
- en: Since we have a frequency for our results we will generate the data set similarly
    like we did for diagnosises.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有结果的频率，我们将生成类似于我们对诊断进行的方式的数据集。
- en: '[PRE109]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The table
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 表
- en: Our main datasets are prepared. Now we can start inserting rows into the table
    one-by-one.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已准备好主要数据集。现在我们可以逐行将行插入表中。
- en: First, let’s retrieve a `Table` object, so we can query it comfortably.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检索一个 `Table` 对象，以便可以舒适地查询它。
- en: '[PRE110]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Then start the loop
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 然后开始循环
- en: '[PRE111]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: All subsequent generations will be proceeded in the loop.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后续的生成将在循环中进行。
- en: National ID
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 国家 ID
- en: 'Format of the national ID can vary between countries and we simply need something
    unique that can follow some pattern. We decided to use format of two digits, followed
    by two uppercase letters and followed by six digits. To generate random digits
    we will use method *randrange* of the module `random` and to generate letters
    we will use method *sample* from the module `random`. We will use pre-defined
    set `string.ascii_uppercase` as a dataset to sample. Then we will join generated
    array to empty string, so it will create a string:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 国家 ID 的格式可以在国家之间有所不同，我们只需要一些能够遵循某种模式的唯一内容。我们决定使用两位数字，后跟两个大写字母，然后是六位数字的格式。为了生成随机数字，我们将使用模块
    `random` 的 *randrange* 方法，并且为了生成字母，我们将使用模块 `random` 的 *sample* 方法。我们将使用预定义的集合
    `string.ascii_uppercase` 作为数据集来抽样。然后，我们将生成的数组连接到空字符串上，这样就会创建一个字符串：
- en: '[PRE112]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Age
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄
- en: 'For the age we will simpy choose a number between 15 and 99\. We would not
    care about frequency of ages or about how many of patients of certain age have
    a certain disease:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对于年龄，我们将简单地选择一个15到99之间的数字。我们不关心年龄频率或特定年龄患者有某种疾病的数量：
- en: '[PRE113]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Dates which a patient spent in the hospital
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 患者在医院中度过的日期
- en: 'For the `date_arrived` column we decided to just use any date in year 2020\.
    We can generate such a date by specifying a start date as January 1, 2020 and
    using method *timedelta*:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `date_arrived` 列，我们决定只使用2020年的任何日期。我们可以通过指定开始日期为2020年1月1日并使用 *timedelta*
    方法来生成这样的日期：
- en: '[PRE114]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'For the column `date_departed` we will use the same idea, but we will use `date_arrived`
    as a starting date and interval of two months:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `date_departed` 列，我们将使用相同的思路，但我们将使用 `date_arrived` 作为起始日期，并间隔两个月：
- en: '[PRE115]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This code creates values for `date_arrived` and `date_departed` as `datetime`
    Python objects that could not be inserted into MySQL table, therefore we need
    to convert them into string format:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将 `date_arrived` 和 `date_departed` 创建为无法插入到 MySQL 表中的 `datetime` Python 对象，因此我们需要将它们转换为字符串格式：
- en: '[PRE116]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Preparing the row
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 准备行
- en: 'We have values to be inserted into `i-`th row of our table into columns `national_id`,
    `age`, `date_arrived` and `date_departed`. But rest of the values are stored in
    `DataFrame`s of exactly desired number of rows size. We only need to retrieve
    specific row from the `DataFrame`:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有要插入到我们表的第 `i-` 行中的值，插入到 `national_id`、`age`、`date_arrived` 和 `date_departed`
    列中。但其余值存储在精确所需行数的 `DataFrame` 中。我们只需要从 `DataFrame` 中检索特定行：
- en: '[PRE117]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Inserting row into a table
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在表中插入行
- en: 'Now we are ready to insert a row into our table. We will use method *insert*
    of the class `Table` that we discussed in detail in [Recipe 2.8](#nch-mysqlshell-mysqlshell-python-tables):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将一行插入到我们的表中。我们将使用我们在[Recipe 2.8](#nch-mysqlshell-mysqlshell-python-tables)中详细讨论的
    `Table` 类的 *insert* 方法：
- en: '[PRE118]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Putting all together
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起
- en: It maybe convenient to define the code we just wrote as a function, so we can
    re-use it. Let’s create one, called *generate_patients_data*.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 或许将刚刚编写的代码定义为函数会更方便，这样我们就可以重复使用它。让我们创建一个名为 *generate_patients_data* 的函数。
- en: '[PRE119]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can check how it works by truncating table patients and then calling the
    function:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过截断 *patients* 表然后调用该函数来检查其工作方式：
- en: '[PRE120]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We can also store this function in a file and re-use it later. We will discuss
    re-using user code in [Recipe 2.17](#nch-mysqlshell-mysqlshell-reuse).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将此函数存储在文件中，并稍后重新使用它。我们将在[Recipe 2.17](#nch-mysqlshell-mysqlshell-reuse)中讨论如何重复使用用户代码。
- en: You will find code of the function *generate_patients_data* in file *mysql_shell/generate_patients_data.py*
    of the `recipes` distribution.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `recipes` 发行版的 *mysql_shell/generate_patients_data.py* 文件中找到 *generate_patients_data*
    函数的代码。
- en: See Also
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about Python module `pandas`, see [pandas documentation](https://pandas.pydata.org/pandas-docs/stable/index.html).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Python 模块 `pandas` 的更多信息，请参阅[pandas 文档](https://pandas.pydata.org/pandas-docs/stable/index.html)。
- en: 2.17 Reusing Your Scripts for MySQL Shell
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.17 重复使用您的 MySQL Shell 脚本
- en: Problem
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You wrote code for MySQL Shell and want to re-use it later.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写了 MySQL Shell 的代码，并希望以后能够重复使用。
- en: Solution
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Store your work, and later load the files using the command *\source*. Or, set
    up the files as startup scripts.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 存储您的工作，并稍后使用 *\source* 命令加载文件。或者，设置这些文件作为启动脚本。
- en: Discussion
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: MySQL Shell allows to re-use your code. You can do it either by using command
    *\source* or by setting your scripts to be executed at startup. Let’s examine
    each of these possibilities in detail.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell 允许您重新使用您的代码。您可以通过使用 *\source* 命令或将您的脚本设置为在启动时执行来实现。让我们详细检查每一种可能性。
- en: The command *\source* is available for each of modes and works similarly to
    the command *\source* of *mysql* client. The only difference is that your source
    files should be written in the same language as the selected mode.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '*\source* 命令适用于每种模式，并且与 *mysql* 客户端的 *\source* 命令类似工作。唯一的区别是，您的源文件应该与所选模式使用相同的语言编写。'
- en: 'For example, to load the object `CookbookCollection` that we discussed in [Recipe
    2.15](#nch-mysqlshell-mysqlshell-javascript), we can type this command:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要加载我们在[Recipe 2.15](#nch-mysqlshell-mysqlshell-javascript)中讨论的 `CookbookCollection`
    对象，可以输入以下命令：
- en: '[PRE121]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: As you see, it immediately becomes available for use.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，它立即可以用于使用。
- en: 'Similarly you can import the definition of the function *generate_patients_data*
    that we discussed in [Recipe 2.16](#nch-mysqlshell-mysqlshell-python):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以导入我们在[Recipe 2.16](#nch-mysqlshell-mysqlshell-python)中讨论的 *generate_patients_data*
    函数的定义：
- en: '[PRE122]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Or, in SQL mode, we can load any SQL file:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在 SQL 模式下，我们可以加载任何 SQL 文件：
- en: '[PRE123]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If you want to execute scripts at startup you need to edit file `mysqlshrc.js`
    for JavaScript mode and `mysqlshrc.py` for Python mode, located in one of the
    locations that MySQL Shell uses to search for the startup scripts. These can be
    located in any of the following:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在启动时执行脚本，您需要编辑 JavaScript 模式的 `mysqlshrc.js` 文件和 Python 模式的 `mysqlshrc.py`
    文件，这些文件位于 MySQL Shell 用于搜索启动脚本的位置之一。这些文件可以位于以下任一位置：
- en: The global configuration file, located in `/etc/mysql/mysqlsh/mysqlshrc.[js|py]`
    on Unix, or `%PROGRAMDATA%\MySQL\mysqlsh\mysqlshrc.[js|py]` on Windows.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局配置文件，位于 Unix 上的 `/etc/mysql/mysqlsh/mysqlshrc.[js|py]`，或者 Windows 上的 `%PROGRAMDATA%\MySQL\mysqlsh\mysqlshrc.[js|py]`。
- en: Your personal configuration file, located either under `$HOME/.mysqlsh/mysqlshrc.[js|py]`
    on Unix, or under `%APPDATA%\MySQL\mysqlsh\mysqlshrc.[js|py]` on Windows. Alternatively
    you can specify the variable `MYSQLSH_USER_CONFIG_HOME` and store file `mysqlshrc.[js|py]`
    under it.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的个人配置文件可以在Unix下的`$HOME/.mysqlsh/mysqlshrc.[js|py]`或Windows下的`%APPDATA%\MySQL\mysqlsh\mysqlshrc.[js|py]`找到。或者你可以指定变量`MYSQLSH_USER_CONFIG_HOME`并将文件`mysqlshrc.[js|py]`存储在其下。
- en: The `share/mysqlsh` directory, located either under MySQL Shell installation
    root or specified by the variable `MYSQLSH_HOME`.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录`share/mysqlsh`可以在MySQL Shell安装根目录下找到，或者通过变量`MYSQLSH_HOME`指定。
- en: 'Format of the `mysqlshrc.[js|py]` is the same as for the corresponding modes.
    Thus, to pre-load the `CookbookCollection` object, you need to convert `CookbookCollection.js`
    into a module by exporting our object `CookbookCollection`:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysqlshrc.[js|py]`的格式与相应模式相同。因此，为了预加载`CookbookCollection`对象，你需要将`CookbookCollection.js`转换为模块，并导出我们的对象`CookbookCollection`：'
- en: '[PRE124]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Then you need to put two lines in the file `mysqlshrc.js`:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要在文件`mysqlshrc.js`中加入两行：
- en: '[PRE125]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In the first line we added a directory where our modules are located into the
    modules search path. On the second line we imported the module itself. Object
    `CookbookCollection` is available as a property of the global object `cookbook`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将包含我们模块的目录添加到模块搜索路径中。在第二行，我们导入了模块本身。`CookbookCollection`对象作为全局对象`cookbook`的属性可用。
- en: '[PRE126]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Tip
  id: totrans-589
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: MySQL Shell uses Node.js modules. Use [Node.js documentation](https://nodejs.org/api/modules.html)
    to find details about how to write and use JavaScript modules in MySQL Shell.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Shell使用Node.js模块。参考[Node.js文档](https://nodejs.org/api/modules.html)了解如何在MySQL
    Shell中编写和使用JavaScript模块的详细信息。
- en: '*CookbookCollectionModule.js* is located in the *mysql_shell* directory of
    the `recipes` distribution.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*CookbookCollectionModule.js*位于`recipes`分发的*mysql_shell*目录中。'
- en: To import the Python function `generate_patients_data` in the startup script
    we need to add instruction *import mysqlsh* to our Python file, because at the
    time when the module is loaded, global objects of the MySQL Shell are not yet
    available. We will also change the line
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动脚本中导入Python函数`generate_patients_data`，我们需要在我们的Python文件中添加指令*import mysqlsh*，因为在加载模块时，MySQL
    Shell的全局对象尚不可用。我们还将更改该行：
- en: '[PRE127]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: to
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE128]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Otherwise Python will fail with an error that the name `session` is not yet
    defined.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 否则Python会因为尚未定义名称`session`而失败。
- en: We will name our module `cookbook.py` for brevity.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模块命名为`cookbook.py`以简洁明了起见。
- en: In our function we use local paths from the current directory to the files,
    therefore we will change the default search path to the directory that has all
    datasets in it. To do this we will import module `os` and use its method `chdir`.
    Then we simply import module `cookbook`. Resulting `mysqlshrc.py` will have this
    code.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数中，我们使用当前目录中的本地路径到文件，因此我们将更改默认搜索路径为包含所有数据集的目录。为此，我们将导入模块`os`并使用其方法`chdir`。然后我们简单地导入模块`cookbook`。生成的`mysqlshrc.py`将有此代码。
- en: '[PRE129]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Module *cookbook.py* is located in the *mysql_shell* directory of the `recipes`
    distribution.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 模块*cookbook.py*位于`recipes`分发的*mysql_shell*目录中。
- en: See Also
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about customizing MySQL Shell with external scripts,
    see [Customizing MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-customizing.html)
    in the MySQL User Reference Manual.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用外部脚本定制MySQL Shell的更多信息，请参阅MySQL用户参考手册中的[定制MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-customizing.html)。
