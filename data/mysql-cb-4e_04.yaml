- en: Chapter 4\. Writing MySQL-Based Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 写MySQL-Based程序
- en: 4.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.0 引言
- en: This chapter discusses how to use MySQL from within the context of a general-purpose
    programming language. It covers basic application programming interface (API)
    operations that are fundamental to and form the basis for the programming recipes
    developed in later chapters. These operations include connecting to the MySQL
    server, executing statements, and retrieving the results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何在通用编程语言的环境中使用MySQL。它涵盖了基本的应用程序编程接口（API）操作，这些操作是后续章节中开发编程示例的基础。这些操作包括连接到MySQL服务器、执行语句和检索结果。
- en: 'MySQL-based client programs can be written using many languages. This book
    covers the languages and interfaces shown in the [Table 4-1](#nch-api-api-intro-langs)
    (for information on obtaining the interface software, see the [Preface](preface01.xhtml#nch-preface)):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基于MySQL的客户端程序可以使用多种语言编写。本书涵盖了在[表 4-1](#nch-api-api-intro-langs)中显示的语言和接口（有关获取接口软件的信息，请参见[前言](preface01.xhtml#nch-preface)）：
- en: Table 4-1\. Languages and interfaces, covered in this book
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1 本书涵盖的语言和接口
- en: '| Language | Interface |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 接口 |'
- en: '| --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Perl | Perl DBI |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| Perl | Perl DBI |'
- en: '| Ruby | Mysql2 gem |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | Mysql2 gem |'
- en: '| PHP | PDO |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| PHP | PDO |'
- en: '| Python | DB API |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| Python | DB API |'
- en: '| Go | Go sql |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| Go | Go sql |'
- en: '| Java | JDBC |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| Java | JDBC |'
- en: 'MySQL client APIs provide the following capabilities, each covered in a section
    of this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL客户端API提供以下功能，本章的各节详细介绍了每个功能：
- en: Connecting to the MySQL server, selecting a database, and disconnecting from
    the server
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到MySQL服务器、选择数据库和断开与服务器的连接
- en: Every program that uses MySQL must first establish a connection to the server.
    Most programs also select a default database, and well-behaved MySQL programs
    close the connection to the server when they’re done with it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MySQL的每个程序必须首先与服务器建立连接。大多数程序还会选择一个默认数据库，并且表现良好的MySQL程序在完成后会关闭与服务器的连接。
- en: Checking for errors
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 检查错误
- en: Any database operation can fail. If you know how to find out when that occurs
    and why, you can take appropriate action such as terminating the program or informing
    the user of the problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据库操作都有可能失败。如果你知道何时发生以及原因，就可以采取适当的措施，比如终止程序或通知用户出现问题。
- en: Executing SQL statements and retrieving results
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 执行SQL语句和检索结果
- en: The point of connecting to a database server is to execute SQL statements. Each
    API provides at least one way to do this, as well as methods for processing statement
    results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库服务器的目的是执行SQL语句。每个API都至少提供一种执行此操作的方式，以及处理语句结果的方法。
- en: Handling special characters and `NULL` values in statements
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 处理语句中的特殊字符和`NULL`值
- en: Data values can be embedded directly in statement strings. However, some characters
    such as quotes and backslashes have special meaning, and their use requires certain
    precautions. The same is true for `NULL` values. If you handle these improperly,
    your programs will generate SQL statements that are erroneous or yield unexpected
    results. If you incorporate data from external sources into queries, your program
    might become subject to SQL injection attacks. Most APIs enable you to avoid these
    problems by using placeholders, which refer to data values symbolically in a statement
    to be executed and supply those values separately. The API inserts data into the
    statement string after properly encoding any special characters or `NULL` values.
    Placeholders are also known as parameter markers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据值可以直接嵌入到语句字符串中。然而，某些字符如引号和反斜杠具有特殊含义，使用它们需要采取特定的预防措施。对于`NULL`值也是如此。如果处理不当，你的程序将生成错误的SQL语句或产生意外结果。如果将来自外部来源的数据合并到查询中，你的程序可能会成为SQL注入攻击的目标。大多数API通过使用占位符来避免这些问题，占位符在执行语句时以符号方式引用数据值，并单独提供这些值。API将数据插入语句字符串中，正确编码任何特殊字符或`NULL`值。占位符也称为参数标记。
- en: Identifying `NULL` values in result sets
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果集中标识`NULL`值
- en: '`NULL` values are special not only when you construct statements, but also
    in results returned from them. Each API provides a convention for recognizing
    and dealing with them.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL`值不仅在构造语句时是特殊的，在返回的结果中也是如此。每个API都提供了一种识别和处理它们的约定。'
- en: No matter which programming language you use, it’s necessary to know how to
    perform each of the fundamental database API operations just described, so this
    chapter shows each operation in all five languages. Seeing how each API handles
    a given operation should help you see the correspondences between APIs more easily
    and better understand the recipes shown in the following chapters, even if they’re
    written in a language you don’t use much. (Later chapters usually implement recipes
    using only one or two languages.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种编程语言，都需要知道如何执行刚才描述的每个基本数据库API操作，因此本章展示了这五种语言中的每个操作。了解每个API如何处理给定操作应该有助于您更轻松地看到API之间的对应关系，并更好地理解接下来章节中显示的配方，即使它们是用您不太熟悉的语言编写的。（后续章节通常仅使用一种或两种语言实现配方。）
- en: It may seem overwhelming to see each recipe in several languages if your interest
    is in only one particular API. If so, we advise you to read just the introductory
    recipe part that provides the general background, then go directly to the section
    for the language in which you’re interested. Skip the other languages; should
    you develop an interest in them later, come back and read about them then.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对特定API的一个语言感兴趣，看到每个配方都用几种语言编写可能会让人感到不知所措。如果是这样，请建议您仅阅读提供一般背景信息的介绍性配方部分，然后直接转到您感兴趣的语言部分。跳过其他语言；如果以后对它们产生兴趣，请回来再了解它们。
- en: 'This chapter also discusses the following topics, which are not directly part
    of the MySQL APIs but help you use them more easily:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了以下几个主题，虽然它们不是MySQL API的直接组成部分，但有助于更轻松地使用它们：
- en: Writing library files
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 写作库文件
- en: As you write program after program, you find that you carry out certain operations
    repeatedly. Library files enable encapsulating code for those operations so they
    can be performed easily from multiple scripts without repeating the code in each
    one. This reduces code duplication and makes your programs more portable. This
    chapter shows how to write a library file for each API that includes a routine
    for connecting to the server—one operation that every program that uses MySQL
    must perform. Later chapters develop additional library routines for other operations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您编写程序，您会发现重复执行某些操作。库文件可以封装这些操作的代码，使其可以在多个脚本中轻松执行，而无需在每个脚本中重复编写代码。这减少了代码重复，并使您的程序更具可移植性。本章展示了如何为每个API编写库文件，其中包括用于连接到服务器的例行操作，这是每个使用MySQL的程序必须执行的操作之一。后续章节将为其他操作开发额外的库程序。
- en: Additional techniques for obtaining connection parameters
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 获取连接参数的其他技术
- en: An early section on establishing connections to the MySQL server relies on connection
    parameters hardwired into the code. However, there are other (and better) ways
    to obtain parameters, ranging from storing them in a separate file to enabling
    the user to specify them at runtime.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 早期关于连接到MySQL服务器的部分依赖于硬编码到代码中的连接参数。然而，还有其他（更好的）获取参数的方式，从将其存储在单独的文件中到允许用户在运行时指定。
- en: To avoid manually typing in the example programs, get a copy of the `recipes`
    source distribution (see the [Preface](preface01.xhtml#nch-preface)). Then, when
    an example says something like <q>create a file named *xyz* that contains the
    following information ...,</q> you can use the corresponding file from the `recipes`
    distribution. Most scripts for this chapter are located under the *api* directory;
    library files are located in the *lib* directory.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在示例程序中手动输入，获取`recipes`源代码分发的副本（参见[前言](preface01.xhtml#nch-preface)）。然后，当一个示例说“创建一个名为*xyz*的文件，其中包含以下信息…”时，你可以使用`recipes`分发中对应的文件。本章的大多数脚本位于*api*目录下；库文件位于*lib*目录下。
- en: The primary table used for examples in this chapter is named `profile`. It first
    appears in [Recipe 4.4](#nch-api-api-statement), which you should know in case
    you skip around in the chapter and wonder where it came from. See also the section
    at the very end of the chapter about resetting the `profile` table to a known
    state for use in other chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中用于示例的主要表格名为`profile`。它首次出现在[Recipe 4.4](#nch-api-api-statement)中，如果您跳转章节并想知道它来自哪里，请了解这一点。还请参阅本章末尾关于将`profile`表重置为已知状态以在其他章节中使用的部分。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The programs discussed here can be run from the command line. For instructions
    on invoking programs for each language covered here, read `cmdline.pdf` in the
    recipes distribution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的程序可以从命令行运行。有关如何调用本章涵盖的每种语言的程序的说明，请阅读`recipes`分发中的`cmdline.pdf`。
- en: Assumptions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设
- en: 'To use the material in this chapter most effectively, make sure to satisfy
    these requirements:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要最有效地使用本章的材料，请确保满足以下要求：
- en: Install MySQL programming support for any languages that you plan to use (see
    the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您计划使用的任何语言安装MySQL编程支持（请参阅[前言](preface01.xhtml#nch-preface)）。
- en: You should already have set up a MySQL user account for accessing the server
    and a database for executing SQL statements. As described in [Recipe 1.1](ch01.xhtml#nch-mysql-mysql-account),
    the examples in this book use a MySQL account that has a username and password
    of `cbuser` and `cbpass`, and we’ll connect to a MySQL server running on the local
    host to access a database named `cookbook`. To create the account or the database,
    see the instructions in that recipe.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该已经为访问服务器设置了一个MySQL用户帐户和一个用于执行SQL语句的数据库。如[食谱1.1](ch01.xhtml#nch-mysql-mysql-account)所述，本书中的示例使用的是一个MySQL帐户，用户名和密码分别为`cbuser`和`cbpass`，我们将连接到运行在本地主机上的MySQL服务器，以访问名为`cookbook`的数据库。要创建帐户或数据库，请参阅该食谱中的说明。
- en: The discussion here shows how to use each API language to perform database operations,
    but assumes a basic understanding of the language itself. If a recipe uses programming
    constructs with which you’re unfamiliar, consult a general reference for the language
    of interest.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此处的讨论展示了如何使用每种API语言执行数据库操作，但假定您对语言本身有基本的理解。如果某个食谱使用您不熟悉的编程构造，请查阅相关语言的通用参考书。
- en: Proper execution of some of the programs might require that you set certain
    environment variables. General syntax for doing so is covered in `cmdline.pdf`
    in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
    For details about environment variables that apply specifically to library file
    locations, see [Recipe 4.3](#nch-api-api-library).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些程序的正确执行可能需要您设置某些环境变量。关于如何设置环境变量的一般语法，请参阅配方分发中的`cmdline.pdf`（请参阅[前言](preface01.xhtml#nch-preface)）。有关专门适用于库文件位置的环境变量的详细信息，请参阅[食谱4.3](#nch-api-api-library)。
- en: MySQL Client API Architecture
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL客户端API架构
- en: 'Each MySQL programming interface covered in this book uses a two-level architecture:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖的每个MySQL编程接口都使用了两级架构：
- en: The upper level provides database-independent methods that implement database
    access in a portable way that’s the same whether you use MySQL, PostgreSQL, Oracle,
    or whatever.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上层提供了独立于数据库的方法，以便以与使用MySQL、PostgreSQL、Oracle或其他任何数据库相同的便携方式访问数据库。
- en: The lower level consists of a set of drivers, each of which implements the details
    for a single database system.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下层由一组驱动程序组成，每个驱动程序实现了单个数据库系统的详细信息。
- en: 'This two-level architecture enables application programs to use an abstract
    interface not tied to details specific to any particular database server. This
    enhances portability of your programs: to use a different database system, just
    select a different lower-level driver. However, perfect portability is elusive:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种两级架构使应用程序能够使用与任何特定数据库服务器的详细信息无关的抽象接口。这增强了程序的可移植性：要使用不同的数据库系统，只需选择不同的下层驱动程序。但是，完全的可移植性是难以实现的：
- en: The interface methods provided by the upper level of the architecture are consistent
    regardless of the driver you use, but it’s still possible to write SQL statements
    that use constructs supported only by a particular server. For example, MySQL
    has `SHOW` statements that provide information about database and table structure,
    but using `SHOW` with a non-MySQL server likely will produce an error.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论您使用哪个驱动程序，架构的上层提供的接口方法都是一致的，但仍然有可能编写只支持特定服务器的SQL语句。例如，MySQL具有`SHOW`语句，用于提供关于数据库和表结构的信息，但在非MySQL服务器上使用`SHOW`可能会导致错误。
- en: Lower-level drivers often extend the abstract interface to make it more convenient
    to access database-specific features. For example, the MySQL driver for Perl DBI
    makes the most recent `AUTO_INCREMENT` value available as a database handle attribute
    accessible as `$dbh->{mysql_insertid}`. Such features make a program easier to
    write, but less portable. To use the program with another database system will
    require some rewriting.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下层驱动程序经常扩展抽象接口，使访问数据库特定功能更方便。例如，Perl DBI的MySQL驱动程序可以将最新的`AUTO_INCREMENT`值作为数据库句柄属性`$dbh->{mysql_insertid}`提供。这些功能使程序更易于编写，但更不可移植。要将程序用于另一个数据库系统，可能需要进行一些重写。
- en: Despite these factors that compromise portability to some extent, the general
    portability characteristics of the two-level architecture provide significant
    benefits for MySQL developers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些因素在某种程度上影响可移植性，但两级架构的一般可移植特性为 MySQL 开发人员提供了显著的好处。
- en: Another characteristic common to the APIs used in this book is that they are
    object oriented. Whether you write in Perl, Ruby, PHP, Python, Java or Go, the
    operation that connects to the MySQL server returns an object that enables you
    to process statements in an object-oriented manner. For example, when you connect
    to the database server, you get a database connection object with which to further
    interact with the server. The interfaces also provide objects for statements,
    result sets, metadata, and so forth.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的 API 共同的另一个特点是它们是面向对象的。无论您使用 Perl、Ruby、PHP、Python、Java 还是 Go 编写代码，连接到
    MySQL 服务器的操作都会返回一个对象，使您能够以面向对象的方式处理语句。例如，当您连接到数据库服务器时，您会得到一个数据库连接对象，可以进一步与服务器交互。接口还提供语句、结果集、元数据等对象。
- en: 'Now let’s see how to use these programming interfaces to perform the most fundamental
    MySQL operations: connecting to and disconnecting from the server.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用这些编程接口执行最基本的 MySQL 操作：连接到服务器和断开连接。
- en: 4.1 Connecting, Selecting a Database, and Disconnecting
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 连接，选择数据库和断开连接
- en: Problem
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to establish a connection to the database server and shut down the
    connection when you’re done.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在连接到数据库服务器时建立连接，在完成后关闭连接。
- en: Solution
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Each API provides routines for connecting and disconnecting. The connection
    routines require that you provide parameters specifying the host on which the
    MySQL server is running and the MySQL account to use. You can also select a default
    database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 API 都提供了连接和断开连接的例程。连接例程要求您提供指定 MySQL 服务器运行的主机和要使用的 MySQL 帐户的参数。您还可以选择一个默认数据库。
- en: Discussion
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'This section shows how to perform some fundamental operations common to most
    MySQL programs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了执行大多数 MySQL 程序共同的一些基本操作的方法：
- en: Establishing a connection to the MySQL server
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 建立连接到 MySQL 服务器
- en: Every program that uses MySQL does this, no matter which API you use. The details
    on specifying connection parameters vary between APIs, and some APIs provide more
    flexibility than others. However, there are many common parameters, such as the
    host on which the server is running, and the username and password of the MySQL
    account to use for accessing the server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MySQL 的每个程序都要做到这一点，无论使用哪种 API。在指定连接参数方面的细节因 API 而异，有些 API 提供的灵活性更大。但是，有许多共同的参数，如运行服务器的主机，以及用于访问服务器的
    MySQL 帐户的用户名和密码。
- en: Selecting a database
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选择数据库
- en: Most MySQL programs select a default database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 MySQL 程序选择一个默认数据库。
- en: Disconnecting from the server
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器断开连接
- en: Each API provides a way to close an open connection. It’s best to do so as soon
    as you’re done using the server. If your program holds the connection open longer
    than necessary, the server cannot free up resources allocated to servicing the
    connection. It’s also preferable to close the connection explicitly. If a program
    simply terminates, the MySQL server eventually notices, but an explicit close
    on the user end enables the server to perform an immediate orderly close on its
    end.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 API 都提供了关闭打开连接的方法。最好在使用服务器后立即关闭连接。如果您的程序保持连接时间超过必要时间，服务器将无法释放为服务连接分配的资源。显式关闭连接也是首选。如果程序简单地终止，MySQL
    服务器最终会注意到，但用户端的显式关闭使服务器能够在其端执行立即有序的关闭。
- en: This section includes example programs that show how to use each API to connect
    to the server, select the `cookbook` database, and disconnect. The discussion
    for each API also indicates how to connect without selecting any default database.
    This might be the case if you plan to execute a statement that doesn’t require
    a default database, such as `SHOW` `VARIABLES` or `SELECT` `VERSION()`. Or perhaps
    you’re writing a program that enables the user to specify the database after the
    connection has been made.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括示例程序，展示如何使用每个 API 连接到服务器，选择`cookbook`数据库并断开连接。每个 API 的讨论还说明了如何在不选择任何默认数据库的情况下连接。如果您计划执行不需要默认数据库的语句，例如`SHOW
    VARIABLES`或`SELECT VERSION()`，或者编写一个允许用户在连接后指定数据库的程序，这可能是适用的情况。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The scripts shown here use `localhost` as the hostname. If they produce a connection
    error indicating that a socket file cannot be found, try changing `localhost`
    to `127.0.0.1`, the TCP/IP address of the local host. This tip applies throughout
    the book.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的脚本使用`localhost`作为主机名。如果它们产生连接错误，指示找不到套接字文件，请尝试将`localhost`更改为本地主机的TCP/IP地址`127.0.0.1`。本提示适用于整本书。
- en: Perl
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl
- en: To write MySQL scripts in Perl, the DBI module must be installed, as well as
    the MySQL-specific driver module, DBD::mysql. To obtain these modules if they’re
    not already installed, see the [Preface](preface01.xhtml#nch-preface).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Perl中编写MySQL脚本，必须安装DBI模块以及MySQL特定的驱动程序模块DBD::mysql。如果这些模块尚未安装，请参阅[前言](preface01.xhtml#nch-preface)获取这些模块。
- en: 'The following Perl script, *connect.pl*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Perl脚本*connect.pl*连接到MySQL服务器，选择`cookbook`作为默认数据库，并断开连接：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To try *connect.pl*, locate it under the *api* directory of the `recipes` distribution
    and run it from the command line. The program should print two lines indicating
    that it connected and disconnected successfully:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试*connect.pl*，请在`recipes`分发的*api*目录下找到它，并从命令行运行。程序应打印两行，指示成功连接和断开连接：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the rest of the section we will walk through the code and explain how it
    works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分中，我们将浏览代码并解释其工作原理。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you get `Access Denied` error when connect to MySQL 8.0 ensure that the version
    of DBD::MySQL is linked with the MySQL 8.0 client library or use authentication
    plugin `mysql_native_password` instead of default `caching_sha2_password` plugin.
    We discuss authentication plugins in [Recipe 24.2](ch24.xhtml#nch-security-account-management)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接到MySQL 8.0时出现“Access Denied”错误，请确保DBD::MySQL的版本与MySQL 8.0客户端库链接，或者使用身份验证插件`mysql_native_password`而不是默认的`caching_sha2_password`插件。我们在[第24.2章](ch24.xhtml#nch-security-account-management)中讨论了身份验证插件。
- en: For background on running Perl programs, read `cmdline.pdf` in the recipes distribution
    (see the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运行Perl程序的背景，请阅读配方分发中的*cmdline.pdf*（参见[前言](preface01.xhtml#nch-preface)）。
- en: The `use` `strict` line turns on strict variable checking and causes Perl to
    complain about any variables that are used without having been declared first.
    This precaution helps find errors that might otherwise go undetected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` `strict`行打开严格变量检查，并导致Perl对任何在未声明的情况下使用的变量抱怨。这种预防措施有助于发现否则可能未被察觉的错误。'
- en: The `use` `warnings` line turns on warning mode so that Perl produces warnings
    for any questionable constructs. Our example script has none, but it’s a good
    idea to get in the habit of enabling warnings to catch problems that occur during
    the script development process. `use` `warnings` is similar to specifying the
    Perl `-w` command-line option, but provides more control over which warnings to
    display. (For more information, execute a *perldoc* *warnings* command.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` `warnings`行打开警告模式，以便Perl对任何可疑的结构生成警告。我们的示例脚本没有问题，但养成在脚本开发过程中启用警告以捕获问题的习惯是个好主意。`use`
    `warnings`类似于指定Perl `-w`命令行选项，但提供了更多控制要显示哪些警告的功能。（有关更多信息，请执行*perldoc* *warnings*命令。）'
- en: The `use` `DBI` statement tells Perl to load the DBI module. It’s unnecessary
    to load the MySQL driver module (DBD::mysql) explicitly. DBI does that itself
    when the script connects to the database server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` `DBI`语句告诉Perl加载DBI模块。当脚本连接到数据库服务器时，显式加载MySQL驱动程序模块（DBD::mysql）是不必要的，DBI在连接时会自行处理。'
- en: The next two lines establish the connection to MySQL by setting up a data source
    name (DSN) and calling the DBI `connect()` method. The arguments to `connect()`
    are the DSN, the MySQL username and password, and any connection attributes you
    want to specify. The DSN is required. The other arguments are optional, although
    usually it’s necessary to supply a username and password.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两行通过设置数据源名称（DSN）和调用DBI `connect()`方法来建立与MySQL的连接。`connect()`的参数是DSN、MySQL用户名和密码，以及您想指定的任何连接属性。DSN是必需的。其他参数是可选的，尽管通常需要提供用户名和密码。
- en: The DSN specifies which database driver to use and other options that indicate
    where to connect. For MySQL programs, the DSN has the format ``DBI:mysql:*`options`*``.
    The second colon in the DSN is required even if you specify no following options.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: DSN指定要使用的数据库驱动程序和指示连接位置的其他选项。对于MySQL程序，DSN的格式为``DBI:mysql:*`options`*``。即使您未指定后续选项，DSN中的第二个冒号也是必需的。
- en: 'Use the DSN components as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DSN组件如下：
- en: The first component is always `DBI`. It’s not case sensitive.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个组件始终是`DBI`。大小写不敏感。
- en: The second component tells DBI which database driver to use, and it *is* case
    sensitive. For MySQL, the name must be `mysql`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个组件告诉DBI要使用哪个数据库驱动程序，并且*区分大小写*。对于MySQL，名称必须是`mysql`。
- en: The third component, if present, is a semicolon-separated list of *`name`*`=`*`value`*
    pairs that specify additional connection options, in any order. For our purposes,
    the two most relevant options are `host` and `database`, to specify the hostname
    where the MySQL server is running and the default database.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在第三个组件，则是以分号分隔的*`name`*`=`*`value`* 对的列表，用于指定任意顺序的额外连接选项。对于我们的目的，最相关的两个选项是`host`和`database`，用于指定MySQL服务器运行的主机名和默认数据库。
- en: 'Based on that information, the DSN for connecting to the `cookbook` database
    on the local host *localhost* looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，连接到本地主机*localhost*上的`cookbook`数据库的DSN如下所示：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you omit the `host` option, its default value is `localhost`. These two
    DSNs are equivalent:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`host`选项，则其默认值为`localhost`。这两个DSN是等效的：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To select no default database, omit the `database` option.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择没有默认数据库，请省略`database`选项。
- en: 'The second and third arguments of the `connect()` call are your MySQL username
    and password. Following the password, you can also provide a fourth argument to
    specify attributes that control DBI’s behavior when errors occur. With no attributes,
    DBI by default prints error messages when errors occur but does not terminate
    your script. That’s why *connect.pl* checks whether `connect()` returns `undef`,
    which indicates failure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()` 调用的第二和第三个参数是您的MySQL用户名和密码。在密码之后，您还可以提供第四个参数来指定在发生错误时控制DBI行为的属性。如果没有属性，DBI默认在发生错误时打印错误消息但不终止您的脚本。这就是为什么*connect.pl*
    检查`connect()` 是否返回`undef`（表示失败）的原因：'
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Other error-handling strategies are possible. For example, to tell DBI to terminate
    the script if an error occurs in any DBI call, disable the `PrintError` attribute
    and enable `RaiseError` instead:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他错误处理策略。例如，要告诉DBI在任何DBI调用中发生错误时终止脚本，请禁用`PrintError`属性，改为启用`RaiseError`：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then you need not check for errors yourself. The trade-off is that you also
    lose the ability to decide how your program recovers from errors. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您无需自行检查错误。权衡是，您也失去了决定程序如何从错误中恢复的能力。[配方 4.2](#nch-api-api-error) 进一步讨论了错误处理。
- en: 'Another common attribute is `AutoCommit`, which sets the connection’s auto-commit
    mode for transactions. MySQL enables this by default for new connections, but
    we’ll set it from this point on to make the initial connection state explicit:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的属性是`AutoCommit`，它设置事务的连接自动提交模式。MySQL默认为新连接启用此功能，但从现在开始我们将显式设置初始连接状态：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown, the fourth argument to `connect()` is a reference to a hash of attribute
    name/value pairs. An alternative way of writing this code follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`connect()` 的第四个参数是对属性名称/值对的哈希引用。编写此代码的另一种方法如下：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Use whichever style you prefer. Scripts in this book use the `$conn_attr` hashref
    to make `connect()` calls simpler to read.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的任何风格。本书中的脚本使用`$conn_attr` 的哈希引用使`connect()` 调用更易读。
- en: Assuming that `connect()` succeeds, it returns a database handle that contains
    information about the state of the connection. (In DBI parlance, references to
    objects are called handles.) Later we’ll see other handles such as statement handles,
    which are associated with particular statements. Perl DBI scripts in this book
    conventionally use `$dbh` and `$sth` to signify database and statement handles.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`connect()` 成功，它将返回一个包含连接状态信息的数据库句柄。 （在DBI术语中，对象的引用称为句柄。）稍后我们将看到其他句柄，如与特定语句相关联的语句句柄。本书中的Perl
    DBI脚本惯例上使用`$dbh`和`$sth`分别表示数据库和语句句柄。
- en: Additional connection parameters
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的连接参数
- en: 'To specify the path to a socket file for *localhost* connections on Unix, provide
    a `mysql_socket` option in the DSN:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unix上的*localhost*连接中指定套接字文件的路径，请在DSN中提供`mysql_socket`选项：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To specify the port number for non-*localhost* (TCP/IP) connections, provide
    a `port` option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要为非*localhost*（TCP/IP）连接指定端口号，请提供`port`选项：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ruby
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby
- en: To write MySQL scripts in Ruby, the Mysql2 gem must be installed. To obtain
    this gem if it is not already installed, see the [Preface](preface01.xhtml#nch-preface).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ruby中编写MySQL脚本，必须安装Mysql2 gem。如果尚未安装此gem，请参阅[前言](preface01.xhtml#nch-preface)。
- en: 'The following Ruby script, *connect.rb*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Ruby脚本*connect.rb*连接到MySQL服务器，选择`cookbook`作为默认数据库，并断开连接：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To try *connect.rb*, locate it under the *api* directory of the `recipes` distribution
    and run it from the command line. The program should print two lines indicating
    that it connected and disconnected successfully:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试*connect.rb*，请在`recipes`分发的*api*目录下找到它，并从命令行运行。程序应打印两行，指示成功连接和断开连接：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For background on running Ruby programs, read `cmdline.pdf` in the recipes distribution
    (see the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有关运行Ruby程序的背景，请阅读配方分发中的`cmdline.pdf`（请参阅[前言](preface01.xhtml#nch-preface)）。
- en: The `-w` option turns on warning mode so that Ruby produces warnings for any
    questionable constructs. Our example script has no such constructs, but it’s a
    good idea to get in the habit of using `-w` to catch problems that occur during
    the script development process.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w`选项打开警告模式，以便Ruby对任何可疑构造生成警告。我们的示例脚本没有这样的构造，但养成在脚本开发过程中使用`-w`来捕捉问题的习惯是个好主意。'
- en: The `require` statement tells Ruby to load the Mysql2 module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`语句告诉Ruby加载Mysql2模块。'
- en: To establish the connection, create a `Mysql2::Client` object. Pass connection
    parameters as named arguments for the method `new`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立连接，请创建`Mysql2::Client`对象。将连接参数作为`new`方法的命名参数传递。
- en: To select no default database, omit the `database` option.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择无默认数据库，请省略`database`选项。
- en: Assuming that the `Mysql2::Client` object successfully created, it will act
    as a database handle that contains information about the state of the connection.
    Ruby scripts in this book conventionally use `client` to signify a database handle
    object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设成功创建`Mysql2::Client`对象，则其将充当包含连接状态信息的数据库句柄。本书中的Ruby脚本通常使用`client`表示数据库句柄对象。
- en: If the `new()` method fails, it raises an exception. To handle exceptions, put
    the statements that might fail inside a `begin` block, and use a `rescue` clause
    that contains the error-handling code. Exceptions that occur at the top level
    of a script (that is, outside of any `begin` block) are caught by the default
    exception handler, which prints a stack trace and exits. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`new()`方法失败，则会引发异常。要处理异常，请将可能失败的语句放入`begin`块中，并使用包含错误处理代码的`rescue`子句。在脚本的顶层（即任何`begin`块之外）发生的异常将被默认异常处理程序捕获，后者会打印堆栈跟踪并退出。[配方4.2](#nch-api-api-error)进一步讨论了错误处理。
- en: Additional connection parameters
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他连接参数
- en: 'To specify the path to a socket file for *localhost* connections on Unix, provide
    a `socket` option for the method `new`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Unix上的*localhost*连接指定套接字文件路径，请为`new`方法提供`socket`选项：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To specify the port number for non-*localhost* (TCP/IP) connections, provide
    a `port` option:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要为非*localhost*（TCP/IP）连接指定端口号，请提供`port`选项：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: PHP
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: To write PHP scripts that use MySQL, your PHP interpreter must have MySQL support
    compiled in. If your scripts are unable to connect to your MySQL server, check
    the instructions included with your PHP distribution to see how to enable MySQL
    support.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写使用MySQL的PHP脚本，您的PHP解释器必须已编译有MySQL支持。如果您的脚本无法连接到MySQL服务器，请查看随PHP分发的说明，了解如何启用MySQL支持。
- en: PHP actually has multiple extensions that enable the use of MySQL, such as `mysql`,
    the original (and now deprecated) MySQL extension; `mysqli`, the <q>MySQL improved</q>
    extension; and, more recently, the MySQL driver for the PDO (PHP Data Objects)
    interface. PHP scripts in this book use PDO. To obtain PHP and PDO if they’re
    not already installed, see the [Preface](preface01.xhtml#nch-preface).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: PHP实际上有多个扩展程序可以使用MySQL，例如`mysql`，原始且现在已弃用的MySQL扩展；`mysqli`，改进的MySQL扩展；以及最近的MySQL
    PDO（PHP数据对象）接口驱动程序。本书中的PHP脚本使用PDO。如果尚未安装PHP和PDO，请参阅[前言](preface01.xhtml#nch-preface)。
- en: 'PHP scripts usually are written for use with a web server. I assume that if
    you use PHP that way, you can copy PHP scripts into your server’s document tree,
    request them from your browser, and they will execute. For example, if you run
    Apache as the web server on the host *localhost* and you install a PHP script
    named *myscript.php* at the top level of the Apache document tree, you should
    be able to access the script by requesting this URL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 脚本通常是为与 Web 服务器一起使用而编写的。我假设如果您以这种方式使用 PHP，您可以将 PHP 脚本复制到服务器的文档树中，从浏览器请求它们，它们将执行。例如，如果您在主机
    *localhost* 上运行 Apache 作为 Web 服务器，并且您在 Apache 文档树的顶层安装了名为 *myscript.php* 的 PHP
    脚本，您应该能够通过请求以下 URL 来访问该脚本：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This book uses the *.php* extension (suffix) for PHP script filenames, so your
    web server must be configured to recognize the *.php* extension. Otherwise, when
    you request a PHP script from your browser, the server simply sends the literal
    text of the script and that’s what appears in your browser window. You don’t want
    this to happen, particularly if the script contains the username and password
    for connecting to MySQL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用 *.php* 扩展名（后缀）作为 PHP 脚本文件名，因此您的 Web 服务器必须配置为识别 *.php* 扩展名。否则，当您从浏览器请求 PHP
    脚本时，服务器只会发送脚本的文字内容，这将显示在您的浏览器窗口中。您不希望发生这种情况，特别是如果脚本包含连接到 MySQL 的用户名和密码。
- en: 'PHP scripts often are written as a mixture of HTML and PHP code, with the PHP
    code embedded between the special `<?php` and `?>` tags. Here is an example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 脚本通常是 HTML 和 PHP 代码的混合体，其中 PHP 代码嵌入在特殊的 `<?php` 和 `?>` 标签之间。以下是一个示例：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For brevity in examples consisting entirely of PHP code, typically I’ll omit
    the enclosing `<?php` and `?>` tags. If you see no tags in a PHP example, assume
    that `<?php` and `?>` surround the entire block of code that is shown. Examples
    that switch between HTML and PHP code do include the tags, to make it clear what
    is PHP code and what is not.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在完全由 PHP 代码组成的示例中简洁起见，通常会省略包围的 `<?php` 和 `?>` 标签。如果您在 PHP 示例中看不到标签，请假设 `<?php`
    和 `?>` 包围着显示的整个代码块。在 HTML 和 PHP 代码之间切换的示例中会包含标签，以明确显示哪些是 PHP 代码，哪些不是。
- en: PHP can be configured to recognize <q>short</q> tags as well, written as `<?`
    and `?>`. This book does not assume that you have short tags enabled and does
    not use them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 可以配置为识别 <q>short</q> 标签，写作 `<?` 和 `?>`。本书假设您未启用短标签并且不使用它们。
- en: 'The following PHP script, *connect.php*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 PHP 脚本，*connect.php*，连接到 MySQL 服务器，选择 `cookbook` 作为默认数据库，并断开连接：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To try *connect.php*, locate it under the *api* directory of the `recipes`
    distribution, copy it to your web server’s document tree, and request it using
    your browser. Alternatively, if you have a standalone version of the PHP interpreter
    for use from the command line, execute the script directly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 *connect.php*，请在 `recipes` 分发的 *api* 目录下找到它，将其复制到您的 Web 服务器文档树中，并使用浏览器请求它。或者，如果您有独立版本的
    PHP 解释器用于命令行使用，则可以直接执行脚本：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For background on running PHP programs, read `cmdline.pdf` in the recipes distribution
    (see the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关运行 PHP 程序的背景，请阅读 `cmdline.pdf` 在 recipes 分发中（请参阅 [前言](preface01.xhtml#nch-preface)）。
- en: '`$dsn` is the data source name (DSN) that indicates how to connect to the database
    server. It has this general syntax:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`$dsn` 是数据源名称 (DSN)，指示如何连接到数据库服务器。它具有以下一般语法：'
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The *`driver`* value is the PDO driver type. For MySQL, this is `mysql`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*`driver`* 值是 PDO 驱动程序类型。对于 MySQL，这是 `mysql`。'
- en: Following the driver name, semicolon-separated *`name`*`=`*`value`* pairs specify
    connection parameters, in any order. For our purposes, the two most relevant options
    are `host` and `dbname`, to specify the hostname where the MySQL server is running
    and the default database. To select no default database, omit the `dbname` option.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序名称之后，以分号分隔的 *`name`*`=`*`value`* 对指定连接参数，顺序任意。对我们来说，两个最相关的选项是 `host` 和
    `dbname`，用于指定 MySQL 服务器运行的主机名和默认数据库。要选择没有默认数据库，请省略 `dbname` 选项。
- en: To establish the connection, invoke the `new` `PDO()` class constructor, passing
    to it the appropriate arguments. The DSN is required. The other arguments are
    optional, although usually it’s necessary to supply a username and password. If
    the connection attempt succeeds, `new` `PDO()` returns a database-handle object
    that is used to access other MySQL-related methods. PHP scripts in this book conventionally
    use `$dbh` to signify a database handle.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立连接，调用`new` `PDO()`类构造函数，并传递适当的参数。DSN是必需的。其他参数是可选的，尽管通常需要提供用户名和密码。如果连接尝试成功，`new`
    `PDO()`将返回一个数据库句柄对象，用于访问其他与MySQL相关的方法。本书中的PHP脚本惯例上使用`$dbh`表示数据库句柄。
- en: If the connection attempt fails, PDO raises an exception. To handle this, put
    the connection attempt within a `try` block and use a `catch` block that contains
    the error-handling code, or just let the exception terminate your script. [Recipe
    4.2](#nch-api-api-error) discusses error handling further.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接尝试失败，PDO会引发一个异常。为了处理这种情况，将连接尝试放在一个`try`块中，并使用一个`catch`块包含错误处理代码，或者让异常终止你的脚本。[4.2小节](#nch-api-api-error)进一步讨论了错误处理。
- en: To disconnect, set the database handle to `NULL`. There is no explicit disconnect
    call.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要断开连接，请将数据库句柄设置为`NULL`。没有显式的断开调用。
- en: Additional connection parameters
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的连接参数
- en: 'To specify the path to a socket file for *localhost* connections on Unix, provide
    a `unix_socket` option in the DSN:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unix上指定本地主机连接的套接字文件路径，请在DSN中提供`unix_socket`选项：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To specify the port number for non-*localhost* (TCP/IP) connections, provide
    a `port` option:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要为非本地主机（TCP/IP）连接指定端口号，请提供`port`选项：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Python
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: To write MySQL programs in Python, a module must be installed that provides
    MySQL connectivity for the Python DB API, also known as Python Database API Specification
    v2.0 (PEP 249). This book uses MySQL Connector/Python. To obtain it if it’s not
    already installed, see the [Preface](preface01.xhtml#nch-preface).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中编写MySQL程序，必须安装一个模块，该模块为Python DB API（即Python数据库API规范v2.0，PEP 249）提供MySQL连接。本书使用MySQL
    Connector/Python。如果尚未安装，请参阅[前言](preface01.xhtml#nch-preface)获取。
- en: To use the DB API, import the database driver module that you want to use (which
    is `mysql.connector` for MySQL programs that use Connector/Python). Then create
    a database connection object by calling the driver’s `connect()` method. This
    object provides access to other DB API methods, such as the `close()` method that
    serves the connection to the database server.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用DB API，在要使用的数据库驱动模块中导入它（对于使用Connector/Python的MySQL程序来说，这是`mysql.connector`）。然后通过调用驱动程序的`connect()`方法创建一个数据库连接对象。该对象提供了访问其他DB
    API方法的途径，例如服务于数据库服务器的`close()`方法。
- en: 'The following Python script, *connect.py*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python脚本*connect.py*连接到MySQL服务器，选择`cookbook`作为默认数据库，并断开连接：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To try *connect.py*, locate it under the *api* directory of the `recipes` distribution
    and run it from the command line. The program should print two lines indicating
    that it connected and disconnected successfully:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试*connect.py*，请在`recipes`发行版的*api*目录下找到它，并从命令行运行。程序应该打印两行指示成功连接和断开连接：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For background on running Python programs, read `cmdline.pdf` in the recipes
    distribution (see the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运行Python程序的背景，请阅读`recipes`发行版中的`cmdline.pdf`（参见[前言](preface01.xhtml#nch-preface)）。
- en: The `import` line tells Python to load the `mysql.connector` module. Then the
    script attempts to establish a connection to the MySQL server by calling `connect()`
    to obtain a connection object. Python scripts in this book conventionally use
    `conn` to signify connection objects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`行告诉Python加载`mysql.connector`模块。然后脚本尝试通过调用`connect()`建立与MySQL服务器的连接以获取连接对象。本书中的Python脚本惯例上使用`conn`表示连接对象。'
- en: If the `connect()` method fails, Connector/Python raises an exception. To handle
    exceptions, put the statements that might fail inside a `try` statement and use
    an `except` clause that contains the error-handling code. Exceptions that occur
    at the top level of a script (that is, outside of any `try` statement) are caught
    by the default exception handler, which prints a stack trace and exits. [Recipe
    4.2](#nch-api-api-error) discusses error handling further.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `connect()` 方法失败，Connector/Python 将引发异常。要处理异常，请将可能失败的语句放在 `try` 语句中，并使用包含错误处理代码的
    `except` 子句。在脚本的顶层（即在任何 `try` 语句之外）发生的异常会被默认的异常处理程序捕获，该程序会打印堆栈跟踪并退出。[Recipe 4.2](#nch-api-api-error)
    进一步讨论了错误处理。
- en: The `else` clause contains statements that execute if the `try` clause produces
    no exception. It’s used here to close the successfully opened connection.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 子句包含在 `try` 子句未产生异常时执行的语句。这里用于关闭成功打开的连接。'
- en: Because the `connect()` call uses named arguments, their order does not matter.
    If you omit the `host` argument from the `connect()` call, its default value is
    `127.0.0.1`. To select no default database, omit the `database` argument or pass
    a `database` value of `""` (the empty string) or `None`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `connect()` 调用使用了命名参数，它们的顺序并不重要。如果从 `connect()` 调用中省略 `host` 参数，则其默认值为 `127.0.0.1`。要选择没有默认数据库，请省略
    `database` 参数或传递 `""`（空字符串）或 `None` 作为 `database` 值。
- en: 'Another way to connect is to specify the parameters using a Python dictionary
    and pass the dictionary to `connect()`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种连接方法是使用 Python 字典指定参数，并将字典传递给 `connect()`：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This book generally uses that style from now on.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，本书通常会使用这种风格。
- en: Additional connection parameters
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 附加连接参数
- en: 'To specify the path to a socket file for local host connections on Unix, omit
    the `host` parameter and provide a `unix_socket` parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Unix 上指定本地主机连接的套接字文件路径，请省略 `host` 参数并提供 `unix_socket` 参数：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To specify the port number for TCP/IP connections, include the `host` parameter
    and provide an integer-valued `port` parameter:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 TCP/IP 连接指定端口号，请包含 `host` 参数并提供整数值 `port` 参数：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Go
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go
- en: To write MySQL programs in Go, a Go SQL Driver must be installed. This book
    uses [Go-MySQL-Driver](https://github.com/go-sql-driver/mysql). To obtain it if
    it’s not already installed, install *Git*, then issue the following command.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中编写 MySQL 程序，必须安装 Go SQL 驱动程序。本书使用 [Go-MySQL-Driver](https://github.com/go-sql-driver/mysql)。如果尚未安装，请安装
    *Git*，然后执行以下命令。
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To use the Go SQL interface, import `database/sql` package and your driver package.
    Then create a database connection object by calling the `sql.Open()` function.
    This object provides access to other `database/sql` package functions, such as
    the `db.Close()` that closes the connection to the database server. We also use
    `defer` statement to call the `db.Close()` to make sure the function call is performed
    later in the program execution. You will see this usage throughout this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Go SQL 接口，导入 `database/sql` 包和您的驱动程序包。然后通过调用 `sql.Open()` 函数创建数据库连接对象。此对象提供访问其他
    `database/sql` 包函数的功能，如 `db.Close()` 关闭与数据库服务器的连接。我们还使用 `defer` 语句调用 `db.Close()`，以确保函数调用在程序执行的后续阶段执行。在本章中，您将看到这种用法。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Go package `database/sql` and the Go-MySQL-Driver support context cancellation.
    This means that you can cancel database operations, such as running a query, if
    cancel the context. To use this feature you need to call context-aware functions
    of the `sql` interface. For the brevity we would not use `Context` in our examples
    in this chapter. We will have example of using `Context` when discuss transaction
    handling in [Recipe 20.9](ch20.xhtml#nch-xact-xact-go-context).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包 `database/sql` 和 Go-MySQL-Driver 支持上下文取消。这意味着您可以取消数据库操作（如运行查询），如果取消上下文。要使用此功能，您需要调用
    `sql` 接口的支持上下文的函数。出于简洁起见，在本章的示例中，我们不会使用 `Context`。当讨论事务处理时，我们将在 [Recipe 20.9](ch20.xhtml#nch-xact-xact-go-context)
    中展示使用 `Context` 的示例。
- en: 'The following Go script, *connect.go*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Go 脚本，*connect.go*，连接到 MySQL 服务器，选择 `cookbook` 作为默认数据库，并断开连接：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To try *connect.go*, locate it under the *api/01_connect* directory of the
    `recipes` distribution and run it from the command line. The program should print
    single line indicating that it connected:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 *connect.go*，请在 `recipes` 发行版的 *api/01_connect* 目录下找到它，并从命令行运行。程序应打印一行表示已连接：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `import` line tells Go to load the `go-sql-driver/mysql` package. Then the
    script validates connection parameters and obtains a connection object by calling
    `sql.Open()`. *No MySQL connection established yet!*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句告诉Go加载`go-sql-driver/mysql`包。然后脚本通过调用`sql.Open()`验证连接参数并获取连接对象。*还没有建立MySQL连接！*'
- en: If the `sql.Open()` method fails, `go-sql-driver/mysql` returns an error. To
    handle the error, store it into a variable (in our example `err`) and use an `if`
    block that contains the error-handling code. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sql.Open()`方法失败，`go-sql-driver/mysql`会返回一个错误。要处理错误，将其存储在一个变量中（在我们的例子中为`err`），并使用包含错误处理代码的`if`块。[第4.2节](#nch-api-api-error)进一步讨论了错误处理。
- en: The `db.Ping()` call establishes the database connection. Only at this moment
    we can say that we connected to the MySQL server successfully.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.Ping()`调用建立数据库连接。只有在这一刻我们才能说成功连接到MySQL服务器。'
- en: Additional connection parameters
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 附加连接参数
- en: 'To specify the path to a socket file for local host connections on Unix, omit
    the `tcp` parameter in the DSN and provide a `unix` parameter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unix上指定本地主机连接的套接字文件路径，请在DSN中省略`tcp`参数并提供`unix`参数：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run this program:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To specify the port number for TCP/IP connections, include the `tcp` parameter
    into the DSN and provide an integer-valued `port` port number:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定TCP/IP连接的端口号，请在DSN中包括`tcp`参数并提供一个整数值`port`端口号：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run this program:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Go accepts DSN (Data Source Name) in this form:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Go接受这种形式的DSN（数据源名称）：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Where `protocol` could be either `tcp` or `unix`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`protocol`可以是`tcp`或`unix`。
- en: 'A DSN in its fullest form is:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 完整形式的DSN如下所示：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Java
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: Database programs in Java use the JDBC interface, together with a driver for
    the particular database engine you want to access. That is, the JDBC architecture
    provides a generic interface used in conjunction with a database-specific driver.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的数据库程序使用JDBC接口，以及要访问的特定数据库引擎的驱动程序。也就是说，JDBC架构提供了一个通用接口，与数据库特定的驱动程序结合使用。
- en: Java programming requires a Java Development Kit (JDK), and you must set your
    `JAVA_HOME` environment variable to the location where your JDK is installed.
    To write MySQL-based Java programs, you’ll also need a MySQL-specific JDBC driver.
    Programs in this book use MySQL Connector/J. To obtain it if it’s not already
    installed, see the Preface. For information about obtaining a JDK and setting
    `JAVA_HOME`, read `cmdline.pdf` in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程需要Java开发工具包（JDK），您必须将`JAVA_HOME`环境变量设置为安装JDK的位置。要编写基于MySQL的Java程序，还需要一个特定于MySQL的JDBC驱动程序。本书中使用MySQL
    Connector/J。如果未安装，请参阅前言获取它。有关获取JDK和设置`JAVA_HOME`的信息，请阅读recipes发行版中的`cmdline.pdf`（请参阅[前言](preface01.xhtml#nch-preface)）。
- en: 'The following Java program, *Connect.java*, connects to the MySQL server, selects
    `cookbook` as the default database, and disconnects:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Java程序*Connect.java*连接到MySQL服务器，选择`cookbook`作为默认数据库，并断开连接：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To try *Connect.java*, locate it under the *api* directory of the `recipes`
    distribution, compile it, and execute it. The `class` statement indicates the
    program’s name, which in this case is `Connect`. The name of the file containing
    the program must match this name and include a *.java* extension, so the filename
    for the program is *Connect.java*. Compile the program using *javac*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试*Connect.java*，请找到它在`recipes`发行版的*api*目录下，编译并执行它。`class`语句指示程序的名称，在这种情况下是`Connect`。包含程序的文件名必须与此名称匹配，并包括*.java*扩展名，因此程序的文件名是*Connect.java*。使用*javac*编译程序：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you prefer a different Java compiler, substitute its name for *javac*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢不同的Java编译器，请将其名称替换为*javac*。
- en: 'The Java compiler generates compiled byte code to produce a class file named
    *Connect.class*. Use the *java* program to run the class file (specified without
    the *.class* extension). The program should print two lines indicating that it
    connected and disconnected successfully:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器生成编译的字节码，生成名为*Connect.class*的类文件。使用*java*程序运行该类文件（不带*.class*扩展名）。程序应打印两行表示成功连接和断开连接：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might need to set your `CLASSPATH` environment variable before the example
    program will compile and run. The value of `CLASSPATH` should include at least
    your current directory (`.`) and the path to the Connector/J JDBC driver. For
    background on running Java programs or setting `CLASSPATH`, read `cmdline.pdf`
    in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例程序能够编译和运行之前，您可能需要设置您的 `CLASSPATH` 环境变量。`CLASSPATH` 的值应至少包括当前目录（`.`）和 Connector/J
    JDBC 驱动程序的路径。有关运行 Java 程序或设置 `CLASSPATH` 的背景，请阅读配方分发中的 `cmdline.pdf`（参见 [前言](preface01.xhtml#nch-preface)）。
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Starting from Java 11, you can skip *javac* call for a single-file program
    and run it as:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 11 开始，可以跳过 *javac* 调用，直接运行单文件程序，如下所示：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `import` `java.sql.*` statement references the classes and interfaces that
    provide access to the data types used to manage different aspects of your interaction
    with the database server. These are required for all JDBC programs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` `java.sql.*` 语句引用了类和接口，这些类和接口提供了访问用于管理与数据库服务器交互的不同数据类型的功能。所有 JDBC
    程序都需要这些。'
- en: To connect to the server call `DriverManager.getConnection()` to initiate the
    connection and obtain a `Connection` object that maintains information about the
    state of the connection. Java programs in this book conventionally use `conn`
    to signify connection objects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到服务器，请调用 `DriverManager.getConnection()` 来初始化连接并获取一个 `Connection` 对象，该对象维护有关连接状态的信息。本书中的
    Java 程序通常使用 `conn` 表示连接对象。
- en: '`DriverManager.getConnection()` takes three arguments: a URL that describes
    where to connect and the database to use, the MySQL username, and the password.
    The URL string has this format:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`DriverManager.getConnection()` 接受三个参数：描述连接位置和要使用的数据库的 URL 字符串，MySQL 用户名和密码。URL
    字符串的格式如下：'
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This format follows the Java convention that the URL for connecting to a network
    resource begins with a protocol designator. For JDBC programs, the protocol is
    `jdbc`, and you’ll also need a subprotocol designator that specifies the driver
    name (`mysql`, for MySQL programs). Many parts of the connection URL are optional,
    but the leading protocol and subprotocol designators are not. If you omit *`host_name`*,
    the default host value is `localhost`. To select no default database, omit the
    database name. However, you should not omit any of the slashes in any case. For
    example, to connect to the local host without selecting a default database, the
    URL is:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式遵循 Java 的约定，用于连接网络资源的 URL 必须以协议标识符开头。对于 JDBC 程序，协议是 `jdbc`，还需要一个子协议标识符来指定驱动程序名称（MySQL
    程序使用 `mysql`）。连接 URL 的许多部分都是可选的，但是协议和子协议标识符是必需的。如果省略 *`host_name`*，默认主机值为 `localhost`。如果不选择默认数据库，则应省略数据库名称。但无论如何都不应省略任何斜杠。例如，要连接到本地主机而不选择默认数据库，URL
    如下：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In JDBC, you don’t test method calls for return values that indicate an error.
    Instead, provide handlers to be called when exceptions are thrown. [Recipe 4.2](#nch-api-api-error)
    discusses error handling further.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDBC 中，不要测试返回值指示错误的方法调用。相反，提供处理程序以在抛出异常时调用。[第 4.2 节](#nch-api-api-error) 进一步讨论了错误处理。
- en: 'Some JDBC drivers (Connector/J among them) permit you to specify the username
    and password as parameters at the end of the URL. In this case, omit the second
    and third arguments of the `getConnection()` call. Using that URL style, write
    the code that establishes the connection in the example program like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 JDBC 驱动程序（包括 Connector/J）允许您在 URL 的末尾指定用户名和密码作为参数。在这种情况下，可以省略 `getConnection()`
    调用的第二个和第三个参数。使用这种 URL 样式，可以像下面这样编写建立连接的代码：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The character that separates the `user` and `password` parameters should be
    `&`, not `;`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔 `user` 和 `password` 参数的字符应为 `&`，而不是 `;`。
- en: Additional connection parameters
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 额外的连接参数
- en: 'Connector/J does not natively support Unix domain socket file connections,
    so even connections for which the hostname is *localhost* are made via TCP/IP.
    To specify an explicit port number, add `:`*`port_num`* to the hostname in the
    connection URL:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Connector/J 不原生支持 Unix 域套接字文件连接，因此即使主机名为 *localhost* 的连接也是通过 TCP/IP 进行的。要指定显式端口号，请在连接
    URL 中的主机名后添加 `:`*`port_num`*：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, you can use 3rd-party libraries that provide support for connections
    via socket. See [Connecting Using Unix Domain Sockets](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-unix-socket.html)
    user reference manual page for details.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以使用第三方库来支持通过套接字进行连接。有关详细信息，请参阅 [使用 Unix 域套接字连接](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-unix-socket.html)
    用户参考手册页面。
- en: 4.2 Checking for Errors
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 检查错误
- en: Problem
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Something went wrong with your program, and you don’t know what.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 程序出了问题，但你不知道是什么。
- en: Solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Everyone has problems getting programs to work correctly. But if you don’t anticipate
    problems by checking for errors, the job becomes much more difficult. Add some
    error-checking code so your programs can help you figure out what went wrong.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人在使程序正常工作方面都会遇到问题。但如果你不通过检查错误来预期问题，那么工作将变得更加困难。添加一些错误检查代码，让你的程序能帮助你找出问题所在。
- en: Discussion
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: After working through [Recipe 4.1](#nch-api-api-connect), you know how to connect
    to the MySQL server. It’s also a good idea to know how to check for errors and
    how to retrieve specific error information from the API, so we cover that next.
    You’re probably anxious to do more interesting things (such as executing statements
    and getting back the results), but error checking is fundamentally important.
    Programs sometimes fail, especially during development, and if you can’t determine
    why failures occur, you’re flying blind. Plan for failure by checking for errors
    so that you can take appropriate action.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成[Recipe 4.1](#nch-api-api-connect)后，你知道如何连接到MySQL服务器。了解如何检查错误并从API中检索特定的错误信息也是一个好主意，接下来我们会涵盖这些内容。你可能急于做更有趣的事情（如执行语句并获取结果），但错误检查基本上是非常重要的。程序有时会失败，特别是在开发过程中，如果你不能确定失败的原因，那么你就是在盲目操作。通过检查错误来规划失败，以便你可以采取适当的措施。
- en: 'When an error occurs, MySQL provides three values:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，MySQL提供了三个值：
- en: A MySQL-specific error number
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个特定于MySQL的错误编号
- en: A MySQL-specific descriptive text error message
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL特定的描述性文本错误消息
- en: A five-character SQLSTATE error code defined according to the ANSI and ODBC
    standards
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据ANSI和ODBC标准定义的五字符SQLSTATE错误代码
- en: This recipe show how to access this information. The example programs are deliberately
    designed to fail, so that the error-handling code executes. That’s why they attempt
    to connect using a username and password of `baduser` and `badpass`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了如何访问这些信息。示例程序有意设计成失败的，以便执行错误处理代码。这就是为什么它们尝试使用用户名`baduser`和密码`badpass`连接。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A general debugging aid not specific to any API is to use the available logs.
    Check the MySQL server’s general query log to see what statements the server is
    receiving. (This requires that log to be enabled; see [Recipe 22.3](ch22.xhtml#nch-admin-server-logs).)
    The general query log might show that your program is not constructing the SQL
    statement string you expect. Similarly, if you run a script under a web server
    and it fails, check the web server’s error log.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不特定于任何API的常规调试辅助工具是使用可用的日志。检查MySQL服务器的一般查询日志以查看服务器接收到的语句。 （这需要启用日志记录；参见[Recipe
    22.3](ch22.xhtml#nch-admin-server-logs)。）一般查询日志可能显示你的程序未构建你期望的SQL语句字符串。类似地，如果在Web服务器下运行脚本时失败，请检查Web服务器的错误日志。
- en: Perl
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl
- en: 'The DBI module provides two attributes that control what happens when DBI method
    invocations fail:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: DBI模块提供了两个属性来控制DBI方法调用失败时的处理方式：
- en: '`PrintError`, if enabled, causes DBI to print an error message using `warn()`.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了`PrintError`，DBI会使用`warn()`打印错误消息。
- en: '`RaiseError`, if enabled, causes DBI to print an error message using `die()`.
    This terminates your script.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RaiseError`如果启用，会导致DBI使用`die()`打印错误消息。这将终止你的脚本。'
- en: By default, `PrintError` is enabled and `RaiseError` is disabled, so a script
    continues executing after printing a message if an error occurs. Either or both
    attributes can be specified in the `connect()` call. Setting an attribute to 1
    or 0 enables or disables it, respectively. To specify either or both attributes,
    pass them in a hash reference as the fourth argument to the `connect()` call.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，启用了`PrintError`，而`RaiseError`未启用，因此在打印消息后脚本继续执行。可以在`connect()`调用中指定一个或两个属性。将属性设置为1或0可分别启用或禁用它们。要指定一个或两个属性，请将它们作为第四个参数传递给`connect()`调用的哈希引用。
- en: 'The following code sets only the `AutoCommit` attribute and uses the default
    settings for the error-handling attributes. If the `connect()` call fails, a warning
    message results, but the script continues to execute:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码仅设置`AutoCommit`属性，并使用默认设置处理错误属性。如果`connect()`调用失败，将产生警告消息，但脚本会继续执行：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because you really can’t do much if the connection attempt fails, it’s often
    prudent to exit instead after DBI prints a message:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接尝试失败，你真的不能做什么，因此在DBI打印消息后退出通常是明智的选择：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To print your own error messages, leave `RaiseError` disabled and disable `PrintError`
    as well. Then test the results of DBI method calls yourself. When a method fails,
    the `$DBI::err`, `$DBI::errstr`, and `$DBI::state` variables contain the MySQL
    error number, a descriptive error string, and the SQLSTATE value, respectively:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印自己的错误消息，请禁用`RaiseError`并禁用`PrintError`。然后自行测试DBI方法调用的结果。当方法失败时，`$DBI::err`、`$DBI::errstr`和`$DBI::state`变量分别包含MySQL错误编号、描述性错误字符串和SQLSTATE值：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If no error occurs, `$DBI::err` is 0 or `undef`, `$DBI::errstr` is the empty
    string or `undef`, and `$DBI::state` is empty or `00000`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误发生，`$DBI::err`为0或`undef`，`$DBI::errstr`为空字符串或`undef`，`$DBI::state`为空或`00000`。
- en: When you check for errors, access these variables immediately after invoking
    the DBI method that sets them. If you invoke another method before using them,
    DBI resets their values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查错误时，立即在调用设置它们的DBI方法之后访问这些变量。如果在使用它们之前调用另一个方法，DBI会重置它们的值。
- en: If you print your own messages, the default settings (`PrintError` enabled,
    `RaiseError` disabled) are not so useful. DBI prints a message automatically,
    then your script prints its own message. This is redundant, as well as confusing
    to the person using the script.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打印自己的消息，使用默认设置（启用`PrintError`，禁用`RaiseError`）并不那么有用。DBI会自动打印一条消息，然后你的脚本会打印自己的消息。这是多余的，也会让使用脚本的人感到困惑。
- en: 'If you enable `RaiseError`, you can call DBI methods without checking for return
    values that indicate errors. If a method fails, DBI prints an error and terminates
    your script. If the method returns, you can assume it succeeded. This is the easiest
    approach for script writers: let DBI do all the error checking! However, if both
    `PrintError` and `RaiseError` are enabled, DBI may call `warn()` and `die()` in
    succession, resulting in error messages being printed twice. To avoid this problem,
    disable `PrintError` whenever you enable `RaiseError`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了`RaiseError`，可以调用DBI方法而无需检查指示错误的返回值。如果方法失败，DBI会打印一个错误并终止脚本。如果方法返回，可以假定它成功了。这对于脚本编写者来说是最简单的方法：让DBI做所有的错误检查！但是，如果同时启用了`PrintError`和`RaiseError`，DBI可能会连续调用`warn()`和`die()`，导致错误消息被打印两次。为了避免这个问题，在启用`RaiseError`时禁用`PrintError`：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This book generally uses that approach. If you don’t want the all-or-nothing
    behavior of enabling `RaiseError` for automatic error checking versus having to
    do all your own checking, adopt a mixed approach. Individual handles have `PrintError`
    and `RaiseError` attributes that can be enabled or disabled selectively. For example,
    you can enable `RaiseError` globally by turning it on when you call `connect()`,
    and then disable it selectively on a per-handle basis.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本书一般采用这种方法。如果你不想启用`RaiseError`来进行自动错误检查，也不想完全自己进行检查，可以采用混合方法。单独的句柄具有可以选择启用或禁用的`PrintError`和`RaiseError`属性。例如，你可以在调用`connect()`时全局启用`RaiseError`，然后在每个句柄上选择性地禁用它。
- en: 'Suppose that a script reads the username and password from the command-line
    arguments, and then loops while the user enters statements to be executed. In
    this case, you’d probably want DBI to die and print the error message automatically
    if the connection fails (you cannot proceed to the statement-execution loop in
    that case). After connecting, however, you wouldn’t want the script to exit just
    because the user enters a syntactically invalid statement. Instead, print an error
    message and loop to get the next statement. The following code shows how to do
    this. The `do()` method used in the example executes a statement and returns `undef`
    to indicate an error:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 假设脚本从命令行参数中读取用户名和密码，然后在用户输入要执行的语句时循环。在这种情况下，如果连接失败，你可能希望DBI自动终止并打印错误消息（在这种情况下，不能继续到语句执行循环）。然而，在连接之后，你不希望脚本仅因为用户输入了语法无效的语句而退出。相反，请打印错误消息并循环以获取下一个语句。以下代码展示了如何做到这一点。示例中使用的`do()`方法执行一个语句并返回`undef`以指示错误：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If `RaiseError` is enabled, you can execute code within an `eval` block to
    trap errors without terminating your program. If an error occurs, `eval` returns
    a message in the `$@` variable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了`RaiseError`，可以在`eval`块中执行代码来捕获错误，而不终止程序。如果发生错误，`eval`会在`$@`变量中返回一条消息：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This `eval` technique is commonly used to perform transactions (see [Recipe
    20.4](ch20.xhtml#nch-xact-xact-perl)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`eval`技术通常用于执行事务（见[20.4章节](ch20.xhtml#nch-xact-xact-perl)）。
- en: 'Using `RaiseError` in combination with `eval` differs from using `RaiseError`
    alone:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`eval`和`RaiseError`使用时与仅使用`RaiseError`时有所不同：
- en: Errors terminate only the `eval` block, not the entire script.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误只终止`eval`块，而不是整个脚本。
- en: Any error terminates the `eval` block, whereas `RaiseError` applies only to
    DBI-related errors.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何错误都会终止`eval`块，而`RaiseError`仅适用于与DBI相关的错误。
- en: When you use `eval` with `RaiseError` enabled, disable `PrintError`. Otherwise,
    in some versions of DBI, an error may simply cause `warn()` to be called without
    terminating the `eval` block as you expect.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用带有启用`RaiseError`的`eval`时，请禁用`PrintError`。否则，在某些DBI版本中，错误可能仅会导致调用`warn()`，而不会像您期望的那样终止`eval`块。
- en: 'In addition to using the error-handling attributes `PrintError` and `RaiseError`,
    lots of information about your script’s execution is available using DBI’s tracing
    mechanism. Invoke the `trace()` method with an argument indicating the trace level.
    Levels 1 to 9 enable tracing with increasingly more verbose output, and level
    0 disables tracing:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用错误处理属性`PrintError`和`RaiseError`外，还可以使用DBI的跟踪机制获取有关脚本执行的大量信息。调用`trace()`方法并传递指定的跟踪级别参数。级别1到9使跟踪输出更加详细，级别0禁用跟踪：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Individual database and statement handles also have `trace()` methods, so you
    can localize tracing to a single handle if you want.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，单独的数据库和语句句柄也有`trace()`方法，因此您可以将跟踪限制在单个句柄上。
- en: 'Trace output normally goes to your terminal (or, in the case of a web script,
    to the web server’s error log). To write trace output to a specific file, provide
    a second argument that indicates the filename:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪输出通常发送到您的终端（或者在Web脚本的情况下，发送到Web服务器的错误日志）。要将跟踪输出写入特定文件，请提供第二个参数指定文件名：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If the trace file already exists, its contents are not cleared first; trace
    output is appended to the end. Beware of turning on a file trace while developing
    a script, but forgetting to disable the trace when you put the script into production.
    You’ll eventually find to your chagrin that the trace file has become quite large.
    Or worse, a filesystem will fill up, and you’ll have no idea why!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果跟踪文件已经存在，则其内容不会首先被清除；跟踪输出将追加到末尾。在开发脚本时打开跟踪文件时要小心，但在将脚本投入生产时忘记禁用跟踪。最终你会发现遗憾的是跟踪文件变得非常大。或者更糟糕的是，文件系统将填满，而你却不知道原因！
- en: Ruby
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby
- en: 'Ruby signals errors by raising exceptions and Ruby programs handle errors by
    catching exceptions in a `rescue` clause of a `begin` block. Ruby Mysql2 methods
    raise exceptions when they fail and provide error information by means of a `Mysql2::Error`
    object. To get the MySQL error number, error message, and SQLSTATE value, access
    the `errno`, `message`, and `sql_state` methods of this object. The following
    example shows how to trap exceptions and access error information in a Ruby script:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby通过引发异常来表示错误，Ruby程序通过在`begin`块的`rescue`子句中捕获异常来处理错误。当Ruby Mysql2方法失败时会引发异常，并通过`Mysql2::Error`对象提供错误信息。要获取MySQL错误编号、错误消息和SQLSTATE值，请访问该对象的`errno`、`message`和`sql_state`方法。以下示例展示了如何在Ruby脚本中捕获异常并访问错误信息：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: PHP
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: 'The `new` `PDO()` constructor raises an exception if it fails, but other PDO
    methods by default indicate success or failure by their return value. To cause
    all PDO methods to raise exceptions for errors, use the database handle resulting
    from a successful connection attempt to set the error-handling mode. This enables
    uniform handling of all PDO errors without checking the result of every call.
    The following example shows how to set the error mode if the connection attempt
    succeeds and how to handle exceptions if it fails:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接失败，`new PDO()`构造函数会引发异常，但其他PDO方法默认通过它们的返回值指示成功或失败。为了导致所有PDO方法在错误时引发异常，请使用成功连接尝试的数据库句柄设置错误处理模式。这样可以统一处理所有PDO错误，而无需检查每个调用的结果。以下示例展示了如何设置错误模式（如果连接尝试成功）以及如何处理异常（如果连接失败）：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When PDO raises an exception, the resulting `PDOException` object provides error
    information. The `getCode()` method returns the SQLSTATE value. The `getMessage()`
    method returns a string containing the SQLSTATE value, MySQL error number, and
    error message.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当PDO引发异常时，结果的`PDOException`对象提供错误信息。`getCode()`方法返回SQLSTATE值。`getMessage()`方法返回包含SQLSTATE值、MySQL错误编号和错误消息的字符串。
- en: 'Database and statement handles also provide information when an error occurs.
    For either type of handle, `errorCode()` returns the SQLSTATE value and `errorInfo()`
    returns a three-element array containing the SQLSTATE value and a driver-specific
    error code and message. For MySQL, the latter two values are the error number
    and message string. The following example demonstrates how to get information
    from the exception object and the database handle:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，数据库和语句句柄还提供信息。对于任一类型的句柄，`errorCode()`返回SQLSTATE值，而`errorInfo()`返回一个包含SQLSTATE值和特定于驱动程序的错误代码和消息的三元素数组。对于MySQL，后两个值分别是错误号和消息字符串。以下示例演示了如何从异常对象和数据库句柄获取信息：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Python
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: 'Python signals errors by raising exceptions, and Python programs handle errors
    by catching exceptions in the `except` clause of a `try` statement. To obtain
    MySQL-specific error information, name an exception class, and provide a variable
    to receive the information. Here’s an example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过引发异常信号错误，并通过在`try`语句的`except`子句中捕获异常来处理错误。要获取特定于MySQL的错误信息，请命名一个异常类，并提供一个变量来接收信息。以下是一个示例：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If an exception occurs, the `errno`, `msg`, and `sqlstate` members of the exception
    object contain the error number, error message, and SQLSTATE values, respectively.
    Note that access to the `Error` class is through the driver module name.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生异常，异常对象的`errno`、`msg`和`sqlstate`成员包含错误号、错误消息和SQLSTATE值。请注意，访问`Error`类是通过驱动程序模块名。
- en: Go
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go
- en: Go does not support exceptions. Instead, its multi-value returns make it easy
    to pass error when needed. To handle errors in Go, store returned value of the
    type `Error` into a variable (we use variable name `err` here) and handle it accordingly.
    To handle errors Go offers `defer` statement, `Panic()` and `Recover()` built-in
    functions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Go不支持异常。相反，其多返回值使得在需要时传递错误变得容易。要处理Go中的错误，请将类型为`Error`的返回值存储在变量中（这里我们使用变量名`err`），并相应地处理它。为了处理错误，Go提供了`defer`语句、`Panic()`和`Recover()`内置函数。
- en: Table 4-2\. Error handling in Go
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2\. Go中的错误处理
- en: '| Function or statement | Meaning |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 函数或语句 | 含义 |'
- en: '| --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `defer` | Defers statement execution until the calling function returns.
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `defer` | 将语句的执行延迟到调用函数返回之前。 |'
- en: '| `Panic()` | The calling function normal execution stops, all deferred functions
    are executed, then the function returns a call to panic up the stack. The process
    continues. Finally, the program crashes. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `Panic()` | 调用函数的正常执行停止，所有延迟函数都被执行，然后函数返回一个对栈上的panic调用。进程继续执行。最后，程序崩溃。 |'
- en: '| `Recover()` | Allows to regain control in the panicking goroutine, so the
    program would not crash and continue executing. Only works in the deferred functions.
    If called in the function that is not deferred, does nothing and returns `nil`.
    |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `Recover()` | 允许在恐慌的goroutine中重新获得控制，以便程序不会崩溃并继续执行。仅在延迟函数中有效。如果在非延迟函数中调用，什么也不做并返回`nil`。
    |'
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If an error occurs, the function returns an object of the type `error`. Its
    function `Error()` returns MySQL error code and message for the errors, raised
    by the `Go-MySQL-Driver`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，函数将返回一个`error`类型的对象。它的函数`Error()`返回MySQL错误代码和`Go-MySQL-Driver`引发的错误消息。
- en: There is exceptional case for the function `QueryRow()` with subsequent `Scan()`
    call. By default `Scan()` returns `nil` if there is no error and `error` if there
    is any error. However, in case if the query run successfully but returned no rows
    this function returns `sql.ErrNoRows`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`QueryRow()`与后续的`Scan()`调用有一个特殊情况。默认情况下，如果没有错误，`Scan()`返回`nil`，如果有错误，则返回`error`。但是，如果查询成功运行但没有返回任何行，此函数将返回`sql.ErrNoRows`。
- en: Java
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: 'Java programs handle errors by catching exceptions. To do the minimum amount
    of work, print a stack trace to inform the user where the problem lies:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序通过捕获异常来处理错误。为了做最少的工作，打印堆栈跟踪以通知用户问题所在的位置：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The stack trace shows the location of the problem but not necessarily what
    the problem was. Also, it may not be meaningful except to you, the program’s developer.
    To be more specific, print the error message and code associated with an exception:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪显示问题的位置，但不一定显示问题是什么。此外，除了程序开发人员外，它可能没有意义。为了更具体地说明，打印与异常关联的错误消息和代码：
- en: All `Exception` objects support the `getMessage()` method. JDBC methods may
    throw exceptions using `SQLException` objects; these are like `Exception` objects
    but also support `getErrorCode()` and `getSQLState()` methods. `getErrorCode()`
    and `getMessage()` return the MySQL-specific error number and message string,
    and `getSQLState()` returns a string containing the SQLSTATE value.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 `Exception` 对象都支持 `getMessage()` 方法。JDBC 方法可能会抛出 `SQLException` 对象；这些对象与
    `Exception` 对象类似，但还支持 `getErrorCode()` 和 `getSQLState()` 方法。`getErrorCode()` 和
    `getMessage()` 返回 MySQL 特定的错误编号和消息字符串，`getSQLState()` 返回一个包含 SQLSTATE 值的字符串。
- en: Some methods generate `SQLWarning` objects to provide information about nonfatal
    warnings. `SQLWarning` is a subclass of `SQLException`, but warnings are accumulated
    in a list rather than thrown immediately. They don’t interrupt your program, and
    you can print them at your leisure.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些方法会生成 `SQLWarning` 对象，以提供关于非致命警告的信息。`SQLWarning` 是 `SQLException` 的子类，但警告会积累在一个列表中，而不是立即抛出。它们不会中断你的程序，你可以在方便时打印它们。
- en: 'The following example program, *Error.java*, demonstrates how to access error
    messages by printing all the error information available to it. It attempts to
    connect to the MySQL server and prints exception information if the attempt fails.
    Then it executes a statement and prints exception and warning information if the
    statement fails:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例程序，*Error.java*，展示了如何通过打印所有可用的错误信息来访问错误消息。它尝试连接到 MySQL 服务器，并在连接失败时打印异常信息。然后执行一个语句，并在语句执行失败时打印异常和警告信息：
- en: '[PRE57]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 4.3 Writing Library Files
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 编写库文件
- en: Problem
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You notice that you’re repeating code to perform common operations in multiple
    programs.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在多个程序中重复编写代码来执行常见操作。
- en: Solution
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write routines to perform those operations, put them in a library file, and
    arrange for your programs to access the library. This enables you to write the
    code only once. You might need to set an environment variable so that your scripts
    can find the library.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 编写例程来执行这些操作，将它们放入库文件中，并安排让你的程序访问该库。这使你只需编写一次代码。你可能需要设置一个环境变量，以便你的脚本可以找到该库。
- en: Discussion
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This section describes how to put code for common operations in library files.
    Encapsulation (or modularization) isn’t really a <q>recipe</q> so much as a programming
    technique. Its principal benefit is that you need not repeat code in each program
    you write. Instead, simply call a routine that’s in the library. For example,
    by putting the code for connecting to the `cookbook` database into a library routine,
    you need not write out all the parameters associated with making that connection.
    Simply invoke the routine from your program, and you’re connected.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了如何将常见操作的代码放入库文件中。封装（或模块化）实际上不是一个“食谱”，而是一种编程技术。它的主要好处是你不需要在每个编写的程序中重复编写代码。相反，只需调用库中的一个例程即可。例如，通过将连接到
    `cookbook` 数据库的代码放入库例程中，你无需在每个程序中写出与建立连接相关的所有参数。只需从程序中调用该例程，就可以连接。
- en: Connection establishment isn’t the only operation you can encapsulate, of course.
    Later sections in this book develop other utility functions to be placed in library
    files. All such files, including those shown in this section, are located under
    the *lib* directory of the `recipes` distribution. As you write your own programs,
    be on the lookout for operations that you perform often and that are good candidates
    for inclusion in a library. Use the techniques in this section to write your own
    library files.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，建立连接并不是你唯一可以封装的操作。本书的后续章节将开发其他实用函数，以放置在库文件中。所有这些文件，包括本节中显示的文件，都位于 `recipes`
    发行版的 *lib* 目录下。在编写自己的程序时，要注意那些经常执行的操作，并考虑将其包含到库文件中。使用本节中的技术编写你自己的库文件。
- en: Library files have other benefits besides making it easier to write programs,
    such as promoting portability. If you write connection parameters directly into
    each program that connects to the MySQL server, you must change all those programs
    if you move them to another machine that uses different parameters. If instead
    you write your programs to connect to the database by calling a library routine,
    it’s necessary only to modify the affected library routine, not all the programs
    that use it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使编写程序更容易之外，库文件还有其他好处，例如促进可移植性。如果你直接将连接参数写入每个连接到 MySQL 服务器的程序中，如果将它们移动到使用不同参数的另一台机器上，则必须更改所有这些程序。相反，如果你编写程序以通过调用库例程连接到数据库，只需要修改受影响的库例程，而不必修改所有使用它的程序。
- en: Code encapsulation can also improve security. If you make a private library
    file readable only to yourself, only scripts run by you can execute routines in
    the file. Or suppose that you have some scripts located in your web server’s document
    tree. A properly configured server executes the scripts and sends their output
    to remote clients. But if the server becomes misconfigured somehow, the result
    can be that it sends your scripts to clients as plain text, thus displaying your
    MySQL username and password. If you place the code for establishing a connection
    to the MySQL server in a library file located outside the document tree, those
    parameters won’t be exposed to clients.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 代码封装也可以提高安全性。如果你将私有库文件设置为仅自己可读，那么只有你运行的脚本可以执行文件中的程序。或者假设你有一些位于 Web 服务器文档树中的脚本。一个正确配置的服务器会执行这些脚本并将它们的输出发送给远程客户端。但如果服务器某种方式配置错误，结果可能是将你的脚本作为纯文本发送给客户端，从而显示你的
    MySQL 用户名和密码。如果你将与 MySQL 服务器建立连接的代码放在位于文档树之外的库文件中，这些参数就不会暴露给客户端。
- en: Warning
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be aware that if you install a library file to be readable by your web server,
    you don’t have much security if other developers use the same server. Any of those
    developers can write a web script to read and display your library file because,
    by default, the script runs with the permissions of the web server and thus will
    have access to the library.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你将一个库文件安装为可被你的 Web 服务器读取，那么如果其他开发人员也使用同一台服务器，你的安全性就不高了。任何这些开发人员都可以编写一个
    Web 脚本来读取和显示你的库文件，因为默认情况下，脚本以 Web 服务器的权限运行，因此可以访问该库。
- en: The recipes that follow demonstrate how to write, for each API, a library file
    that contains a routine for connecting to the `cookbook` database on the MySQL
    server. The calling program can use the error-checking techniques discussed in
    [Recipe 4.2](#nch-api-api-error) to determine whether a connection attempt fails.
    The connection routine for each language returns a database handle or connection
    object when it succeeds or raises an exception if the connection cannot be established.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例演示了如何为每个 API 编写一个库文件，其中包含一个用于连接到 MySQL 服务器上的 `cookbook` 数据库的例程。调用程序可以使用[第
    4.2 节](#nch-api-api-error) 中讨论的错误检查技术来确定连接尝试是否失败。每种语言的连接例程在成功时返回一个数据库句柄或连接对象，如果无法建立连接则抛出异常。
- en: Libraries are of no utility in themselves, so the following discussion illustrates
    each one’s use by a short [<q>test harness</q>](https://en.wikipedia.org/wiki/Test_harness)
    program. To use any of these harness programs as the basis for creating new programs,
    make a copy of the file and add your own code between the connect and disconnect
    calls.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 库本身没有任何用处，因此下面的讨论通过一个短的 [<q>测试驱动程序</q>](https://en.wikipedia.org/wiki/Test_harness)
    程序来说明每个库的用途。要将任何这些驱动程序作为创建新程序的基础，请复制该文件并在连接和断开调用之间添加你自己的代码。
- en: Library-file writing involves not only the question of what to put in the file
    but also subsidiary issues such as where to install the file so it is accessible
    by your programs, and (on multiuser systems such as Unix) how to set its access
    privileges so its contents aren’t exposed to people who shouldn’t see it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编写库文件不仅涉及文件中应该放入什么内容的问题，还包括诸如在何处安装文件以使其对你的程序可访问，以及（在类 Unix 的多用户系统上）如何设置其访问权限，以防止其内容暴露给不应查看它的人。
- en: Choosing a library-file installation location
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择库文件安装位置
- en: 'If you install a library file in a directory that a language processor searches
    by default, programs written in that language need do nothing special to access
    the library. However, if you install a library file in a directory that the language
    processor does not search by default, you must tell your scripts how to find it.
    There are two common ways to do this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个库文件安装在语言处理器默认搜索的目录中，那么使用该语言编写的程序无需特别操作即可访问该库。但是，如果你将一个库文件安装在语言处理器不默认搜索的目录中，你必须告诉你的脚本如何找到它。有两种常见的方法来做到这一点：
- en: Most languages provide a statement that can be used within a script to add directories
    to the language processor search path. This requires that you modify each script
    that needs the library.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数语言提供了一种语句，可以在脚本内部使用，以将目录添加到语言处理器的搜索路径中。这需要你修改需要使用该库的每个脚本。
- en: You can set an environment or configuration variable that changes the language
    processor search path. With this approach, each user who executes scripts that
    require the library must set the appropriate variable. Alternatively, if the language
    processor has a configuration file, you might be able to set a parameter in the
    file that affects scripts globally for all users.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以设置一个环境或配置变量，以更改语言处理器的搜索路径。使用这种方法，每个执行需要库的脚本的用户必须设置适当的变量。或者，如果语言处理器有一个配置文件，您可能可以在文件中设置一个影响所有用户全局脚本的参数。
- en: 'We’ll use the second approach. For our API languages, the [Table 4-3](#nch-api-api-library-path)
    shows the relevant variables. In each case, the variable value is a directory
    or list of directories:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第二种方法。对于我们的API语言，[表 4-3](#nch-api-api-library-path)展示了相关变量。在每种情况下，变量值是一个目录或目录列表：
- en: Table 4-3\. Default Library Paths
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. 默认库路径
- en: '| Language | Variable name | Variable type |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 变量名 | 变量类型 |'
- en: '| --- | --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Perl | `PERL5LIB` | Environment variable |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| Perl | `PERL5LIB` | 环境变量 |'
- en: '| Ruby | `RUBYLIB` | Environment variable |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | `RUBYLIB` | 环境变量 |'
- en: '| PHP | `include_path` | Configuration variable |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| PHP | `include_path` | 配置变量 |'
- en: '| Python | `PYTHONPATH` | Environment variable |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| Python | `PYTHONPATH` | 环境变量 |'
- en: '| Go | `GOPATH` | Environment variable |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| Go | `GOPATH` | 环境变量 |'
- en: '| Java | `CLASSPATH` | Environment variable |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| Java | `CLASSPATH` | 环境变量 |'
- en: For general information on setting environment variables, read `cmdline.pdf`
    in the recipes distribution (see the [Preface](preface01.xhtml#nch-preface)).
    You can use those instructions to set environment variables to the values in the
    following discussion.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置环境变量的一般信息，请阅读配方分发中的`cmdline.pdf`（见[前言](preface01.xhtml#nch-preface)）。您可以使用这些说明将环境变量设置为下面讨论中的值。
- en: Suppose that you want to install library files in a directory that language
    processors do not search by default. For purposes of illustration, let’s use */usr/local/lib/mcb*
    on Unix and *C:\lib\mcb* on Windows. (To put the files somewhere else, adjust
    the pathnames in the variable settings accordingly. For example, you might want
    to use a different directory, or you might want to put libraries for each language
    in separate directories.)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要将库文件安装在语言处理器默认不搜索的目录中。作为示例，让我们在Unix上使用*/usr/local/lib/mcb*，在Windows上使用*C:\lib\mcb*。（要将文件放置在其他位置，请相应调整变量设置中的路径名。例如，您可能希望使用不同的目录，或者您可能希望将每种语言的库放在单独的目录中。）
- en: 'Under Unix, if you put Perl library files in the */usr/local/lib/mcb* directory,
    set the `PERL5LIB` environment variable appropriately. For a shell in the Bourne
    shell family (*sh*, *bash*, *ksh*), set the variable like this in the appropriate
    startup file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix下，如果您将Perl库文件放在*/usr/local/lib/mcb*目录中，请适当设置`PERL5LIB`环境变量。对于Bourne shell家族（*sh*、*bash*、*ksh*）的shell，在适当的启动文件中设置变量如下：
- en: '[PRE58]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-338
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the original Bourne shell, *sh*, you may need to split this into two commands:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始的Bourne shell，*sh*，您可能需要将此分成两个命令：
- en: '[PRE59]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For a shell in the C shell family (*csh*, *tcsh*), set `PERL5LIB` like this
    in your *.login* file:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C shell家族（*csh*、*tcsh*）的shell，在您的*.login*文件中设置`PERL5LIB`如下：
- en: '[PRE60]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Under Windows, if you put Perl library files in *C:\lib\mcb*, set `PERL5LIB`
    as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows下，如果您将Perl库文件放在*C:\lib\mcb*中，请设置`PERL5LIB`如下：
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In each case, the variable value tells Perl to look in the specified directory
    for library files, in addition to any other directories it searches by default.
    If you set `PERL5LIB` to name multiple directories, the separator character between
    directory pathnames is colon (`:`) on Unix or semicolon (`;`) on Windows.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，变量值告诉Perl在指定目录中查找库文件，除了默认搜索的任何其他目录。如果将`PERL5LIB`设置为多个目录名称，则在Unix上的分隔符为冒号（`:`），在Windows上为分号（`;`）。
- en: Specify the other environment variables (`RUBYLIB`, `PYTHONPATH`, and `CLASSPATH`)
    using the same syntax.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的语法指定其他环境变量（`RUBYLIB`、`PYTHONPATH`和`CLASSPATH`）。
- en: Note
  id: totrans-347
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Setting these environment variables as just discussed should suffice for scripts
    that you run from the command line. For scripts intended to be executed by a web
    server, you likely must configure the server as well so that it can find the library
    files.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如刚刚讨论的，设置这些环境变量应足以运行从命令行运行的脚本。对于打算由Web服务器执行的脚本，您可能还必须配置服务器，以便它可以找到库文件。
- en: 'For PHP, the search path is defined by the value of the `include_path` variable
    in the *php.ini* PHP initialization file. On Unix, the file’s pathname is likely
    */usr/lib/php.ini* or */usr/local/lib/php.ini*. Under Windows, the file is likely
    found in the Windows directory or under the main PHP installation directory. To
    determine the location, run this commmand:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PHP，搜索路径由 *php.ini* PHP 初始化文件中`include_path`变量的值定义。在 Unix 上，文件的路径名可能是 */usr/lib/php.ini*
    或 */usr/local/lib/php.ini*。在 Windows 下，该文件可能位于 Windows 目录或主 PHP 安装目录下。要确定位置，请运行以下命令：
- en: '[PRE62]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the value of `include_path` in *php.ini* with a line like this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下行在 *php.ini* 中定义`include_path`的值：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Specify *`value`* using the same syntax as for environment variables that name
    directories. That is, it’s a list of directory names, with the names separated
    by colons on Unix or semicolons on Windows. On Unix, if you want PHP to look for
    include files in the current directory and in */usr/local/lib/mcb*, set `include_path`
    like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与环境变量命名目录相同的语法指定 *`value`*。也就是说，它是一个目录名称列表，在 Unix 上用冒号分隔，在 Windows 上用分号分隔。在
    Unix 上，如果您希望 PHP 在当前目录和 */usr/local/lib/mcb* 中查找包含文件，请像这样设置`include_path`：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'On Windows, to search the current directory and *C:\lib\mcb*, set `include_path`
    like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，要在当前目录和 *C:\lib\mcb* 中搜索，请像这样设置`include_path`：
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If PHP is running as an Apache module, restart Apache to make *php.ini* changes
    take effect.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PHP 作为 Apache 模块运行，请重新启动 Apache 以使 *php.ini* 更改生效。
- en: Setting library-file access privileges
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置库文件的访问权限
- en: 'If you use a multiple-user system such as Unix, you must make decisions about
    library-file ownership and access mode:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用类 Unix 的多用户系统，必须对库文件的所有权和访问模式做出决策：
- en: 'If a library file is private and contains code to be used only by you, place
    the file under your own account and make it accessible only to you. Assuming that
    a library file named *mylib* is already owned by you, you can make it private
    like this:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库文件是私有的，并且仅包含您自己使用的代码，请将该文件放在您自己的帐户下，并且仅对您可访问。假设名为 *mylib* 的库文件已由您拥有，您可以像这样使其私有：
- en: '[PRE66]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If the library file is to be used only by your web server, install it in a
    server library directory and make it owned by and accessible only to the server
    user ID. You may need to be `root` to do this. For example, if the web server
    runs as `wwwusr`, the following commands make the file private to that user:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库文件仅由您的 Web 服务器使用，请将其安装在服务器库目录中，并使其由服务器用户 ID 拥有和仅限该用户访问。您可能需要以`root`身份执行此操作。例如，如果
    Web 服务器以`wwwusr`身份运行，则以下命令将文件设为仅该用户私有：
- en: '[PRE67]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the library file is public, you can place it in a location that your programming
    language searches automatically when it looks for libraries. (Most language processors
    search for libraries in some default set of directories, although this set can
    be influenced by setting environment variables as described previously.) You may
    need to be `root` to install files in one of these directories. Then you can make
    the file world readable:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果库文件是公共的，您可以将其放在编程语言在查找库时自动搜索的位置。 （大多数语言处理器在某些默认目录中搜索库，尽管可以通过设置环境变量来影响此集合，如前述所述。）您可能需要以`root`身份在其中一个目录中安装文件。然后您可以将文件设为全局可读：
- en: '[PRE68]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now let’s construct a library for each API. Each section here demonstrates how
    to write the library file itself and discusses how to use the library from within
    programs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为每个 API 构建一个库。本节的每个部分演示了如何编写库文件本身，并讨论了如何从程序内部使用该库。
- en: Perl
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl
- en: 'In Perl, library files are called modules and typically have an extension of
    *.pm* (<q>Perl module</q>). It’s conventional for the basename of a module file
    to be the same as the identifier on the `package` line in the file. The following
    file, *Cookbook.pm*, implements a module named `Cookbook`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Perl 中，库文件称为模块，通常具有 *.pm* 扩展名（Perl 模块）。约定的是模块文件的基本名称与文件中`package`行上的标识符相同。以下文件
    *Cookbook.pm* 实现了一个名为`Cookbook`的模块：
- en: '[PRE69]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The module encapsulates the code for establishing a connection to the MySQL
    server into a `connect()` method, and the `package` identifier establishes a `Cookbook`
    namespace for the module. To invoke the `connect()` method, use the module name:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将与建立与 MySQL 服务器的连接的代码封装到一个`connect()`方法中，而`package`标识符则为该模块建立了一个`Cookbook`命名空间。要调用`connect()`方法，请使用模块名称：
- en: '[PRE70]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The final line of the module file is a statement that trivially evaluates to
    true. (If the module doesn’t return a true value, Perl assumes that something
    is wrong with it and exits.)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文件的最后一行是一个无关紧要的评估为真的语句。如果模块没有返回真值，Perl会认为有问题并退出。
- en: 'Perl locates library files by searching the list of directories named in its
    `@INC` array. To check the default value of this variable on your system, invoke
    Perl as follows at the command line:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Perl通过搜索其`@INC`数组中命名的目录列表来定位库文件。要检查系统上此变量的默认值，请在命令行上调用Perl如下：
- en: '[PRE71]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The last part of the output from the command shows the directories listed in
    `@INC`. If you install a library file in one of those directories, your scripts
    will find it automatically. If you install the module somewhere else, tell your
    scripts where to find it by setting the `PERL5LIB` environment variable, as discussed
    in the introductory part of this recipe.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 命令输出的最后部分显示了`@INC`中列出的目录。如果在这些目录中的一个中安装了库文件，则您的脚本会自动找到它。如果在其他地方安装了模块，请通过设置`PERL5LIB`环境变量来告诉您的脚本在哪里找到它，如本文档介绍的内容。
- en: 'After installing the *Cookbook.pm* module, try it from a test harness script,
    *harness.pl*:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完*Cookbook.pm*模块后，请从测试工具脚本*harness.pl*尝试：
- en: '[PRE72]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*harness.pl* has no `use` `DBI` statement. It’s unnecessary because the `Cookbook`
    module itself imports DBI; any script that uses `Cookbook` also gains access to
    DBI.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*harness.pl*没有`use DBI`语句。这是不必要的，因为`Cookbook`模块本身导入了DBI；任何使用`Cookbook`的脚本也都可以访问DBI。'
- en: 'If you don’t catch connection errors explicitly with `eval`, you can write
    the script body more simply:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用`eval`显式捕获连接错误，则可以更简单地编写脚本主体：
- en: '[PRE73]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this case, Perl catches any connection exception and terminates the script
    after printing the error message generated by the `connect()` method.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Perl捕获任何连接异常，并在打印由`connect()`方法生成的错误消息后终止脚本。
- en: Ruby
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby
- en: 'The following Ruby library file, *Cookbook.rb*, defines a `Cookbook` class
    that implements a `connect` class method:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的Ruby库文件*Cookbook.rb*定义了一个实现`connect`类方法的`Cookbook`类：
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `connect` method is defined in the library as `Cookbook.connect` because
    Ruby class methods are defined as *`class_name.method_name`*.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect`方法在库中被定义为`Cookbook.connect`，因为Ruby类方法被定义为*`class_name.method_name`*。'
- en: 'Ruby locates library files by searching the list of directories named in its
    `$LOAD_PATH` variable (also known as `$:`), which is an array. To check the default
    value of this variable on your system, use interactive Ruby to execute this statement:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby通过搜索其名为`$LOAD_PATH`（也称为`$:`）的变量（数组）中命名的目录列表来定位库文件。要检查系统上此变量的默认值，请使用交互式Ruby执行此语句：
- en: '[PRE75]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If you install a library file in one of those directories, your scripts will
    find it automatically. If you install the file somewhere else, tell your scripts
    where to find it by setting the `RUBYLIB` environment variable, as discussed in
    the introductory part of this recipe.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这些目录中的一个中安装了库文件，则您的脚本会自动找到它。如果您在其他地方安装了文件，请通过设置`RUBYLIB`环境变量来告诉您的脚本在哪里找到它，如本文档介绍的内容。
- en: 'After installing the *Cookbook.rb* library file, try it from a test harness
    script, *harness.rb*:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完*Cookbook.rb*库文件后，请从测试工具脚本*harness.rb*尝试：
- en: '[PRE76]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '*harness.rb* has no `require` statement for the Mysql2 module. It’s unnecessary
    because the `Cookbook` module itself imports Mysql2; any script that imports `Cookbook`
    also gains access to Mysql2.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*harness.rb*没有Mysql2模块的`require`语句。这是不必要的，因为`Cookbook`模块本身导入了Mysql2；任何导入`Cookbook`的脚本也都可以访问Mysql2。'
- en: 'If you want a script to die if an error occurs without checking for an exception
    yourself, write the script body like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望脚本在出现错误时退出而不检查异常本身，请将脚本主体编写如下所示：
- en: '[PRE77]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: PHP
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: 'PHP library files are written like regular PHP scripts. A *Cookbook.php* file
    that implements a `Cookbook` class with a `connect()` method looks like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: PHP库文件就像常规的PHP脚本一样编写。实现`Cookbook`类及其`connect()`方法的*Cookbook.php*文件如下所示：
- en: '[PRE78]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `connect()` routine within the class is declared using the `static` keyword
    to make it a class method rather than an instance method. This designates it as
    directly callable without instantiating an object through which to invoke it.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在类内部声明的`connect()`例程使用`static`关键字来将其声明为类方法，而不是实例方法。这使其可以直接调用，而无需通过实例化对象来调用它。
- en: The `new` `PDO()` constructor raises an exception if the connection attempt
    fails. Following a successful attempt, `connect()` sets the error-handling mode
    so that other PDO calls raise exceptions for failure as well. This way, individual
    calls need not be tested for an error return value.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` `PDO()`构造函数如果连接尝试失败会引发异常。成功尝试后，`connect()`设置错误处理模式，使得其他PDO调用在失败时也会引发异常。这样，不需要为每个调用测试错误返回值。'
- en: Although most PHP examples throughout this book don’t show the `<?php` and `?>`
    tags, I’ve shown them as part of *Cookbook.php* here to emphasize that library
    files must enclose all PHP code within those tags. The PHP interpreter makes no
    assumptions about the contents of a library file when it begins parsing it because
    you might include a file that contains nothing but HTML. Therefore, you must use
    `<?php` and `?>` to specify explicitly which parts of the library file should
    be considered as PHP code rather than as HTML, just as you do in the main script.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书中大多数PHP示例没有显示`<?php`和`?>`标签，但我在这里显示它们作为*Cookbook.php*的一部分，以强调库文件必须将所有PHP代码置于这些标签内。PHP解释器在开始解析库文件时不会对其内容做出任何假设，因为您可能包含一个只包含HTML的文件。因此，您必须使用`<?php`和`?>`显式指定库文件的哪些部分应被视为PHP代码而不是HTML，就像在主脚本中所做的那样。
- en: PHP looks for libraries by searching the directories named in the `include_path`
    variable in the PHP initialization file, as described in the introductory part
    of this recipe.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: PHP通过在PHP初始化文件中描述的`include_path`变量命名的目录中搜索库文件。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: PHP scripts often are placed in the document tree of your web server, and clients
    can request them directly. For PHP library files, we recommend that you place
    them somewhere outside the document tree, especially if (like *Cookbook.php*)
    they contain a username and password.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: PHP脚本通常放置在您的Web服务器文档树中，客户端可以直接请求它们。对于PHP库文件，我们建议将它们放在文档树之外的某个地方，特别是像*Cookbook.php*这样的文件，如果包含用户名和密码的话。
- en: 'After installing *Cookbook.php* in one of the `include_path` directories, try
    it from a test harness script, *harness.php*:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 将*Cookbook.php*安装在`include_path`目录之一后，可以从测试用例脚本*harness.php*中尝试它：
- en: '[PRE79]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `require_once` statement accesses the *Cookbook.php* file that is required
    to use the `Cookbook` class. `require_once` is one of several PHP file-inclusion
    statements:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`require_once`语句访问所需使用`Cookbook`类的*Cookbook.php*文件。`require_once`是几个PHP文件包含语句之一：'
- en: '`require` and `include` instruct PHP to read the named file. They are similar,
    but `require` terminates the script if the file cannot be found; `include` produces
    only a warning.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`和`include`指示PHP读取指定的文件。它们类似，但是如果找不到文件，`require`会终止脚本；`include`只会产生警告。'
- en: '`require_once` and `include_once` are like `require` and `include` except that
    if the file has already been read, its contents are not processed again. This
    is useful for avoiding multiple-declaration problems that can easily occur when
    library files include other library files.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require_once`和`include_once`与`require`和`include`类似，但如果文件已经被读取，则不会再次处理其内容。这对于避免在库文件包含其他库文件时可能出现的多次声明问题非常有用。'
- en: Python
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: 'Python libraries are written as modules and referenced from scripts using `import`
    statements. To create a method for connecting to MySQL, write a module file, *cookbook.py*
    (Python module names should be lowercase):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Python库被编写为模块，并通过`import`语句从脚本中引用。要创建连接到MySQL的方法，请编写一个模块文件*cookbook.py*（Python模块名称应为小写）：
- en: '[PRE80]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The filename basename determines the module name, so the module is called `cookbook`.
    Module methods are accessed through the module name; thus, import the `cookbook`
    module and invoke its `connect()` method like this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名的基本名称确定模块名称，因此该模块被称为`cookbook`。可以通过模块名称访问模块方法；因此，导入`cookbook`模块并调用其`connect()`方法如下：
- en: '[PRE81]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The Python interpreter searches for modules in directories named in the `sys.path`
    variable. To check the default value of `sys.path` on your system, run Python
    interactively and enter a few commands:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器通过`sys.path`变量中命名的目录搜索模块。要检查系统上`sys.path`的默认值，请在Python交互模式下运行，并输入几个命令：
- en: '[PRE82]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If you install *cookbook.py* in one of the directories named by `sys.path`,
    your scripts will find it with no special handling. If you install *cookbook.py*
    somewhere else, you must set the `PYTHONPATH` environment variable, as discussed
    in the introductory part of this recipe.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将*cookbook.py*安装在由`sys.path`命名的目录之一中，则您的脚本将无需特殊处理即可找到它。如果您将*cookbook.py*安装在其他地方，则必须设置`PYTHONPATH`环境变量，如本教程的介绍部分所述。
- en: 'After installing the *cookbook.py* library file, try it from a test harness
    script, *harness.py*:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 *cookbook.py* 库文件后，可以通过测试用的 *harness.py* 脚本进行尝试：
- en: '[PRE83]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The *cookbook.py* file imports the `mysql.connector` module, but a script that
    imports `cookbook` does not thereby gain access to `mysql.connector`. If the script
    needs Connector/Python-specific information (such as `mysql.connector.Error`),
    the script itself must import `mysql.connector`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*cookbook.py* 文件导入了 `mysql.connector` 模块，但导入 `cookbook` 的脚本并不能因此获得对 `mysql.connector`
    的访问权限。如果脚本需要 Connector/Python 特定的信息（如 `mysql.connector.Error`），则脚本本身必须导入 `mysql.connector`。'
- en: 'If you want a script to die if an error occurs without checking for an exception
    yourself, write the script body like this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望脚本在发生错误时退出而无需自行检查异常，请像这样编写脚本体：
- en: '[PRE84]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Go
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go
- en: Go programs are organized into packages that are a collection of the source
    files, located in the same directory. Packages, in their turn, are organized into
    modules that are collections of Go packages that are released together. Modules
    belong to a Go repository. A typical Go repository contains only one module, but
    you may have several modules in the same repository.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Go 程序被组织成包，这些包是位于同一目录中的源文件集合。包又被组织成模块，这些模块是一起发布的 Go 包的集合。模块属于 Go 代码库。一个典型的 Go
    代码库只包含一个模块，但在同一个代码库中可以有多个模块。
- en: The Go interpreter searches for packages in directories named in the `$GOPATH/src/{domain}/{project}`
    variable. However, when using modules, Go is no longer uses `GOPATH`. You do not
    need to change this variable no matter where your module is installed. We will
    use modules for our examples.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Go 解释器在名为 `$GOPATH/src/{domain}/{project}` 的目录中搜索包。但是，使用模块时，Go 不再使用 `GOPATH`。无论您的模块安装在何处，都不需要更改此变量。我们将在示例中使用模块。
- en: 'To create a method for connecting to MySQL, write a package file, *cookbook.go*:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建连接到 MySQL 的方法，编写一个名为 *cookbook.go* 的包文件：
- en: '[PRE85]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The filename basename does not determine the package name: Go searches through
    all files in the import path until it finds the one with the required package
    declaration. Package methods are accessed via the package name.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名的基本名称不确定包的名称：Go 通过导入路径中的所有文件搜索，直到找到具有所需包声明的文件。包方法通过包名访问。
- en: 'To test the package you can specify relative path to the directory where the
    package file is located:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试包，可以指定包文件所在目录的相对路径：
- en: '[PRE86]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is very easy way to quickly test your libraries but such commands, as *go
    install* would not work for packages, imported this way. As a result, your program
    will be rebuilt from scratch each time you access it.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常简单的方法来快速测试您的库，但是像 *go install* 这样的命令不能用于以这种方式导入的包。因此，每次访问时都会从头开始重建您的程序。
- en: 'Better way to work with packages is to publish them as part of modules. To
    do it, run following in the directory where you store `cookbook.go`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的处理包的方式是将它们作为模块的一部分发布。要执行此操作，请在存储 `cookbook.go` 的目录中运行以下命令：
- en: '[PRE87]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This will create file `go.mod` that will have your module name and version of
    Go. You can name the module as you wish.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含您的模块名称和 Go 版本的 `go.mod` 文件。您可以根据需要命名模块。
- en: You can publish your module on the Internet and access it from the local program
    as you would do with any other module. However, during development, it would be
    useful to have the module only locally. In this case you need to make few adjustments
    in the program directory that will use it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将模块发布到互联网并像处理任何其他模块一样从本地程序中访问它。但在开发过程中，仅在本地使用该模块将非常有用。在这种情况下，您需要在将使用它的程序目录中进行一些调整。
- en: 'First, create a program that will call the package, `harness.go`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个将调用包的程序，`harness.go`：
- en: '[PRE88]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, in the directory, there the package is installed, initialize the module:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在安装包的目录中，初始化模块：
- en: '[PRE89]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Once the module is initialized and `go.mod` is created edit it with:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 模块初始化完成并创建了 `go.mod` 后，通过以下方式编辑它：
- en: '[PRE90]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Replace URL and the local path with the ones, valid in your environment.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 用您环境中有效的 URL 和本地路径替换它们。
- en: This command will tell Go to replace remote module path with local directory.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将告诉 Go 使用本地目录替换远程模块路径。
- en: 'Once done, you can test your connection:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以测试您的连接：
- en: '[PRE91]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Java
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: 'Java library files are similar to Java programs in most ways:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Java 库文件在大多数方面与 Java 程序相似：
- en: The `class` line in the source file indicates a class name.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件中的 `class` 行指示了一个类名。
- en: The file should have the same name as the class (with a *.java* extension).
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件应与类名相同（使用 *.java* 扩展名）。
- en: Compile the *.java* file to produce a *.class* file.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译*.java*文件以生成*.class*文件。
- en: 'Java library files also differ from Java programs in some ways:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Java库文件在某些方面也与Java程序不同：
- en: Unlike regular program files, Java library files have no `main()` function.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与常规程序文件不同，Java库文件没有`main()`函数。
- en: A library file should begin with a `package` identifier that specifies the position
    of the class within the Java namespace.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个库文件应该以指定类在Java命名空间中位置的`package`标识符开始。
- en: 'A common convention for Java package identifiers is to use the domain of the
    code author as a prefix; this helps make identifiers unique and avoids conflict
    with classes written by other authors. Domain names proceed right to left from
    more general to more specific within the domain namespace, whereas the Java class
    namespace proceeds left to right from general to specific. Thus, to use a domain
    as the prefix for a package name within the Java class namespace, it’s necessary
    to reverse it. For example, Paul’s domain is *kitebird.com*, so if he writes a
    library file and places it under `mcb` within his domain’s namespace, the library
    begins with a `package` statement like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Java包标识符的常见约定是使用代码作者的域作为前缀；这有助于使标识符保持唯一，并避免与其他作者编写的类发生冲突。域名在域命名空间中从右向左逐渐具体化，而Java类命名空间则从左向右从一般到特定。因此，要在Java类命名空间中使用域作为包名的前缀，需要对其进行反转。例如，Paul的域名是*kitebird.com*，因此如果他编写一个库文件并将其放在其域命名空间中的`mcb`下，则库文件以如下`package`语句开头：
- en: '[PRE92]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Java packages developed for this book are placed within the `com.kitebird.mcb`
    namespace to ensure their uniqueness in the package namespace.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Java命名空间中的唯一性，本书开发的Java包位于`com.kitebird.mcb`命名空间内。
- en: 'The following library file, *Cookbook.java*, defines a `Cookbook` class that
    implements a `connect()` method for connecting to the `cookbook` database. `connect()`
    returns a `Connection` object if it succeeds and throws an exception otherwise.
    To help the caller deal with failures, the `Cookbook` class also defines `getErrorMessage()`
    and `printErrorMessage()` utility methods that return the error message as a string
    and print it to `System.err`, respectively:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的库文件*Cookbook.java*定义了一个`Cookbook`类，实现了一个`connect()`方法用于连接到`cookbook`数据库。如果`connect()`成功，则返回一个`Connection`对象，否则抛出异常。为了帮助调用者处理失败，`Cookbook`类还定义了`getErrorMessage()`和`printErrorMessage()`实用方法，分别返回错误消息字符串并将其打印到`System.err`：
- en: '[PRE93]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The routines within the class are declared using the `static` keyword, which
    makes them class methods rather than instance methods. That is done here because
    the class is used directly rather than creating an object from it and invoking
    the methods through the object.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的例程使用`static`关键字声明，这使它们成为类方法而不是实例方法。之所以这样做是因为该类是直接使用而不是从中创建对象并通过对象调用方法。
- en: To use the *Cookbook.java* file, compile it to produce *Cookbook.class*, then
    install the class file in a directory that corresponds to the package identifier.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用*Cookbook.java*文件，首先编译它以生成*Cookbook.class*，然后将类文件安装在与包标识符对应的目录中。
- en: This means that *Cookbook.class* should be installed in a directory named *com/kitebird/mcb*
    (Unix) or *com\kitebird\mcb* (Windows) that is located under some directory named
    in your `CLASSPATH` setting. For example, if `CLASSPATH` includes */usr/local/lib/mcb*
    under Unix, you can install *Cookbook.class* in the */usr/local/lib/mcb/com/kitebird/mcb*
    directory. (For more information about the `CLASSPATH` variable, see the Java
    discussion in [Recipe 4.1](#nch-api-api-connect).)
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着*Cookbook.class*应安装在名为*com/kitebird/mcb*（Unix）或*com\kitebird\mcb*（Windows）的目录中，该目录位于您的`CLASSPATH`设置中指定的某个目录下。例如，如果在Unix下`CLASSPATH`包含*/usr/local/lib/mcb*，则可以将*Cookbook.class*安装在*/usr/local/lib/mcb/com/kitebird/mcb*目录下。（有关`CLASSPATH`变量的更多信息，请参阅[Recipe
    4.1](#nch-api-api-connect)中的Java讨论。）
- en: 'To use the `Cookbook` class from within a Java program, import it and invoke
    the `Cookbook.connect()` method. The following test harness program, *Harness.java*,
    shows how to do this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Java程序中使用`Cookbook`类，导入它并调用`Cookbook.connect()`方法。以下测试框架程序*Harness.java*展示了如何做到这一点：
- en: '[PRE94]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '*Harness.java* also shows how to use the error message utility methods from
    the `Cookbook` class when a MySQL-related exception occurs:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '*Harness.java*还展示了当发生MySQL相关异常时如何使用`Cookbook`类的错误消息实用方法：'
- en: '`printErrorMessage()` takes the exception object and uses it to print an error
    message to `System.err`.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printErrorMessage()`接受异常对象并用它打印错误消息到`System.err`。'
- en: '`getErrorMessage()` returns the error message as a string. You can display
    the message yourself, write it to a logfile, or whatever.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getErrorMessage()` 返回错误消息作为字符串。你可以自行显示该消息，将其写入日志文件，或者其他操作。'
- en: 4.4 Executing Statements and Retrieving Results
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 执行语句和检索结果
- en: Problem
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a program to send an SQL statement to the MySQL server and retrieve
    its result.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个程序向 MySQL 服务器发送 SQL 语句并检索其结果。
- en: Solution
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Some statements return only a status code; others return a result set (a set
    of rows). Some APIs provide different methods for executing each type of statement.
    If so, use the appropriate method for the statement to be executed.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语句仅返回状态代码；其他则返回结果集（一组行）。某些 API 提供了执行每种类型语句的不同方法。如果是这样，请使用适当的方法执行要执行的语句。
- en: Discussion
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You can execute two general categories of SQL statements. Some retrieve information
    from the database; others change that information or the database itself. Statements
    in the two categories are handled differently. In addition, some APIs provide
    multiple routines for executing statements, complicating matters further. Before
    we get to examples demonstrating how to execute statements from within each API,
    we’ll describe the database table the examples use, and then further discuss the
    two statement categories and outline a general strategy for processing statements
    in each category.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以执行两类通用的 SQL 语句。一些从数据库检索信息；其他则更改信息或数据库本身。这两类语句有不同的处理方式。此外，一些 API 提供多个例程来执行语句，进一步增加了复杂性。在我们演示如何从每个
    API 内部执行语句的示例之前，我们将描述示例使用的数据库表，并进一步讨论这两类语句，并概述处理每类语句的一般策略。
- en: 'In [Chapter 1](ch01.xhtml#nch-mysql), we created a table named `limbs` to try
    some sample statements. In this chapter, we’ll use a different table named `profile`.
    It’s based on the idea of a <q>buddy list,</q> that is, the set of people we like
    to keep in touch with while we’re online. The table definition looks like this:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 1 章](ch01.xhtml#nch-mysql)中，我们创建了一个名为`limbs`的表来尝试一些示例语句。在本章中，我们将使用名为`profile`的不同表。它基于一个<q>好友列表</q>的概念，即我们在线时想要保持联系的人。该表的定义如下：
- en: '[PRE95]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `profile` table indicates the things that are important to us about each
    buddy: name, age, favorite color, favorite foods, and number of cats. Additionally,
    the table uses several different data types for its columns, and these come in
    handy to illustrate how to solve problems that pertain to specific data types.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`profile`表指示我们关于每个好友重要的事情：姓名、年龄、喜欢的颜色、喜欢的食物和猫的数量。此外，该表使用多种不同的数据类型作为其列，并且这些类型对于说明如何解决特定数据类型相关的问题非常有用。'
- en: The table also includes an `id` column containing unique values so that we can
    distinguish one row from another, even if two buddies have the same name. `id`
    and `name` are declared as `NOT` `NULL` because they’re each required to have
    a value. The other columns are implicitly permitted to be `NULL` (and that is
    also their default value) because we might not know the value to assign them for
    any given individual. That is, `NULL` signifies <q>unknown.</q>
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 该表还包括一个`id`列，其中包含唯一的值，以便我们可以区分一行与另一行，即使两个好友有相同的名字。`id`和`name`被声明为`NOT NULL`，因为它们各自需要有一个值。其他列隐式允许为`NULL`（这也是它们的默认值），因为我们可能不知道为任何给定个体分配的值。也就是说，`NULL`表示<q>未知</q>。
- en: 'Notice that although we want to keep track of age, there is no `age` column
    in the table. Instead, there is a `birth` column of `DATE` type. Ages change,
    so if we store age values, we’d have to keep updating them. Storing birth dates
    is better: they don’t change and can be used to calculate age any time (see [Recipe
    8.14](ch08.xhtml#nch-dates-dates-age)). `color` is an `ENUM` column; color values
    can be any one of the listed values. `foods` is a `SET`, which permits the value
    to be any combination of the individual set members. That way we can record multiple
    favorite foods for any buddy.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们想追踪年龄，但表中没有`age`列。相反，有一个`DATE`类型的`birth`列。年龄会变化，因此如果存储年龄值，我们将不得不不断更新它们。存储出生日期更好：它们不会改变，并且可以随时用来计算年龄（参见[Recipe
    8.14](ch08.xhtml#nch-dates-dates-age)）。`color`是一个`ENUM`列；颜色值可以是所列出的任何一个值。`foods`是一个`SET`，允许值是个别集合成员的任意组合。这样我们可以记录每个好友的多个喜欢的食物。
- en: 'To create the table, use the *profile.sql* script in the *tables* directory
    of the `recipes` distribution. Change location into that directory, then run this
    command:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建表格，请使用`recipes`分发中`tables`目录下的*profile.sql*脚本。切换到该目录，然后运行以下命令：
- en: '[PRE96]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The script also loads sample data into the table. You can experiment with the
    table, then restore it if you change its contents by running the script again.
    (See the final section of this chapter on the importance of restoring the `profile`
    table after modifying it.)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还将示例数据加载到表中。您可以对表进行实验，然后如果修改了其内容，可以再次运行脚本来恢复它。（请参阅本章末尾关于修改后重要性的`profile`表的恢复。）
- en: 'The contents of the `profile` table as loaded by the *profile.sql* script look
    like this:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 由*profile.sql*脚本加载的`profile`表内容如下所示：
- en: '[PRE97]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Although most of the columns in the `profile` table permit `NULL` values, none
    of the rows in the sample dataset actually contain `NULL` yet. (We want to defer
    the complications of `NULL` value processing to [Recipe 4.5](#nch-api-api-quoting)
    and [Recipe 4.7](#nch-api-api-null).)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`profile`表中大多数列允许`NULL`值，但样本数据集中的行实际上都不包含`NULL`值。我们将`NULL`值处理的复杂性推迟到[Recipe
    4.5](#nch-api-api-quoting)和[Recipe 4.7](#nch-api-api-null)。
- en: SQL statement categories
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL语句的分类
- en: 'SQL statements can be grouped into two broad categories, depending on whether
    they return a result set (a set of rows):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: SQL语句可以根据是否返回结果集（一组行）分为两大类：
- en: 'Statements that return no result set, such as `INSERT`, `DELETE`, or `UPDATE`.
    As a general rule, statements of this type generally change the database in some
    way. There are some exceptions, such as `USE` *`db_name`*, which changes the default
    (current) database for your session without making any changes to the database
    itself. The example data-modifying statement used in this section is an `UPDATE`:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不返回结果集的语句，例如`INSERT`、`DELETE`或`UPDATE`。一般而言，这类语句通常会对数据库进行某种形式的更改。也有例外情况，比如`USE`
    *`db_name`*，它会改变你会话的默认数据库而不对数据库本身进行任何更改。本节中用到的数据修改语句是`UPDATE`：
- en: '[PRE98]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We’ll cover how to execute this statement and determine the number of rows that
    it affects.
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将介绍如何执行此语句并确定它影响的行数。
- en: 'Statements that return a result set, such as `SELECT`, `SHOW`, `EXPLAIN`, or
    `DESCRIBE`. I refer to such statements generically as `SELECT` statements, but
    you should understand that category to include any statement that returns rows.
    The example row-retrieval statement used in this section is a `SELECT`:'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果集的语句，例如`SELECT`、`SHOW`、`EXPLAIN`或`DESCRIBE`。我通常把这些语句泛称为`SELECT`语句，但你应理解这一类别包括返回行的任何语句。本节中用到的行检索语句是`SELECT`：
- en: '[PRE99]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We’ll cover how to execute this statement, fetch the rows in the result set,
    and determine the number of rows and columns in the result set. (To get information
    such as the column names or data types, access the result set metadata. That’s
    [Recipe 12.2](ch12.xhtml#nch-meta-meta-result).)
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将介绍如何执行此语句、获取结果集中的行，并确定结果集中的行数和列数。（要获取诸如列名或数据类型的信息，请访问结果集元数据。这在[Recipe 12.2](ch12.xhtml#nch-meta-meta-result)中。）
- en: The first step in processing an SQL statement is to send it to the MySQL server
    for execution. Some APIs (those for Perl, and Java, for example) recognize a distinction
    between the two categories of statements and provide separate calls for executing
    them. Other APIs (such as the one for Python or Ruby) have a single call used
    for all statements. However, one thing all APIs have in common is that no special
    character indicates the end of the statement. No terminator is necessary because
    the end of the statement string terminates it. This differs from executing statements
    in the *mysql* program, where you terminate statements using a semicolon (`;`)
    or `\g`. (It also differs from how this book usually includes semicolons in examples
    to make it clear where statements end.)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 处理SQL语句的第一步是将其发送到MySQL服务器执行。某些API（如Perl和Java）识别这两类语句并为其提供单独的调用。其他API（如Python或Ruby）使用单一调用来执行所有语句。不过，所有API都共同点是没有特殊字符表示语句的结束。不需要终止符，因为语句字符串的结尾就是其终止符。这与在*mysql*程序中执行语句不同，在那里你使用分号(`;`)或`\g`来终止语句。（这也不同于本书通常在示例中包含分号以明确语句结束的方式。）
- en: When you send a statement to the server, be prepared to handle errors if it
    did not execute successfully. If a statement fails and you proceed on the basis
    that it succeeded, your program won’t work. For the most part, this section does
    not show error-checking code, but that is for brevity. Production code always
    should include error handling. The sample scripts in the `recipes` distribution
    from which the examples are taken do include error handling, based on the techniques
    illustrated in [Recipe 4.2](#nch-api-api-error).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向服务器发送语句时，要准备好处理执行失败的错误。如果语句执行失败但你仍然基于其成功继续执行，你的程序将无法正常工作。大多数情况下，本节不显示错误检查代码，这是为了简洁。实际生产代码中应始终包括错误处理。示例脚本中的`recipes`分发从中提取示例包含基于[Recipe
    4.2](#nch-api-api-error)展示的技术的错误处理。
- en: If a statement does execute without error, your next step depends on the statement
    type. If it’s one that returns no result set, there’s nothing else to do, unless
    you want to check how many rows were affected. If the statement does return a
    result set, fetch its rows, then close the result set. In a context where you
    don’t know whether a statement returns a result set, [Recipe 12.2](ch12.xhtml#nch-meta-meta-result)
    discusses how to tell.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句成功执行且没有错误，接下来的步骤取决于语句类型。如果是不返回结果集的语句，则无需进一步操作，除非你想检查影响了多少行。如果语句返回结果集，则获取其行并关闭结果集。在不确定语句是否返回结果集的上下文中，[Recipe
    12.2](ch12.xhtml#nch-meta-meta-result)讨论了如何判断。
- en: Perl
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl
- en: 'The Perl DBI module provides two basic approaches to SQL statement execution,
    depending on whether you expect to get back a result set. For a statement such
    as `INSERT` or `UPDATE` that returns no result set, use the database handle `do()`
    method. It executes the statement and returns the number of rows affected by it,
    or `undef` if an error occurs. If Sybil gets a new cat, the following statement
    increments her `cats` count by one:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Perl DBI模块提供了两种基本的SQL语句执行方法，取决于是否期望得到结果集。对于像`INSERT`或`UPDATE`这样不返回结果集的语句，使用数据库句柄的`do()`方法。它执行语句并返回受其影响的行数，或者如果发生错误则返回`undef`。如果Sybil有了一只新猫，下面的语句会将她的`cats`计数增加一：
- en: '[PRE100]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If the statement executes successfully but affects no rows, `do()` returns
    a special value, `"0E0"` (the value zero in scientific notation, expressed as
    a string). `"0E0"` can be used for testing the execution status of a statement
    because it is true in Boolean contexts (unlike `undef`). For successful statements,
    it can also be used when counting how many rows were affected because it is treated
    as the number zero in numeric contexts. Of course, if you print that value as
    is, you’ll print `"0E0"`, which might look odd to people who use your program.
    The preceding example makes sure that doesn’t happen by adding zero to the value
    to coerce it to numeric form so that it displays as `0`. Alternatively, use `printf`
    with a `%d` format specifier to cause an implicit numeric conversion:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句成功执行但未影响任何行，`do()`将返回特殊值`"0E0"`（科学计数法下的零，表示为字符串）。在测试语句执行状态时，可以使用`"0E0"`因为它在布尔上下文中为真（与`undef`不同）。对于成功的语句，它还可用于计算受影响行数，因为在数值上下文中它被视为零。当然，如果直接打印该值，会显示为`"0E0"`，这可能对使用你的程序的人来说看起来很奇怪。前面的示例通过将零加到该值以强制其转换为数值形式来确保不会发生这种情况，以便显示为`0`。或者，使用`printf`和`%d`格式说明符以导致隐式数值转换：
- en: '[PRE101]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If `RaiseError` is enabled, your script terminates automatically for DBI-related
    errors, so you need not check `$count` to find out whether `do()` failed and consequently
    can simplify the code:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了`RaiseError`，你的脚本会在DBI相关错误时自动终止，因此无需检查`$count`来查找`do()`是否失败，从而简化代码：
- en: '[PRE102]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To process a statement such as `SELECT` that does return a result set, use
    a different approach that involves these steps:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理像`SELECT`这样返回结果集的语句，需采用不同的方法：
- en: Specify the statement to be executed by calling `prepare()` using the database
    handle. `prepare()` returns a statement handle to use with all subsequent operations
    on the statement. (If an error occurs, the script terminates if `RaiseError` is
    enabled; otherwise, `prepare()` returns `undef`.)
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用数据库句柄调用`prepare()`指定要执行的语句。`prepare()`返回一个语句句柄，用于后续所有操作。如果发生错误且启用了`RaiseError`，脚本将终止；否则，`prepare()`返回`undef`。
- en: Call `execute()` to execute the statement and generate the result set.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`execute()`来执行语句并生成结果集。
- en: Loop to fetch the rows returned by the statement. DBI provides several methods
    for this; we cover them shortly.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环获取语句返回的行。DBI提供了几种方法，我们很快会介绍它们。
- en: If you don’t fetch the entire result set, release resources associated with
    it by calling `finish()`.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不获取整个结果集，请通过调用 `finish()` 来释放与其关联的资源。
- en: 'The following example illustrates these steps, using `fetchrow_array()` as
    the row-fetching method and assuming that `RaiseError` is enabled so that errors
    terminate the script:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了这些步骤，使用 `fetchrow_array()` 作为获取行的方法，并假定启用了 `RaiseError` 以便错误终止脚本：
- en: '[PRE103]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The row array size indicates the number of columns in the result set.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 行数组大小表示结果集中的列数。
- en: The row-fetching loop just shown is followed by a call to `finish()`, which
    closes the result set and tells the server to free any resources associated with
    it. If you fetch every row in the set, DBI notices when you reach the end and
    releases the resources for you. Thus, the example could omit the `finish()` call
    without ill effect.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才显示的获取行循环后调用了 `finish()`，它关闭了结果集并告诉服务器释放与其关联的任何资源。如果获取了集合中的每一行，DBI 在到达末尾时会注意到并为你释放资源。因此，示例可以省略
    `finish()` 调用而不会产生任何不良影响。
- en: As the example illustrates, to determine how many rows a result set contains,
    count them while fetching them. Do not use the DBI `rows()` method for this purpose.
    The DBI documentation discourages this practice because `rows()` is not necessarily
    reliable for `SELECT` statements—due to differences in behavior among database
    engines and drivers.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，当获取行时同时计数可以确定结果集包含的行数。不要使用 DBI 的 `rows()` 方法来达到此目的。DBI 文档不建议这种做法，因为 `rows()`
    对于 `SELECT` 语句并不一定可靠——由于不同数据库引擎和驱动程序的行为差异。
- en: DBI has several methods that fetch a row at a time. The one used in the preceding
    example, `fetchrow_array()`, returns an array containing the next row, or an empty
    list when there are no more rows. Array elements are present in the order named
    in the `SELECT` statement. Access them as `$val[0]`, `$val[1]`, and so forth.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: DBI 有几种一次获取一行的方法。在前面的例子中使用的 `fetchrow_array()` 方法返回一个包含下一行的数组，或者当没有更多行时返回一个空列表。数组元素按照
    `SELECT` 语句中指定的顺序存在。可以使用 `$val[0]`，`$val[1]` 等来访问它们。
- en: The `fetchrow_array()` method is most useful for statements that explicitly
    name the columns to select. (With `SELECT` `*`, there are no guarantees about
    the positions of columns within the array.)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchrow_array()` 方法对于显式命名要选择的列的语句最为有用。（使用 `SELECT *`，不能保证数组中列的位置。）'
- en: '`fetchrow_arrayref()` is like `fetchrow_array()`, except that it returns a
    reference to the array, or `undef` when there are no more rows. As with `fetchrow_array()`,
    array elements are present in the order named in the statement. Access them as
    `$ref->[0]`, `$ref->[1]`, and so forth:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchrow_arrayref()` 类似于 `fetchrow_array()`，但它返回数组的引用，或者当没有更多行时返回`undef`。与
    `fetchrow_array()` 一样，数组元素按照语句中指定的顺序存在。可以使用 `$ref->[0]`，`$ref->[1]` 等来访问它们：'
- en: '[PRE104]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`fetchrow_hashref()` returns a reference to a hash structure, or `undef` when
    there are no more rows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchrow_hashref()` 返回一个指向哈希结构的引用，当没有更多行时返回`undef`：'
- en: '[PRE105]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: To access the elements of the hash, use the names of the columns selected by
    the statement (`$ref->{id}`, `$ref->{name}`, and so forth). `fetchrow_hashref()`
    is particularly useful for `SELECT` `*` statements because you can access elements
    of rows without knowing anything about the order in which columns are returned.
    You need know only their names. On the other hand, it’s more expensive to set
    up a hash than an array, so `fetchrow_hashref()` is slower than `fetchrow_array()`
    or `fetchrow_arrayref()`. It’s also possible to <q>lose</q> row elements if they
    have the same name because column names must be unique. Same-name columns are
    not uncommon for joins between tables. For solutions to this problem, see [Recipe
    16.11](ch16.xhtml#nch-multi-multi-api-col-names).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问哈希的元素，使用语句选择的列名（`$ref->{id}`，`$ref->{name}` 等）。`fetchrow_hashref()` 对于 `SELECT
    *` 语句特别有用，因为可以访问行的元素，而无需知道列返回的顺序。你只需要知道它们的名称即可。另一方面，建立哈希比建立数组更昂贵，因此 `fetchrow_hashref()`
    比 `fetchrow_array()` 或 `fetchrow_arrayref()` 更慢。如果列名重复，可能会<q>丢失</q>行元素，因为列名必须是唯一的。在表连接时，同名列并不少见。有关此问题的解决方案，请参阅
    [Recipe 16.11](ch16.xhtml#nch-multi-multi-api-col-names)。
- en: 'In addition to the statement execution methods just described, DBI provides
    several high-level retrieval methods that execute a statement and return the result
    set in a single operation. All are database-handle methods that create and dispose
    of the statement handle internally before returning the result set. The methods
    differ in the form in which they return the result. Some return the entire result
    set, others return a single row or column of the set, as summarized in the [Table 4-4](#nch-api-api-statement-select):'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刚刚描述的语句执行方法外，DBI 还提供了几种高级检索方法，这些方法执行语句并以单个操作返回结果集。所有这些方法都是数据库句柄方法，在返回结果集之前在内部创建和处理语句句柄。这些方法在返回结果集的形式上有所不同。有些返回整个结果集，其他返回集合的单行或单列，如
    [Table 4-4](#nch-api-api-statement-select) 所总结：
- en: Table 4-4\. Perl methods to retrieve results
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-4\. 检索结果的 Perl 方法
- en: '| Method | Return value |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 返回值 |'
- en: '| --- | --- |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `selectrow_array()` | First row of result set as an array |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| `selectrow_array()` | 结果集的第一行作为数组 |'
- en: '| `selectrow_arrayref()` | First row of result set as a reference to an array
    |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| `selectrow_arrayref()` | 结果集的第一行作为数组引用 |'
- en: '| `selectrow_hashref()` | First row of result set as a reference to a hash
    |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| `selectrow_hashref()` | 结果集的第一行作为哈希引用 |'
- en: '| `selectcol_arrayref()` | First column of result set as a reference to an
    array |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| `selectcol_arrayref()` | 结果集的第一列作为数组引用 |'
- en: '| `selectall_arrayref()` | Entire result set as a reference to an array of
    array references |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `selectall_arrayref()` | 整个结果集作为数组引用的数组 |'
- en: '| `selectall_hashref()` | Entire result set as a reference to a hash of hash
    references |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `selectall_hashref()` | 整个结果集作为哈希引用的哈希 |'
- en: 'Most of these methods return a reference. The exception is `selectrow_array()`,
    which selects the first row of the result set and returns an array or a scalar,
    depending on how you call it. In array context, `selectrow_array()` returns the
    entire row as an array (or the empty list if no row was selected). This is useful
    for statements from which you expect to obtain only a single row. The return value
    can be used to determine the result set size. The column count is the number of
    elements in the array, and the row count is 1 or 0:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些方法返回一个引用。`selectrow_array()` 是个例外，它选择结果集的第一行并返回一个数组或标量，具体返回取决于调用方式。在数组上下文中，`selectrow_array()`
    返回整行作为数组（如果未选择任何行则返回空列表）。这对于预期仅获取单行的语句很有用。返回值可用于确定结果集大小。列数为数组的元素个数，行数为1或0：
- en: '[PRE106]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`selectrow_arrayref()` and `selectrow_hashref()` select the first row of the
    result set and return a reference to it, or `undef` if no row was selected. To
    access the column values, treat the reference the same way you treat the return
    value from `fetchrow_arrayref()` or `fetchrow_hashref()`. The reference also provides
    the row and column counts:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectrow_arrayref()` 和 `selectrow_hashref()` 选择结果集的第一行并返回其引用，如果未选择任何行则返回`undef`。要访问列值，处理引用的方式与处理
    `fetchrow_arrayref()` 或 `fetchrow_hashref()` 返回值相同。引用还提供了行数和列数：'
- en: '[PRE107]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`selectcol_arrayref()` returns a reference to a single-column array representing
    the first column of the result set. Assuming a non-`undef` return value, access
    elements of the array as `$ref->[`*`i`*`]` for the value from row *`i`*. The number
    of rows is the number of elements in the array, and the column count is 1 or 0:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectcol_arrayref()` 返回指向结果集第一列的单列数组的引用。假设返回值不为`undef`，则可以使用 `$ref->[$i]`
    访问数组的第 *`i`* 行值。数组的元素个数即为行数，列数为1或0：'
- en: '[PRE108]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`selectall_arrayref()` returns a reference to an array containing an element
    for each row of the result. Each element is a reference to an array. To access
    row *`i`* of the result set, use `$ref->[`*`i`*`]` to get a reference to the row.
    Then treat the row reference the same way as a return value from `fetchrow_arrayref()`
    to access individual column values in the row. The result set row and column counts
    are available as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectall_arrayref()` 返回一个包含结果集每行元素的数组引用。每个元素都是一个数组的引用。要访问结果集的第 *`i`* 行，使用
    `$ref->[$i]` 获得行的引用，然后像处理 `fetchrow_arrayref()` 返回值一样访问行中的各个列值。结果集的行数和列数可按如下方式获取：'
- en: '[PRE109]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`selectall_hashref()` returns a reference to a hash, each element of which
    is a hash reference to a row of the result. To call it, specify an argument that
    indicates which column to use for hash keys. For example, if you retrieve rows
    from the `profile` table, the primary key is the `id` column:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectall_hashref()`返回对哈希的引用，其中每个元素都是结果行的哈希引用。要调用它，请指定一个参数，该参数指示要用于哈希键的列。例如，如果从`profile`表检索行，则主键是`id`列。'
- en: '[PRE110]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Access rows using the keys of the hash. For a row that has a key column value
    of `12`, the hash reference for the row is `$ref->{12}`. That row value is keyed
    on column names, which you can use to access individual column elements (for example,
    `$ref->{12}->{name}`). The result set row and column counts are available as follows:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哈希的键访问行。对于键列值为`12`的行，行的哈希引用是`$ref->{12}`。该行值以列名为键，您可以使用它们来访问单个列元素（例如，`$ref->{12}->{name}`）。结果集的行数和列数如下所示：
- en: '[PRE111]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `selectall_`*`XXX`*`()` methods are useful when you need to process a result
    set more than once because Perl DBI provides no way to <q>rewind</q> a result
    set. By assigning the entire result set to a variable, you can iterate through
    its elements multiple times.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要多次处理结果集时，`selectall_`*`XXX`*`()`方法非常有用，因为Perl DBI没有提供回放结果集的方法。通过将整个结果集分配给变量，可以多次迭代其元素。
- en: 'Take care when using the high-level methods if you have `RaiseError` disabled.
    In that case, a method’s return value may not enable you to distinguish an error
    from an empty result set. For example, if you call `selectrow_array()` in scalar
    context to retrieve a single value, an `undef` return value is ambiguous because
    it may indicate any of three things: an error, an empty result set, or a result
    set consisting of a single `NULL` value. To test for an error, check the value
    of `$DBI::errstr`, `$DBI::err`, or `$DBI::state`.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果禁用了`RaiseError`，在使用高级方法时要小心。在这种情况下，方法的返回值可能无法让您区分错误和空结果集。例如，如果以标量上下文调用`selectrow_array()`以检索单个值，则`undef`返回值是模棱两可的，因为它可能表示三种情况之一：错误、空结果集或由单个`NULL`值组成的结果集。要检测错误，请检查`$DBI::errstr`、`$DBI::err`或`$DBI::state`的值。
- en: Ruby
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby
- en: The Ruby Mysql2 API uses the same calls for SQL statements that do not return
    a result set and those that do. To process a statement in Ruby use method `query`.
    If the statement fails with an error, `query` raises an exception. Otherwise,
    method `affected_rows` returns number of rows changed for the last statement that
    modify data.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的Mysql2 API使用相同的调用来处理不返回结果集和返回结果集的SQL语句。在Ruby中处理语句时，使用`query`方法。如果语句因错误而失败，`query`会抛出异常。否则，`affected_rows`方法返回修改数据的最后一条语句的行数。
- en: '[PRE112]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: For statements such as `SELECT` that return a result set, method `query` returns
    the result set as an instance of the class `Mysql2::Result`. Method `affected_rows`
    will return number of rows in the result set for such statements. You may also
    obtain number of rows in the result set by using method `count` of the `Mysql2::Result`
    object.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回结果集的`SELECT`等语句，`query`方法将结果集作为`Mysql2::Result`类的实例返回。对于这种语句，`affected_rows`方法将返回结果集中的行数。您还可以通过`Mysql2::Result`对象的`count`方法获取结果集中的行数。
- en: '[PRE113]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '`result.fields` contains the names of the columns in the result set.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`result.fields`包含结果集中列的名称。'
- en: PHP
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: 'PDO has two connection-object methods to execute SQL statements: `exec()` for
    statements that do not return a result set and `query()` for those that do. If
    you have PDO exceptions enabled, both methods raise an exception if statement
    execution fails. (Another approach couples the `prepare()` and `execute()` methods;
    see [Recipe 4.5](#nch-api-api-quoting).)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: PDO有两个连接对象方法用于执行SQL语句：`exec()`用于不返回结果集的语句，`query()`用于返回结果集的语句。如果启用了PDO异常，这两个方法在语句执行失败时都会抛出异常。（另一种方法是结合`prepare()`和`execute()`方法；请参见[Recipe
    4.5](#nch-api-api-quoting)。）
- en: 'To execute statements such as `INSERT` or `UPDATE` that don’t return rows,
    use `exec()`. It returns a count to indicate how many rows were changed:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行诸如`INSERT`或`UPDATE`等不返回行的语句，请使用`exec()`。它返回一个计数，指示更改了多少行：
- en: '[PRE114]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'For statements such as `SELECT` that return a result set, the `query()` method
    returns a statement handle. Generally, you use this object to call a row-fetching
    method in a loop, and count the rows if you need to know how many there are:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回结果集的`SELECT`等语句，`query()`方法返回一个语句句柄。通常，您使用此对象在循环中调用行提取方法，并计算行数（如果需要知道有多少行）。
- en: '[PRE115]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: To determine the number of columns in the result set, call the statement handle
    `columnCount()` method.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定结果集中列的数量，请调用语句句柄的`columnCount()`方法。
- en: The example demonstrates the statement handle `fetch()` method, which returns
    the next row of the result set or `FALSE` when there are no more. `fetch()` takes
    an optional argument that indicates what type of value it should return. As shown,
    with an argument of `PDO::FETCH_NUM`, `fetch()` returns an array with elements
    accessed using numeric subscripts, beginning with 0\. The array size indicates
    the number of result set columns.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 示例演示了语句句柄的`fetch()`方法，该方法返回结果集的下一行或在没有更多行时返回`FALSE`。`fetch()`接受一个可选参数，指示它应返回什么类型的值。如示所示，使用`PDO::FETCH_NUM`作为参数，`fetch()`返回一个数组，可以使用数值下标访问其元素，从0开始。数组大小表示结果集列数。
- en: With an argument of `PDO::FETCH_ASSOC`, `fetch()` returns an associative array
    containing values accessed by column name (`$row["id"]`, `$row["name"]`, `$row["cats"]`).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PDO::FETCH_ASSOC`作为参数，`fetch()`返回一个包含通过列名访问的值的关联数组（`$row["id"]`，`$row["name"]`，`$row["cats"]`）。
- en: With an argument of `PDO::FETCH_OBJ`, `fetch()` returns an object having members
    accessed using the column names (`$row->id`, `$row->name`, `$row->cats`).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PDO::FETCH_OBJ`作为参数，`fetch()`返回一个对象，可以使用列名访问其成员（`$row->id`，`$row->name`，`$row->cats`）。
- en: '`fetch()` uses the default fetch mode if you invoke it with no argument. Unless
    you have changed the mode, it’s `PDO::FETCH_BOTH`, which is like a combination
    of `PDO::FETCH_NUM` and `PDO::FETCH_ASSOC`. To set the default fetch mode for
    all statements executed within a connection, use the `setAttribute` database-handle
    method:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用`fetch()`而不带参数，则使用默认的提取模式。除非已更改模式，否则默认为`PDO::FETCH_BOTH`，类似于`PDO::FETCH_NUM`和`PDO::FETCH_ASSOC`的组合。要为连接中执行的所有语句设置默认提取模式，请使用`setAttribute`数据库句柄方法：
- en: '[PRE116]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To set the mode for a given statement, call its `setFetchMode()` method after
    executing the statement and before fetching the results:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 要在给定语句中设置模式，请在执行语句之后并获取结果之前调用其`setFetchMode()`方法：
- en: '[PRE117]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'It’s also possible to use a statement handle as an iterator. The handle uses
    the current default fetch mode:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将语句句柄用作迭代器。句柄使用当前默认的提取模式：
- en: '[PRE118]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `fetchAll()` method fetches and returns the entire result set as an array
    of rows. It permits an optional fetch-mode argument:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchAll()`方法将整个结果集作为行数组提取并返回。它允许一个可选的提取模式参数：'
- en: '[PRE119]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In this case, the row count is the number of elements in `$rows`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，行数是`$rows`中元素的数量。
- en: Python
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: 'The Python DB API uses the same calls for SQL statements that do not return
    a result set and those that do. To process a statement in Python, use your database
    connection object to get a cursor object. Then use the cursor’s `execute()` method
    to send the statement to the server. If the statement fails with an error, `execute()`
    raises an exception. Otherwise, if there is no result set, statement execution
    is complete, and the cursor’s `rowcount` attribute indicates how many rows were
    changed:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Python DB API对不返回结果集的SQL语句和返回结果集的SQL语句使用相同的调用方式。要在Python中处理语句，使用数据库连接对象获取游标对象。然后使用游标的`execute()`方法将语句发送到服务器。如果语句出错，`execute()`会引发异常。否则，如果没有结果集，语句执行完成，并且游标的`rowcount`属性指示更改了多少行：
- en: '[PRE120]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note
  id: totrans-570
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Python DB API specification indicates that database connections should begin
    with auto-commit mode *disabled*, so Connector/Python disables auto-commit when
    it connects to the MySQL server. If you use transactional tables, modifications
    to them are rolled back when you close the connection unless you commit the changes
    first, which is why the preceding example invokes the `commit()` method. For more
    information on auto-commit mode, see [Chapter 20](ch20.xhtml#nch-xact), particularly
    [Recipe 20.7](ch20.xhtml#nch-xact-xact-python)).
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: Python DB API规范指示，数据库连接应以禁用自动提交模式开始，因此当Connector/Python连接到MySQL服务器时，它会禁用自动提交。如果使用事务表，在关闭连接之前未提交更改，这些修改将被回滚，因此前面的示例调用了`commit()`方法。有关自动提交模式的更多信息，请参阅[第20章](ch20.xhtml#nch-xact)，特别是[Recipe
    20.7](ch20.xhtml#nch-xact-xact-python))。
- en: 'If the statement returns a result set, fetch its rows, then close the cursor.
    The `fetchone()` method returns the next row as a sequence, or `None` when there
    are no more rows:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句返回结果集，则提取其行，然后关闭游标。`fetchone()`方法将下一行作为序列返回，或者在没有更多行时返回`None`：
- en: '[PRE121]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: As you can see from the preceding example, the `rowcount` attribute is useful
    for `SELECT` statements, too; it indicates the number of rows in the result set.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`rowcount` 属性对 `SELECT` 语句也很有用；它指示结果集中的行数。
- en: '`len(row)` tells you the number of columns in the result set.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`len(row)` 告诉您结果集中的列数。'
- en: 'Alternatively, use the cursor itself as an iterator that returns each row in
    turn:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将游标本身用作迭代器，依次返回每一行：
- en: '[PRE122]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `fetchall()` method returns the entire result set as a list of tuples.
    Iterate through the list to access the rows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchall()` 方法将整个结果集作为元组列表返回。通过列表迭代以访问行：'
- en: '[PRE123]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: DB API provides no way to rewind a result set, so `fetchall()` can be convenient
    when you must iterate through the rows of the result set more than once or access
    individual values directly. For example, if `rows` holds the result set, you can
    access the value of the third column in the second row as `rows[1][2]` (indexes
    begin at 0, not 1).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: DB API 提供了一种重置结果集的方法，因此当必须多次迭代结果集的行或直接访问单个值时，`fetchall()` 很方便。例如，如果 `rows` 包含结果集，则可以通过
    `rows[1][2]` 访问第二行的第三列的值（索引从 0 开始，而不是 1）。
- en: Go
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go
- en: 'The Go `sql` interface has two connection-object functions to execute SQL statements:
    `Exec()` for statements that do not return result set and `Query()` for the statements
    that do. Both return `error` if the statement fails.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `sql` 接口有两个连接对象函数来执行 SQL 语句：`Exec()` 用于不返回结果集的语句，`Query()` 用于返回结果集的语句。如果语句失败，两者都会返回
    `error`。
- en: 'To run a statement that does not return any row, such as `INSERT`, `UPDATE`
    or `DELETE`, use the function `Exec()`. It’s return values can have one of the
    types: `Result` or `error`. Interface `Result` has a function `RowsAffected()`
    that indicates how many rows were changed.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行不返回任何行的语句（如 `INSERT`、`UPDATE` 或 `DELETE`），请使用函数 `Exec()`。其返回值可以是 `Result`
    或 `error` 类型。接口 `Result` 具有函数 `RowsAffected()`，指示更改了多少行。
- en: '[PRE124]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: For the satements that return a result set, typically `SELECT`, use the function
    `Query()`. This function returns cursor to the object of type `Rows` that holds
    the result of the query. Call the function `Next()` to iterate through the result
    and store returned values in the variables using function `Scan()`. If `Next()`
    returns `false` this means that there is no result.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回结果集的语句，通常使用函数 `Query()`。该函数返回一个 `Rows` 类型的游标对象，其中保存了查询的结果。使用函数 `Next()`
    来遍历结果，并使用函数 `Scan()` 将返回的值存储在变量中。如果 `Next()` 返回 `false`，表示没有结果。
- en: '[PRE125]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: If `Next()` is called and returns `false` the `Rows` are closed automatically.
    Otherwise you need to close them using function `Close()`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用 `Next()` 并返回 `false`，则 `Rows` 会自动关闭。否则，需要使用函数 `Close()` 来关闭它们。
- en: For the queries that expect to return at most one row exists a special function
    `QueryRow()` that returns a `Row` object that could be immediately scanned. `QueryRow()`
    never returns error until `Scan()` is called. If the query returns no row, `Scan()`
    returns `ErrNoRows`.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预期最多返回一行的查询，存在特殊函数 `QueryRow()`，返回一个 `Row` 对象，可以立即进行扫描。在调用 `Scan()` 之前，`QueryRow()`
    不会返回错误。如果查询没有返回行，则 `Scan()` 返回 `ErrNoRows`。
- en: '[PRE126]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Java
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: The JDBC interface provides specific object types for the various phases of
    SQL statement processing. Statements are executed in JDBC using Java objects of
    one type. The results, if any, are returned as objects of another type.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 接口为 SQL 语句处理的各个阶段提供了特定的对象类型。在 JDBC 中，语句通过一种类型的 Java 对象执行。结果（如果有）以另一种类型的对象返回。
- en: 'To execute a statement, first get a `Statement` object by calling the `createStatement()`
    method of your `Connection` object:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行语句，请先通过调用连接对象的 `createStatement()` 方法获取 `Statement` 对象：
- en: '[PRE127]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then use the `Statement` object to send the statement to the server. JDBC provides
    several methods for doing this. Choose the one that’s appropriate for the type
    of statement: `executeUpdate()` for statements that don’t return a result set,
    `executeQuery()` for statements that do, and `execute()` when you don’t know.
    Each method raises an exception if the statement fails.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `Statement` 对象将语句发送到服务器。JDBC 提供了几种执行此操作的方法。选择适合语句类型的方法：`executeUpdate()`
    用于不返回结果集的语句，`executeQuery()` 用于返回结果集的语句，`execute()` 用于其他情况。如果语句失败，每种方法都会引发异常。
- en: 'The `executeUpdate()` method sends a statement that generates no result set
    to the server and returns a count indicating the number of affected rows. When
    you’re done with the statement object, close it:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeUpdate()` 方法向服务器发送不生成结果集的语句，并返回受影响行数。完成语句对象后，请关闭它：'
- en: '[PRE128]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'For statements that return a result set, use `executeQuery()`. Then get a result
    set object, and use it to retrieve the row values. When you’re done, close the
    result set and statement objects:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回结果集的语句，请使用`executeQuery()`。然后获取一个结果集对象，并使用它检索行值。完成后，关闭结果集和语句对象：
- en: '[PRE129]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The `ResultSet` object returned by the `getResultSet()` method of your `Statement`
    object has its own methods, such as `next()` to fetch rows and various `get`*`XXX`*`()`
    methods that access columns of the current row. Initially, the result set is positioned
    just before the first row of the set. Call `next()` to fetch each row in succession
    until it returns false. To determine the number of rows in a result set, count
    them yourself, as shown in the preceding example.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`Statement`对象的`getResultSet()`方法返回的`ResultSet`对象具有自己的方法，例如`next()`以获取行和各种`get`*`XXX`*`()`方法以访问当前行的列。最初，结果集位于集合的第一行之前。调用`next()`以连续获取每行，直到返回false。要确定结果集中的行数，请自行计算，如前面的示例所示。'
- en: Tip
  id: totrans-600
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'For queries that return single result set it is not necessary to call *getResultSet*.
    Code above could be written as:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回单个结果集的查询，不需要调用*getResultSet*。上面的代码可以写成：
- en: '[PRE130]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: . Separate call is needed when your query can return multiple result sets, for
    example, if you call a stored routine.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: . 当您的查询可能返回多个结果集时，例如，如果调用存储过程，需要单独调用。
- en: 'To access column values, use methods such as `getInt()`, `getString()`, `getFloat()`,
    and `getDate()`. To obtain the column value as a generic object, use `getObject()`.
    The argument to a `get`*`XXX`*`()` call can indicate either column position (beginning
    at 1, not 0) or column name. The previous example shows how to retrieve the `id`,
    `name`, and `cats` columns by position. To access columns by name instead, write
    the row-fetching loop as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问列值，使用诸如`getInt()`、`getString()`、`getFloat()`和`getDate()`等方法。要将列值作为通用对象获取，使用`getObject()`。`get`*`XXX`*`()`调用的参数可以指示列位置（从1开始，而不是0）或列名。前面的示例展示了如何按位置检索`id`、`name`和`cats`列。要改为按名称访问列，编写行提取循环如下：
- en: '[PRE131]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'To retrieve a given column value, use any `get`*`XXX`*`()` call that makes
    sense for the data type. For example, `getString()` retrieves any column value
    as a string:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索给定列值，请使用任何对于数据类型有意义的`get`*`XXX`*`()`调用。例如，`getString()`将任何列值作为字符串检索：
- en: '[PRE132]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Or use `getObject()` to retrieve values as generic objects and convert the
    values as necessary. The following example uses `toString()` to convert object
    values to printable form:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 或使用`getObject()`将值检索为通用对象，并根据需要转换值。以下示例使用`toString()`将对象值转换为可打印形式：
- en: '[PRE133]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To determine the number of columns in the result set, access its metadata:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定结果集中的列数，请访问其元数据：
- en: '[PRE134]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The third JDBC statement-execution method, `execute()`, works for either type
    of statement. It’s particularly useful when you receive a statement string from
    an external source and don’t know whether it generates a result set or returns
    multiple result sets. The return value from `execute()` indicates the statement
    type so that you can process it appropriately: if `execute()` returns true, there
    is a result set, otherwise not. Typically, you’d use it something like this, where
    `stmtStr` represents an arbitrary SQL statement:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个JDBC语句执行方法`execute()`适用于任何类型的语句。当您从外部来源接收语句字符串并不知道它是否生成结果集或返回多个结果集时，它特别有用。`execute()`的返回值指示语句类型，以便您可以适当处理它：如果`execute()`返回true，则存在结果集，否则没有。通常，您会像这样使用它，其中`stmtStr`表示任意SQL语句：
- en: '[PRE135]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 4.5 Handling Special Characters and NULL Values in Statements
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 处理语句中的特殊字符和NULL值
- en: Problem
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to construct SQL statements that refer to data values containing special
    characters such as quotes or backslashes, or special values such as `NULL`. Or
    you are constructing statements using data obtained from external sources and
    want to prevent SQL injection attacks.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要构造引用包含特殊字符（如引号或反斜杠）或特殊值（如`NULL`）的数据值的SQL语句。或者您正在使用从外部来源获取的数据构造语句，并希望防止SQL注入攻击。
- en: Solution
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use your API’s placeholder mechanism or quoting function to make data safe for
    insertion.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API的占位符机制或引用函数使数据安全可插入。
- en: Discussion
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Up to this point in the chapter, our statements have used <q>safe</q> data
    values that require no special treatment. For example, we can easily construct
    the following SQL statements from within a program by writing the data values
    literally in the statement strings:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章为止，我们的语句使用了不需要特殊处理的<q>安全</q>数据值。例如，我们可以轻松地从程序内部编写数据值直接在语句字符串中构造以下SQL语句：
- en: '[PRE136]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: However, some data values are not so easily handled and cause problems if you
    are not careful. Statements might use values that contain special characters such
    as quotes, backslashes, binary data, or values that are `NULL`. The following
    discussion describes the difficulties these values cause and the proper techniques
    for handling them.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些数据值不那么容易处理，如果不小心就会引起问题。语句可能使用包含特殊字符（如引号、反斜杠、二进制数据或`NULL`值）的数值。以下讨论描述了这些数值引起的困难以及正确的处理技术。
- en: 'Suppose that you want to execute this `INSERT` statement:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想执行这个`INSERT`语句：
- en: '[PRE137]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'There’s nothing unusual about that. But if you change the `name` column value
    to something like `De''Mont` that contains a single quote, the statement becomes
    syntactically invalid:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`name`列的值更改为像`De'Mont`这样包含单引号的内容，这个语句就会变得语法无效：
- en: '[PRE138]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The problem is the single quote inside a single-quoted string. To make the
    statement legal by escaping the quote, precede it with either a single quote or
    a backslash:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于单引号位于单引号字符串内部。为了通过转义引号使语句合法，可以在其前面加上单引号或反斜杠：
- en: '[PRE139]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Alternatively, quote the `name` value itself within double quotes rather than
    within single quotes (assuming that the `ANSI_QUOTES` SQL mode is not enabled):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用双引号引用`name`值本身，而不是单引号（假设未启用`ANSI_QUOTES` SQL模式）：
- en: '[PRE141]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: If you are writing a statement literally in your program, you can escape or
    quote the `name` value by hand because you know what the value is. But if the
    name is stored in a variable, you don’t necessarily know what the variable’s value
    is. Worse yet, single quote isn’t the only character you must be prepared to deal
    with; double quotes and backslashes cause problems, too. And if the database stores
    binary data such as images or sound clips, a value might contain anything—not
    only quotes or backslashes, but other characters such as nulls (zero-valued bytes).
    The need to handle special characters properly is particularly acute in a web
    environment where statements are constructed using form input (for example, if
    you search for rows that match search terms entered by the remote user). You must
    be able to handle any kind of input in a general way because you can’t predict
    in advance what kind of information a user will supply. It is not uncommon for
    malicious users to enter garbage values containing problematic characters in a
    deliberate attempt to compromise the security of your server and even execute
    fatal commands, such as `DROP TABLE`. That is a standard technique for exploiting
    insecure scripts, called [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序中直接编写语句，可以手动转义或引用`name`值，因为你知道该值是什么。但是如果名称存储在变量中，你并不一定知道变量的值。更糟糕的是，你必须准备处理的不仅仅是单引号；双引号和反斜杠也会引起问题。如果数据库存储二进制数据（如图像或音频剪辑），某个值可能包含任何内容——不仅仅是引号或反斜杠，还可能包含空值（零值字节）等其他字符。正确处理特殊字符的需求在Web环境中尤为迫切，因为语句是使用表单输入构建的（例如，如果你搜索与远程用户输入的搜索词匹配的行）。你必须能够以通用方式处理任何类型的输入，因为你无法预测用户将提供什么样的信息。恶意用户常常输入包含问题字符的垃圾值，试图攻击服务器安全性，甚至执行致命命令，比如`DROP
    TABLE`。这是一种利用不安全脚本的标准技术，称为[SQL注入](https://en.wikipedia.org/wiki/SQL_injection)。
- en: 'The SQL `NULL` value is not a special character, but it too requires special
    treatment. In SQL, `NULL` indicates <q>no value.</q> This can have several meanings
    depending on context, such as <q>unknown,</q> <q>missing,</q> <q>out of range,</q>
    and so forth. Our statements thus far have not used `NULL` values, to avoid dealing
    with the complications that they introduce, but now it’s time to address these
    issues. For example, if you don’t know De’Mont’s favorite color, you can set the
    `color` column to `NULL`—but not by writing the statement like this:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: SQL中的`NULL`值不是特殊字符，但它也需要特殊处理。在 SQL 中，`NULL`表示<q>无值</q>。这可能根据上下文有几种含义，例如<q>未知</q>，<q>丢失</q>，<q>超出范围</q>等等。到目前为止，我们的语句还没有使用`NULL`值，以避免处理它们引入的复杂性，但现在是时候解决这些问题了。例如，如果你不知道De’Mont最喜欢的颜色，你可以将`color`列设为`NULL`，但不能这样写语句：
- en: '[PRE142]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Instead, the `NULL` value must have no enclosing quotes:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`NULL`值必须没有引号包围：
- en: '[PRE143]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Were you writing the statement literally in your program, you’d simply write
    the word <q>NULL</q> without enclosing quotes. But if the `color` value comes
    from a variable, the proper action is not so obvious. You must know whether the
    variable’s value represents `NULL` to determine whether to enclose it within quotes
    when you construct the statement.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在程序中直接写语句，你只需写单词<q>NULL</q>而不加引号。但如果`color`值来自变量，正确的操作就不那么明显了。您必须知道变量的值是否表示`NULL`，以确定在构造语句时是否将其置于引号中。
- en: 'You have two means at your disposal for dealing with special characters such
    as quotes and backslashes, and with special values such as `NULL`:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两种方法来处理诸如引号和反斜杠之类的特殊字符以及`NULL`之类的特殊值：
- en: Use placeholders in the statement string to refer to data values symbolically,
    then bind the data values to the placeholders when you execute the statement.
    This is the preferred method because the API itself does all or most of the work
    for you of providing quotes around values as necessary, quoting or escaping special
    characters within the data value, and possibly interpreting a special value to
    map onto `NULL` without enclosing quotes.
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行语句时，使用占位符在语句字符串中象征性地引用数据值，然后将数据值绑定到占位符。这是首选方法，因为 API 本身会根据需要为您提供引号，引用或转义数据值中的特殊字符，并可能解释特殊值以映射到`NULL`而不用加引号。
- en: Use a quoting function (if your API provides one) for converting data values
    to a safe form that is suitable for use in statement strings.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引号函数（如果您的 API 提供）将数据值转换为适合在语句字符串中使用的安全形式。
- en: This section shows how to use these techniques to handle special characters
    and `NULL` values for each API. One of the examples demonstrated here shows how
    to insert a `profile` table row that contains `De'Mont` for the `name` value and
    `NULL` for the `color` value. However, the principles shown here have general
    utility and handle any special characters, including those found in binary data.
    Also, the principles are not limited to `INSERT` statements. They work for other
    kinds of statements as well, such as `SELECT`. One of the other examples shown
    here demonstrates how to execute a `SELECT` statement using placeholders.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用这些技术来处理每个 API 中的特殊字符和`NULL`值。这里展示的一个示例演示了如何插入包含`De'Mont`作为`name`值和`NULL`作为`color`值的`profile`表行。然而，这里展示的原则具有一般实用性，并处理任何特殊字符，包括二进制数据中的特殊字符。此外，这些原则不仅限于`INSERT`语句，它们同样适用于其他类型的语句，比如`SELECT`。这里展示的另一个示例演示了如何使用占位符执行`SELECT`语句。
- en: 'Processing of special characters and `NULL` values comes up in other contexts
    covered elsewhere:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 处理特殊字符和`NULL`值是其他上下文中涉及到的内容：
- en: The placeholder and quoting techniques described here are *only* for data values
    and not for identifiers such as database or table names. For discussion of identifier
    quoting, refer to [Recipe 4.6](#nch-api-api-ident-quoting).
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此处描述的占位符和引用技术*仅*适用于数据值，而不适用于诸如数据库或表名之类的标识符。有关标识符引用的讨论，请参阅[Recipe 4.6](#nch-api-api-ident-quoting)。
- en: Comparisons of `NULL` values require different operators than non-`NULL` values.
    [Recipe 5.6](ch05.xhtml#nch-select-select-null-compare) discusses how to construct
    SQL statements that perform `NULL` comparisons from within programs.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较`NULL`值需要与非`NULL`值不同的运算符。[Recipe 5.6](ch05.xhtml#nch-select-select-null-compare)讨论如何从程序内部构造执行`NULL`比较的
    SQL 语句。
- en: This section covers the issue of getting special characters *into* your database.
    A related issue is the inverse operation of transforming special characters in
    values returned *from* your database for display in various contexts. For example,
    if you generate HTML pages that include values taken from your database, you must
    perform output encoding to convert `<` and `>` characters in those values to the
    HTML entities `&lt;` and `&gt;` to make sure they display properly.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本节涵盖了将特殊字符 *插入* 到你的数据库中的问题。相关问题是反向操作，即将值中的特殊字符 *从* 你的数据库中转换，以在各种上下文中进行显示。例如，如果你生成包含来自数据库的值的
    HTML 页面，则必须执行输出编码，将这些值中的 `<` 和 `>` 字符转换为 HTML 实体 `&lt;` 和 `&gt;` 以确保它们正确显示。
- en: Using placeholders
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用占位符
- en: 'Placeholders enable you to avoid writing data values literally in SQL statements.
    Using this approach, you write statements using placeholders—special markers that
    indicate where the values go. Two common parameter markers are `?` and `%s`. Depending
    on the marker, rewrite the `INSERT` statement to use placeholders like this:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符允许你避免在 SQL 语句中直接写入数据值。使用这种方法，你可以使用占位符——特殊的标记，指示数值应该放在哪里。两种常见的参数标记是`?`和`%s`。根据标记，重写`INSERT`语句以使用如下的占位符：
- en: '[PRE144]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Then pass the statement string to the database server and supply the data values
    separately. The API binds the values to the placeholders to replace them, resulting
    in a statement that contains the data values.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将语句字符串传递给数据库服务器，并单独提供数据值。API 将这些值绑定到占位符上以替换它们，生成包含数据值的语句。
- en: One benefit of placeholders is that parameter-binding operations automatically
    handle escaping of characters such as quotes and backslashes. This is especially
    useful for inserting binary data such as images into your database or using data
    values with unknown content such as input submitted by a remote user through a
    form in a web page. Also, there is usually some special value that you bind to
    a placeholder to indicate that you want an SQL `NULL` value in the resulting statement.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符的一个好处是参数绑定操作会自动处理转义字符，如引号和反斜杠。这对于将二进制数据（例如图像）插入到数据库中或使用具有未知内容的数据值（例如通过网页表单由远程用户提交的输入）特别有用。此外，通常有一些特殊值，你可以绑定到占位符，以指示你希望在结果语句中得到
    SQL 的 `NULL` 值。
- en: A second benefit of placeholders is that you can <q>prepare</q> a statement
    in advance, then reuse it by binding different values to it each time it’s executed.
    Prepared statements thus encourage statement reuse. Statements become more generic
    because they contain placeholders rather than specific data values. If you perform
    an operation over and over, you may be able to reuse a prepared statement and
    simply bind different data values to it each time you execute it. Some database
    systems (MySQL not among them) have the capability of performing some preparsing
    or even execution planning prior to executing a prepared statement. For a statement
    that is executed multiple times later, this reduces overhead because anything
    that can be done prior to execution need be done only once, not once per execution.
    For example, if a program executes a particular type of `SELECT` statement several
    times while it runs, such a database system can construct a plan for the statement
    and then reuse it each time, rather than rebuild the plan over and over. MySQL
    doesn’t build query plans in advance, so you get no performance boost from using
    prepared statements. However, if you port a program to a database that does reuse
    query plans and you’ve written your program to use prepared statements, you can
    get this advantage of prepared statements automatically. You need not convert
    from nonprepared statements to enjoy that benefit.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符的第二个好处是，你可以预先<q>准备</q>一个语句，然后每次执行时绑定不同的值以重复使用它。预准备的语句鼓励语句重用。语句变得更通用，因为它们包含占位符而不是特定的数据值。如果你反复执行某个操作，可能可以重用一个预准备的语句，每次执行时只需绑定不同的数据值。某些数据库系统（MySQL
    不在其中）具有在执行预准备语句之前执行某些预解析或执行计划的能力。对于稍后多次执行的语句，这减少了开销，因为只需在执行前完成一次工作，而不是每次执行都要完成。例如，如果一个程序在运行时多次执行特定类型的`SELECT`语句，这样的数据库系统可以构建该语句的计划，然后每次重用，而不是反复重建计划。MySQL
    不预先构建查询计划，因此使用预准备语句不会带来性能提升。但是，如果你将程序移植到一个支持重用查询计划的数据库，并且你已经编写程序以使用预准备语句，那么你可以自动享受到预准备语句的这个优势。你无需从非预准备语句转换，就可以享受到这个好处。
- en: A third (admittedly subjective) benefit is that code that uses placeholder-based
    statements can be easier to read. As you work through this section, compare the
    statements used here with those from [Recipe 4.4](#nch-api-api-statement) that
    did not use placeholders to see which you prefer.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个（诚然是主观的）好处是使用基于占位符的语句的代码可能更易于阅读。在您阅读本节时，请比较这里使用的语句与未使用占位符的 [Recipe 4.4](#nch-api-api-statement)
    中的语句，看看您更喜欢哪一种。
- en: Using a quoting function
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用引号函数
- en: Some APIs provide a quoting function that takes a data value as its argument
    and returns a properly quoted and escaped value suitable for safe insertion into
    an SQL statement. This is less common than using placeholders, but it can be useful
    for constructing statements that you do not intend to execute immediately. However,
    you must have a connection open to the database server while you use such a quoting
    function because the API cannot select the proper quoting rules until the database
    driver is known. (The rules differ among database systems.)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 API 提供了一个引号函数，它以数据值作为其参数并返回一个适合安全插入到 SQL 语句中的正确引号和转义值。这种方法不如使用占位符常见，但在构造不打算立即执行的语句时可能很有用。但是，在使用此类引号函数时，必须保持对数据库服务器的连接打开，因为
    API 无法在不知道数据库驱动程序的情况下选择正确的引号规则（这些规则在不同的数据库系统中有所不同）。
- en: Note
  id: totrans-655
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As we’ll indicate later, some APIs quote as strings all non-`NULL` values, even
    numbers, when binding them to parameter markers. This can be an issue in contexts
    that *require* numbers, as described further in [Recipe 5.11](ch05.xhtml#nch-select-select-limit-calc).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将指出的那样，某些 API 在将非 `NULL` 值绑定到参数标记时会将所有非 `NULL` 值（包括数字）都视为字符串引号。在需要 *必须*
    数字的情况下，这可能会成为问题，如 [Recipe 5.11](ch05.xhtml#nch-select-select-limit-calc) 中进一步描述的那样。
- en: Perl
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl
- en: To use placeholders with Perl DBI, put a `?` in your SQL statement string at
    each data value location. Then bind the values to the statement by passing them
    to `do()` or `execute()`, or by calling a DBI method specifically intended for
    placeholder substitution. Use `undef` to bind a `NULL` value to a placeholder.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用带有 Perl DBI 的占位符，请在 SQL 语句字符串中的每个数据值位置放置一个`?`。然后通过将这些值传递给 `do()` 或 `execute()`，或者调用专门用于占位符替换的
    DBI 方法来绑定这些值到语句中。使用 `undef` 来绑定一个 `NULL` 值到占位符。
- en: 'With `do()`, add the `profile` row for De’Mont by passing the statement string
    and the data values in the same call:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `do()`，通过在同一调用中传递语句字符串和数据值，为 De’Mont 添加 `profile` 行：
- en: '[PRE145]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The arguments following the statement string are `undef`, then one data value
    for each placeholder. The `undef` argument is a historical artifact, but must
    be present.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 跟在语句字符串后面的参数是 `undef`，然后是每个占位符对应的一个数据值。`undef` 参数是一个历史遗留物，但必须存在。
- en: 'Alternatively, pass the statement string to `prepare()` to get a statement
    handle, then use that handle to pass the data values to `execute()`:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将语句字符串传递给 `prepare()` 以获得语句句柄，然后使用该句柄将数据值传递给 `execute()`：
- en: '[PRE146]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'In either case, DBI generates this statement:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，DBI 生成此语句：
- en: '[PRE147]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The Perl DBI placeholder mechanism provides quotes around data values when they
    are bound to the statement string, so don’t put quotes around the `?` characters
    in the string.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: Perl DBI 占位符机制在将数据值绑定到语句字符串时会为其添加引号，因此不要在字符串中的 `?` 字符周围加引号。
- en: Note that the placeholder mechanism adds quotes around numeric values. DBI relies
    on the MySQL server to perform type conversion as necessary to convert strings
    to numbers. If you bind `undef` to a placeholder, DBI puts a `NULL` into the statement
    and correctly refrains from adding enclosing quotes.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，占位符机制会在数值周围添加引号。DBI 依赖于 MySQL 服务器根据需要将字符串转换为数字进行类型转换。如果将 `undef` 绑定到占位符，则
    DBI 将 `NULL` 放入语句中，并正确地避免添加包围引号。
- en: To execute the same statement over and over again, use `prepare()` once, then
    call `execute()` with appropriate data values each time you run it.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 要重复执行同一语句，请先使用 `prepare()`，然后每次运行时使用适当的数据值调用 `execute()`。
- en: 'You can use these methods for other types of statements as well. For example,
    the following `SELECT` statement uses a placeholder to look for rows that have
    a `cats` value larger than 2:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些方法用于其他类型的语句。例如，以下 `SELECT` 语句使用占位符来查找 `cats` 值大于 2 的行：
- en: '[PRE148]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'High-level retrieval methods such as `selectrow_array()` and `selectall_arrayref()`
    can be used with placeholders, too. Like the `do()` method, the arguments are
    the statement string, `undef`, and the data values to bind to the placeholders.
    Here’s an example:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 高级检索方法（如`selectrow_array()`和`selectall_arrayref()`）也可以与占位符一起使用。与`do()`方法一样，参数是语句字符串、`undef`和要绑定到占位符的数据值。以下是一个例子：
- en: '[PRE149]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The Perl DBI `quote()` database- handle method is an alternative to using placeholders.
    Here’s how to use `quote()` to create a statement string that inserts a new row
    in the `profile` table. Write the `%s` format specifiers without enclosing quotes
    because `quote()` provides them automatically as necessary. Non-`undef` values
    are inserted with quotes, and `undef` values are inserted as `NULL` without quotes:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: Perl DBI的`quote()`数据库句柄方法是使用占位符的替代方法。以下是如何使用`quote()`创建插入`profile`表中新行的语句字符串。由于`quote()`会根据需要自动提供引号，因此请不要用引号括住`%s`格式说明符。非`undef`值会带有引号插入，而`undef`值会作为`NULL`值插入而不带引号：
- en: '[PRE150]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The statement string generated by this code is the same as when you use placeholders.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 由此代码生成的语句字符串与使用占位符时相同。
- en: Ruby
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby
- en: Ruby DBI uses `?` as the placeholder character in SQL statements and `nil` as
    the value for binding an SQL `NULL` value to a placeholder.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby DBI在SQL语句中使用`?`作为占位符字符，并使用`nil`作为将SQL `NULL`值绑定到占位符的值。
- en: 'To use the `?`, pass the statement string to `prepare` to get a statement handle,
    then use that handle to invoke `execute` with the data values:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`?`，请将语句字符串传递给`prepare`以获取语句句柄，然后使用该句柄调用带有数据值的`execute`：
- en: '[PRE151]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Mysql2 includes properly escaped quotes and a properly unquoted `NULL` value
    in the resulting statement:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: Mysql2在结果语句中包含正确转义的引号和正确的未引用`NULL`值：
- en: '[PRE152]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The Ruby Mysql2 placeholder mechanism provides quotes around data values as
    necessary when they are bound to the statement string, so don’t put quotes around
    the `?` characters in the string.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的Mysql2占位符机制在绑定到语句字符串时根据需要在数据值周围添加引号，因此不要在字符串中的`?`字符周围放置引号。
- en: PHP
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: 'To use placeholders with the PDO extension, pass a statement string to `prepare()`
    to get a statement object. The string can contain `?` characters as placeholder
    markers. Use this object to invoke `execute()`, passing to it the array of data
    values to bind to the placeholders. Use the PHP `NULL` value to bind an SQL `NULL`
    value to a placeholder. The code to add the `profile` table row for De’Mont looks
    like this:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PDO扩展的占位符，请将语句字符串传递给`prepare()`以获取语句对象。字符串可以包含`?`字符作为占位符标记。使用此对象调用`execute()`，向其传递要绑定到占位符的数据值数组。使用PHP的`NULL`值将SQL
    `NULL`值绑定到占位符。用于为De’Mont添加`profile`表行的代码如下：
- en: '[PRE153]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The resulting statement includes a properly escaped quote and a properly unquoted
    `NULL` value:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 结果语句包含正确转义的引号和正确的未引用`NULL`值：
- en: '[PRE154]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The PDO placeholder mechanism provides quotes around data values when they are
    bound to the statement string, so don’t put quotes around the `?` characters in
    the string. (Note that even the numeric value `4` is quoted; PDO relies on MySQL
    to perform type conversion as necessary when the statement executes.)
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: PDO占位符机制在绑定到语句字符串时在数据值周围添加引号，因此不要在字符串中的`?`字符周围放置引号。（请注意，甚至数字值`4`也会被引用；PDO依赖MySQL在语句执行时进行必要的类型转换。）
- en: Python
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: 'The Connector/Python module implements placeholders using `%s` format specifiers
    in the SQL statement string. (To place a literal `%` character into the statement,
    use `%%` in the statement string.) To use placeholders, invoke the `execute()`
    method with two arguments: a statement string containing format specifiers and
    a sequence containing the values to bind to the statement string. Use `None` to
    bind a `NULL` value to a placeholder. The code to add the `profile` table row
    for De’Mont looks like this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: Connector/Python模块通过在SQL语句字符串中使用`%s`格式说明符来实现占位符。（要在语句中插入字面上的`%`字符，请在语句字符串中使用`%%`。）要使用占位符，请使用两个参数调用`execute()`方法：包含格式说明符的语句字符串和包含要绑定到语句字符串的值的序列。使用`None`将`NULL`值绑定到占位符。用于为De’Mont添加`profile`表行的代码如下：
- en: '[PRE155]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The statement sent to the server by the preceding `execute()` call looks like
    this:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 由上述`execute()`调用发送到服务器的语句如下所示：
- en: '[PRE156]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The Connector/Python placeholder mechanism provides quotes around data values
    as necessary when they are bound to the statement string, so don’t put quotes
    around the `%s` format specifiers in the string.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: Connector/Python的占位符机制在绑定到语句字符串时根据需要在数据值周围添加引号，因此不要在字符串中的`%s`格式说明符周围放置引号。
- en: 'If you have only a single value *`val`* to bind to a placeholder, write it
    as a sequence using the syntax `(`*`val`*,`)`:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个单值 *`val`* 需要绑定到占位符，可以使用以下语法将其写为序列： `(`*`val`*,`)`：
- en: '[PRE157]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Alternatively, write the value as a list using the syntax `[`*`val`*`]`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将值写为列表，使用以下语法 `[`*`val`*`]`。
- en: Go
  id: totrans-698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go
- en: 'Go `sql` package uses question marks (`?`) as a placeholder markers. You can
    use placeholders with single `Exec()` or `Query()` calls, and also you can prepare
    the statement in advance and execute it later. Latter method is good when you
    need to execute the statement multiple times. The code to add the `profile` table
    row for De’Mont looks like this:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `sql` 包使用问号 (`?`) 作为占位符标记。你可以在单个 `Exec()` 或 `Query()` 调用中使用占位符，也可以预先准备语句并稍后执行。当需要多次执行语句时，后一种方法很有用。为了为
    De’Mont 添加 `profile` 表行的代码看起来像这样：
- en: '[PRE158]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The same code with the `Prepare()` call will look like this:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Prepare()` 调用的相同代码看起来像这样：
- en: '[PRE159]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Java
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: JDBC provides support for placeholders if you use prepared statements. Recall
    that the process for executing nonprepared statements in JDBC is to create a `Statement`
    object, and then pass the statement string to the `executeUpdate()`, `executeQuery()`,
    or `execute()` function. To use a prepared statement instead, create a `PreparedStatement`
    object by passing a statement string containing `?` placeholder characters to
    your connection object’s `prepareStatement()` method. Then bind the data values
    to the statement using `set`*`XXX`*`()` methods. Finally, execute the statement
    by calling `executeUpdate()`, `executeQuery()`, or `execute()` with an empty argument
    list.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用预编译语句，JDBC 提供了对占位符的支持。回顾在 JDBC 中执行非预编译语句的过程是创建 `Statement` 对象，然后将语句字符串传递给
    `executeUpdate()`、`executeQuery()` 或 `execute()` 函数。相反，如果使用预编译语句，通过将包含 `?` 占位符字符的语句字符串传递给连接对象的
    `prepareStatement()` 方法来创建 `PreparedStatement` 对象。然后使用 `set`*`XXX`*`()` 方法将数据值绑定到语句。最后，通过调用
    `executeUpdate()`、`executeQuery()` 或 `execute()` 执行语句，并使用空参数列表。
- en: 'Here is an example that uses `executeUpdate()` to execute an `INSERT` statement
    that adds the `profile` table row for De’Mont:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，使用 `executeUpdate()` 执行 `INSERT` 语句，为 De’Mont 添加 `profile` 表行：
- en: '[PRE160]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The `set`*`XXX`*`()` methods that bind data values to statements take two arguments:
    a placeholder position (beginning with 1, not 0) and the value to bind to the
    placeholder. Choose each value-binding call to match the data type of the column
    to which the value is bound: `setString()` to bind a string to the `name` column,
    `setInt()` to bind an integer to the `cats` column, and so forth. (Actually, I
    cheated a bit by using `setString()` to treat the date value for `birth` as a
    string.)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`*`XXX`*`()` 方法将数据值绑定到语句上，需要两个参数：占位符位置（从1开始，不是0）和要绑定到占位符的值。选择每个值绑定调用以匹配绑定到的列的数据类型：`setString()`
    绑定字符串到 `name` 列，`setInt()` 绑定整数到 `cats` 列，依此类推。 （实际上，我使用 `setString()` 将日期值绑定为字符串以处理
    `birth`。）'
- en: 'One difference between JDBC and the other APIs is that you don’t bind a `NULL`
    to a placeholder by specifying some special value (such as `undef` in Perl or
    `nil` in Ruby). Instead, invoke `setNull()` with a second argument that indicates
    the type of the column: `java.sql.Types.CHAR` for a string, `java.sql.Types.INTEGER`
    for an integer, and so forth.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 与其他 API 的一个区别是，你不需要指定特殊值（例如 Perl 中的 `undef` 或 Ruby 中的 `nil`）来将 `NULL` 绑定到占位符上。相反，调用
    `setNull()` 并传递第二个参数指示列的类型：`java.sql.Types.CHAR` 表示字符串，`java.sql.Types.INTEGER`
    表示整数，依此类推。
- en: The `set`*`XXX`*`()` calls add quotes around data values if necessary, so don’t
    put quotes around the `?` placeholder characters in the statement string.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`*`XXX`*`()` 调用会根据需要为数据值添加引号，因此不要在语句字符串中的 `?` 占位符字符周围加上引号。'
- en: 'To handle a statement that returns a result set, the process is similar, but
    execute the prepared statement with `executeQuery()` rather than `executeUpdate()`:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理返回结果集的语句，流程类似，但要使用 `executeQuery()` 而不是 `executeUpdate()` 执行准备好的语句：
- en: '[PRE161]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 4.6 Handling Special Characters in Identifiers
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 处理标识符中的特殊字符
- en: Problem
  id: totrans-713
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to construct SQL statements that refer to identifiers containing special
    characters.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要构造引用包含特殊字符的标识符的 SQL 语句。
- en: Solution
  id: totrans-715
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Quote each identifier so it can be inserted safely into statement strings.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个标识符进行引用，以便安全地插入到语句字符串中。
- en: Discussion
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 4.5](#nch-api-api-quoting) discusses how to handle special characters
    in data values by using placeholders or quoting methods. Special characters also
    can be present in identifiers such as database, table, and column names. For example,
    the table name `some table` contains a space, which is not permitted by default:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 4.5](#nch-api-api-quoting) 讨论如何通过使用占位符或引用方法处理数据值中的特殊字符。标识符中也可能存在特殊字符，例如数据库、表和列名。例如，表名
    `some table` 包含默认情况下不允许的空格：'
- en: '[PRE162]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Special characters are handled differently in identifiers than in data values.
    To make an identifier safe for insertion into an SQL statement, quote it by enclosing
    it within backticks:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符中的特殊字符与数据值中的处理方式不同。为了使标识符能够安全地插入到 SQL 语句中，请使用反引号将其括起来进行引用：
- en: '[PRE163]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'In MySQL, backticks are always permitted for identifier quoting. The double-quote
    character is permitted as well, if the `ANSI_QUOTES` SQL mode is enabled. Thus,
    with `ANSI_QUOTES` enabled, both of these statements are equivalent:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中，反引号始终允许用于标识符引用。如果启用了 `ANSI_QUOTES` SQL 模式，则也允许双引号字符。因此，在启用 `ANSI_QUOTES`
    的情况下，以下两个语句等效：
- en: '[PRE164]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: If it’s necessary to know which identifier quoting characters are permitted,
    execute a `SELECT` `@@sql_mode` statement to retrieve the SQL mode for your session
    and check whether its value includes `ANSI_QUOTES`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要知道哪些标识符引用字符是允许的，请执行 `SELECT @@sql_mode` 语句来检索您会话的 SQL 模式，并检查其值是否包含 `ANSI_QUOTES`。
- en: If a quoting character appears within the identifier itself, double it when
    quoting the identifier. For example, quote ``abc`def`` as [PRE165].
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引号字符出现在标识符本身中，请在引用标识符时加倍。例如，将 ``abc`def`` 引用为 [PRE165]。
- en: Be aware that although string data values in MySQL normally can be quoted using
    either single-quote or double-quote characters (`'abc'`, `"abc"`), that is not
    true when `ANSI_QUOTES` is enabled. In that case, MySQL interprets `'abc'` as
    a string and `"abc"` as an identifier, so you must use only single quotes for
    strings.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 MySQL 中的字符串数据值通常可以使用单引号或双引号字符 (`'abc'`, `"abc"`) 进行引用，但在启用 `ANSI_QUOTES`
    的情况下并非如此。在这种情况下，MySQL 将 `'abc'` 解释为字符串，`"abc"` 解释为标识符，因此您必须仅使用单引号来引用字符串。
- en: 'Within a program, you can use an identifier-quoting routine if your API provides
    one, or write one yourself if not. Perl DBI has a `quote_identifier()` method
    that returns a properly quoted identifier. For an API that has no such method,
    you can quote an identifier by enclosing it within backticks and doubling any
    backticks that occur within the identifier. Here’s a PHP routine that does so:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，如果 API 提供了标识符引用例程，您可以使用该例程，如果没有，则可以自己编写一个。Perl DBI 有一个 `quote_identifier()`
    方法，返回一个正确引用的标识符。对于没有此类方法的 API，您可以通过将其用反引号括起来并加倍任何出现在标识符中的反引号来引用标识符。以下是一个执行此操作的
    PHP 例程：
- en: '[PRE166]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Portability note: If you write your own identifier-quoting routines, remember
    that other DBMSs may require different quoting conventions.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植性注意事项：如果编写自己的标识符引用例程，请记住其他 DBMS 可能需要不同的引用约定。
- en: 'In contexts where identifiers are used as data values, handle them as such.
    If you select information from the `INFORMATION_SCHEMA` metadata database, it’s
    common to indicate which rows to return by specifying database object names in
    the `WHERE` clause. For example, this statement retrieves the column names for
    the `profile` table in the `cookbook` database:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在将标识符用作数据值的上下文中，请相应处理它们。如果从 `INFORMATION_SCHEMA` 元数据数据库中选择信息，通常会通过在 `WHERE`
    子句中指定数据库对象名称来指示返回哪些行。例如，此语句检索 `cookbook` 数据库中 `profile` 表的列名：
- en: '[PRE167]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The database and table names are used here as data values, not as identifiers.
    Were you to construct this statement within a program, parameterize them using
    placeholders, not identifier quoting. For example, in Ruby, do this:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的数据库和表名作为数据值使用，而不是标识符。如果在程序中构造此语句，使用占位符参数化它们，而不是标识符引用。例如，在 Ruby 中，执行如下操作：
- en: '[PRE168]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 4.7 Identifying NULL Values in Result Sets
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 在结果集中识别 NULL 值
- en: Problem
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: A query result includes `NULL` values, but you’re not sure how to identify them.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果包含 `NULL` 值，但你不确定如何识别它们。
- en: Solution
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Your API probably has some special value that represents `NULL` by convention.
    You just have to know what it is and how to test for it.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 API 可能通过惯例使用特殊值表示 `NULL`。你只需知道它是什么，以及如何测试它。
- en: Discussion
  id: totrans-739
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 4.5](#nch-api-api-quoting) describes how to refer to `NULL` values
    when you send statements *to* the database server. In this section, we’ll deal
    instead with the question of how to recognize and process `NULL` values returned
    *from* the database server. In general, this is a matter of knowing what special
    value the API maps `NULL` values to, or what method to call. The [Table 4-5](#nch-api-api-nul-detect)
    shows these values:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 4.5](#nch-api-api-quoting) 描述了在向数据库服务器发送语句时如何引用 `NULL` 值。在本节中，我们将处理如何识别和处理从数据库服务器返回的
    `NULL` 值的问题。通常，这涉及知道 API 将 `NULL` 值映射到什么特殊值，或者调用什么方法。[Table 4-5](#nch-api-api-nul-detect)
    显示了这些值：'
- en: Table 4-5\. Detected NULL values
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-5\. 检测到的 NULL 值
- en: '| Language | NULL-detection value or method |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 检测 `NULL` 值的值或方法 |'
- en: '| --- | --- |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Perl DBI | `undef` value |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| Perl DBI | `undef` 值 |'
- en: '| Ruby Mysql2 gem | `nil` value |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| Ruby Mysql2 gem | `nil` 值 |'
- en: '| PHP PDO | `NULL` value |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| PHP PDO | `NULL` 值 |'
- en: '| Python DB API | `None` value |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| Python DB API | `None` 值 |'
- en: '| Go `sql` interface | Go Null type implementation for the nullable data types.
    |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| Go `sql` 接口 | 为可空数据类型实现的 Go Null 类型 |'
- en: '| Java JDBC | `wasNull()` method |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| Java JDBC | `wasNull()` 方法 |'
- en: The following sections show a very simple application of `NULL` value detection.
    The examples retrieve a result set and print all values in it, mapping `NULL`
    values onto the printable string `"NULL"`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节展示了检测 `NULL` 值的非常简单的应用程序示例。示例检索结果集并打印其中的所有值，将 `NULL` 值映射到可打印的字符串 `"NULL"`。
- en: 'To make sure that the `profile` table has a row that contains some `NULL` values,
    use *mysql* to execute the following `INSERT` statement, then execute the `SELECT`
    statement to verify that the resulting row has the expected values:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `profile` 表中有包含一些 `NULL` 值的行，请使用 *mysql* 执行以下 `INSERT` 语句，然后执行 `SELECT`
    语句以验证生成的行具有预期的值：
- en: '[PRE169]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The `id` column might contain a different number, but the other columns should
    appear as shown, with values of `NULL`.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 列可能包含不同的数字，但其他列应该按照所示的方式出现，其中值为 `NULL`。'
- en: Perl
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Perl
- en: Perl DBI represents `NULL` values using `undef`. To detect such values, use
    the `defined()` function; it’s particularly important to do so if you enable warnings
    with the Perl `-w` option or by including a `use` `warnings` line in your script.
    Otherwise, accessing `undef` values causes Perl to issue `Use` `of` `uninitialized`
    `value` warnings.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: Perl DBI 使用 `undef` 表示 `NULL` 值。要检测这些值，请使用 `defined()` 函数；如果启用了 Perl 的 `-w`
    选项或通过在脚本中包含 `use warnings` 行，则这样做尤为重要。否则，访问 `undef` 值会导致 Perl 发出 `Use of uninitialized
    value` 警告。
- en: 'To prevent these warnings, test column values that might be `undef` with `defined()`
    before using them. The following code selects a few columns from the `profile`
    table and prints `"NULL"` for any undefined values in each row. This makes `NULL`
    values explicit in the output without activating any warning messages:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些警告，请在使用之前使用 `defined()` 测试可能是 `undef` 的列值。以下代码从 `profile` 表中选择几列，并为每行中任何未定义的值打印
    `"NULL"`。这样可以在输出中明确地表示 `NULL` 值，而不激活任何警告消息：
- en: '[PRE170]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Unfortunately, testing multiple column values is ponderous and becomes worse
    the more columns there are. To avoid this, test and set undefined values using
    a loop or `map` prior to printing them. The following example uses `map`:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，测试多个列值很冗长，随着列数的增加而变得更糟。为了避免这种情况，在打印之前使用循环或 `map` 测试和设置未定义的值。以下示例使用 `map`：
- en: '[PRE171]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: With this technique, the amount of code to perform the tests is constant, not
    proportional to the number of columns to be tested. Also, there is no reference
    to specific column names, so it can more easily be used in other programs or as
    the basis for a utility routine.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，执行测试的代码量是恒定的，而不是与要测试的列数成比例增加的。此外，没有引用特定的列名，因此它可以更轻松地用于其他程序或作为实用程序例程的基础。
- en: 'If you fetch rows into an array rather than into a hash, use `map` like this
    to convert `undef` values:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将行数据取出到一个数组而不是哈希表中，可以使用以下方式使用 `map` 来转换 `undef` 值：
- en: '[PRE172]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Ruby
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ruby
- en: 'Ruby Mysql2 module represents `NULL` values using `nil`, which can be identified
    by applying the `nil?` method to a value. The following example uses the `nil?`
    method and ternary operator to determine whether to print result set values as
    is or as the string `"NULL"` for `NULL` values:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby Mysql2 模块使用 `nil` 表示 `NULL` 值，可以通过将 `nil?` 方法应用于值来识别。以下示例使用 `nil?` 方法和三元运算符确定是否将结果集值原样打印，或者对于
    `NULL` 值打印字符串 `"NULL"`：
- en: '[PRE173]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: PHP
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP
- en: 'PHP represents SQL `NULL` values in result sets as the PHP `NULL` value. To
    determine whether a value from a result set represents a `NULL` value, compare
    it to the PHP `NULL` value using the `===` <q>triple equal</q> operator:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 将 SQL 结果集中的 `NULL` 值表示为 PHP 的 `NULL` 值。要确定来自结果集的值是否表示 `NULL` 值，请使用 `===`
    <q>三重等</q> 运算符进行比较：
- en: '[PRE174]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'In PHP, the triple equal operator means <q>exactly equal to.</q> The usual
    `==` <q>equal to</q> comparison operator is not suitable here: with `==`, PHP
    considers the `NULL` value, the empty string, and `0` all equal.'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，三重等号运算符意味着 <q>完全相等</q>。通常的 `==` <q>相等</q> 比较运算符在这里不适用：使用 `==` 时，PHP
    认为 `NULL` 值、空字符串和 `0` 都相等。
- en: 'The following code uses the `===` operator to identify `NULL` values in a result
    set and print them as the string `"NULL"`:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用 `===` 运算符来识别结果集中的 `NULL` 值并将它们打印为字符串 `"NULL"`：
- en: '[PRE175]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: An alternative to `===` for `NULL` value tests is `is_null()`.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 `NULL` 值测试的 `===` 的替代方法是 `is_null()`。
- en: Python
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python
- en: 'Python DB API programs represent `NULL` in result sets using `None`. The following
    example shows how to detect `NULL` values:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: Python DB API 程序使用 `None` 表示结果集中的 `NULL`。以下示例显示如何检测 `NULL` 值：
- en: '[PRE176]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The inner loop checks for `NULL` column values by looking for `None` and converts
    them to the string `"NULL"`. The example converts `row` to a mutable object (list)
    prior to the loop because `fetchall()` returns rows as sequence values, which
    are nonmutable (read only).
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环通过查找 `None` 来检查 `NULL` 列值，并将它们转换为字符串 `"NULL"`。示例在循环之前将 `row` 转换为可变对象（列表），因为
    `fetchall()` 返回行作为序列值，这些值是不可变的（只读）。
- en: Go
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前往
- en: Go `sql` interface provides special data types to handle values in the result
    set that may contain NULL values. They are defined for the standard Go types.
    [Table 4-6](#nch-api-api-null-go) contains the list of the standard data types
    and their nullable equivalents.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `sql` 接口提供了特殊的数据类型来处理结果集中可能包含 NULL 值的值。它们针对标准 Go 类型进行了定义。[表 4-6](#nch-api-api-null-go)
    包含标准数据类型及其可为空的等效类型的列表。
- en: Table 4-6\. Handling NULL values in Go
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-6\. 在 Go 中处理 NULL 值
- en: '| Standard Go Type | Type that can contain NULL values |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| Go 标准类型 | 可包含 NULL 值的类型 |'
- en: '| --- | --- |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `bool` | `NullBool` |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `NullBool` |'
- en: '| `float64` | `NullFloat64` |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | `NullFloat64` |'
- en: '| `int32` | `NullInt32` |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | `NullInt32` |'
- en: '| `int64` | `NullInt64` |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `NullInt64` |'
- en: '| `string` | `NullString` |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `NullString` |'
- en: '| `time.Time` | `NullTime` |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| `time.Time` | `NullTime` |'
- en: To define a variable that can take both `NULL` and non-`NULL` value when passed
    as an argument to the function `Scan()`, use the corresponding nullable type.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个变量，它既可以接受 `NULL` 值也可以接受非 `NULL` 值作为传递给 `Scan()` 函数的参数，请使用相应的可为空类型。
- en: 'All nullable types contains two functions: `Valid()` that returns `true` if
    the value is not `NULL` and `false` if the value is `NULL`. Second function is
    the type name, started from the capital letter. For example, `String()` for `string`
    values and `Time()` for `time.Time` values. This method returns actual value when
    it is not `NULL`.'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可为空类型都包含两个函数：`Valid()` 如果值不为 `NULL` 则返回 `true`，如果值为 `NULL` 则返回 `false`。第二个函数是以大写字母开头的类型名称。例如，对于
    `string` 值是 `String()`，对于 `time.Time` 值是 `Time()`。当值不为 `NULL` 时，此方法返回实际值。
- en: Here is the example on how to handle `NULL` values in Go.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在 Go 中处理 `NULL` 值的示例。
- en: '[PRE177]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Warning
  id: totrans-792
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: We used type `NullString` for the `birth` column for simplicity. If you want
    to use type `NullTime` you need to add parameter `parseTime=true` to your connection
    string.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `birth` 列中简单使用了类型 `NullString`。如果您想使用类型 `NullTime`，则需要在连接字符串中添加参数 `parseTime=true`。
- en: Tip
  id: totrans-794
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Alternatively you can use MySQL’s `COALESCE()` function to convert null value
    to a string during the query execution.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以在查询执行期间使用 MySQL 的 `COALESCE()` 函数将 `NULL` 值转换为字符串。
- en: '[PRE178]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Java
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java
- en: 'For JDBC programs, if it’s possible for a column in a result set to contain
    `NULL` values, it’s best to check for them explicitly. The way to do this is to
    fetch the value and then invoke `wasNull()`, which returns true if the column
    is `NULL` and false otherwise. For example:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JDBC 程序，如果结果集中的某列可能包含 `NULL` 值，最好显式检查它们。具体方法是获取该值，然后调用 `wasNull()` 方法，如果该列为
    `NULL` 则返回 true，否则返回 false。例如：
- en: '[PRE179]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The preceding example uses `getObject()`, but the principle holds for other
    `get`*`XXX`*`()` calls as well.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例使用了 `getObject()`，但同样适用于其他 `get`*`XXX`*`()` 调用。
- en: 'Here’s an example that prints each row of a result set as a comma-separated
    list of values, with `"NULL"` printed for each `NULL` value:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是打印结果集中每行作为逗号分隔值列表的示例，对于每个 `NULL` 值都打印 `"NULL"`：
- en: '[PRE180]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 4.8 Obtaining Connection Parameters
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 获取连接参数
- en: Problem
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to obtain connection parameters for a script so that it can connect
    to a MySQL server.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要获取一个脚本的连接参数，以便它可以连接到一个MySQL服务器。
- en: Solution
  id: totrans-806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: There are several ways to do this. Take your pick from the alternatives described
    here.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点。从这里描述的备选方案中选择一种。
- en: Discussion
  id: totrans-808
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Any program that connects to MySQL specifies connection parameters such as
    the username, password, and hostname. The recipes shown so far have put connection
    parameters directly into the code that attempts to establish the connection, but
    that is not the only way for your programs to obtain the parameters. This discussion
    briefly surveys some of the available techniques:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 任何连接到MySQL的程序都会指定连接参数，例如用户名、密码和主机名。到目前为止显示的方法将连接参数直接放入尝试建立连接的代码中，但这并不是您的程序获取参数的唯一方式。本讨论简要概述了一些可用的技术：
- en: Hardwire the parameters into the program
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数硬编码到程序中
- en: The parameters can be given either in the main source file or in a library file
    used by the program. This technique is convenient because users need not enter
    the values themselves, but it’s also inflexible. To change parameters, you must
    modify your program. It is also insecure, because everyone who accesses the library
    would be able to read your database credentials.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以在主源文件或程序使用的库文件中给出。这种技术非常方便，因为用户无需自己输入值，但也非常不灵活。要更改参数，必须修改程序。这也是不安全的，因为访问库的每个人都可以读取您的数据库凭据。
- en: Ask for the parameters interactively
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交互方式询问参数
- en: In a command-line environment, you can ask the user a series of questions. In
    a web or GUI environment, you might do this by presenting a form or dialog. Either
    way, this becomes tedious for people who use the application frequently, due to
    the need to enter the parameters each time.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行环境中，您可以询问用户一系列问题。在Web或GUI环境中，您可以通过呈现表单或对话框来执行此操作。无论哪种方式，对于经常使用应用程序的人来说，由于每次需要输入参数，这变得很繁琐。
- en: Get the parameters from the command line
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行获取参数
- en: You can use this method either for commands run interactively or from within
    a script. Like the method of obtaining parameters interactively, you must supply
    parameters for each command invocation. (A factor that mitigates this burden is
    that many shells enable you to easily recall commands from your history list for
    re-execution.) This method could be insecure if you provide your credentials this
    way.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此方法用于交互式运行的命令或从脚本中运行的命令。与交互式获取参数的方法一样，您必须为每个命令调用提供参数。（减轻这种负担的因素是，许多Shell允许您轻松地从历史列表中重新调用命令以重新执行。）如果以这种方式提供凭据，则此方法可能是不安全的。
- en: Get the parameters from the execution environment
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 从执行环境获取参数
- en: The most common way to do this is to set the appropriate environment variables
    in one of your shell’s startup files (such as *.profile* for *sh*, *bash*, *ksh*;
    or *.login* for *csh* or *tcsh*). Programs that you run during your login session
    then can get parameter values by examining their environment.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最常见方法是在您的Shell启动文件之一中设置适当的环境变量（如*.profile*对于*sh*、*bash*、*ksh*；或者*.login*对于*csh*或*tcsh*）。然后在登录会话期间运行的程序可以通过检查它们的环境来获取参数值。
- en: Get the parameters from a separate file
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个单独的文件中获取参数
- en: With this method, store information such as the username and password in a file
    that programs can read before connecting to the MySQL server. Reading parameters
    from a file that’s separate from your program gives you the benefit of not having
    to enter them each time you use the program, without hardwiring the values into
    it. Also, storing the values in a file enables you to centralize parameters for
    use by multiple programs, and for security purposes you can set the file access
    mode to keep other users from reading the file.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，将诸如用户名和密码之类的信息存储在程序连接到MySQL服务器之前可以读取的文件中。从与您的程序分离的文件中读取参数使您无需每次使用程序时都输入它们，而不需要将值硬编码到程序中。此外，将值存储在文件中使您能够集中存储用于多个程序的参数，并且出于安全目的，您可以设置文件访问模式以防止其他用户读取文件。
- en: The MySQL client library itself supports an option file mechanism, although
    not all APIs provide access to it. For those that don’t, workarounds may exist.
    (As an example, Java supports the use of properties files and supplies utility
    routines for reading them.)
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL客户端库本身支持一个选项文件机制，尽管并非所有的API都提供对其的访问。对于那些不支持的情况，可能存在解决方法。（例如，Java支持使用属性文件，并提供用于读取它们的实用程序例程。）
- en: Use a combination of methods
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多种方法的组合。
- en: It’s often useful to combine methods, to give users the flexibility of providing
    parameters different ways. For example, MySQL clients such as *mysql* and *mysqladmin*
    look for option files in several locations and read any that are present. They
    then check the command-line arguments for further parameters. This enables users
    to specify connection parameters in an option file or on the command line.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 结合方法通常很有用，以便用户可以以不同的方式提供参数。例如，MySQL 客户端（如*mysql*和*mysqladmin*）在几个位置查找选项文件并读取所有存在的选项文件。然后，它们检查命令行参数以获取更多参数。这使用户可以在选项文件或命令行中指定连接参数。
- en: 'These methods of obtaining connection parameters do involve security issues:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 获取连接参数的这些方法确实涉及安全问题：
- en: Any method that stores connection parameters in a file may compromise your system’s
    security unless the file is protected against access by unauthorized users. This
    is true whether parameters are stored in a source file, an option file, or a script
    that invokes a command and specifies the parameters on the command line. (Web
    scripts that can be read only by the web server don’t qualify as secure if other
    users have administrative access to the server.)
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何将连接参数存储在文件中的方法都可能危及您系统的安全，除非该文件受到未经授权用户访问的保护。无论参数存储在源文件、选项文件还是调用命令并在命令行上指定参数的脚本中，这一点都是真实的。（如果其他用户具有对服务器的管理访问权限，则只能由
    Web 服务器读取的 Web 脚本不算安全。）
- en: Parameters specified on the command line or in environment variables are not
    particularly secure. While a program is executing, its command-line arguments
    and environment may be visible to other users who run process status commands
    such as *ps* `-e`. In particular, storing the password in an environment variable
    perhaps is best limited to those situations in which you’re the only user on the
    machine or you trust all other users.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行或环境变量中指定的参数并不特别安全。当程序执行时，它的命令行参数和环境可能对运行`ps` `-e`等进程状态命令的其他用户可见。特别是，将密码存储在环境变量中最好限制在你是机器上唯一的用户或者你信任所有其他用户的情况下。
- en: The rest of this section discusses how to process command-line arguments to
    get connection parameters and how to read parameters from option files.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分讨论如何处理命令行参数以获取连接参数以及如何从选项文件中读取参数。
- en: Getting parameters from the command line
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从命令行获取参数
- en: The convention used by standard clients such as *mysql* and *mysqladmin* for
    command-line arguments is to permit parameters to be specified using either a
    short option or a long option. For example, the username `cbuser` can be specified
    either as `-u` `cbuser` (or `-ucbuser`) or `--user=cbuser`. In addition, for either
    of the password options (`-p` or `--password`), the password value may be omitted
    after the option name to cause the program to prompt for the password interactively.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 标准客户端（如*mysql*和*mysqladmin*）用于命令行参数的约定是允许使用短选项或长选项指定参数。例如，用户名`cbuser`可以指定为`-u`
    `cbuser`（或`-ucbuser`）或`--user=cbuser`。此外，对于密码选项（`-p`或`--password`），在选项名称后可能省略密码值，以导致程序交互式提示输入密码。
- en: The standard flags for these command options are `-h` or `--host`, `-u` or `--user`,
    and `-p` or `--password`. You could write your own code to iterate through the
    argument list, but it’s much easier to use existing option-processing modules
    written for that purpose. Under the *api* directory of the `recipes` distribution,
    you’ll find example programs that show how to process command arguments to obtain
    the hostname, username, and password for Perl, Ruby, Python, and Java. An accompanying
    PDF file explains how each one works.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令选项的标准标记是`-h`或`--host`，`-u`或`--user`，以及`-p`或`--password`。您可以编写自己的代码来遍历参数列表，但使用为此目的编写的现有选项处理模块要容易得多。在`recipes`分发的*api*目录下，您会找到示例程序，展示如何处理命令参数以获取Perl、Ruby、Python和Java的主机名、用户名和密码。附带的PDF文件解释了每个程序的工作原理。
- en: Note
  id: totrans-830
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Insofar as possible, the programs mimic option-handling behavior of the standard
    MySQL clients. An exception is that option-processing libraries may not permit
    making the password value optional, and they provide no way of prompting the user
    for a password interactively if a password option is specified without a password
    value. Consequently, the programs are written so that if you use `-p` or `--password`,
    you must provide the password value following the option.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在尽可能大的程度上，程序模仿了标准 MySQL 客户端的选项处理行为。一个例外是选项处理库可能不允许使密码值变为可选，并且如果指定了密码选项但未提供密码值，则它们不提供以交互方式提示用户输入密码的方法。因此，程序是这样编写的：如果您使用
    `-p` 或 `--password`，则必须提供该选项后面的密码值。
- en: Getting parameters from option files
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从选项文件获取参数
- en: If your API supports it, you can specify connection parameters in a MySQL option
    file and let the API read the parameters from the file for you. For APIs that
    do not support option files directly, you may be able to arrange to read other
    types of files in which parameters are stored or to write your own functions that
    read option files.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 API 支持，可以在 MySQL 选项文件中指定连接参数，并让 API 为您从文件中读取参数。对于不直接支持选项文件的 API，您可以安排读取存储参数的其他类型的文件，或者编写自己的函数来读取选项文件。
- en: '[Recipe 1.4](ch01.xhtml#nch-mysql-mysql-options) describes the format of MySQL
    option files. We assume that you’ve read the discussion there and concentrate
    here on how to use option files from within programs. You can find files containing
    the code discussed here under the *api* directory of the `recipes` distribution.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 1.4](ch01.xhtml#nch-mysql-mysql-options)描述了 MySQL 选项文件的格式。我们假设您已经阅读了那里的讨论，并集中在如何在程序中使用选项文件。您可以在`recipes`分发的*api*目录下找到包含此处讨论代码的文件。'
- en: Under Unix, user-specific options are specified by convention in *~/.my.cnf*
    (that is, in the *.my.cnf* file in your home directory). However, the MySQL option-file
    mechanism can look in several different files if they exist, although no option
    file is *required* to exist. (For the list of standard locations in which MySQL
    programs look for them, see [Recipe 1.4](ch01.xhtml#nch-mysql-mysql-options).)
    If multiple option files exist and a given parameter is specified in several of
    them, the last value found takes precedence.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 下，特定于用户的选项按约定规定在 *~/.my.cnf* 中（即在您的主目录中的 *.my.cnf* 文件中）。但是，MySQL 选项文件机制可以在多个不同的文件中查找，尽管没有任何选项文件是
    *必须* 存在的。（有关 MySQL 程序查找它们的标准位置列表，请参见 [食谱 1.4](ch01.xhtml#nch-mysql-mysql-options)。）如果存在多个选项文件，并且在其中几个文件中指定了给定参数，则最后找到的值优先。
- en: 'Programs you write do not use MySQL option files unless you tell them to:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写的程序不会使用 MySQL 选项文件，除非您告诉它们：
- en: Perl DBI and Ruby Mysql2 gem provide direct API support for reading option files;
    simply indicate that you want to use them at the time that you connect to the
    server. It’s possible to specify that only a particular file should be read, or
    that the standard search order should be used to look for multiple option files.
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perl DBI 和 Ruby Mysql2 gem 提供了直接的 API 支持以读取选项文件；只需在连接到服务器时指示您想使用它们即可。可以指定仅读取特定文件，或者使用标准搜索顺序来查找多个选项文件。
- en: PHP PDO, Connector/Python, Java and Go do not support option files. (The PDO
    MySQL driver does, but not if you use `mysqlnd` as the underlying library.) As
    a workaround for PHP, we’ll write a simple option-file parsing function. For Java,
    we’ll adopt a different approach that uses properties files. For Go we will utilize
    `INI` parsing library.
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP PDO、Connector/Python、Java 和 Go 不支持选项文件。（PDO MySQL 驱动程序除外，但如果使用 `mysqlnd`
    作为底层库则不支持。）作为 PHP 的一种解决方法，我们将编写一个简单的选项文件解析函数。对于 Java，我们将采用使用属性文件的不同方法。对于 Go，我们将利用
    `INI` 解析库。
- en: Although the conventional name under Unix for the user-specific option file
    is *.my.cnf* in the current user’s home directory, there’s no rule that your own
    programs must use this particular file. You can name an option file anything you
    like and put it wherever you want. For example, you might set up a file named
    *mcb.cnf* and install it in the */usr/local/lib/mcb* directory for use by scripts
    that access the `cookbook` database. Under some circumstances, you might even
    want to create multiple option files. Then, from within any given script, select
    the file that’s appropriate for the access privileges the script needs. For example,
    you might have one option file, *mcb.cnf*, that lists parameters for a full-access
    MySQL account, and another file, *mcb-readonly.cnf*, that lists connection parameters
    for an account that needs only read-only access to MySQL. Another possibility
    is to list multiple groups within the same option file and have your scripts select
    options from the appropriate group.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Unix下用户特定选项文件的常规名称是`.my.cnf`，位于当前用户的主目录下，但并没有规定你自己的程序必须使用这个特定的文件。你可以任意命名一个选项文件，并将其放置在任何你想要的位置。例如，你可以设置一个名为`mcb.cnf`的文件，并将其安装在`/usr/local/lib/mcb`目录下，以供访问`cookbook`数据库的脚本使用。在某些情况下，你可能甚至希望创建多个选项文件。然后，在任何给定的脚本中，选择适合脚本需要的访问权限的文件。例如，你可以有一个选项文件`mcb.cnf`，列出完全访问MySQL帐户的参数，以及另一个文件`mcb-readonly.cnf`，列出仅需要MySQL只读访问权限帐户的连接参数。另一种可能性是在同一个选项文件中列出多个组，并让你的脚本从适当的组中选择选项。
- en: Perl
  id: totrans-840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Perl
- en: 'Perl DBI scripts can use option files. To take advantage of this, place the
    appropriate option specifiers in the third component of the data source name (DSN)
    string:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: Perl DBI脚本可以使用选项文件。为了利用这一点，请将适当的选项规范放置在数据源名称（DSN）字符串的第三个组件中：
- en: To specify an option group, use ``mysql_read_default_group=*`groupname`*``.
    This tells MySQL to search the standard option files for options in the named
    group and in the `[client]` group. Write the *`groupname`* value without the surrounding
    square brackets. (If a group in an option file begins with a `[my_prog]` line,
    specify the *`groupname`* value as `my_prog`.) To search the standard files but
    look only in the `[client]` group, *`groupname`* should be `client`.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定一个选项组，请使用``mysql_read_default_group=*`groupname`*``。这告诉MySQL在标准选项文件中搜索指定组和`[client]`组中的选项。将*`groupname`*值写入，不包含周围的方括号。（如果选项文件中的组以`[my_prog]`行开始，则将*`groupname`*值指定为`my_prog`。）要搜索标准文件，但仅在`[client]`组中查找，*`groupname`*应为`client`。
- en: To name a specific option file, use ``mysql_read_default_file=*`filename`*``
    in the DSN. When you do this, MySQL looks only in that file and only for options
    in the `[client]` group.
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要命名特定的选项文件，请在DSN中使用``mysql_read_default_file=*`filename`*``。这样做时，MySQL仅在该文件中查找并仅使用`[client]`组中的选项。
- en: If you specify both an option file and an option group, MySQL reads only the
    named file, but looks for options both in the named group and in the `[client]`
    group.
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果同时指定了选项文件和选项组，MySQL只读取指定的文件，但在指定组和`[client]`组中查找选项。
- en: 'The following example tells MySQL to use the standard option-file search order
    to look for options in both the `[cookbook]` and `[client]` groups:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例告诉MySQL使用标准选项文件搜索顺序来查找`[cookbook]`和`[client]`组中的选项：
- en: '[PRE181]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The next example explicitly names the option file located in `$ENV{HOME}`,
    the home directory of the user running the script. Thus, MySQL looks only in that
    file and uses options from the `[client]` group:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例明确指定了位于`$ENV{HOME}`（运行脚本的用户的主目录）中的选项文件。因此，MySQL仅在该文件中查找并使用`[client]`组中的选项：
- en: '[PRE182]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'If you pass an empty value (`undef` or the empty string) for the username or
    password arguments of the `connect()` call, `connect()` uses whatever values are
    found in the option file or files. A nonempty username or password in the `connect()`
    call overrides any option-file value. Similarly, a host named in the DSN overrides
    any option-file value. Use this behavior to enable DBI scripts to obtain connection
    parameters both from option files as well as from the command line as follows:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`connect()`调用的用户名或密码参数中传递空值（`undef`或空字符串），`connect()`将使用在选项文件中找到的任何值。在`connect()`调用中，非空的用户名或密码会覆盖选项文件中的任何值。类似地，DSN中指定的主机会覆盖选项文件中的任何值。使用此行为使得DBI脚本可以从选项文件和命令行获取连接参数：
- en: Create `$host_name`, `$user_name`, and `$password` variables, each with a value
    of `undef`. Then parse the command-line arguments to set the variables to non-`undef`
    values if the corresponding options are present on the command line. (The *cmdline.pl*
    Perl script under the *api* directory of the `recipes` distribution demonstrates
    how to do this.)
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`$host_name`、`$user_name`和`$password`变量，每个变量的值为`undef`。然后解析命令行参数，如果命令行中存在相应的选项，则将变量设置为非`undef`值。（*api*目录下的*cmdline.pl*
    Perl脚本演示了如何执行此操作。）
- en: After parsing the command arguments, construct the DSN string, and call `connect()`.
    Use `mysql_read_default_group` and `mysql_read_default_file` in the DSN to specify
    how you want option files to be used, and, if `$host_name` is not `undef`, add
    `host=$host_name` to the DSN. In addition, pass `$user_name` and `$password` as
    the username and password arguments to `connect()`. These will be `undef` by default;
    if they were set from the command-line arguments, they will have non-`undef` values
    that override any option-file values.
  id: totrans-851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解析命令参数后，构建DSN字符串，并调用`connect()`。在DSN中使用`mysql_read_default_group`和`mysql_read_default_file`来指定选项文件的使用方式，如果`$host_name`不是`undef`，则将`host=$host_name`添加到DSN中。此外，将`$user_name`和`$password`作为用户名和密码参数传递给`connect()`。这些参数默认为`undef`；如果它们从命令行参数设置了值，则这些值将覆盖任何选项文件中的值。
- en: If a script follows this procedure, parameters given by the user on the command
    line are passed to `connect()` and take precedence over the contents of option
    files.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本遵循此过程，则用户在命令行上提供的参数将传递给`connect()`，并优先于选项文件中的内容。
- en: Ruby
  id: totrans-853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Ruby
- en: Ruby Mysql2 scripts can read option files, specified by the `default_file` connection
    parameter. If you want to specify default group, use option `default_group`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby Mysql2脚本可以读取选项文件，通过`default_file`连接参数指定。如果要指定默认组，请使用选项`default_group`。
- en: 'This example uses the standard option-file search order to look for options
    in both the `[cookbook]` and `[client]` groups:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用标准的选项文件搜索顺序来查找`[cookbook]`和`[client]`组中的选项：
- en: '[PRE183]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The following example uses the *.my.cnf* file in the current user’s home directory
    to obtain parameters from the `[client]` group:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用当前用户主目录中的*.my.cnf*文件获取`[client]`组中的参数：
- en: '[PRE184]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: PHP
  id: totrans-859
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PHP
- en: As mentioned earlier, the PDO MySQL driver does not necessarily support using
    MySQL option files (it does not if you use `mysqlnd` as the underlying library).
    To work around that limitation, use a function that reads an option file, such
    as the `read_mysql_option_file()` function shown in the following listing. It
    takes as arguments the name of an option file and an option group name or an array
    containing group names. (Group names should be written without square brackets.)
    It then reads any options present in the file for the named group or groups. If
    no option group argument is given, the function looks by default in the `[client]`
    group. The return value is an array of option name/value pairs, or `FALSE` if
    an error occurs. It is not an error for the file not to exist. (Note that quoted
    option values and trailing `#`-style comments following option values are legal
    in MySQL option files, but this function does not handle those constructs.)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，PDO MySQL驱动程序不一定支持使用MySQL选项文件（如果使用`mysqlnd`作为底层库则不支持）。为了解决这个限制，可以使用一个函数来读取选项文件，例如下面列表中显示的`read_mysql_option_file()`函数。它的参数包括选项文件的名称和选项组名称或包含组名称的数组（组名称应该不带方括号）。然后，它读取文件中指定组或组的任何选项。如果没有给出选项组参数，则函数默认在`[client]`组中查找。返回值是一个选项名称/值对的数组，如果发生错误则返回`FALSE`。文件不存在并不是错误。（请注意，MySQL选项文件中的带引号的选项值和选项值后的尾随`#`风格注释是合法的，但该函数不处理这些结构。）
- en: '[PRE185]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Here are two examples showing how to use `read_mysql_option_file()`. The first
    reads a user’s option file to get the `[client]` group parameters and uses them
    to connect to the server. The second reads the system-wide option file, */etc/my.cnf*,
    and prints the server startup parameters that are found there (that is, the parameters
    in the `[mysqld]` and `[server]` groups):'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个示例展示如何使用`read_mysql_option_file()`。第一个示例读取用户的选项文件以获取`[client]`组参数，并将它们用于连接到服务器。第二个示例读取系统范围的选项文件，*/etc/my.cnf*，并打印在那里找到的服务器启动参数（即`[mysqld]`和`[server]`组中的参数）：
- en: '[PRE186]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'PHP does have a `parse_ini_file()` function that is intended for parsing *.ini*
    files. These have a syntax that is similar to MySQL option files, so you might
    find this function of use. However, there are some differences to watch out for.
    Suppose that you have a file written like this:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 确实有一个 `parse_ini_file()` 函数，用于解析 *.ini* 文件。这些文件的语法与 MySQL 选项文件类似，因此您可能会发现此函数有用。但是，需要注意一些区别。假设您有一个文件写成这样：
- en: '[PRE187]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Standard MySQL option parsing considers both the `user` and `host` values part
    of the `[client]` group, whereas `parse_ini_file()` returns only the contents
    of the final `[client]` stanza; the `user` option is lost. Also, `parse_ini_file()`
    ignores options that are given without a value, so the `no-auto-rehash` option
    is lost.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 MySQL 选项解析将 `user` 和 `host` 值都视为 `[client]` 组的一部分，而 `parse_ini_file()` 仅返回最终
    `[client]` 节的内容；`user` 选项会丢失。此外，`parse_ini_file()` 忽略未附带值的选项，因此 `no-auto-rehash`
    选项也会丢失。
- en: Go
  id: totrans-867
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Go
- en: 'The Go-MySQL-Driver doesn’t support option files. However, the INI parsing
    library supports reading properties files that contain lines in the *`name=value`*
    format. Here is a sample properties file:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: Go-MySQL-Driver 不支持选项文件。然而，INI 解析库支持读取包含以 *`name=value`* 格式为行的属性文件。以下是一个示例属性文件：
- en: '[PRE188]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Function `MyCnf()` shows one way to read a properties file named *~/.my.cnf*
    to obtain connection parameters:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `MyCnf()` 展示了读取名为 *~/.my.cnf* 的属性文件以获取连接参数的一种方法：
- en: '[PRE189]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The function `MyCnf()` defined in the *cookbook.go*, developed elsewhere in
    the chapter (see [Recipe 4.3](#nch-api-api-library)). It is used in the file *mycnf.go*
    which you will find in the directory *api/06_conn_params* in the `recipes` distribution:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章其他地方开发的 *cookbook.go* 中定义的 `MyCnf()` 函数（参见 [Recipe 4.3](#nch-api-api-library)）。它在
    *api/06_conn_params* 目录中的 *mycnf.go* 文件中使用，在 `recipes` 发行版中找到：
- en: '[PRE190]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: The function `MyCnf()` accepts section name as a parameter. If you want to replace
    section `[client]` with any other name call `MyCnf()` as `MyCnf("other")` where
    `other` is the name of the section.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `MyCnf()` 接受节名作为参数。如果要用任何其他名称替换 `[client]` 节，请调用 `MyCnf()`，如 `MyCnf("other")`，其中
    `other` 是节的名称。
- en: Java
  id: totrans-875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Java
- en: 'The JDBC MySQL Connector/J driver doesn’t support option files. However, the
    Java class library supports reading properties files that contain lines in *`name=value`*
    format. This is similar but not identical to MySQL option-file format (for example,
    properties files do not permit ``[*`groupname`*]`` lines). Here is a simple properties
    file:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC MySQL Connector/J 驱动程序不支持选项文件。然而，Java 类库支持读取以 *`name=value`* 格式为行的属性文件。这与
    MySQL 选项文件格式类似但并非完全相同（例如，属性文件不允许 ``[*`groupname`*]`` 行）。以下是一个简单的属性文件：
- en: '[PRE191]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The following program, *ReadPropsFile.java*, shows one way to read a properties
    file named *Cookbook.properties* to obtain connection parameters. The file must
    be in some directory named in your `CLASSPATH` variable, or you must specify it
    using a full pathname (the example shown here assumes that the file is in a `CLASSPATH`
    directory):'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的程序 *ReadPropsFile.java* 展示了读取名为 *Cookbook.properties* 的属性文件以获取连接参数的一种方法。文件必须位于您的
    `CLASSPATH` 变量命名的某个目录中，或者您必须使用完整路径名指定它（这里显示的示例假定文件位于 `CLASSPATH` 目录中）：
- en: '[PRE192]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'To have `getProperty()` return a particular default value when the named property
    is not found, pass that value as a second argument. For example, to use `127.0.0.1`
    as the default `host` value, call `getProperty()` like this:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 要在未找到命名属性时使 `getProperty()` 返回特定的默认值，请将该值作为第二个参数传递。例如，要将 `127.0.0.1` 作为默认的 `host`
    值，可以像这样调用 `getProperty()`：
- en: '[PRE193]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The *Cookbook.java* library file developed elsewhere in the chapter (see [Recipe
    4.3](#nch-api-api-library)) includes an extra library call in the version of the
    file that you’ll find in the *lib* directory of the `recipes` distribution: a
    `propsConnect()` routine that is based on the concepts discussed here. To use
    it, set up the contents of the properties file, *Cookbook.properties*, and copy
    the file to the same location where you installed *Cookbook.class*. You can then
    establish a connection within a program by importing the `Cookbook` class and
    calling `Cookbook.propsConnect()` rather than by calling `Cookbook.connect()`.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 本章其他地方开发的 *Cookbook.java* 库文件（参见 [Recipe 4.3](#nch-api-api-library)）在 *lib*
    目录中的版本中包含一个额外的库调用：一个基于此处讨论的概念的 `propsConnect()` 程序。要使用它，请设置 *Cookbook.properties*
    属性文件的内容，并将文件复制到安装 *Cookbook.class* 的相同位置。然后，通过导入 `Cookbook` 类并调用 `Cookbook.propsConnect()`
    来在程序中建立连接，而不是调用 `Cookbook.connect()`。
- en: 4.9 Resetting the profile Table
  id: totrans-883
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.9 重置 profile 表
- en: Problem
  id: totrans-884
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: While working on examples in this chapter you changed original content of the
    table `profile` and now want it back, so you can use it while working with other
    recipes.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，您改变了`profile`表的原始内容，现在希望将其恢复，以便在处理其他配方时使用。
- en: Solution
  id: totrans-886
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Reload the table using the *mysql* client.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*mysql*客户端重新加载表格。
- en: Discussion
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'It’s a good idea to reset the `profile` table used in this chapter to a known
    state. Change location into the *tables* directory of the `recipes` distribution,
    and run these commands:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将本章中使用的`profile`表重置为已知状态。切换到`recipes`分发的*tables*目录，并运行以下命令：
- en: '[PRE194]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Several statements in later chapters use the `profile` table; by reinitializing
    it, you’ll get the same results displayed in those chapters when you run the statements
    shown there.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 几个后续章节中的语句使用了`profile`表；通过重新初始化它，您可以在运行那些章节中显示的语句时获得相同的结果。
- en: This chapter discussed the basic operations provided by each of our APIs for
    handling various aspects of interaction with the MySQL server. These operations
    enable you to write programs that execute any kind of statement and retrieve the
    results. Up to this point, we’ve used simple statements because the focus is on
    the APIs rather than on SQL. The next chapter focuses on SQL instead, to show
    how to ask the database server more complex questions.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了我们的每个 API 提供的基本操作，用于处理与 MySQL 服务器的交互的各个方面。这些操作使您能够编写执行任何类型语句并检索结果的程序。到目前为止，我们使用了简单的语句，因为重点是在
    API 上而不是 SQL 上。下一章则专注于 SQL，展示如何向数据库服务器提出更复杂的问题。
