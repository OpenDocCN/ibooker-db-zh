- en: Chapter 5\. Selecting Data from Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 从表中选择数据
- en: 5.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.0 引言
- en: This chapter focuses on using the `SELECT` statement to retrieve information
    from your database. You will find the chapter helpful if your SQL background is
    limited or to find out about the MySQL-specific extensions to `SELECT` syntax.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用`SELECT`语句从数据库中检索信息。如果你的SQL背景有限或想了解MySQL特定的`SELECT`语法扩展，本章对你会很有帮助。
- en: There are many ways to write `SELECT` statements; we’ll look at only a few.
    Consult the *MySQL Reference Manual* or a general MySQL text for more information
    about `SELECT` syntax and the functions and operators available to extract and
    manipulate data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以编写`SELECT`语句；我们只会讨论其中几种。有关`SELECT`语法以及提取和操作数据的函数和运算符的更多信息，请参阅*MySQL参考手册*或一般的MySQL文本。
- en: 'Many examples in this chapter use a table named `mail` that contains rows that
    track mail message traffic between users on a set of hosts. The following shows
    how that table was created:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例使用了一个名为`mail`的表，该表包含跟踪用户之间邮件消息流量的行。以下显示了如何创建该表：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `mail` table contents look like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`mail`表的内容如下：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create and load the `mail` table, change location into the *tables* directory
    of the `recipes` distribution and run this command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建并加载`mail`表，请进入`recipes`分发的*tables*目录，并运行以下命令：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This chapter also uses other tables from time to time. Some were used in previous
    chapters, whereas others are new. To create any of them, do so the same way as
    for the `mail` table, using the appropriate script in the *tables* directory.
    In addition, many of the other scripts and programs used in this chapter are located
    in the *select* directory. The files in that directory enable you to try the examples
    more easily.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有时还会使用其他表。有些表在之前的章节中已经用过，而其他表则是新的。要创建任何表，请像创建`mail`表那样，在*tables*目录中使用适当的脚本。此外，本章中使用的许多其他脚本和程序位于*select*目录中。该目录中的文件使您可以更轻松地尝试示例。
- en: Many of the statements shown here can be executed from within the *mysql* program,
    which is discussed in [Chapter 1](ch01.xhtml#nch-mysql). A few examples involve
    issuing statements from within the context of a programming language. See [Chapter 4](ch04.xhtml#nch-api)
    for information on programming techniques.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例可以在*mysql*程序内部执行，该程序在[第1章](ch01.xhtml#nch-mysql)中有所讨论。少数示例涉及从编程语言的上下文中发布语句。有关编程技术的信息，请参阅[第4章](ch04.xhtml#nch-api)。
- en: 5.1 Specifying Which Columns and Rows to Select
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 指定要选择的列和行
- en: Problem
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to display specific columns and rows from a table.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要从表中显示特定的列和行。
- en: Solution
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To indicate which columns to display, name them in the output column list. To
    indicate which rows to display, use a `WHERE` clause that specifies conditions
    that rows must satisfy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示显示哪些列，请在输出列列表中命名它们。要指示显示哪些行，请使用一个`WHERE`子句，指定行必须满足的条件。
- en: Discussion
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The simplest way to display columns from a table is to use `SELECT` `*` `FROM`
    *`tbl_name`*. The `*` specifier is a shortcut that means <q>all columns</q>:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中显示列的最简单方法是使用`SELECT * FROM` *`tbl_name`*。`*`说明符是一个快捷方式，意思是<q>所有列</q>：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using `*` is easy, but you cannot select only certain columns or control column
    display order. Naming columns explicitly enables you to select only the ones of
    interest, in any order. This query omits the recipient columns and displays the
    sender before the date and size:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*`很容易，但你不能选择特定的列或控制列的显示顺序。明确命名列使你能够按任意顺序选择感兴趣的列。这个查询省略了收件人列，并在日期和大小之前显示发件人：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unless you qualify or restrict a `SELECT` query in some way, it retrieves every
    row in your table. To be more precise, provide a `WHERE` clause that specifies
    one or more conditions that rows must satisfy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不限定或限制`SELECT`查询的方式，它将检索表中的每一行。为了更精确，请提供一个`WHERE`子句，指定行必须满足的一个或多个条件。
- en: 'Conditions can test for equality, inequality, or relative ordering. For some
    types of data, such as strings, you can use pattern matches. The following statements
    select columns from rows in the `mail` table containing `srchost` values that
    are exactly equal to the string `''venus''` or that begin with the letter `''s''`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 条件可以测试相等性、不等式或相对顺序。对于某些类型的数据，如字符串，可以使用模式匹配。以下语句从`mail`表中选择包含`srchost`值完全等于字符串`'venus'`或以字母`s`开头的行的列：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `LIKE` operator in the previous query performs a pattern match, where `%`
    acts as a wildcard that matches any string. [Recipe 7.10](ch07.xhtml#nch-strings-strings-pat-sql)
    discusses pattern matching further.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个查询中的`LIKE`运算符执行模式匹配，其中`%`充当通配符，匹配任何字符串。[配方 7.10](ch07.xhtml#nch-strings-strings-pat-sql)进一步讨论了模式匹配。
- en: 'A `WHERE` clause can test multiple conditions and different conditions can
    test different columns. The following statement finds messages sent by `barb`
    to `tricia`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`子句可以测试多个条件，不同的条件可以测试不同的列。下面的语句查找由`barb`发送给`tricia`的消息：'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Output columns can be calculated by evaluating expressions. This query combines
    the `srcuser` and `srchost` columns using `CONCAT()` to produce composite values
    in email address format:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列可以通过评估表达式来计算。此查询使用`CONCAT()`将`srcuser`和`srchost`列组合成电子邮件地址格式的复合值：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll notice that the email address column label is the expression that calculates
    it. To provide a better label, use a column alias (see [Recipe 5.2](#nch-select-select-column-alias)).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到电子邮件地址列标签是计算它的表达式。为了提供更好的标签，请使用列别名（参见[配方 5.2](#nch-select-select-column-alias)）。
- en: As of MySQL 8.0.19 you can use statement `TABLE` to select all columns from
    the table. `TABLE` supports `ORDER BY` (see [Recipe 5.3](#nch-select-select-sort))
    and `LIMIT` (see [Recipe 5.11](#nch-select-select-limit-calc)) clauses, but does
    not allow any other filtering of columns or rows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自 MySQL 8.0.19 起，您可以使用`TABLE`语句从表中选择所有列。`TABLE`支持`ORDER BY`（参见[配方 5.3](#nch-select-select-sort)）和`LIMIT`（参见[配方
    5.11](#nch-select-select-limit-calc)）子句，但不允许对列或行进行任何其他过滤。
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 5.2 Naming Query Result Columns
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 命名查询结果列
- en: Problem
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The column names in a query result are unsuitable, ugly, or difficult to work
    with, so you want to name them yourself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果中的列名不合适、难看或难以处理，因此您希望自己命名它们。
- en: Solution
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use aliases to choose your own column names.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名来选择您自己的列名。
- en: Discussion
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When you retrieve a result set, MySQL gives every output column a name. (That’s
    how the *mysql* program gets the names you see displayed in the initial row of
    column headers in result set output.) By default, MySQL assigns the column names
    specified in the `CREATE` `TABLE` or `ALTER` `TABLE` statement to output columns,
    but if these defaults are not suitable, you can use column aliases to specify
    your own names.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检索结果集时，MySQL为每个输出列指定一个名称。（这就是*mysql*程序获取在结果集输出的列标题初始行中看到的名称的方式。）默认情况下，MySQL将`CREATE`
    `TABLE`或`ALTER` `TABLE`语句中指定的列名分配给输出列，但如果这些默认名称不合适，则可以使用列别名指定自己的名称。
- en: This recipe explains aliases and shows how to use them to assign column names
    in statements. If you’re writing a program that must determine the names, see
    [Recipe 12.2](ch12.xhtml#nch-meta-meta-result) for information about accessing
    column metadata.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方解释了别名，并展示了如何在语句中使用它们来分配列名。如果您正在编写一个必须确定名称的程序，请参阅[配方 12.2](ch12.xhtml#nch-meta-meta-result)以获取有关访问列元数据的信息。
- en: 'If an output column comes directly from a table, MySQL uses the table column
    name for the output column name. The following statement selects four table columns,
    the names of which become the corresponding output column names:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出列直接来自表格，MySQL会使用表列名作为输出列名。以下语句选择四个表列，其名称成为相应的输出列名：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you generate a column by evaluating an expression, the expression itself
    is the column name. This can produce long and unwieldy names in result sets, as
    illustrated by the following statement that uses one expression to reformat the
    dates in the `t` column, and another to combine `srcuser` and `srchost` into email
    address format:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过评估表达式生成列，则表达式本身就是列名。这可能会在结果集中产生长而难以控制的名称，如下面的语句所示，该语句使用一个表达式重新格式化`t`列中的日期，并使用另一个表达式将`srcuser`和`srchost`组合成电子邮件地址格式：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To choose your own output column name, use an `AS` *`name`* clause to specify
    a column alias (the keyword `AS` is optional). The following statement retrieves
    the same result as the previous one, but renames the first column to `date_sent`
    and the second to `sender`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择自己的输出列名，使用`AS` *`name`* 子句指定列别名（关键字`AS`是可选的）。下面的语句检索与前一个语句相同的结果，但将第一列重命名为`date_sent`，第二列重命名为`sender`：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The aliases make the column names more concise, easier to read, and more meaningful.
    Aliases are subject to a few restrictions. For example, they must be quoted if
    they are SQL keywords, entirely numeric, or contain spaces or other special characters
    (an alias can consist of several words if you want to use a descriptive phrase).
    The following statement retrieves the same data values as the preceding one but
    uses phrases to name the output columns:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 别名使列名称更简洁，更易于阅读，更有意义。别名受到一些限制。例如，如果它们是SQL关键字、完全是数字或包含空格或其他特殊字符（如果您想使用描述性短语，别名可以由多个单词组成）。下面的语句检索与前一个语句相同的数据值，但使用短语命名输出列：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If MySQL complains about a single-word alias, the word probably is reserved.
    Quoting the alias should make it legal:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MySQL对单词别名抱怨，则该单词可能是保留字。引用别名应该使其合法：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Column aliases also are useful for programming purposes. If you write a program
    that fetches rows into an array and accesses them by numeric column indexes, the
    presence or absence of column aliases makes no difference because aliases don’t
    change the positions of columns within the result set. However, aliases make a
    big difference if you access output columns by name because aliases change those
    names. Exploit this fact to give your program easier names to work with. For example,
    if your query displays reformatted message time values from the `mail` table using
    the expression `DATE_FORMAT(t,''%M %e, %Y'')`, that expression is also the name
    you must use when referring to the output column. In a Perl hashref, for example,
    you’d access it as `$ref->{"DATE_FORMAT(t,''%M %e, %Y'')"}`. That’s inconvenient.
    Use `AS` `date_sent` to give the column an alias and you can refer to it more
    easily as `$ref->{date_sent}`. Here’s an example that shows how a Perl DBI script
    might process such values. It retrieves rows into a hash and refers to column
    values by name:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列别名对编程目的也非常有用。如果您编写一个程序，将行获取到数组中并通过数值列索引访问它们，则列别名的存在与否不会有任何影响，因为别名不会改变结果集中列的位置。然而，如果您通过名称访问输出列，则别名会产生很大的影响，因为别名会改变这些名称。利用这一点，可以为程序提供更容易处理的名称。例如，如果您的查询使用表`mail`中的表达式`DATE_FORMAT(t,'%M
    %e, %Y')`显示重新格式化的消息时间值，那么该表达式也是在引用输出列时必须使用的名称。例如，在Perl的哈希引用中，您可以将其访问为`$ref->{"DATE_FORMAT(t,'%M
    %e, %Y')}"`。这很不方便。使用`AS date_sent`为列添加别名，您可以更轻松地引用它，例如`$ref->{date_sent}`。下面是一个示例，显示Perl
    DBI脚本如何处理这样的值。它将行检索到哈希中，并通过名称引用列值：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In Java, you’d do something like this, where the argument to `getString()`
    names the column to access:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，您可以这样做，其中`getString()`的参数命名要访问的列：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Recipe 4.4](ch04.xhtml#nch-api-api-statement) shows for each of our programming
    languages how to fetch rows into data structures that permit access to column
    values by name. The *select* directory of the `recipes` distribution has examples
    that show how to do this for the `mail` table.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 4.4](ch04.xhtml#nch-api-api-statement)显示了我们每种编程语言如何将行获取到允许按名称访问列值的数据结构中的示例。`recipes`分发的*select*目录有示例显示如何对`mail`表执行此操作。'
- en: 'You cannot refer to column aliases in a `WHERE` clause. Thus, the following
    statement is illegal:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在`WHERE`子句中引用列别名。因此，以下语句是非法的：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The error occurs because an alias names an *output* column, whereas a `WHERE`
    clause operates on *input* columns to determine which rows to select for output.
    To make the statement legal, replace the alias in the `WHERE` clause with the
    same column or expression that the alias represents:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为别名命名了一个*输出*列，而`WHERE`子句操作*输入*列来确定要为输出选择哪些行。要使语句合法，将`WHERE`子句中的别名替换为代表该别名的相同列或表达式即可。
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 5.3 Sorting Query Results
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 排序查询结果
- en: Problem
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to control how your query results are sorted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望控制查询结果的排序方式。
- en: Solution
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: MUse an `ORDER` `BY` clause to tell it how to sort result rows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ORDER BY`子句告诉它如何排序结果行。
- en: Discussion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When you select rows, the MySQL server is free to return them in any order
    unless you instruct it otherwise by saying how to sort the result. There are lots
    of ways to use sorting techniques, as [Chapter 9](ch09.xhtml#nch-sort) explores
    in detail. Briefly, to sort a result set, add an `ORDER` `BY` clause that names
    the column or columns to use for sorting. This statement names multiple columns
    in the `ORDER` `BY` clause to sort rows by host and by user within each host:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择行时，MySQL 服务器可以按任意顺序返回它们，除非您通过排序结果来指示它。有许多排序技术可以使用，正如[第 9 章](ch09.xhtml#nch-sort)详细探讨的那样。简言之，要对结果集排序，请在`ORDER
    BY`子句中指定要用于排序的列。以下语句在`ORDER BY`子句中命名多个列，按主机和每个主机内的用户排序行：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'MySQL sorts rows in the ascending order by default. To sort a column in reverse
    (descending) order, add the keyword `DESC` after its name in the `ORDER` `BY`
    clause:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 默认按升序对行进行排序。要按逆序（降序）排序列，请在`ORDER BY`子句中列名后添加关键字`DESC`：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 5.4 Removing Duplicate Rows
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 删除重复行
- en: Problem
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Output from a query contains duplicate rows. You want to eliminate them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的输出包含重复行。您希望消除它们。
- en: Solution
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `DISTINCT`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DISTINCT`。
- en: Discussion
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Some queries produce results containing duplicate rows. For example, to see
    who sent mail, query the `mail` table like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 某些查询会生成包含重复行的结果。例如，要查看谁发送了邮件，请像这样查询`mail`表：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That result is heavily redundant. To remove the duplicate rows and produce
    a set of unique values, add `DISTINCT` to the query:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那个结果非常冗余。要删除重复行并生成一组唯一值，请在查询中添加`DISTINCT`：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To count the number of unique values in a column, use `COUNT(DISTINCT)`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算列中唯一值的数量，请使用`COUNT(DISTINCT)`：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`DISTINCT` works with multiple-column output, too. The following query shows
    which dates are represented in the `mail` table:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`DISTINCT`也适用于多列输出。以下查询显示了`mail`表中表示的日期：'
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See Also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 10](ch10.xhtml#nch-sum) revisits `DISTINCT` and `COUNT(DISTINCT)`.
    [Chapter 18](ch18.xhtml#nch-dups) discusses duplicate removal in more detail.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 10 章](ch10.xhtml#nch-sum)重新讨论了`DISTINCT`和`COUNT(DISTINCT)`。[第 18 章](ch18.xhtml#nch-dups)更详细地讨论了重复项的移除。'
- en: 5.5 Working with NULL Values
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 处理 NULL 值
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re trying to to compare column values to `NULL`, but it isn’t working.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您试图比较列值和`NULL`，但却无法正常工作。
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the proper comparison operators: `IS` `NULL`, `IS` `NOT` `NULL`, or `<=>`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的比较操作符：`IS NULL`、`IS NOT NULL`或`<=>`。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Conditions that involve `NULL` are special because `NULL` means <q>unknown value.</q>
    Consequently, comparisons such as *`value`* `=` `NULL` or *`value`* `<>` `NULL`
    always produce a result of `NULL` (not true or false) because it’s impossible
    to tell whether they are true or false. Even `NULL` `=` `NULL` produces `NULL`
    because you can’t determine whether one unknown value is the same as another.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及`NULL`的条件很特殊，因为`NULL`意味着<q>未知值。</q>因此，像*`value`* `=` `NULL`或*`value`* `<>`
    `NULL`这样的比较总是产生`NULL`（而不是真或假），因为无法确定它们是真还是假。即使`NULL` `=` `NULL`也产生`NULL`，因为您无法确定一个未知值是否与另一个相同。
- en: 'To look for values that are or are not `NULL`, use the `IS` `NULL` or `IS`
    `NOT` `NULL` operator. Suppose that a table named `expt` contains experimental
    results for subjects who are to be given four tests each and that represents tests
    not yet administered using `NULL`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找`NULL`或非`NULL`的值，请使用`IS NULL`或`IS NOT NULL`运算符。假设名为`expt`的表包含待给每个主题四次测试的实验结果，并且表示尚未进行的测试使用`NULL`：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can see that `=` and `<>` fail to identify `NULL` values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`=`和`<>`无法识别`NULL`值：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write the statements like this instead:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将语句写成这样：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The MySQL-specific `<=>` null-safe comparison operator, unlike the `=` operator,
    is true even for two `NULL` values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 特定的`<=>`空安全比较运算符，与`=``运算符不同，即使是两个`NULL`值也为真：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Sometimes it’s useful to map `NULL` values onto some other value that has more
    meaning in the context of your application. For example, use `IF()` to map `NULL`
    onto the string `Unknown`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候将`NULL`值映射到应用程序上下文中具有更多含义的其他值是很有用的。例如，使用`IF()`将`NULL`映射到字符串`Unknown`：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This `IF()`-based mapping technique works for any kind of value, but it’s especially
    useful with `NULL` values because `NULL` tends to be given a variety of meanings:
    unknown, missing, not yet determined, out of range, and so forth. Choose the label
    that makes the most sense in a given context.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于`IF()`的映射技术适用于任何类型的值，但对于`NULL`值尤其有用，因为`NULL`往往被赋予多种含义：未知、缺失、尚未确定、超出范围等等。选择在特定上下文中最合适的标签。
- en: 'The preceding query can be written more concisely using `IFNULL()`, which tests
    its first argument and returns it if it’s not `NULL`, or returns its second argument
    otherwise:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询可以更简洁地使用 `IFNULL()` 编写，它测试其第一个参数，如果不为 `NULL` 则返回该参数，否则返回其第二个参数：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In other words, these two tests are equivalent:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这两个测试是等效的：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From a readability standpoint, `IF()` often is easier to understand than `IFNULL()`.
    From a computational perspective, `IFNULL()` is more efficient because *`expr1`*
    need not be evaluated twice, as happens with `IF()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从可读性角度来看，`IF()` 往往比 `IFNULL()` 更容易理解。从计算的角度来看，`IFNULL()` 更有效率，因为 *`expr1`* 不需要像
    `IF()` 那样评估两次。
- en: One more way to map `NULL` values is to use function `COALESCE` that returns
    first not-null element from the list of parameters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 映射 `NULL` 值的另一种方法是使用函数 `COALESCE`，它从参数列表中返回第一个非空元素。
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See Also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`NULL` values also behave differently when used by sorting and summary operations.
    See [Recipe 9.11](ch09.xhtml#nch-sort-sort-float) and [Recipe 10.9](ch10.xhtml#nch-sum-sum-null).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于排序和汇总操作时，`NULL` 值的行为也不同。参见 [Recipe 9.11](ch09.xhtml#nch-sort-sort-float)
    和 [Recipe 10.9](ch10.xhtml#nch-sum-sum-null)。
- en: 5.6 Writing Comparisons Involving NULL in Programs
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 编写涉及程序中的 NULL 的比较
- en: Problem
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’re writing a program that looks for rows containing a specific value, but
    it fails when the value is `NULL`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在编写一个程序，查找包含特定值的行，但当该值为 `NULL` 时失败。
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Choose the proper comparison operator according to whether the comparison value
    is or is not `NULL`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据比较值是否为 `NULL`，选择适当的比较运算符。
- en: Discussion
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 5.5](#nch-select-select-null) discusses the need to use different comparison
    operators for `NULL` values than for non-`NULL` values in SQL statements. This
    issue leads to a subtle danger when constructing statement strings within programs.
    If a value stored in a variable might represent a `NULL` value, you must account
    for that when you use the value in comparisons. For example, in Python, `None`
    represents a `NULL` value, so to construct a statement that finds rows in the
    `expt` table matching some arbitrary value in a `score` variable, you cannot do
    this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 5.5](#nch-select-select-null) 讨论了在 SQL 语句中使用与非 `NULL` 值不同比较运算符的需要。这个问题在构建程序内的语句字符串时可能会导致微妙的危险。如果存储在变量中的值可能表示
    `NULL` 值，则在比较中使用该值时必须考虑到这一点。例如，在 Python 中，`None` 表示 `NULL` 值，因此要构建一个语句来查找 `expt`
    表中与某个 `score` 变量中的任意值匹配的行，不能这样做：'
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The statement fails when `score` is `None` because the resulting statement
    becomes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `score` 是 `None` 时，语句失败，因为结果语句变成了：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A comparison of `score` `=` `NULL` is never true, so that statement returns
    no rows. To take into account the possibility that `score` could be `None`, construct
    the statement using the appropriate comparison operator like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`score` `=` `NULL` 的比较永远不成立，因此该语句不返回行。为了考虑到 `score` 可能是 `None` 的情况，构建语句时应使用适当的比较运算符，例如这样：'
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This results in statements as follows for `score` values of `None` (`NULL`)
    or 43 (not `NULL`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致对于 `score` 值为 `None` (`NULL`) 或 43（不为 `NULL`）的语句如下所示：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For inequality tests, set `operator` like this instead:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不等式测试，应像这样设置 `operator`：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 5.7 Using Views to Simplify Table Access
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 使用视图简化表访问
- en: Problem
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to refer to values calculated from expressions without writing the
    expressions each time you retrieve them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望引用从表达式计算的值，而不是每次检索时都写入表达式。
- en: Solution
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a view defined such that its columns perform the desired calculations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义了其列执行所需计算的视图。
- en: Discussion
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Suppose that you retrieve several values from the `mail` table, using expressions
    to calculate most of them:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你从 `mail` 表中检索了几个值，使用表达式计算大多数值：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you must issue such a statement often, it’s inconvenient to keep writing
    the expressions. To make the statement results easier to access, use a view, which
    is a virtual table that contains no data. Instead, it’s defined as the `SELECT`
    statement that retrieves the data of interest. The following view, `mail_view`,
    is equivalent to the `SELECT` statement just shown:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常要发出这样的语句，每次都写表达式很不方便。为了更容易访问语句结果，可以使用视图，这是一个不包含数据的虚拟表。相反，它被定义为检索感兴趣数据的
    `SELECT` 语句。以下视图 `mail_view` 等效于刚刚显示的 `SELECT` 语句：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To access the view contents, refer to it like any other table. You can select
    some or all of its columns, add a `WHERE` clause to restrict which rows to retrieve,
    use `ORDER` `BY` to sort the rows, and so forth. For example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问视图内容，请像访问任何其他表一样引用它。你可以选择它的一些或所有列，添加`WHERE`子句以限制要检索的行，使用`ORDER BY`来对行进行排序，等等。例如：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stored programs provide another way to encapsulate calculations (see [Recipe
    11.2](ch11.xhtml#nch-routines-routines-encapsulation)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程提供了另一种封装计算的方式（参见[食谱 11.2](ch11.xhtml#nch-routines-routines-encapsulation)）。
- en: 5.8 Selecting Data from Multiple Tables
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 从多个表中选择数据
- en: Problem
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: The answer to a question requires data from more than one table, so you need
    to select data from multiple tables.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 答案需要从多个表中获取数据，因此需要从多个表中选择数据。
- en: Solution
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a join or a subquery.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连接或子查询。
- en: Discussion
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The queries shown so far select data from a single table, but sometimes you
    must retrieve information from multiple tables. Two types of statements that accomplish
    this are joins and subqueries. A join matches rows in one table with rows in another
    and enables you to retrieve output rows that contain columns from either or both
    tables. A subquery is one query nested within another, to perform a comparison
    between values selected by the inner query against values selected by the outer
    query.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所展示的查询从单个表中选择数据，但有时必须从多个表中检索信息。实现此目的的两种类型的语句是连接和子查询。连接将一个表中的行与另一个表中的行匹配，并使你能够检索包含来自任一表或两个表的列的输出行。子查询是嵌套在另一个查询中的查询，用于通过内部查询选择的值与外部查询选择的值进行比较。
- en: 'This recipe shows a couple brief examples to illustrate the basic ideas. Other
    examples appear elsewhere: subqueries are used in various examples throughout
    the book (for example, [Recipe 5.10](#nch-select-select-limit-sort) and [Recipe
    10.6](ch10.xhtml#nch-sum-sum-assoc)). [Chapter 16](ch16.xhtml#nch-multi) discusses
    joins in detail, including some that select from more than two tables.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例显示了几个简短的例子，以说明基本思想。其他示例出现在其他地方：子查询在本书的各处示例中使用（例如，[食谱 5.10](#nch-select-select-limit-sort)和[食谱
    10.6](ch10.xhtml#nch-sum-sum-assoc)）。[第 16 章](ch16.xhtml#nch-multi)详细讨论连接，包括从超过两个表中选择的连接。
- en: 'The following examples use the `profile` table introduced in [Chapter 4](ch04.xhtml#nch-api).
    Recall that it lists the people on your buddy list:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例使用了在[第 4 章](ch04.xhtml#nch-api)介绍的`profile`表。回想一下，它列出了你的好友名单：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s extend use of the `profile` table to include another table named `profile_contact`.
    This second table indicates how to contact people listed in the `profile` table
    via various social media services and is defined like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展使用`profile`表，包括另一个名为`profile_contact`的表。此第二个表示如何通过各种社交媒体服务联系`profile`表中列出的人员，并定义如下：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The table associates each row with the proper `profile` row via the `profile_id`
    column. The `service` and `contact_name` columns name the media service and the
    name to use for contacting the given person via that service. For the examples,
    assume that the table contains these rows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该表通过`profile_id`列将每行与适当的`profile`行关联起来。`service`和`contact_name`列命名了媒体服务和用于通过该服务联系给定人员的名称。对于示例，请假设该表包含以下行：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A question that requires information from both tables is, <q>For each person
    in the `profile` table, show me which services I can use to get in touch, and
    the contact name for each service.</q> To answer this question, use a join. Select
    from both tables and match rows by comparing the `id` column from the `profile`
    table with the `profile_id` column from the `profile_contact` table:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要来自两个表信息的问题是：<q>对于`profile`表中的每个人员，向我展示我可以使用哪些服务进行联系，以及每个服务的联系人姓名。</q>为了回答这个问题，使用连接。从两个表中选择并通过比较`profile`表的`id`列与`profile_contact`表的`profile_id`列来匹配行：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `FROM` clause indicates the tables from which to select data, and the `ON`
    clause tells MySQL which columns to use to find matches between the tables. In
    the result, rows include the `id` and `name` columns from the `profile` table,
    and the `service` and `contact_name` columns from the `profile_contact` table.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`子句指示要从中选择数据的表，`ON`子句告诉MySQL使用哪些列在表之间查找匹配项。在结果中，行包括`profile`表的`id`和`name`列，以及`profile_contact`表的`service`和`contact_name`列。'
- en: 'Here’s another question that requires both tables to answer: <q>List all the
    `profile_contact` records for Nancy.</q> To pull the proper rows from the `profile_contact`
    table, you need Nancy’s ID, which is stored in the `profile` table. To write the
    query without looking up Nancy’s ID yourself, use a subquery that, given her name,
    looks it up for you:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个需要两个表才能回答的问题：<q>列出所有 Nancy 的 `profile_contact` 记录。</q> 要从 `profile_contact`
    表中提取正确的行，您需要 Nancy 的 ID，该 ID 存储在 `profile` 表中。要编写查询而不自行查找 Nancy 的 ID，请使用一个子查询，该子查询根据她的姓名为您查找：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here the subquery appears as a nested `SELECT` statement enclosed within parentheses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此处子查询显示为括在括号中的嵌套 `SELECT` 语句。
- en: 5.9 Selecting Rows from the Beginning, End, or Middle of Query Results
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.9 从查询结果的开始、结尾或中间选择行
- en: Problem
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want only certain rows from a result set, such as the first one, the last
    five, or rows 21 through 40.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您只希望从结果集中获取特定的行，如第一行、最后五行或第 21 至 40 行。
- en: Solution
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a `LIMIT` clause, perhaps in conjunction with an `ORDER` `BY` clause.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LIMIT` 子句，也许与 `ORDER` `BY` 子句结合使用。
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'MySQL supports a `LIMIT` clause that tells the server to return only part of
    a result set. `LIMIT` is a MySQL-specific extension to SQL that is extremely valuable
    when your result set contains more rows than you want to see at a time. It enables
    you to retrieve an arbitrary section of a result set. Typical `LIMIT` uses include
    the following kinds of problems:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 支持 `LIMIT` 子句，告诉服务器仅返回结果集的一部分。`LIMIT` 是 SQL 的 MySQL 特定扩展，在结果集包含比您想要一次看到的行数更多时非常有价值。它允许您检索结果集的任意部分。典型的
    `LIMIT` 使用包括以下类型的问题：
- en: Answering questions about first or last, largest or smallest, newest or oldest,
    least or most expensive, and so forth.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答有关第一个或最后一个、最大或最小、最新或最旧、最便宜或最昂贵等问题。
- en: Splitting a result set into sections so that you can process it one piece at
    a time. This technique is common in web applications for displaying a large search
    result across several pages. Showing the result in sections enables display of
    smaller, easier-to-understand pages.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果集分成几个部分，以便可以逐部分处理它。此技术在 Web 应用程序中很常见，用于在多页上显示大型搜索结果。以部分显示结果可以显示更小、更易理解的页面。
- en: 'The following examples use the `profile` table shown in [Recipe 5.8](#nch-select-select-join).
    To see the first *`n`* rows of a `SELECT` result, add `LIMIT` *`n`* to the end
    of the statement:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 [Recipe 5.8](#nch-select-select-join) 中显示的 `profile` 表。要查看 `SELECT` 结果的前
    *`n`* 行，将 `LIMIT` *`n`* 添加到语句的末尾：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`LIMIT` *`n`* means <q>return *at most* *`n`* rows.</q> If you specify `LIMIT`
    `10`, and the result set has only four rows, the server returns four rows.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT` *`n`* 意味着 <q>返回 *最多* *`n`* 行。</q> 如果指定 `LIMIT` `10`，而结果集只有四行，则服务器返回四行。'
- en: 'The rows in the preceding query results are returned in no particular order,
    so they may not be very meaningful. A more common technique uses `ORDER` `BY`
    to sort the result set and `LIMIT` to find smallest and largest values. For example,
    to find the row with the minimum (earliest) birth date, sort by the `birth` column,
    then add `LIMIT` `1` to retrieve the first row:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 前述查询结果中的行未按任何特定顺序返回，因此可能无太大意义。更常见的技术是使用 `ORDER` `BY` 对结果集排序并使用 `LIMIT` 查找最小值和最大值。例如，要找到具有最小（最早）出生日期的行，请按
    `birth` 列排序，然后添加 `LIMIT` `1` 以检索第一行：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This works because MySQL processes the `ORDER` `BY` clause to sort the rows,
    then applies `LIMIT`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效是因为 MySQL 处理 `ORDER` `BY` 子句来对行进行排序，然后应用 `LIMIT`。
- en: 'To obtain rows from the end of a result set, sort them in the opposite order.
    The statement that finds the row with the most recent birth date is similar to
    the previous one, except that the sort order is descending:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取结果集末尾的行，请按相反顺序排序它们。查找最近出生日期的语句类似于前一个语句，但排序顺序是降序：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To find the earliest or latest birthday within the calendar year, sort by the
    month and day of the `birth` values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找日历年内最早或最晚的生日，请按 `birth` 值的月和日排序：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can obtain the same information by running these statements without `LIMIT`
    and ignoring everything but the first row. The advantage of `LIMIT` is that the
    server returns only the first row, and the extra rows don’t cross the network
    at all. This is much more efficient than retrieving an entire result set, only
    to discard all but one row.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在没有 `LIMIT` 的情况下运行这些语句并忽略除第一行以外的所有内容来获得相同的信息。`LIMIT` 的优点是服务器仅返回第一行，而额外的行根本不跨网络。这比检索整个结果集并丢弃除一个行以外的所有行要高效得多。
- en: 'To pull rows from the middle of a result set, use the two-argument form of
    `LIMIT`, which enables you to pick an arbitrary section of rows. The arguments
    indicate how many rows to skip and how many to return. This means that you can
    use `LIMIT` to do such things as skip two rows and return the next one, thus answering
    questions such as <q>What is the *third-*smallest or *third-*largest value?</q>
    These are questions that `MIN()` or `MAX()` are not suited for, but are easy with
    `LIMIT`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要从结果集的中间提取行，请使用 `LIMIT` 的两参数形式，这使您可以选择任意部分的行。参数指示要跳过多少行以及要返回多少行。这意味着您可以使用 `LIMIT`
    来执行诸如跳过两行并返回下一行的操作，从而回答诸如“第三个最小值或第三个最大值是什么？”这些问题 `MIN()` 或 `MAX()` 不适合，但 `LIMIT`
    却很容易实现：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The two-argument form of `LIMIT` also makes it possible to partition a result
    set into smaller sections. For example, to retrieve 20 rows at a time from a result,
    issue a `SELECT` statement repeatedly, but vary its `LIMIT` clause like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT` 的两参数形式还可以将结果集分成较小的部分。例如，要从结果中每次检索 20 行，重复发出 `SELECT` 语句，但变化其 `LIMIT`
    子句如下：'
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Warning
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This way of using `LIMIT` clause can cause performance degradations for large
    data sets, because it requires reading minimum `OFFSET` plus `LIMIT` rows. This
    means that to get result for the `LIMIT 0, 20` statement MySQL will have to read
    20 rows from the table, to get result of `LIMIT 20, 20` it will need to read 40
    rows, and so on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大数据集，使用 `LIMIT` 子句的这种方式可能会导致性能下降，因为它需要读取至少 `OFFSET` 加 `LIMIT` 行。这意味着要获得 `LIMIT
    0, 20` 语句的结果，MySQL 必须从表中读取 20 行，要获得 `LIMIT 20, 20` 的结果，它需要读取 40 行，依此类推。
- en: 'To determine the number of rows in a result set so that you can determine the
    number of sections, issue a `COUNT()` statement first. For example, to display
    `profile` table rows in name order, three at a time, you can find out how many
    there are with the following statement:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定结果集中的行数，以便确定部分的数量，请首先发出 `COUNT()` 语句。例如，要按名称顺序显示 `profile` 表行，每次三个，您可以使用以下语句找出行数：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That tells you that there are three sets of rows (the last with fewer than
    three rows), which you can retrieve as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你有三组行（最后一组少于三行），你可以按以下方式检索：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: See Also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`LIMIT` is useful in combination with `RAND()` to make random selections from
    a set of items. See [Recipe 17.8](ch17.xhtml#nch-stats-stats-rand-items).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 `RAND()` 使用 `LIMIT` 可以从一组项目中进行随机选择。请参阅 [Recipe 17.8](ch17.xhtml#nch-stats-stats-rand-items)。
- en: You can use `LIMIT` to restrict the effect of a `DELETE` or `UPDATE` statement
    to a subset of the rows that would otherwise be deleted or updated, respectively.
    For more information about using `LIMIT` for duplicate row removal, see [Recipe
    18.5](ch18.xhtml#nch-dups-dups-elim-table).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `LIMIT` 限制 `DELETE` 或 `UPDATE` 语句的影响范围，以防止删除或更新除特定行之外的所有行。有关使用 `LIMIT`
    去重的更多信息，请参阅 [Recipe 18.5](ch18.xhtml#nch-dups-dups-elim-table)。
- en: 5.10 What to Do When LIMIT and Final Result Require Different Sort Order
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.10 当 `LIMIT` 和最终结果要求不同的排序顺序时该怎么办
- en: Problem
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '`LIMIT` usually works best in conjunction with an `ORDER` `BY` clause that
    sorts rows. But sometimes that sort order differs from what you want for the final
    result.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT` 通常最好与排序行的 `ORDER BY` 子句结合使用。但有时候这种排序顺序与你希望的最终结果不同。'
- en: Solution
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `LIMIT` in a subquery to retrieve the desired rows, then use the outer query
    to sort them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在子查询中使用 `LIMIT` 检索所需的行，然后在外部查询中对它们进行排序。
- en: Discussion
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If you want the last four rows of a result set, you can obtain them easily
    by sorting the set in reverse order and using `LIMIT` `4`. The following statement
    returns the names and birth dates for the four people in the `profile` table who
    were born most recently:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要获取结果集的最后四行，可以通过以相反顺序排序并使用 `LIMIT 4` 轻松获取它们。以下语句返回 `profile` 表中最近出生的四个人的姓名和出生日期：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'But that requires sorting the `birth` values in descending order to place them
    at the head of the result set. What if you want the output rows to appear in ascending
    order instead? Use the `SELECT` as a subquery of an outer statement that re-sorts
    the rows in the desired final order:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 但这要求以降序排序 `birth` 值，以将它们放在结果集的前面。如果希望输出行按升序顺序显示怎么办？将 `SELECT` 用作外部语句的子查询，以按所需的最终顺序重新对行进行排序：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`AS` `t` is used here because any table referred to in the `FROM` clause must
    have a name, even a <q>derived</q> table produced from a subquery.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `FROM` 子句中引用的任何表都必须有一个名称，所以在此处使用 `AS` `t`，即使是从子查询生成的 <q>派生</q> 表也是如此。
- en: 5.11 Calculating LIMIT Values from Expressions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.11 从表达式计算 LIMIT 值
- en: Problem
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use expressions to specify the arguments for `LIMIT`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用表达式来指定 `LIMIT` 的参数。
- en: Solution
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: '`LIMIT` arguments must be literal integers—unless you issue the statement in
    a context that permits the statement string to be constructed dynamically. In
    that case, you can evaluate the expressions yourself and insert the resulting
    values into the statement string.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT` 的参数必须是文字整数 —— 除非您在允许动态构建语句字符串的上下文中发出该语句。在这种情况下，您可以自行评估表达式，并将结果值插入语句字符串中。'
- en: Discussion
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Arguments to `LIMIT` must be literal integers, not expressions. Statements
    such as the following are illegal:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT` 的参数必须是文字整数，而不是表达式。类似以下语句是不合法的：'
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The same <q>no expressions permitted</q> principle applies if you use an expression
    to calculate a `LIMIT` value in a program that constructs a statement string.
    You must evaluate the expression first, and then place the resulting value in
    the statement. For example, if you produce a statement string in Perl or PHP as
    follows, an error will result when you attempt to execute the statement:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构造语句字符串的程序中使用表达式计算 `LIMIT` 值，则同样适用 <q>不允许表达式</q> 原则。您必须先评估表达式，然后将结果值放入语句中。例如，如果您在
    Perl 或 PHP 中生成语句字符串如下所示，在执行语句时会出现错误：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To avoid the problem, evaluate the expression first:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免问题，请先评估表达式：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Or do this (don’t omit the parentheses or the expression won’t evaluate properly):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样做（不要省略括号，否则表达式将无法正确评估）：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To construct a two-argument `LIMIT` clause, evaluate both expressions before
    placing them into the statement string.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个两个参数的 `LIMIT` 子句，请先评估这两个表达式，然后将它们放入语句字符串中。
- en: 5.12 Combining Two or More SELECT Results
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.12 结合两个或更多 SELECT 结果
- en: Problem
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to combine rows, retrieved by two or more `SELECT` statements into
    one result set.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将两个或更多 `SELECT` 语句检索的行合并到一个结果集中。
- en: Solution
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `UNION` clause.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UNION` 子句。
- en: Discussion
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `mail` table stores user names and hosts of the email senders and recipients.
    But what if we want to know all the user and host combinations possible?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`mail` 表存储电子邮件发送者和接收者的用户名称和主机。但是，如果我们想知道所有可能的用户和主机组合呢？'
- en: Naive approach would be to choose either sender or receiver pairs. But if we
    perform even very basic test by comparing number of unique user-host combinations
    we will find out that it is different for each of directions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是选择发送者或接收者对。但是，如果我们进行基本测试，比较唯一用户-主机组合的数量，我们会发现每个方向的数量是不同的。
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We also do not know if our table stores emails from users who only send them
    and for users who receive but never send.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不知道我们的表是否存储只发送而不接收邮件的用户，以及只接收但从不发送邮件的用户。
- en: To get the full list we need to select pairs for both sender and receiver, then
    remove duplicates. SQL clause `UNION DISTINCT` and its short form `UNION` does
    exactly that. It combines results of two or more `SELECT` queries that select
    the same number of columns of the same type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整列表，我们需要为发送者和接收者选择成对，然后删除重复项。SQL 子句 `UNION DISTINCT` 及其简短形式 `UNION` 正好做到这一点。它将两个或更多选择相同列类型的
    `SELECT` 查询结果组合在一起。
- en: By default `UNION` uses column names of the first `SELECT` for the full result
    set header, but we can also use aliases as discussed in [Recipe 5.2](#nch-select-select-column-alias).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`UNION` 使用第一个 `SELECT` 的列名作为完整结果集的标题，但是我们也可以像 [Recipe 5.2](#nch-select-select-column-alias)
    中讨论的那样使用别名。
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You may sort as individual query, participating in `UNION`, as well the whole
    result. If you do not want to remove duplicates from the result use clause `UNION
    ALL`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将每个独立查询排序，参与 `UNION`，以及整个结果。如果不希望从结果中删除重复项，请使用 `UNION ALL` 子句。
- en: To demonstrate this lets create a query that will find four users who sent the
    highest number of emails and four users who recieved the highest number of emails,
    then sort result of the union by the user name.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们创建一个查询，找出发送最多电子邮件的四个用户和接收最多电子邮件的四个用户，然后按用户名对联合结果进行排序。
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[![1](Images/1.png)](#co_nch-select-select-union-concat_co)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_nch-select-select-union-concat_co)'
- en: Concatenate user and host into email address of the user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户和主机连接成用户的电子邮件地址。
- en: '[![2](Images/2.png)](#co_nch-select-select-union-order_co)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_nch-select-select-union-order_co)'
- en: Order first `SELECT` result by number of emails descending and limit number
    of retrieved rows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先按电子邮件数量降序排序第一个 `SELECT` 的结果，并限制检索到的行数。
- en: '[![3](Images/3.png)](#co_nch-select-select-union-order2_co)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_nch-select-select-union-order2_co)'
- en: Order result of the second `SELECT`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个`SELECT`结果进行排序。
- en: '[![4](Images/4.png)](#co_nch-select-select-union-order-union_co)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_nch-select-select-union-order-union_co)'
- en: Order result of the `UNION` by the user email address.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 按用户电子邮件地址对`UNION`的结果排序。
- en: '[![5](Images/5.png)](#co_nch-select-select-union-duplicate_co)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_nch-select-select-union-duplicate_co)'
- en: We used clause `UNION ALL` instead of `UNION [DISTINCT]`, therefore we have
    two entries for `gene@venus` in the result. This user is in the top list of those
    who send emails and also of those who recieve emails.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`UNION ALL`子句而不是`UNION [DISTINCT]`，因此结果中`gene@venus`有两个条目。这个用户是发送和接收电子邮件最多的名单中的一员。
- en: 5.13 Selecting Results of Subqueries
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.13 选择子查询的结果
- en: Problem
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to retrieve not only table columns, but also results of queries that
    use these columns.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望检索的不仅是表列，还包括使用这些列的查询的结果。
- en: Solution
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use subquery in the column list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在列列表中使用子查询。
- en: Discussion
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Suppose that you want to know not only how many emails sent a particular user,
    but also how many emails they received. You cannot do it without accessing the
    table `mail` two times: one to count how many emails were sent and second to count
    how many emails were received.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您不仅想知道特定用户发送了多少封电子邮件，还想知道他们收到了多少封。您不能只访问`mail`表两次来实现这一点：一次用于计算发送的电子邮件数，第二次用于计算接收的电子邮件数。
- en: One of solutions for this issue is to use subqueries in the column list.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一个解决方案是在列列表中使用子查询。
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](Images/1.png)](#co_nch-select-select-subqueries-sent_co)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_nch-select-select-subqueries-sent_co)'
- en: First we are retrieved a user name and a host of the sender and count number
    of emails that they sent.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检索了发送者的用户名和主机，并计算了他们发送的电子邮件数。
- en: '[![2](Images/2.png)](#co_nch-select-select-subqueries-received_co)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_nch-select-select-subqueries-received_co)'
- en: To find the number of emails that this user received we are using subquery to
    the same table `mail`. In the `WHERE` clause we select only those rows where receiver
    has the same credentials as the sender in the main query.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出此用户收到的电子邮件数量，我们在相同的`mail`表中使用子查询。在`WHERE`子句中，我们只选择接收者与主查询中的发送者具有相同凭据的行。
- en: '[![3](Images/3.png)](#co_nch-select-select-subqueries-received_alias_co)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_nch-select-select-subqueries-received_alias_co)'
- en: A subquery in the column list must have its own alias.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列列表中的子查询必须有自己的别名。
- en: '[![4](Images/4.png)](#co_nch-select-select-subqueries-group_co)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_nch-select-select-subqueries-group_co)'
- en: To display statistics per user we use clause `GROUP BY`, so result is groupped
    by each user name and host. We discuss `GROUP BY` clause in detail in [Chapter 10](ch10.xhtml#nch-sum).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按用户显示统计信息，我们使用了`GROUP BY`子句，因此结果按每个用户名和主机分组。我们在[第10章](ch10.xhtml#nch-sum)中详细讨论了`GROUP
    BY`子句。
