- en: Chapter 9\. Sorting Query Results
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。排序查询结果
- en: 9.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.0 介绍
- en: This chapter covers sorting, an extremely important operation for controlling
    how MySQL displays results from `SELECT` statements. To sort a query result, add
    an `ORDER` `BY` clause to the query. Without such a clause, MySQL is free to return
    rows in any order, so sorting helps bring order to disorder and makes query results
    easier to examine and understand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了排序操作，这是控制MySQL从`SELECT`语句显示结果的极其重要的操作。要对查询结果进行排序，请向查询添加`ORDER` `BY`子句。如果没有这样的子句，MySQL可以自由地以任何顺序返回行，因此排序有助于使混乱的结果有序化，使查询结果更易于检查和理解。
- en: 'You can sort rows of a query result several ways:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按多种方式对查询结果的行进行排序：
- en: Using a single column, a combination of columns, or even parts of columns or
    expression results
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个列，多个列的组合，甚至列或表达式结果的部分
- en: Using ascending or descending order
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用升序或降序排序
- en: Using case-sensitive or case-insensitive string comparisons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用区分大小写或不区分大小写的字符串比较
- en: Using temporal ordering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间顺序排序
- en: 'Several examples in this chapter use the `driver_log` table, which contains
    columns for recording daily mileage logs for a set of truck drivers:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的多个示例使用`driver_log`表，该表包含用于记录一组卡车司机每日里程日志的列：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Many other examples use the `mail` table (used in earlier chapters):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他示例使用`mail`表（在较早的章节中使用）：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Other tables are used occasionally as well. To create them, use scripts found
    in the *tables* directory of the `recipes` distribution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时也会偶尔使用其他表。要创建它们，请使用`recipes`分发的*tables*目录中的脚本。
- en: 9.1 Using ORDER BY to Sort Query Results
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 使用ORDER BY对查询结果进行排序
- en: Problem
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Rows in a query result don’t appear in the order you want.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查询结果中的行不按你想要的顺序显示。
- en: Solution
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add an `ORDER` `BY` clause to the query to sort its result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询中添加`ORDER` `BY`子句来对其结果进行排序。
- en: Discussion
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The contents of the `driver_log` and `mail` tables shown in the chapter introduction
    are disorganized and difficult to make sense of. The values in the `id` and `t`
    columns are in order only by a coincident.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节介绍中显示的`driver_log`和`mail`表的内容是杂乱无章且难以理解的。`id`和`t`列中的值仅仅是巧合的顺序排列。
- en: When you select rows, they’re returned from the database in whatever order the
    server happens to use. A relational database makes no guarantee about the order
    in which it returns rows—unless you tell it how, by adding an `ORDER` `BY` clause
    to your `SELECT` statement. Without `ORDER` `BY`, you may find that the retrieval
    order changes over time as you modify the table contents. With an `ORDER` `BY`
    clause, MySQL always sorts rows as you indicate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择行时，它们会以服务器当前使用的任何顺序返回。关系数据库不保证以任何顺序返回行，除非你通过向你的`SELECT`语句添加`ORDER` `BY`子句来告诉它如何排序。如果没有`ORDER`
    `BY`，你可能会发现检索顺序随着时间的推移而更改，因为你修改表内容。使用`ORDER` `BY`子句，MySQL始终按照你指定的方式对行进行排序。
- en: '`ORDER` `BY` has the following general characteristics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDER` `BY`具有以下一般特性：'
- en: You can sort using one or more column or expression values.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用一个或多个列或表达式的值进行排序。
- en: You can sort columns independently in ascending order (the default) or descending
    order.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以独立按列升序（默认）或降序排序。
- en: You can refer to sort columns by name or by using an alias.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过名称或使用别名来引用排序列。
- en: This recipe shows some basic sorting techniques, such as how to name the sort
    columns and specify the sort direction. Recipes later in this chapter illustrate
    how to perform more complex sorts. Paradoxically, you can even use `ORDER` `BY`
    to *disorder* a result set, which is useful for randomizing the rows or (in conjunction
    with `LIMIT`) for picking a row at random from a result set (see [Recipe 17.7](ch17.xhtml#nch-stats-stats-rand-rows)
    and [Recipe 17.8](ch17.xhtml#nch-stats-stats-rand-items)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇介绍了一些基本的排序技巧，比如如何命名排序列和指定排序方向。本章后面的示例演示了如何执行更复杂的排序。具有讽刺意味的是，你甚至可以使用`ORDER`
    `BY`来*打乱*结果集，这对于随机化行或（与`LIMIT`一起）从结果集中随机选择行很有用（参见[Recipe 17.7](ch17.xhtml#nch-stats-stats-rand-rows)和[Recipe
    17.8](ch17.xhtml#nch-stats-stats-rand-items))。
- en: The following examples demonstrate how to sort on a single column or multiple
    columns and how to sort in ascending or descending order. The examples select
    the rows in the `driver_log` table but sort them in different orders to demonstrate
    the effect of the different `ORDER` `BY` clauses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了如何按单个列或多个列进行排序，以及如何按升序或降序排序。这些示例选择`driver_log`表中的行，但以不同的`ORDER` `BY`子句来展示不同的效果。
- en: 'This query produces a single-column sort using the driver name:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用司机名称进行单列排序：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The default sort direction is ascending. To make the direction for an ascending
    sort explicit, add `ASC` after the sorted column’s name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的排序方向是升序。要使升序排序的方向明确，添加`ASC`到排序列名后：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The opposite (or reverse) of ascending order is descending order, specified
    by adding `DESC` after the sorted column’s name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 升序排序的反义词（或反向）是降序排序，通过在排序列名后添加`DESC`来指定：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Closely examine the output from the queries just shown and you’ll notice that
    although rows are sorted by name, rows for any given name are in no special order.
    (The `trav_date` values aren’t in date order for Henry or Ben, for example.) That’s
    because MySQL doesn’t sort something unless you tell it to:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查刚才显示的查询的输出，你会注意到虽然按名称对行进行了排序，但任何给定名称的行没有特定的顺序。（例如，Henry或Ben的`trav_date`值不按日期顺序排列。）这是因为MySQL不会对某些东西进行排序，除非你告诉它：
- en: The overall order of rows returned by a query is indeterminate unless you specify
    an `ORDER` `BY` clause.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询返回的行的整体顺序是不确定的，除非你指定了`ORDER` `BY`子句。
- en: Within a group of rows that sort together based on the values in a given column,
    the order of values in other columns also is indeterminate unless you name them
    in the `ORDER` `BY` clause.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根据给定列中的值排序的行组内，除非在`ORDER` `BY`子句中命名它们，否则其他列中的值的顺序也是不确定的。
- en: 'To more fully control output order, specify a multiple-column sort by listing
    each column to use for sorting, separated by commas. The following query sorts
    in ascending order by `name` and by `trav_date` within the rows for each name:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要更全面地控制输出顺序，请通过逗号分隔的每个用于排序的列列表指定多列排序。以下查询按名称升序排序，并在每个名称的行内按`trav_date`升序排序：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Multiple-column sorts can be descending as well, but `DESC` must be specified
    after *each* column name to perform a fully descending sort.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多列排序也可以是降序，但必须在*每个*列名后指定`DESC`以执行完全降序排序。
- en: 'Multiple-column `ORDER` `BY` clauses can perform mixed-order sorting where
    some columns are sorted in ascending order and others in descending order. The
    following query sorts by `name` in descending order, then by `trav_date` in ascending
    order for each name:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 多列`ORDER` `BY`子句可以执行混合顺序排序，其中某些列按升序排序，而其他列按降序排序。以下查询按名称降序排序，然后按每个名称的`trav_date`升序排序：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `ORDER` `BY` clauses in the queries shown thus far refer to the sorted
    columns by name. You can also name the columns by using aliases. That is, if an
    output column has an alias, you can refer to the alias in the `ORDER` `BY` clause:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止显示的查询中的`ORDER` `BY`子句是通过名称引用排序的列。你也可以使用别名命名列。也就是说，如果输出列有别名，你可以在`ORDER`
    `BY`子句中引用别名：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 9.2 Using Expressions for Sorting
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 使用表达式进行排序
- en: Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort a query result based on values calculated from a column rather
    than the values actually stored in the column.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你想根据从列计算而不是实际存储在列中的值对查询结果进行排序。
- en: Solution
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Put the expression that calculates the values in the `ORDER` `BY` clause.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算值的表达式放入`ORDER` `BY`子句。
- en: Discussion
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'One of the `mail` table columns shows how large each mail message is, in bytes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`mail`表的一个列显示每个邮件消息的大小，以字节为单位：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Suppose that you want to retrieve rows for <q>big</q> mail messages (defined
    as those larger than 50,000 bytes), but you want them to be displayed and sorted
    by sizes in terms of kilobytes, not bytes. In this case, the values to sort are
    calculated by an expression:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想检索超过50,000字节的邮件（定义为大邮件），但希望它们按千字节显示和排序大小。在这种情况下，排序的值由表达式计算：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `+1023` in the `FLOOR()` expression groups `size` values to the nearest
    upper boundary of the 1,024-byte categories. Without it, the values group by lower
    boundaries (for example, a 2,047-byte message is reported as having a size of
    1 kilobyte rather than 2). [Recipe 10.13](ch10.xhtml#nch-sum-sum-noncat) discusses
    this technique in more detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FLOOR()`表达式中的`+1023`将`size`值分组到最接近的1,024字节类别的上限。如果没有它，值将按下限分组（例如，2,047字节的消息报告为1千字节大小而不是2）。[Recipe
    10.13](ch10.xhtml#nch-sum-sum-noncat)更详细地讨论了这种技术。
- en: 'To sort by that expression, put it directly in the `ORDER` `BY` clause:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要按该表达式排序，请直接将其放入`ORDER` `BY`子句中：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, if the sorting expression appears in the output column list,
    you can alias it there and refer to the alias in the `ORDER` `BY` clause:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果排序表达式出现在输出列列表中，您可以在那里对其进行别名，并在`ORDER` `BY`子句中引用该别名：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You might prefer the alias method for several reasons:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于几个原因，你可能更喜欢别名方法：
- en: It’s easier to write the alias in the `ORDER` `BY` clause than to repeat the
    (cumbersome) expression.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ORDER BY`子句中，写别名比重复（冗长的）表达式更容易。
- en: Without the alias, if you change the expression one place, you must change it
    in the other.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有别名，如果你在一个地方更改表达式，那么你必须在另一个地方也进行更改。
- en: The alias may be useful for display purposes, to provide a better column label.
    Note how the third column heading is much more meaningful in the second of the
    two preceding queries.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名可能对显示目的很有用，可以提供更好的列标签。注意前面两个查询中第三列标题的意义大不相同。
- en: 9.3 Displaying One Set of Values While Sorting by Another
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 显示一组值但按另一组值排序
- en: Problem
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort a result set using values that don’t appear in the output column
    list.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用不出现在输出列列表中的值对结果集进行排序。
- en: Solution
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: That’s not a problem. The `ORDER` `BY` clause can refer to columns you don’t
    display.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是问题。`ORDER BY`子句可以引用你不显示的列。
- en: Discussion
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`ORDER` `BY` is not limited to sorting only those columns named in the output
    column list. It can sort using values that are <q>hidden</q> (that is, not displayed
    in the query output). This technique is commonly used when you have values that
    can be represented different ways and you want to display one type of value but
    sort by another. For example, you may want to display mail message sizes not in
    terms of bytes, but as strings such as `103K` for 103 kilobytes. You can convert
    a byte count to that kind of value using this expression:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDER BY`不仅限于仅对输出列列表中命名的列进行排序。它可以使用那些“隐藏”的值进行排序（即在查询输出中不显示的值）。当你有不同表示方式的值，并且想要显示一种类型的值但按另一种类型排序时，这种技术通常被使用。例如，你可能希望将邮件消息大小显示为`103K`而不是字节。你可以使用以下表达式将字节计数转换为这种类型的值：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, such values are strings, so they sort lexically, not numerically.
    If you use them for sorting, a value such as `96K` sorts after `2339K`, even though
    it represents a smaller number:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些值是字符串，所以它们按字典顺序而不是数字顺序排序。如果你用它们来排序，像`96K`这样的值将排在`2339K`之后，尽管它代表一个较小的数字：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To achieve the desired output order, display the string, but use actual numeric
    size for sorting:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到期望的输出顺序，显示字符串，但使用实际的数字大小进行排序：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Displaying values as strings but sorting them as numbers helps solve some otherwise
    difficult problems. Members of sports teams typically are assigned a jersey number,
    which normally you might think should be stored using a numeric column. Not so
    fast! Some players like to have a jersey number of zero (`0`), and some like double-zero
    (`00`). If a team happens to have players with both numbers, you cannot represent
    them using a numeric column because both values will be treated as the same number.
    To solve this problem, store jersey numbers as strings:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将值显示为字符串但按数字排序有助于解决一些其他情况下难以解决的问题。体育队成员通常会被分配一个球衣号码，通常你可能认为应该使用一个数字列来存储它。不那么快！一些球员喜欢球衣号码为零（`0`），一些喜欢双零（`00`）。如果一支队伍恰好有两种球员，即使两个值是不同的数字，你也不能使用数字列来表示它们。为了解决这个问题，将球衣号码存储为字符串：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then the jersey numbers will display the same way you enter them, and `0` and
    `00` will be treated as distinct values. Unfortunately, although representing
    numbers as strings solves the problem of distinguishing `0` and `00`, it introduces
    a different problem. Suppose that a team has the following players:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后球衣号码将以你输入的方式显示，并且`0`和`00`将被视为不同的值。不幸的是，虽然将数字表示为字符串解决了区分`0`和`00`的问题，但引入了另一个问题。假设一个球队有以下球员：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now try to sort the team members by jersey number. If those numbers are stored
    as strings, they sort lexically, and lexical order often differs from numeric
    order. That’s certainly true for the team in question:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试按球衣号码对团队成员进行排序。如果这些数字被存储为字符串，它们将按字典顺序排序，而字典顺序通常不同于数字顺序。对于所讨论的球队，这绝对是真实的：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The values `100` and `8` are out of place, but that’s easily solved: display
    the string values and use the numeric values for sorting. To accomplish this,
    add zero to the `jersey_num` values to force a string-to-number conversion:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值`100`和`8`错位了，但这很容易解决：显示字符串值，并使用数字值进行排序。为了实现这一点，将零添加到`jersey_num`的值中以强制进行字符串到数字的转换：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Warning
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Note that because this method performs string-to-number conversion it cannot
    use indexes and will run slower as the table gets bigger. As alternative solution
    you may create a column that will hold result of this calculation and use it in
    the `ORDER BY` expression.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于此方法执行字符串到数字的转换，它不能使用索引，并且在表变大时会运行得更慢。作为替代方案，您可以创建一个列，用于保存此计算的结果，并在 `ORDER
    BY` 表达式中使用它。
- en: 'The technique of displaying one value but sorting by another is also useful
    when you display values composed from multiple columns that don’t sort the way
    you want. For example, the `mail` table lists message senders using separate `srcuser`
    and `srchost` values. To display message senders from the `mail` table as email
    addresses in `srcuser@srchost` format with the username first, construct those
    values using the following expression:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您显示一个值但按另一个值排序的技术，在显示由多个列组成且无法按您希望的方式排序的值时，也很有用。例如，`mail` 表列出使用单独的 `srcuser`
    和 `srchost` 值的消息发送者。要以 `srcuser@srchost` 格式显示 `mail` 表中的消息发送者作为电子邮件地址，并确保用户名排在前面，请使用以下表达式构造这些值：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, those values are no good for sorting if you want to treat the hostname
    as more significant than the username. Instead, sort the results using the underlying
    column values rather than the displayed composite values:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果要将主机名视为比用户名更重要的内容来排序，那些值就不适合排序。而是使用底层列值而不是显示的复合值来排序结果：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The same idea commonly applies to sorting people’s names. Suppose that a `names`
    table contains last and first names. To display rows sorted by last name first,
    the query is straightforward when the columns are displayed separately:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法通常也适用于排序人名。假设 `names` 表包含姓和名。要按姓氏首先显示行，当分别显示列时，查询非常简单：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If instead you want to display each name as a single string composed of the
    first name, a space, and the last name, begin the query like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将每个姓名显示为由名字、一个空格和姓组成的单个字符串，查询可以如下开始：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But then how do you sort the names so they come out in last-name order? Display
    composite names, but refer to the constituent values in the `ORDER` `BY` clause:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何按姓氏顺序排序这些姓名呢？显示复合姓名，但在 `ORDER BY` 子句中引用各组成值：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 9.4 Controlling Case Sensitivity of String Sorts
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 控制字符串排序的大小写敏感性
- en: Problem
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: String-sorting operations are case sensitive when you don’t want them to be,
    or vice versa.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不希望字符串排序操作区分大小写时，或者反之。
- en: Solution
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Alter the comparison characteristics of the sorted values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更改排序值的比较特性。
- en: Discussion
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 7.1](ch07.xhtml#nch-strings-strings-properties) discusses how string-comparison
    properties depend on whether the strings are binary or nonbinary:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 7.1](ch07.xhtml#nch-strings-strings-properties) 讨论了字符串比较属性如何取决于字符串是二进制还是非二进制的：'
- en: Binary strings are sequences of bytes. They are compared byte by byte using
    numeric byte values. Character set and lettercase have no meaning for comparisons.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制字符串是字节序列。它们按照数值字节值逐字节比较。字符集和大小写对比较无意义。
- en: Nonbinary strings are sequences of characters. They have a character set and
    collation and are compared character by character using the order defined by the
    collation.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非二进制字符串是字符序列。它们具有字符集和排序规则，并且按照由排序规则定义的顺序逐字符比较。
- en: These properties also apply to string sorting because sorting is based on comparison.
    To alter the sorting properties of a string column, alter its comparison properties.
    (For a summary of which string data types are binary and nonbinary, see [Recipe
    7.2](ch07.xhtml#nch-strings-strings-types).)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性也适用于字符串排序，因为排序基于比较。要修改字符串列的排序属性，请修改其比较属性。（有关字符串数据类型是二进制还是非二进制的摘要，请参阅 [食谱
    7.2](ch07.xhtml#nch-strings-strings-types)。）
- en: 'The examples in this section use a table that has case-insensitive and case-sensitive
    nonbinary columns, and a binary column:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例使用一个具有大小写不敏感和大小写敏感的非二进制列以及一个二进制列的表：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Suppose that the table has these contents:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表中有以下内容：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As of MySLQ 8.0.19 *mysql* client prints binary data in hexademical format.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自 MySQL 8.0.19 起，*mysql* 客户端以十六进制格式打印二进制数据。
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To print values in ASCII format start *mysql* with option `--binary-as-hex=0`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要以 ASCII 格式打印值，请使用选项 `--binary-as-hex=0` 启动 *mysql*。
- en: 'Each column contains the same values, but the natural sort orders for the column
    data types produce three different results:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每列包含相同的值，但是不同数据类型的列数据的自然排序顺序会产生三种不同的结果：
- en: 'The case-insensitive collation sorts `a` and `A` together, placing them before
    `b` and `B`. However, for a given letter, it does not necessarily order one lettercase
    before another, as shown by the following result:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不区分大小写的排序将`a`和`A`放在一起，将它们排在`b`和`B`之前。然而，对于给定的字母，它并不一定会将一个大小写字母排在另一个字母之前，如下结果所示：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The case-sensitive collation puts `a` and `A` before `b` and `B`, and sorts
    lowercase before uppercase:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小写敏感的排序将`a`和`A`排在`b`和`B`之前，并将小写字母排在大写字母之前：
- en: '[PRE28]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The binary strings sort numerically. Assuming that uppercase letters have numeric
    values less than those of lowercase letters, a binary sort results in the following
    ordering:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制字符串按数字顺序排序。假设大写字母的数值小于小写字母的数值，二进制排序将产生以下顺序：
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You get the same result for a nonbinary string column that has a binary collation,
    as long as the column contains single-byte characters (for example, `CHAR(3)`
    `CHARACTER` `SET` `latin1` `COLLATE` `latin1_bin`). For multibyte characters,
    a binary collation still produces a numeric sort, but the character values use
    multibyte numbers.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于具有二进制排序的非二进制字符串列，如果列包含单字节字符（例如`CHAR(3)` `CHARACTER` `SET` `latin1` `COLLATE`
    `latin1_bin`），则会得到相同的结果。对于多字节字符，二进制排序仍然会产生数字排序，但字符值使用多字节数字。
- en: 'To alter the sorting properties of each column, use the techniques described
    in [Recipe 7.7](ch07.xhtml#nch-strings-strings-compare) for controlling string
    comparisons:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变每列的排序属性，请使用[食谱 7.7](ch07.xhtml#nch-strings-strings-compare)中描述的技术来控制字符串比较：
- en: 'To sort case-insensitive strings in case-sensitive fashion, order the sorted
    values using a case-sensitive collation:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要按区分大小写的方式排序不区分大小写的字符串，请使用区分大小写的排序来排序排序值：
- en: '[PRE30]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To sort case-sensitive strings in case-insensitive fashion, order the sorted
    values using a case-insensitive collation:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要按区分大小写的方式排序区分大小写的字符串，请使用不区分大小写的排序来排序排序值：
- en: '[PRE31]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Alternatively, sort using values that have been converted to the same lettercase,
    which makes lettercase irrelevant:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用转换为相同大小写的值进行排序，使大小写无关紧要：
- en: '[PRE32]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Binary strings sort using numeric byte values, so there is no concept of lettercase
    involved. However, because letters in different cases have different byte values,
    comparisons of binary strings effectively are case sensitive. (That is, `a` and
    `A` are unequal.) To sort binary strings using a case-insensitive ordering, convert
    them to nonbinary strings and apply an appropriate collation. For example, to
    perform a case-insensitive sort, use a statement like this:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制字符串按照数字字节值排序，因此没有字母大小写的概念。然而，由于不同大小写的字母具有不同的字节值，对二进制字符串的比较实际上是大小写敏感的（即`a`和`A`不相等）。要使用不区分大小写的排序来排序二进制字符串，请将其转换为非二进制字符串并应用适当的排序。例如，要执行不区分大小写的排序，请使用以下语句：
- en: '[PRE33]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the character-set default collation is case insensitive (as is true for `utf8mb4`),
    you can omit the `COLLATE` clause.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果字符集默认的排序不区分大小写（如`utf8mb4`），可以省略`COLLATE`子句。
- en: 9.5 Sorting in Temporal Order
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 按时间顺序排序
- en: Problem
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort rows in temporal order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望按时间顺序对行进行排序。
- en: Solution
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Sort using a date or time column. If some parts of the values are irrelevant
    for the sort that you want to accomplish, ignore them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日期或时间列进行排序。如果值的某些部分对于您想要完成的排序无关紧要，请忽略它们。
- en: Discussion
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Many database tables include date or time information and it’s very often necessary
    to sort results in temporal order. MySQL knows how to sort temporal data types,
    so there’s no special trick to ordering them. The next few examples use the `mail`
    table, which contains a `DATETIME` column, but the same sorting principles apply
    to `DATE`, `TIME`, and `TIMESTAMP` columns.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库表包括日期或时间信息，通常需要按时间顺序对结果进行排序。MySQL知道如何对时间数据类型进行排序，因此没有特殊的技巧来对其进行排序。接下来的几个示例使用包含`DATETIME`列的`mail`表，但相同的排序原则适用于`DATE`、`TIME`和`TIMESTAMP`列。
- en: 'Here are the messages sent by `phil`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是由`phil`发送的消息：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To display the messages, most recently sent ones first, use `ORDER` `BY` with
    `DESC`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示最近发送的消息，先使用`ORDER` `BY`和`DESC`进行排序：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Sometimes a temporal sort uses only part of a date or time column. In that case,
    use an expression that extracts the part or parts you need and sort the result
    using the expression. Some examples of this are given in the following discussion.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，时间排序仅使用日期或时间列的一部分。在这种情况下，使用提取所需部分的表达式，并使用该表达式对结果进行排序。以下讨论中给出了一些示例。
- en: Sorting by time of day
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按照一天中的时间排序
- en: 'You can do time-of-day sorting different ways, depending on your column type.
    If the values are stored in a `TIME` column named `timecol`, just sort them directly
    using `ORDER` `BY` `timecol`. To put `DATETIME` or `TIMESTAMP` values in time-of-day
    order, extract the time parts and sort them. For example, the `mail` table contains
    `DATETIME` values, which can be sorted by time of day like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以不同的方式对时间进行排序，具体取决于列类型。如果值存储在名为`timecol`的`TIME`列中，只需直接使用`ORDER BY timecol`进行排序。要按天时序排序`DATETIME`或`TIMESTAMP`值，提取时间部分并进行排序。例如，`mail`表包含`DATETIME`值，可以按一天中的时间进行排序如下：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Sorting by calendar day
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按日历日排序
- en: 'To sort date values in calendar order, ignore the year part of the dates and
    use only the month and day to order values by where they fall during the calendar
    year. Suppose that an `occasion` table looks like this when values are ordered
    by date:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 若要按日历顺序排序日期值，请忽略日期的年份部分，仅使用月份和日期按日历年中的位置排序值。假设`occasion`表如下所示，当值按日期排序时：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To put these items in calendar order, sort them by month and day within month:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要按日历顺序排列这些项目，请按月份和每月内的日期排序：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'MySQL has a `DAYOFYEAR()` function that you might suspect would be useful for
    calendar-day sorting. However, it can generate the same value for different calendar
    days. For example, February 29 of leap years and March 1 of nonleap years have
    the same day-of-year value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL具有`DAYOFYEAR()`函数，你可能会认为它在日历日排序中很有用。然而，它可能会为不同的日历日期生成相同的值。例如，闰年的2月29日和非闰年的3月1日具有相同的一年中的日值：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that `DAYOFYEAR()` can group dates that actually occur on different
    calendar days.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`DAYOFYEAR()`可以将实际上出现在不同日历日期上的日期分组。
- en: If a table represents dates using separate year, month, and day columns, calendar
    sorting does not require to extract date parts. Just sort the relevant columns
    directly. For large datasets, sorting using separate date-part columns can be
    much faster than sorts based on extracting pieces of `DATE` values. There’s no
    overhead for part extraction, but more importantly, you can index the date-part
    columns separately—something not possible with a `DATE` column. The principle
    here is that you should design the table to make it easy to extract or sort by
    the values that you expect to use a lot.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表使用单独的年、月和日列表示日期，那么日历排序不需要提取日期部分。直接按相关列进行排序即可。对于大型数据集，使用单独的日期部分列进行排序可能比基于提取`DATE`值片段的排序要快得多。这里的原则是，应设计表格以便轻松提取或按预期频繁使用的值排序。
- en: Sorting by day of week
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按星期几排序
- en: Day-of-week sorting is similar to calendar-day sorting, except that you use
    different functions to obtain the relevant ordering values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 按星期几排序类似于按日历日排序，只是使用不同的函数来获取相关的排序值。
- en: 'You can get the day of the week using `DAYNAME()`, but that produces strings
    that sort lexically rather than in day-of-week order (Sunday, Monday, Tuesday,
    and so forth). Here the technique of displaying one value but sorting by another
    is useful (see [Recipe 9.3](#nch-sort-sort-one-display-other)). Display day names
    using `DAYNAME()`, but sort in day-of-week order using `DAYOFWEEK()`, which returns
    numeric values from 1 to 7 for Sunday through Saturday:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DAYNAME()`可以获取星期几，但这会按字典顺序而不是按星期几的顺序排序（星期日、星期一、星期二等）。在这里，显示一个值但按另一个值排序的技术很有用（见[配方
    9.3](#nch-sort-sort-one-display-other)）。使用`DAYNAME()`显示星期几，但使用`DAYOFWEEK()`按星期几排序，它返回从1到7的数字值，分别对应星期日到星期六：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To sort rows in day-of-week order but treat Monday as the first day of the
    week and Sunday as the last, use the modulo operation and the `MOD()` function
    to map Monday to 0, Tuesday to 1, …, Sunday to 6:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 若要按星期几排序，但将星期一视为一周的第一天，星期日视为最后一天，则使用模运算和`MOD()`函数将星期一映射为0，星期二映射为1，……，星期日映射为6：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The [Table 9-1](#nch-sort-sort-date-mod) shows the `DAYOFWEEK()` expressions
    for putting any day of the week first in the sort order:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](#nch-sort-sort-date-mod)显示了`DAYOFWEEK()`表达式，用于在排序中将任何一天作为第一天：'
- en: Table 9-1\. Using modulo to properly order days of a week
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. 使用模运算正确排序一周的日子
- en: '| Day to list first | DAYOFWEEK() expression |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 列出第一天 | DAYOFWEEK()表达式 |'
- en: '| --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Sunday | `DAYOFWEEK(date)` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 星期日 | `DAYOFWEEK(date)` |'
- en: '| Monday | `MOD(DAYOFWEEK(date)+5, 7)` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 星期一 | `MOD(DAYOFWEEK(date)+5, 7)` |'
- en: '| Tuesday | `MOD(DAYOFWEEK(date)+4, 7)` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 星期二 | `MOD(DAYOFWEEK(date)+4, 7)` |'
- en: '| Wednesday | `MOD(DAYOFWEEK(date)+3, 7)` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 星期三 | `MOD(DAYOFWEEK(date)+3, 7)` |'
- en: '| Thursday | `MOD(DAYOFWEEK(date)+2, 7)` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 星期四 | `MOD(DAYOFWEEK(date)+2, 7)` |'
- en: '| Friday | `MOD(DAYOFWEEK(date)+1, 7)` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 星期五 | `MOD(DAYOFWEEK(date)+1, 7)` |'
- en: '| Saturday | `MOD(DAYOFWEEK(date)+0, 7)` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 星期六 | `MOD(DAYOFWEEK(date)+0, 7)` |'
- en: You can also use `WEEKDAY()` for day-of-week sorting, although it returns a
    different set of values (0 for Monday through 6 for Sunday).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`WEEKDAY()`进行按星期几排序，尽管它返回不同的值集（星期一到星期日分别为0到6）。
- en: 9.6 Sorting by Substrings of Column Values
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 按列值的子字符串排序
- en: Problem
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort a set of values using one or more substrings of each value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用每个值的一个或多个子字符串进行排序。
- en: Solution
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Extract the pieces you want and sort them separately.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 提取您想要的部分并将它们单独排序。
- en: Discussion
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: This is a specific application of sorting by expression value (see [Recipe 9.2](#nch-sort-sort-expr)).
    To sort rows using just a particular portion of a column’s values, extract the
    substring you need and use it in the `ORDER` `BY` clause. This is easiest if the
    substrings are at a fixed position and length within the column. For substrings
    of variable position or length, you can still use them for sorting if you have
    a reliable way to identify them. The next several recipes show how to use substring
    extraction to produce specialized sort orders.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是排序表达式值的特定应用（见[Recipe 9.2](#nch-sort-sort-expr)）。要仅使用列值的特定部分对行进行排序，请提取您需要的子字符串，并在`ORDER
    BY`子句中使用它。如果子字符串在列内具有固定的位置和长度，则这样做最为简单。对于位置或长度可变的子字符串，如果您有可靠的识别方法，仍然可以用它们进行排序。接下来的几个示例展示如何使用子字符串提取来生成专门的排序顺序。
- en: 9.7 Sorting by Fixed-Length Substrings
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 按固定长度子字符串排序
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort using parts of a column that occur at a given position within
    the column.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用在列内给定位置出现的部分来进行排序。
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Pull out the parts you need with `LEFT()`, `SUBSTRING()` (`MID()`), or `RIGHT()`,
    and sort them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LEFT()`、`SUBSTRING()`（`MID()`）或`RIGHT()`拉出您需要的部分，并对它们进行排序。
- en: Discussion
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Suppose that a `housewares` table catalogs houseware furnishings, each identified
    by 10-character ID values consisting of three subparts: a three-character category
    abbreviation (such as `DIN` for <q>dining room</q> or `KIT` for <q>kitchen</q>),
    a five-digit serial number, and a two-character country code indicating where
    the part is manufactured:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`housewares`表格记录家居用品家具，每个都由10个字符的ID值标识，包括三个子部分：三个字符的类别缩写（例如用于<dining room>餐厅的`DIN`或<kitchen>厨房的`KIT`），五位数的序列号，以及指示零件制造地的两个字符的国家代码：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is not necessarily a good way to store complex ID values, and later we’ll
    consider how to represent them using separate columns. For now, assume that the
    values must be stored as shown.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定是存储复杂ID值的好方法，稍后我们将考虑如何使用单独的列来表示它们。现在假设这些值必须按照所示存储。
- en: 'To sort rows from this table based on the `id` values, use the entire column
    value:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据`id`值对来自该表的行进行排序，请使用整个列值：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But you might also have a need to sort on any of the three subparts (for example,
    to sort by country of manufacture). For that kind of operation, functions such
    as `LEFT()`, `MID()`, and `RIGHT()` are useful to extract `id` value components:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能还需要按照这三个子部分的任意一个进行排序（例如，按制造国家排序）。对于这种操作，诸如`LEFT()`、`MID()`和`RIGHT()`的函数非常有用，用于提取`id`值的组件：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Function `MID()` is a synonym of the function `SUBSTRING()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`MID()`是函数`SUBSTRING()`的同义词。
- en: 'Those fixed-length substrings of the `id` values can be used for sorting, either
    alone or in combination. For example, to sort by product category, extract and
    use the category in the `ORDER` `BY` clause:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`id`值的固定长度子字符串可以单独或组合用于排序。例如，要按产品类别排序，请在`ORDER BY`子句中提取和使用类别：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To sort by product serial number, use `MID()` to extract the middle five characters
    from the `id` values, beginning with the fourth:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要按产品序列号排序，请使用`MID()`从`id`值中提取中间的五个字符，从第四个字符开始：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This appears to be a numeric sort, but it’s actually a string sort because `MID()`
    returns strings. The lexical and numeric sort order are the same in this case
    because the <q>numbers</q> have leading zeros to make them all the same length.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是数字排序，但实际上是字符串排序，因为`MID()`返回字符串。在这种情况下，词汇和数字的排序顺序相同，因为<numbers>具有前导零，使它们长度相同。
- en: To sort by country code, use the rightmost two characters of the `id` values
    (`ORDER` `BY` `RIGHT(id,2)`).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要按国家代码排序，请使用`id`值的最后两个字符（`ORDER BY RIGHT(id,2)`）。
- en: 'You can also sort using combinations of substrings; for example, by country
    code and serial number within country:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按组合的子字符串进行排序；例如，按国家代码和国内序列号排序：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `ORDER` `BY` clauses just shown suffice to sort by substrings of the `id`
    values, but if such operations on the table are common, it might be worth representing
    houseware IDs differently; for example, using separate columns for the ID components.
    This table, `housewares2`, is like `housewares` but uses `category`, `serial`,
    and `country` columns generated from the `id` column:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚显示的`ORDER BY`子句足以按`id`值的子串排序，但如果此类操作在表上常见，则可能值得以不同方式表示家居设备ID；例如，使用单独的列表示。此表`housewares2`与`housewares`类似，但使用从`id`列生成的`category`、`serial`和`country`列：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example we used generated columns that are generated based on the expressions,
    defined at the column creation time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了基于表达式生成的生成列，在列创建时定义。
- en: With the ID values split into separate parts, sorting operations are easier
    to specify; refer to individual columns directly rather than pulling out substrings
    of the original `id` column. You can also make operations that sort the `serial`
    and `country` columns more efficient by adding indexes on those columns.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将ID值拆分为单独的部分后，排序操作更容易指定；直接引用各个列而不是提取原始`id`列的子串。您还可以通过在这些列上添加索引，使对`serial`和`country`列进行排序的操作更加高效。
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This example illustrates an important principle: you might think about values
    one way (`id` values as single strings), but you need not necessarily represent
    them that way in the database. If an alternative representation (separate columns)
    is more efficient or easier to work with, it may well be worth using—even if you
    must reformat the underlying columns so they appear as people expect.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了一个重要原则：您可能会以某种方式考虑值（`id`值作为单个字符串），但不一定需要在数据库中以此方式表示。如果另一种表示方式（单独列）更有效或更易于处理，那么即使必须重新格式化底层列使其看起来符合人们的期望，也可能值得使用。
- en: 9.8 Sorting by Variable-Length Substrings
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.8 变长子串排序
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort using parts of a column that do *not* occur at a given position
    within the column.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用不在列中给定位置出现的部分进行排序。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Determine how to identify the parts you need so that you can extract them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确定如何识别您需要的部分，以便可以提取它们。
- en: Discussion
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If substrings to be used for sorting vary in length, you need a reliable means
    of extracting just the part you want. To see how this works, let’s create a `housewares3`
    table that is like the `housewares` table used in [Recipe 9.7](#nch-sort-sort-substr-fixed),
    except that it has no leading zeros in the serial number part of the `id` values:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用于排序的子串长度不同，您需要一种可靠的方法来仅提取您想要的部分。为了了解其工作原理，让我们创建一个`housewares3`表，其类似于[配方 9.7](#nch-sort-sort-substr-fixed)中使用的`housewares`表，但`id`值的序号部分没有前导零：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The category and country parts of the `id` values can be extracted and sorted
    using `LEFT()` and `RIGHT()`, just as for the `housewares` table. But now the
    numeric segments of the values have different lengths and cannot be extracted
    and sorted using a simple `MID()` call. Instead, use its full version `SUBSTRING()`
    to skip the first three characters. Of the remainder beginning with the fourth
    character (the first digit), take everything but the rightmost two columns. One
    way to do this is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`LEFT()`和`RIGHT()`提取和排序`id`值的类别和国家部分，就像`housewares`表一样。但是现在值的数值部分长度不同，不能使用简单的`MID()`调用来提取和排序。而是使用其完整版本`SUBSTRING()`跳过前三个字符。从从第四个字符开始的余下部分（第一个数字），取除最右侧两列之外的所有内容。一个方法如下：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But that’s more complex than necessary. The `SUBSTRING()` function takes an
    optional third argument specifying a desired result length, and we know that the
    length of the middle part is equal to the length of the string minus five (three
    for the characters at the beginning and two for the characters at the end). The
    following query demonstrates how to get the numeric middle part by beginning with
    the ID, and then stripping the rightmost suffix:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但这比必要的更复杂。`SUBSTRING()`函数接受一个可选的第三个参数，指定所需的结果长度，我们知道中间部分的长度等于字符串长度减去五（开头三个字符和结尾两个字符）。以下查询演示了如何通过开始于ID并剥离最右侧后缀来获取数值中间部分：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Unfortunately, although the final expression correctly extracts the numeric
    part from the IDs, the resulting values are strings. Consequently, they sort lexically
    rather than numerically:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管最终表达式正确地从ID中提取了数值部分，但结果值是字符串。因此，它们按字典顺序而不是数值顺序排序：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'How to deal with that? One way is to add zero, which tells MySQL to perform
    a string-to-number conversion that results in a numeric sort of the serial number
    values:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理？一种方法是添加零，告诉 MySQL 执行字符串到数字的转换，这样可以对序列号值进行数字排序：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding example, the ability to extract variable-length substrings
    is based on the different kinds of characters in the middle of the `id` values,
    compared to the characters on the ends (that is, digits versus nondigits). In
    other cases, you may be able to use delimiter characters to pull apart column
    values. For the next examples, assume a `housewares4` table with `id` values that
    look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，提取可变长度子字符串的能力基于`id`值中中间字符与两端字符的不同类型（即数字与非数字）。在其他情况下，您可能可以使用分隔符字符来拆分列值。对于下一个示例，请假设一个具有以下`id`值的`housewares4`表：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To extract segments from these values, use `SUBSTRING_INDEX(`*`str`*`,`*`c`*`,`*`n`*`)`.
    It searches a string *`str`* for the *`n`*-th occurrence of a given character
    *`c`* and returns everything to the left of that character. For example, the following
    call returns `13-478`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这些值中提取段，使用`SUBSTRING_INDEX(`*`str`*`,`*`c`*`,`*`n`*`)`。它搜索字符串 *`str`* 中给定字符
    *`c`* 的第 *`n`* 次出现，并返回该字符左边的所有内容。例如，以下调用返回`13-478`：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If *`n`* is negative, the search for *`c`* proceeds from the right and returns
    the rightmost string. This call returns `478-92-2`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *`n`* 为负数，则从右边开始搜索 *`c`* 并返回最右边的字符串。这个调用返回`478-92-2`：
- en: '[PRE57]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'By combining `SUBSTRING_INDEX()` calls with positive and negative indexes,
    it’s possible to extract successive pieces from each `id` value: extract the first
    *`n`* segments of the value and pull off the rightmost one. By varying *`n`* from
    1 to 4, we get the successive segments from left to right:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`SUBSTRING_INDEX()`调用与正负索引结合使用，可以从每个`id`值中提取连续的片段：提取值的第一个 *`n`* 段并去掉最右边的一个。通过将
    *`n`* 从 1 变化到 4，我们从左到右获取连续的片段：
- en: '[PRE58]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first of those expressions can be optimized because the inner `SUBSTRING_INDEX()`
    call returns a single-segment string and is sufficient by itself to return the
    leftmost `id` segment:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 那些表达式中的第一个可以进行优化，因为内部的`SUBSTRING_INDEX()`调用返回单段字符串，并且单独就足以返回最左边的`id`段：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another way to obtain substrings is to extract the rightmost *`n`* segments
    of the value and pull off the first one. Here we vary *`n`* from –4 to –1:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 获取子字符串的另一种方法是提取值的最右边 *`n`* 段并去掉第一个。在这里，我们将 *`n`* 从 -4 变化到 -1：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Again, an optimization is possible. For the fourth expression, the inner `SUBSTRING_INDEX()`
    call is sufficient to return the final substring:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，可以进行优化。对于第四个表达式，内部`SUBSTRING_INDEX()`调用足以返回最终子字符串：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'These expressions can be difficult to read and understand, and experimenting
    with a few to see how they work may be useful. Here is an example that shows how
    to get the second and fourth segments from the `id` values:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这   这些表达式可能很难阅读和理解，尝试几个实验看看它们的工作方式可能会有所帮助。以下是一个示例，展示如何从`id`值中获取第二和第四段：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To use the substrings for sorting, use the appropriate expressions in the `ORDER`
    `BY` clause. (Remember to force a string-to-number conversion by adding zero if
    you want a numeric rather than lexical sort.) The following two queries order
    the results based on the second `id` segment. The first sorts lexically, the second
    numerically:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用子字符串进行排序，请在`ORDER` `BY`子句中使用适当的表达式。（如果要进行数字排序而不是词法排序，请记得通过添加零来强制进行字符串到数字的转换。）以下两个查询基于第二个`id`段对结果进行排序。第一个是按字母顺序排序，第二个是按数字顺序排序：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The substring-extraction expressions here are messy, but at least the column
    values to which we apply the expressions have a consistent number of segments.
    To sort values that have varying numbers of segments, the job can be more difficult.
    [Recipe 9.9](#nch-sort-sort-domain) shows an example illustrating why that is.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的子字符串提取表达式很混乱，但至少我们应用表达式的列值具有一致的段数。对具有不同段数的值进行排序，这项工作可能更加困难。[第 9.9 节](#nch-sort-sort-domain)展示了一个示例，说明了其中的原因。
- en: 9.9 Sorting Hostnames in Domain Order
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.9 按域名顺序对主机名排序
- en: Problem
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort hostnames in domain order, with the rightmost parts of the
    names more significant than the leftmost parts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你想按域名顺序对主机名进行排序，右边的名称部分比左边的部分更重要。
- en: Solution
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Break apart the names, and sort the pieces from right to left.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分名称，并从右到左对这些部分进行排序。
- en: Discussion
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Hostnames are strings and therefore their natural sort order is lexical. However,
    it’s often desirable to sort hostnames in domain order, where the rightmost segments
    of the hostname values are more significant than the leftmost segments. Suppose
    that a `hostname` table contains the following names:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名是字符串，因此它们的自然排序顺序是词法顺序。但通常希望按域顺序对主机名进行排序，其中主机名值的右侧段比左侧段更重要。假设一个`hostname`表包含以下名称：
- en: '[PRE64]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding query demonstrates the natural lexical sort order of the `name`
    values. That differs from domain order, as the [Table 9-2](#nch-sort-sort-domain-domain)
    shows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询展示了`name`值的自然词法排序顺序。这与域顺序不同，如[Table 9-2](https://example.org/table_9_2)所示：
- en: Table 9-2\. Lexical versus Domain sort order
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2\. 词法顺序与域顺序
- en: '| Lexical order | Domain order |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 词法顺序 | 域顺序 |'
- en: '| --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `dbi.perl.org` | `www.kitebird.com` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `dbi.perl.org` | `www.kitebird.com` |'
- en: '| `jakarta.apache.org` | `mysql.com` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `jakarta.apache.org` | `mysql.com` |'
- en: '| `lists.mysql.com` | `lists.mysql.com` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `lists.mysql.com` | `lists.mysql.com` |'
- en: '| `mysql.com` | `svn.php.net` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `mysql.com` | `svn.php.net` |'
- en: '| `svn.php.net` | `jakarta.apache.org` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `svn.php.net` | `jakarta.apache.org` |'
- en: '| `www.kitebird.com` | `dbi.perl.org` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `www.kitebird.com` | `dbi.perl.org` |'
- en: Producing domain-ordered output is a substring-sorting problem for which it’s
    necessary to extract each segment of the names so they can be sorted in right-to-left
    fashion. There is also an additional complication if your values contain different
    numbers of segments, as our example hostnames do. (Most of them have three segments,
    but `mysql.com` has only two.)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 生产域排序的输出是一个子字符串排序问题，需要提取每个名称段，以便按照从右到左的顺序进行排序。如果您的值包含不同数量的段落，比如我们的示例主机名，这还会带来额外的复杂性（大多数有三段，但`mysql.com`只有两段）。
- en: 'To extract the pieces of the hostnames, begin by using `SUBSTRING_INDEX()`
    in a manner similar to that described previously in [Recipe 9.8](#nch-sort-sort-substr-variable).
    The hostname values have a maximum of three segments, from which the pieces can
    be extracted left to right like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取主机名的各部分，请使用`SUBSTRING_INDEX()`，类似于[Recipe 9.8](https://example.org/recipe_9_8)中所描述的方式。主机名的值最多有三个段，可以从左到右提取这些部分，就像这样：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'These expressions work properly as long as all the hostnames have three components.
    But if a name has fewer than three, you don’t get the correct result, as the following
    query demonstrates:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所有主机名都有三个组件，这些表达式就能正常工作。但是，如果名称少于三个组件，则不会得到正确的结果，如下面的查询所示：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Notice the output for the `mysql.com` row; it has `mysql` for the value of
    the `leftmost` column, where it should have an empty string. The segment-extraction
    expressions work by pulling off the rightmost *`n`* segments, and then returning
    the leftmost segment of the result. The source of the problem for `mysql.com`
    is that if there aren’t *`n`* segments, the expression simply returns the leftmost
    segment of however many there are. To fix this problem, add a sufficient number
    of periods at the beginning of the hostname values to guarantee that they have
    the requisite number of segments:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`mysql.com`行的输出；它在`leftmost`列的值是`mysql`，但应该是空字符串。段落提取表达式通过删除右侧的*n*个段落，然后返回结果的左侧段落来工作。对于`mysql.com`的问题在于，如果段落数量不足，表达式只返回其中有的最左侧段落。要解决此问题，请在主机名值的开头添加足够数量的句点，以保证它们具有必需的段落数量：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'That’s pretty ugly. But the expressions do serve to extract the substrings
    that are needed for sorting hostname values correctly in right-to-left fashion:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当丑陋。但是这些表达式确实可以提取所需的子字符串，以正确地按从右到左的方式排序主机名值：
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If your hostnames have a maximum of four segments rather than three, add to
    the `ORDER` `BY` clause another `SUBSTRING_INDEX()` expression that adds three
    dots at the beginning of the hostname values.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的主机名最多有四个段而不是三个，那么在`ORDER BY`子句中添加另一个`SUBSTRING_INDEX()`表达式，以在主机名值的开头添加三个句点。
- en: 9.10 Sorting Dotted-Quad IP Values in Numeric Order
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.10 按数字顺序排序点分IP值
- en: Problem
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort in numeric order strings that represent IP numbers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望按照表示IP号码的字符串进行数字顺序排序。
- en: Solution
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Break apart the strings, and sort the pieces numerically. Or just use `INET_ATON()`.
    Or consider storing the values as numbers instead.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分字符串并按数字顺序排序各部分。或者只需使用`INET_ATON()`。或考虑将值存储为数字。
- en: Discussion
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If a table contains IP numbers represented as strings in dotted-quad notation
    (`192.168.1.10`), they sort lexically rather than numerically. To produce a numeric
    ordering instead, sort them as four-part values with each part sorted numerically.
    Or, to be more efficient, represent the IP numbers as 32-bit unsigned integers,
    which take less space and can be ordered by a simple numeric sort. This section
    shows both methods.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表中包含以点分十进制表示的 IP 数字字符串（`192.168.1.10`），则它们按词法顺序而不是数值顺序排序。为了产生数值排序，可以将它们作为四部分值进行排序，每部分按数值顺序排序。或者更高效地，将
    IP 数字表示为 32 位无符号整数，这需要更少的空间并且可以通过简单的数值排序来排序。本节展示了两种方法。
- en: 'To sort string-valued dotted-quad IP numbers, use a technique similar to that
    for sorting hostnames (see [Recipe 9.9](#nch-sort-sort-domain)), but with the
    following differences:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要对字符串形式的点分十进制 IP 数字进行排序，可以使用类似于主机名排序的技术（见[食谱 9.9](#nch-sort-sort-domain)），但有以下几点不同：
- en: Dotted quads always have four segments. There’s no need to add dots to the value
    before extracting substrings.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点分四段始终存在。在提取子字符串之前不需要向值添加点。
- en: Dotted quads sort left to right. The order of the substrings used in the `ORDER`
    `BY` clause is opposite to that used for hostname sorting.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点分四段按从左到右排序。在 `ORDER BY` 子句中使用的子字符串顺序与主机名排序相反。
- en: The segments of dotted-quad values are numbers. Add zero to each substring to
    force a numeric rather than lexical sort.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点分十进制值的各段都是数字。对每个子字符串添加零以强制执行数值而不是词法排序。
- en: 'Suppose that a `hostip` table has a string-valued `ip` column containing IP
    numbers:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `hostip` 表具有一个字符串值 `ip` 列，其中包含 IP 数字：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding query produces output sorted in lexical order. To sort the `ip`
    values numerically, extract each segment and add zero to convert it to a number
    like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 前述查询生成的输出按词法顺序排序。要按 `ip` 值进行数值排序，提取每个段并加零以将其转换为数字，如下所示：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'However, although that `ORDER` `BY` clause produces a correct result, it’s
    complicated. A simpler solution uses the `INET_ATON()` function to convert network
    addresses in string form to their underlying numeric values, then sorts those
    numbers:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管 `ORDER BY` 子句生成了正确的结果，但它很复杂。更简单的解决方案是使用 `INET_ATON()` 函数将网络地址从字符串形式转换为其基础数值，然后对这些数值进行排序：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you’re tempted to sort by simply adding zero to the `ip` value and using
    `ORDER` `BY` on the result, consider the values that kind of string-to-number
    conversion actually produces:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图通过简单地将零添加到 `ip` 值并在结果上使用 `ORDER BY` 进行排序，考虑一下该类型的字符串到数字转换实际产生的值：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The conversion retains only as much of each value as can be interpreted as a
    valid number (hence the warnings). The remainder becomes unavailable for sorting
    purposes, even though it’s required for a correct ordering.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 转换仅保留每个值的尽可能多的部分以解释为有效数字（因此会有警告）。其余部分因排序目的不可用，即使对于正确排序也是如此。
- en: 'Use of `INET_ATON()` in the `ORDER` `BY` clause is more efficient than six
    `SUBSTRING_INDEX()` calls. Moreover, if you storing IP addresses as numbers rather
    than as strings, you can avoid performing any conversion at all when sorting.
    You gain other benefits as well: numeric IP addresses have 32 bits, so you can
    use a 4-byte `INT` `UNSIGNED` column to store them, which requires less storage
    than the string form. Also, if you index the column, the query optimizer may be
    able to use the index for certain queries. For cases requiring display of numeric
    IP values in dotted-quad notation, convert them with the `INET_NTOA()` function.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ORDER BY` 子句中使用 `INET_ATON()` 比六个 `SUBSTRING_INDEX()` 调用更高效。此外，如果将 IP 地址存储为数字而不是字符串，则在排序时可以完全避免进行任何转换。这样做还有其他好处：数值
    IP 地址有 32 位，因此可以使用 4 字节的 `INT UNSIGNED` 列来存储它们，这比字符串形式需要更少的存储空间。而且，如果对该列创建索引，查询优化器可能能够在某些查询中使用该索引。对于需要以点分十进制表示形式显示数值
    IP 值的情况，可以使用 `INET_NTOA()` 函数进行转换。
- en: 9.11 Floating Values to the Head or Tail of the Sort Order
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.11 将浮点值放在排序顺序的开头或结尾
- en: Problem
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a column to sort the way it normally does, except for a few values
    that should appear at the beginning or end of the sort order. For example, you
    want to sort a list in lexical order except for certain high-priority values that
    should appear first no matter where they fall in the normal sort order.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望按列的通常方式排序，但某些值应出现在排序顺序的开头或结尾。例如，您想按词法顺序排序列表，但希望某些高优先级值无论出现在正常排序顺序的何处都应首先显示。
- en: Solution
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add an initial sort column to the `ORDER` `BY` clause that places those few
    values where you want them. The remaining sort columns have their usual effect
    for the other values.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `ORDER BY` 子句添加一个初始排序列，以放置您希望它们出现的那些值。其余的排序列对其他值有正常效果。
- en: Discussion
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To sort a result set normally *except* that you want particular values first,
    create an additional sort column that is 0 for those values and 1 for everything
    else. This enables you to float the values to the head of the ascending sort order.
    To put the values at the tail instead, use descending sort order or store 1 for
    rows that you want to be in the end of the list and 0 for others.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要正常排序结果集，*除非*您希望特定值出现在首位，请创建一个额外的排序列，对于这些值为 `0`，对于其他一切为 `1`。这样可以使这些值浮动到升序排序顺序的最前面。若要将这些值放在末尾，请使用降序排序或者为希望在列表末尾的行存储
    `1`，对于其他行存储 `0`。
- en: 'Suppose that a column contains `NULL` values:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 假设某列包含 `NULL` 值：
- en: '[PRE73]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Normally, sorting groups the `NULL` values at the beginning for an ascending
    sort:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于升序排序，`NULL` 值会排在最前面：
- en: '[PRE74]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To put them at the end instead, without changing the order of other values,
    introduce an extra `ORDER` `BY` column that maps `NULL` values to a higher value
    than non-`NULL` values:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们放在末尾而不改变其他值的顺序，请引入额外的 `ORDER BY` 列，将 `NULL` 值映射到高于非 `NULL` 值的值：
- en: '[PRE75]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `IF()` expression creates a new column for the sort that is used as the
    primary sort value.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`IF()` 表达式会为排序创建一个新列，该列作为主要排序值使用。'
- en: 'For descending sorts, `NULL` values group at the end. To put them at the beginning
    instead, use the same technique, but reverse the second and third arguments of
    the `IF()` function to map `NULL` values to a lower value than non-`NULL` values:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于降序排序，`NULL` 值会排在最后面。若要将它们放在最前面，请使用相同的技术，但反转 `IF()` 函数的第二和第三参数的顺序，以将 `NULL`
    值映射到低于非 `NULL` 值的值：
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The same technique is useful for floating values other than `NULL` to either
    end of the sort order. Suppose that you want to sort `mail` table messages in
    sender/recipient order, but you want to put messages for a particular sender first.
    In the real world, the most interesting sender might be `postmaster` or `root`.
    Those names don’t appear in the table, so let’s use `phil` as the name of interest
    instead:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术也适用于浮动除 `NULL` 之外的值到排序顺序的两端。假设您希望按发件人/收件人顺序排序 `mail` 表中的消息，但希望将某个发件人的消息放在首位。在实际世界中，最感兴趣的发件人可能是
    `postmaster` 或 `root`。这些名称在表中不存在，因此我们将使用 `phil` 作为感兴趣的名称：
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The value of the extra sort column is `0` for rows in which the `srcuser` value
    is `phil`, and `1` for all other rows. By making that the most significant sort
    column, rows for messages sent by `phil` float to the top of the output. (To sink
    them to the bottom instead, either sort the column in reverse order using `DESC`,
    or reverse the order of the second and third arguments of the `IF()` function.)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 额外排序列的值对于 `srcuser` 值为 `phil` 的行为 `0`，对于所有其他行为 `1`。通过将其作为最重要的排序列，由 `phil` 发送的消息的行会浮动到输出的顶部。（若要将它们放在底部，可以使用
    `DESC` 反向排序该列，或反转 `IF()` 函数的第二和第三参数的顺序。）
- en: 'You can also use this technique for particular conditions, not only specific
    values. To put first those rows where people sent messages to themselves, do this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以根据特定条件使用此技术，而不仅仅是特定值。要先放置那些发送消息给自己的行，请执行以下操作：
- en: '[PRE78]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If you have a pretty good idea about the contents of your table, it’s sometimes
    possible to eliminate the extra sort column. For example, `srcuser` is never `NULL`
    in the `mail` table, so the previous query can be rewritten as follows to use
    one less column in the `ORDER` `BY` clause (this relies on the property that `NULL`
    values sort ahead of all non-`NULL` values):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对表的内容有很好的了解，有时可以省略额外的排序列。例如，在 `mail` 表中，`srcuser` 永远不会是 `NULL`，因此可以将前一个查询重写如下，以在
    `ORDER BY` 子句中使用少一列（这依赖于 `NULL` 值在所有非 `NULL` 值之前排序的属性）：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 9.12 Defining a Custom Sort Order
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.12 定义自定义排序顺序
- en: Problem
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort values in a nonstandard order.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您想按非标准顺序对值进行排序。
- en: Solution
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `FIELD()` to map column values to a sequence that places the values in the
    desired order.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FIELD()` 将列值映射到一个序列，以便按照所需顺序排列这些值。
- en: Discussion
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 9.11](#nch-sort-sort-float) shows how to make a specific group of rows
    float to the head of the sort order. To impose a specific order on *all* values
    in a column, use the `FIELD()` function to map them to a list of numeric values
    and use the numbers for sorting. `FIELD()` compares its first argument to the
    following arguments and returns an integer indicating which one it matches. (This
    works best when the column contains a small number of distinct values.)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 9.11](#nch-sort-sort-float) 展示了如何使一组特定行浮动到排序顺序的开头。要对列中的所有值施加特定顺序，请使用
    `FIELD()` 函数将它们映射到一组数值，并使用这些数字进行排序。（当列包含少量不同的值时效果最佳。）'
- en: 'The following `FIELD()` call compares *`value`* to *`str1`*, *`str2`*, *`str3`*,
    and *`str4`*, and returns 1, 2, 3, or 4, depending on which of them *`value`*
    is equal to:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIELD()` 调用以下比较 *`value`* 与 *`str1`*, *`str2`*, *`str3`*, 和 *`str4`*，并根据 *`value`*
    等于哪个值返回 1, 2, 3, 或 4。'
- en: '[PRE80]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If *`value`* is `NULL` or none of the values match, `FIELD()` returns 0.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *`value`* 是 `NULL` 或没有匹配的值，`FIELD()` 返回 0。
- en: 'You can use `FIELD()` to sort an arbitrary set of values into any order you
    please. For example, to display `driver_log` rows for Henry, Suzi, and Ben, in
    that order, do this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `FIELD()` 将任意一组值按任意顺序排序。例如，要按 Henry、Suzi 和 Ben 的顺序显示 `driver_log` 行，请执行以下操作：
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 9.13 Sorting ENUM Values
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.13 排序 ENUM 值
- en: Problem
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '`ENUM` values don’t sort like other string columns, and you want them to retrieve
    results in the order you expect.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENUM` 值与其他字符串列不同，你希望它们按照预期顺序检索结果。'
- en: Solution
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Study how `ENUM` stores data and use those properties to your advantage. You
    can, for example, define your own sort order for strings, stored in the `ENUM`
    column.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 研究 `ENUM` 如何存储数据，并利用这些属性为你所用。例如，可以定义自己的字符串排序顺序，存储在 `ENUM` 列中。
- en: Discussion
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`ENUM` is a string data type, but `ENUM` values actually are stored numerically
    with values ordered the same way they are listed in the table definition. These
    numeric values affect how enumerations are sorted, which can be very useful. Suppose
    that a table named `weekday` contains an enumeration column named `day` that has
    weekday names as its members:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENUM` 是一种字符串数据类型，但 `ENUM` 值实际上是按照它们在表定义中列出的顺序存储的数值。这些数值影响枚举排序的方式，这可能非常有用。假设名为
    `weekday` 的表包含一个名为 `day` 的枚举列，其成员为工作日名称：'
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Internally, MySQL defines the enumeration values `Sunday` through `Saturday`
    in that definition to have numeric values from 1 to 7\. To see this for yourself,
    create the table using the definition just shown, and then insert into it a row
    for each day of the week. To make the insertion order differ from sorted order
    (so that you can see the effect of sorting), add the days in random order:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，MySQL 在该定义中定义枚举值 `Sunday` 到 `Saturday` 具有从 1 到 7 的数字值。要自行验证，请使用刚才展示的定义创建表，并为每周的每一天插入一行。为了使插入顺序与排序顺序不同（以便查看排序效果），以随机顺序添加这些天：
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then select the values, both as strings and as the internal numeric value (obtain
    the latter using `+0` to force a string-to-number conversion):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择这些值，既作为字符串，也作为内部数值（使用 `+0` 强制将字符串转换为数字）：
- en: '[PRE84]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Notice that because the query includes no `ORDER` `BY` clause, the rows are
    returned in unsorted order. If you add an `ORDER` `BY` `day` clause, it becomes
    apparent that MySQL uses the internal numeric values for sorting:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于查询不包括 `ORDER BY` 子句，行以未排序顺序返回。如果添加一个 `ORDER BY day` 子句，就会明显看出 MySQL 使用内部数字值进行排序：
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'What about occasions when you want to sort `ENUM` values in lexical order?
    Force them to be treated as strings for sorting using the `CAST()` function:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望按字典顺序排序 `ENUM` 值时怎么办？使用 `CAST()` 函数强制它们在排序时被视为字符串：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If you always (or nearly always) sort a non-enumeration column in a specific
    nonlexical order, consider changing the data type to `ENUM`, with its values listed
    in the desired sort order. To see how this works, create a `color` table containing
    a string column, and populate it with some sample rows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你总是（或几乎总是）按特定非字典顺序排序非枚举列，请考虑将数据类型更改为 `ENUM`，其值按所需的排序顺序列出。要了解其工作原理，请创建一个包含字符串列的
    `color` 表，并填充一些示例行：
- en: '[PRE87]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Sorting by the `name` column at this point produces lexical order because the
    column contains `CHAR` values:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此时按 `name` 列排序会产生字典顺序，因为该列包含 `CHAR` 值：
- en: '[PRE88]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now suppose that you want to sort the column by the order in which colors occur
    in the rainbow. (This is <q>Roy G. Biv</q> order; successive letters of that name
    indicate the first letters of the corresponding color names.) One way to produce
    a rainbow sort is to use `FIELD()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想按照彩虹中颜色出现的顺序对列进行排序。（这是 <q>Roy G. Biv</q> 顺序；该名称的连续字母表示相应颜色名称的首字母。）产生彩虹排序的一种方法是使用
    `FIELD()`：
- en: '[PRE89]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To accomplish the same end without `FIELD()`, use `ALTER` `TABLE` to convert
    the `name` column to an `ENUM` that lists the colors in the desired sort order:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现不使用 `FIELD()` 达到相同的目的，可以使用 `ALTER` `TABLE` 将 `name` 列转换为按照彩虹中颜色出现顺序列出的 `ENUM`：
- en: '[PRE90]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'After converting the table, sorting on the `name` column produces rainbow sorting
    naturally with no special treatment:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换表后，对 `name` 列进行排序自然地产生彩虹排序，无需特殊处理：
- en: '[PRE91]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note that once you switched to the `ENUM` data type you would not be able to
    insert any value that does not belong to list. If you need to change `ENUM` definition,
    for example, by adding new color, you will have to perform one more `ALTER` command.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦您切换到 `ENUM` 数据类型，将无法插入不属于列表的任何值。如果需要更改 `ENUM` 定义，例如添加新颜色，您将需要执行另一条 `ALTER`
    命令。
