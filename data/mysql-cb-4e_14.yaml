- en: Chapter 14\. Validating and Reformatting Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章。验证和重新格式化数据
- en: 14.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.0 介绍
- en: 'The previous chapter, [Chapter 13](ch13.xhtml#nch-xfer), focused on methods
    for moving data into and out of MySQL, by reading lines and breaking them into
    separate columns. In this chapter, we’ll focus on the content rather than structure
    issues. For example, if you don’t know whether the values contained in a file
    or recieved via web form are legal, preprocess them to check or reformat them:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章，[第 13 章](ch13.xhtml#nch-xfer)，侧重于通过读取行并将其分解为单独列来将数据移入和移出 MySQL 的方法。在本章中，我们将重点放在内容而不是结构问题上。例如，如果您不知道文件中包含的值或通过
    Web 表单接收的值是否合法，请预处理它们以进行检查或重新格式化：
- en: It’s often a good idea to validate data values to make sure they’re legal for
    the data types into which you store them. For example, you can make sure that
    values intended for `INT`, `DATE`, and `ENUM` columns are integers, dates in ISO
    format (*`YYYY-MM-DD`* ), and legal enumeration values, respectively.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据值通常是一个好主意，以确保它们对于存储它们的数据类型是合法的。例如，您可以确保用于 `INT`、`DATE` 和 `ENUM` 列的值分别是整数、ISO
    格式的日期（*`YYYY-MM-DD`*）和合法的枚举值。
- en: Data values may need reformatting. You might store credit card values as a string
    of digits but permit users of a web application to separate blocks of digits by
    spaces or dashes. These values must be rewritten before storing them. Rewriting
    dates from one format to another is especially common; for example, if a program
    writes dates in *`MM-DD-YY`* format to ISO format for import into MySQL. If a
    program understands only date and time formats and not a combined date-and-time
    format (such as MySQL uses for the `DATETIME` and `TIMESTAMP` data types), you
    must split date-and-time values into separate date and time values.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据值可能需要重新格式化。您可能将信用卡的值存储为一串数字，但允许 Web 应用程序的用户通过空格或破折号分隔数字块。这些值在存储之前必须重新编写。将日期从一种格式重写为另一种格式是非常常见的；例如，如果程序以*`MM-DD-YY`*格式编写日期以便导入到
    MySQL 中的 ISO 格式。如果程序只理解日期和时间格式而不理解组合的日期和时间格式（例如 MySQL 用于 `DATETIME` 和 `TIMESTAMP`
    数据类型的格式），则必须将日期和时间值拆分为单独的日期和时间值。
- en: The chapter deals with formatting and validation issues primarily within the
    context of checking entire files, but many of the techniques discussed here can
    be applied to one-time validations as well. Consider a web-based application that
    presents a form for a user to fill in and then processes its contents to create
    a new row in the database. Web APIs generally make form contents available as
    a set of already parsed discrete values, so the application may not need to deal
    with record and column delimiters. On the other hand, validation issues remain
    paramount. You really have no idea what kind of values a user is sending your
    script, so it’s important to check them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要涉及在检查整个文件的上下文中的格式和验证问题，但这里讨论的许多技术也可以应用于一次性验证。考虑一个基于 Web 的应用程序，该应用程序提供一个表单供用户填写，然后处理其内容以在数据库中创建新行。
    Web API 通常将表单内容作为一组已解析的离散值提供，因此应用程序可能不需要处理记录和列分隔符。另一方面，验证问题仍然至关重要。您真的不知道用户向您的脚本发送什么样的值，因此检查它们很重要。
- en: First three recipes introduce you data validation capabilities, available in
    MySQL. Starting from [Recipe 14.4](#nch-format-format-validate-input-loop) we
    focus on validating and pre-processing data on the application side. We introduce
    technicques that allow to process large bulks of data effectively.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个配方介绍了 MySQL 中可用的数据验证功能。从[配方 14.4](#nch-format-format-validate-input-loop)开始，我们将重点放在验证和预处理应用程序端的数据上。我们介绍了一些技巧，可以有效地处理大量数据。
- en: Source code for program fragments and scripts discussed in this chapter is located
    in the *transfer* directory of the `recipes` distribution, with the exception
    that some utility functions are contained in library files located in the *lib*
    directory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的程序片段和脚本的源代码位于 `recipes` 分发的 *transfer* 目录中，但一些实用函数包含在位于 *lib* 目录中的库文件中。
- en: 14.1 Using the SQL Mode to Reject Bad Input Values
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.1 使用 SQL 模式拒绝不良输入值
- en: Problem
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: MySQL accepts data values that are invalid, out of range, or otherwise unsuitable
    for the data types of the columns into which you insert them. You want the server
    to be more restrictive and not accept bad data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 接受无效、超出范围或其他不适合插入的列的数据值。您希望服务器更具限制性，不接受不良数据。
- en: Solution
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Check the SQL mode and make sure it is not empty. There are several modes that
    you can use to control how strict the server is on data values. Some modes apply
    generally to all input values. Others apply to specific data types such as dates.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 检查SQL模式并确保它不为空。有几种模式可以用来控制服务器对数据值的严格程度。有些模式适用于所有输入值，而其他模式适用于特定的数据类型，如日期。
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When the SQL mode is not setor is set to an empty value, MySQL allows all input
    values for your table columns, even if the input data types do not match the column’s
    data type. Consider the following table, which has integer, string, and date columns:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQL模式未设置或设置为空值时，MySQL允许所有输入值用于表列，即使输入数据类型与列的数据类型不匹配。考虑以下表，其中包含整数、字符串和日期列：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inserting a row with unsuitable data values into the table causes warnings
    (which you can see with `SHOW` `WARNINGS`), but the server loads the values into
    the table after converting them to some value that fits the column:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 向表中插入具有不合适数据值的行会导致警告（可以通过`SHOW WARNINGS`查看），但服务器会将这些值加载到表中，并将它们转换为适合该列的某个值：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'One way to prevent these converstions to happen is to check the input data
    on the client side to make sure that it’s legal. This is a reasonable strategy
    in certain circumstances (see the sidebar in [Recipe 14.0](#nch-format-format-intro)),
    but there is an alternative: let the server check data values on the server side
    and reject them with an error if they’re invalid.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这些转换发生的一种方法是在客户端检查输入数据，以确保其合法。在某些情况下，这是一种合理的策略（参见[Recipe 14.0](#nch-format-format-intro)中的侧边栏），但也有一种替代方案：让服务器在服务器端检查数据值，并在无效时拒绝它们并显示错误。
- en: 'To do this, set the `sql_mode` system variable to enable server restrictions
    on input data acceptance. With the proper restrictions in place, data values that
    would otherwise result in conversions and warnings result in errors instead. Try
    the `INSERT` statement from the previous example again after enabling <q>strict</q>
    SQL mode:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，需要将`sql_mode`系统变量设置为启用服务器对输入数据的限制接受。通过适当的限制，否则会导致转换和警告的数据值将导致错误。在启用<q>strict</q>
    SQL模式后，再次尝试上一个示例中的`INSERT`语句：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here the statement doesn’t even progress to the second and third data values
    because the first is invalid for an integer column and the server raises an error.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语句甚至没有进展到第二和第三个数据值，因为第一个对于整数列来说是无效的，服务器会报错。
- en: Without input restrictions enabled, the server checks that the month part of
    date values is in the range from 1 to 12 and that the day value is legal for the
    given month. This means that `'2005-02-31'` generates a warning by default (with
    conversion to zero date `'0000-00-00'`). In strict mode, an error occurs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未启用输入限制，服务器将检查日期值的月份部分是否在1到12的范围内，并且日期值对于给定的月份是否合法。这意味着`'2005-02-31'`默认情况下会生成警告（转换为零日期`'0000-00-00'`）。在严格模式下，会发生错误。
- en: 'MySQL still permits dates such as `''1999-11-00''` or `''1999-00-00''` that
    have zero parts, or the <q>zero</q> date (`''0000-00-00''`). To restrict these
    kinds of date values, enable the `NO_ZERO_IN_DATE` and `NO_ZERO_DATE` SQL modes
    to cause warnings, or errors in strict mode. For example, to prohibit dates with
    zero parts or <q>zero</q> dates, set the SQL mode like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL仍然允许诸如`'1999-11-00'`或`'1999-00-00'`这样具有零部分的日期，或者称为<q>零</q>日期（`'0000-00-00'`）。为了限制这些类型的日期值，启用`NO_ZERO_IN_DATE`和`NO_ZERO_DATE`
    SQL模式会导致警告，或在严格模式下导致错误。例如，要禁止具有零部分或<q>零</q>日期的日期，请像这样设置SQL模式：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A simpler way to enable these restrictions, and a few more besides, is to enable
    `TRADITIONAL` SQL mode. `TRADITIONAL` mode is actually a constellation of modes,
    as you can see by setting and displaying the `sql_mode` value:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 启用这些限制的更简单方法，以及其他几种方法，是启用`TRADITIONAL` SQL模式。`TRADITIONAL`模式实际上是一组模式，可以通过设置和显示`sql_mode`值来查看：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can read more about the various SQL modes in the [MySQL Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[MySQL参考手册](https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html)中详细了解各种SQL模式。
- en: 'The examples shown set the session value of the `sql_mode` system variable,
    so they change the SQL mode only for your current session. To set the mode globally
    for all clients, start the server with a `--sql_mode=`*`mode_value`* option. Alternatively,
    if you have the `SYSTEM_VARIABLES_ADMIN` or `SUPER` privilege, you can set the
    global mode at runtime:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的示例设置了`sql_mode`系统变量的会话值，因此它们仅更改当前会话的SQL模式。要为所有客户端全局设置模式，请在启动服务器时使用`--sql_mode=`*`mode_value`*选项。或者，如果具有`SYSTEM_VARIABLES_ADMIN`或`SUPER`特权，则可以在运行时设置全局模式。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before MySQL 5.7, the SQL mode was forgiving by default. Newer versions are
    much more restrictive, and SQL mode is set to `ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES,
    NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER,
    NO_ENGINE_SUBSTITUTION`. Therefore, if you want to have a restrictive server,
    you don’t need to do anything extra, unless you intentionally relaxed the SQL
    mode earlier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 5.7 之前，默认情况下 SQL 模式是宽容的。更新的版本更加严格，SQL 模式设置为 `ONLY_FULL_GROUP_BY, STRICT_TRANS_TABLES,
    NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_AUTO_CREATE_USER,
    NO_ENGINE_SUBSTITUTION`。因此，如果您希望拥有严格的服务器，您不需要额外做任何事情，除非您有意放宽了之前的 SQL 模式。
- en: 14.2 Using CHECK Constraints to Reject Invalid Values
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.2 使用 `CHECK` 约束拒绝无效值
- en: Problem
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to validate data so it follows business logic of your application and
    rejects values if they do not satisfy requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望验证数据以便符合应用程序的业务逻辑，并在不满足要求时拒绝值。
- en: Solution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `CHECK` constraints.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `CHECK` 约束。
- en: Discussion
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: If a value matches the MySQL data type format, it does not mean it matches logic
    of the application. For example, if you want to store only even numbers you cannot
    simply use data type integer, because both odd and even numbers are valid integers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个值与 MySQL 数据类型格式匹配，并不意味着它与应用程序的逻辑匹配。例如，如果您只想存储偶数，您不能简单地使用整数数据类型，因为奇数和偶数都是有效的整数。
- en: '`CHECK` constraints, introduced in version 8.0, allow to setup a custom condition
    on the table column and rejects the statement if value does not satisfy it. Thus,
    to create a table that will store only even values, you would need to use `CHECK`
    to check if the number can be divided by two without a reminder.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHECK` 约束在 8.0 版本中引入，允许在表列上设置自定义条件，并在值不满足条件时拒绝语句。因此，要创建一个只存储偶数的表，您需要使用 `CHECK`
    来检查数字是否可以被二整除。'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we can successfully insert even numbers into this table.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以成功地插入偶数到这个表中。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Odd values would be rejected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数值将被拒绝。
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also create multiple `CHECK` constraints for a single column. For example,
    to accept only even values that are less than 100 create two constraints.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为单个列创建多个 `CHECK` 约束。例如，为了仅接受小于 100 的偶数值，创建两个约束。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, MySQL will check the first condition and if it is satisfied it
    will process the second one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，MySQL 将检查第一个条件，如果满足则处理第二个条件。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you specify a `CHECK` constraint when defining a column it will validate
    only this column. If you want to check two or more columns in the single constraint
    you will need to specify it separately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在定义列时指定 `CHECK` 约束，它将仅验证此列。如果您希望在单个约束中检查两个或更多列，则需要单独指定它。
- en: A common validation task is to check if the departure date is later than the
    arrival date. We can add such a check to the `patients` table.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的验证任务是检查出发日期是否晚于到达日期。我们可以将此检查添加到 `patients` 表中。
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, it will not allow you to insert records where departure date is earlier
    than the arrival date.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它将不允许插入出发日期早于到达日期的记录。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 14.3 Using Triggers to Reject Input Values
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.3 使用触发器拒绝输入值
- en: Problem
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to validate if data to be inserted into the table follows business
    logic, but your logic is more complicated than `CHECK` constraints can handle.
    You may also need to rewrite the data instead of rejecting it. Or you are using
    an earlier version of MySQL where `CHECK` constraints are not available.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望验证要插入表中的数据是否遵循业务逻辑，但您的逻辑比 `CHECK` 约束能处理的更复杂。您可能还需要重写数据而不是拒绝它。或者您正在使用 MySQL
    的较早版本，不支持 `CHECK` 约束。
- en: Solution
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `BEFORE` triggers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BEFORE` 触发器。
- en: Discussion
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`CHECK` constraints have certain limitations. They do not allow you to use
    stored or user-defined functions, subqueries, or user-defined variables. They
    also do not allow you to modify inserted data. If you want to format inserted
    value to satisfy your business standards you may want to explore another solution,
    such as validation on the application side or `BEFORE` triggers on MySQL side.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHECK` 约束有一些限制。它们不允许使用存储的或用户定义的函数、子查询或用户定义的变量。它们还不允许修改插入的数据。如果您想要格式化插入的值以满足业务标准，您可能需要探索其他解决方案，例如在应用程序端进行验证或在
    MySQL 端使用 `BEFORE` 触发器。'
- en: To perform more complicated validation on MySQL side create a trigger and raise
    a SQL exception in it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 MySQL 端执行更复杂的验证，请创建触发器并在其中引发 SQL 异常。
- en: Let’s take a look at an example. Suppose that a groceries table stores details
    about the products in a supermarket. In some countries, it is forbidden to sell
    alcohol in supermarkets between certain hours. For example, in Turkey, you wouldn’t
    be able to buy alcohol in a supermarket between 10 pm and 6 am. If you are working
    with such limitations, you may want to limit times when users can place orders.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。假设一个杂货表存储超市中产品的详细信息。在一些国家，超市在特定时间内禁止出售酒精制品。例如，在土耳其，您无法在晚上10点至早上6点之间在超市购买酒精。如果您遇到此类限制，您可能希望限制用户可以下订单的时间。
- en: Suppose that a `groceries` table stores details about groceries in the supermarket.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个 `groceries` 表存储超市杂货的详细信息。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Columns `forbidden_after` and `forbidden_before` define time range when it is
    not allowed to sell particular item.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列 `forbidden_after` 和 `forbidden_before` 定义了禁止销售特定物品的时间范围。
- en: Another table, named `groceries_order_items`, contains information about purchases.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为 `groceries_order_items` 的表包含有关购买的信息。
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To disallow the purchase of items during certain times, you could create a trigger
    that checks the current time and if there are any restrictions to a selected product.
    If restrictions exist the purchase will be rejected.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要在某些时间禁止购买物品，您可以创建一个触发器，检查当前时间和对所选产品的任何限制。如果存在限制，则拒绝购买。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_nch-format-format-triggers_declare_co)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_nch-format-format-triggers_declare_co)'
- en: Declare variables to store time range when the purchase is forbidden, the name
    of the product, and an error message.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量以存储禁止购买的时间范围、产品名称和错误消息。
- en: '[![2](Images/2.png)](#co_nch-format-format-triggers_select_co)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_nch-format-format-triggers_select_co)'
- en: Select restricted time range and name of the product into variables.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 选择限制的时间范围和产品名称存入变量。
- en: '[![3](Images/3.png)](#co_nch-format-format-triggers_check_co)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_nch-format-format-triggers_check_co)'
- en: Check if current time fails into forbidden range for the selected product.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 检查当前时间是否在所选产品的禁止范围内。
- en: '[![4](Images/4.png)](#co_nch-format-format-triggers_message_co)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_nch-format-format-triggers_message_co)'
- en: If the time fails into forbidden range craft a message, explaining restrictions
    for the product.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间落入禁止范围内，编制一条消息，解释该产品的限制。
- en: '[![5](Images/5.png)](#co_nch-format-format-triggers_signal_co)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_nch-format-format-triggers_signal_co)'
- en: Raise an error and reject the insert.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引发错误并拒绝插入。
- en: As a result you can purchase cheese or water at 3 am, but you cannot purchase
    beer or wine at that time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在凌晨3点购买奶酪或水，但不能在那时购买啤酒或葡萄酒。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The purchase limitation is relaxed during day time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 白天购买限制会放宽。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See Also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For additional information about using triggers to reject or modify invalid
    values, see [Recipe 11.11](ch11.xhtml#nch-routines-preprocess-reject).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用触发器拒绝或修改无效值的更多信息，请参见[配方 11.11](ch11.xhtml#nch-routines-preprocess-reject)。
- en: 14.4 Writing an Input-Processing Loop
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.4 编写输入处理循环
- en: Problem
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make sure that the data values in a file are legal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望确保文件中的数据值合法。
- en: Solution
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Write an input process loop that will check them, possibly rewriting them into
    a more suitable format.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个输入处理循环，用于检查它们，可能会将它们重写为更合适的格式。
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Many of the validation recipes shown in this chapter are typical of those that
    you perform within the context of a program that reads a file and checks individual
    column values. The general framework for such a file-processing utility looks
    like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的许多验证示例都是在读取文件并检查各列值的程序上执行的典型操作。这类文件处理实用程序的一般框架如下：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `for()` loop reads each input line. Within the loop, each line is broken
    into fields. The inner `for()` loop iterates through the fields, enabling each
    to be processed in sequence. If you don’t apply a given test uniformly to all
    the fields, replace the `for()` loop with separate column-specific tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`for()` 循环读取每个输入行。在循环内部，每行被分割为字段。内部的 `for()` 循环迭代处理每个字段，按顺序处理。如果不对所有字段统一应用特定测试，则用单独的基于列的测试替换
    `for()` 循环。'
- en: This loop assumes tab-delimited, linefeed-terminated input, an assumption shared
    by most of the utilities discussed throughout this chapter. To use these utilities
    with datafiles in other formats, you may be able to convert such files to tab-delimited
    format using the *cvt_file.pl* script, available in the recipes distribution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环假设制表符分隔的、以换行符终止的输入，这是本章讨论的大多数实用程序共享的假设。要使用这些实用程序处理其他格式的数据文件，您可以尝试使用*recipes*分发中提供的*cvt_file.pl*脚本将这些文件转换为制表符分隔格式。
- en: 14.5 Putting Common Tests in Libraries
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.5 将常见测试放入库中
- en: Problem
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to do repeated validation operations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望执行重复的验证操作。
- en: Solution
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Package validation operations as library routines.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将验证操作封装为库例程。
- en: Discussion
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'It’s not unusual for certain validation operations to occur repeatedly, in
    which case you’ll probably find it useful to construct a library of functions.
    By packaging validation operations as library routines, it is easier to write
    utilities based on them, and the utilities make it easier to perform command-line
    operations on entire files so that you can avoid editing them yourself. This also
    gives the operation a name that’s likely to make the meaning of it clearer than
    the comparison code itself. The following test in Python language performs a pattern
    match to check that `val` consists entirely of digits (optionally preceded by
    a plus sign), and then makes sure the value is greater than zero:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些验证操作频繁发生并且重复的情况并不罕见，此时您可能会发现构建函数库非常有用。通过将验证操作封装为库例程，编写基于它们的实用程序更加容易，这些实用程序使得在整个文件上执行命令行操作变得更加简单，因此您可以避免手动编辑它们。这也为操作赋予了一个比比较代码本身更清晰的名称。以下是在Python语言中进行的测试，执行模式匹配以检查`val`是否完全由数字（可选前导加号）组成，然后确保该值大于零：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In other words, the test looks for strings that represent positive integers.
    To make the test easier to use and its intent clearer, package it as a function
    that is used like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，该测试寻找表示正整数的字符串。为了使测试更易于使用并使其意图更清晰，请将其封装为以下形式的函数使用：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the function as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数定义如下：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now put the function definition into a library file so that multiple scripts
    can use it easily. The *cookbook_utils.py* module file in the *lib* directory
    of the `recipes` distribution is an example of a library file that contains a
    number of validation functions. Take a look through it to see which functions
    may be useful in your own programs (or as a model for writing your own library
    files). To gain access to this module from within a script, include a `use` statement
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将函数定义放入库文件中，以便多个脚本可以轻松使用。*cookbook_utils.py*模块文件位于`recipes`发行版的*lib*目录中，是一个包含多个验证函数的库文件示例。浏览一下它，看看哪些函数可能对您自己的程序有用（或作为编写自己库文件的模板）。要从脚本内部访问此模块，请包含像这样的`use`语句：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You must of course install the module file in a directory where Python will
    find it (see [Recipe 4.3](ch04.xhtml#nch-api-api-library)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您必须将模块文件安装在Python能找到的目录中（参见[Recipe 4.3](ch04.xhtml#nch-api-api-library)）。
- en: A significant benefit of putting a collection of utility routines into a library
    file is that you can use it for all kinds of programs. It’s rare for a data manipulation
    problem to be completely unique. If you can pick and choose at least a few validation
    routines from a library, it reduces the amount of code you must write, even for
    highly specialized programs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列实用程序例程放入库文件的显著好处之一是，您可以将其用于各种程序。数据处理问题很少是完全独特的。如果您可以从库中挑选至少几个验证例程，即使对于高度专业化的程序，也能减少必须编写的代码量。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: To avoid writing your own library routines, look around to see if someone else
    has already written suitable routines that you can use. For example, if you check
    the Perl CPAN (*cpan.perl.org*), you’ll find a Data::Validate module hierarchy.
    The modules there provide library routines that standardize a number of common
    validation tasks. Data::Validate::MySQL deals specifically with MySQL data types.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免编写自己的库例程，可以查看是否有其他人已经编写了可用的例程。例如，如果您查看Perl CPAN（*cpan.perl.org*），您会找到一个Data::Validate模块层次结构。那里的模块提供了标准化多种常见验证任务的库例程。Data::Validate::MySQL专门处理MySQL数据类型。
- en: 14.6 Using Pattern Matching to Validate Data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.6 使用模式匹配验证数据
- en: Problem
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to compare a value to a set of values that is difficult to specify
    without writing a really ugly expression.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将值与难以在没有编写非常丑陋的表达式的情况下指定的一组值进行比较。
- en: Solution
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use pattern matching.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配。
- en: Discussion
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Pattern matching is a powerful validation tool that enables you to test entire
    classes of values with a single expression. You can also use pattern tests to
    break matched values into subparts for further individual testing or in substitution
    operations to rewrite matched values. For example, you might break a matched date
    into pieces to verify that the month is in the range from 1 to 12, and the day
    is within the number of days in the month. You might use a substitution to reorder
    *`MM-DD-YYYY`* or *`DD-MM-YYYY`* values into *`YYYY-MM-DD`* format.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一个强大的验证工具，它使您能够使用单个表达式测试整个类别的值。您还可以使用模式测试将匹配值分解为子部分以进行进一步的个别测试，或者在替换操作中重新编写匹配的值。例如，您可以将匹配的日期分解为部分以验证月份是否在
    1 到 12 的范围内，日期是否在该月的天数内。您可以使用替换来重新排列 *`MM-DD-YYYY`* 或 *`DD-MM-YYYY`* 值为 *`YYYY-MM-DD`*
    格式。
- en: The next few sections describe how to use patterns to test several types of
    values, but first let’s review some general pattern-matching principles. The following
    discussion focuses on Python’s regular-expression capabilities. Pattern matching
    in Ruby, PHP, Go, and Perl is similar, although you should consult the relevant
    documentation for any differences. For Java, use the `java.util.regex` package.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节描述如何使用模式来测试几种类型的值，但首先让我们回顾一些一般的模式匹配原则。以下讨论侧重于 Python 的正则表达式能力。Ruby、PHP、Go
    和 Perl 中的模式匹配类似，但应查阅相关文档以了解任何差异。对于 Java，请使用 `java.util.regex` 包。
- en: 'In Python, regular expressions are part of the module `re`. The pattern constructor
    is `re.compile(`*`pat`*`)`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，正则表达式是 `re` 模块的一部分。模式构造函数是 `re.compile(`*`pat`*`)`：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To find if a value matches a pattern use method `match`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找值是否与模式匹配，请使用 `match` 方法：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can construct regular expression in the method `match`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `match` 方法中构造正则表达式：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Put a flag `re.I` as the second argument to the regular expression constructor
    to make the pattern match case insensitive:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将标志 `re.I` 作为正则表达式构造函数的第二个参数，使模式匹配不区分大小写：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To look for a nonmatch, replace the `=` operator with the combination of the
    `=` and `not` operators:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找非匹配项，请用 `=` 操作符替换为 `=` 和 `not` 操作符的组合：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To perform a substitution in `val` based on a pattern match, use `re.sub(/`*`pat`*`,`
    *`replacement`*`, val)`*`replacement`*`/`. If *`pat`* occurs within `val`, it’s
    replaced by *`replacement`*. For a case-insensitive match, put an `re.I` flag.
    To conduct a substitution that replaces only few instances of *`pat`* rather than
    all of them, add an option `count`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据模式匹配在 `val` 中执行替换，请使用 `re.sub(/`*`pat`*`,` *`replacement`*`, val)`*`replacement`*`/`。如果
    `val` 中出现 *`pat`*，则将其替换为 *`replacement`*。要进行大小写不敏感匹配，加上 `re.I` 标志。要执行替换，只替换 *`pat`*
    的几个实例而不是所有实例，请添加选项 `count`：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The [Table 14-1](#nch-format-format-pattern-special) shows some of the special
    pattern elements available in Python regular expressions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 14-1](#nch-format-format-pattern-special) 显示了 Python 正则表达式中可用的一些特殊模式元素：'
- en: Table 14-1\. Pattern elements in Python regular expressions
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-1\. Python 正则表达式中的模式元素
- en: '| Pattern | What the pattern matches |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 模式匹配的内容 |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^` | Beginning of string |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 字符串的开始 |'
- en: '| `$` | End of string |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 字符串的结尾 |'
- en: '| `.` | Any character except a newline |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 除换行符外的任意字符 |'
- en: '| `\s`, `\S` | Whitespace or nonwhitespace character |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `\s`, `\S` | 空白或非空白字符 |'
- en: '| `\d`, `\D` | Digit or nondigit character |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `\d`, `\D` | 数字或非数字字符 |'
- en: '| `\w`, `\W` | Word (alphanumeric or underscore) or nonword character |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `\w`, `\W` | 单词（字母数字或下划线）或非单词字符 |'
- en: '| `[...]` | Any character listed between the square brackets |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `[...]` | 方括号内列出的任何字符 |'
- en: '| `[^...]` | Any character not listed between the square brackets |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `[^...]` | 方括号内未列出的任何字符 |'
- en: '| *`p1`*`&#124;`*`p2`*`&#124;`*`p3`* | Alternation; matches any of the patterns
    *`p1`*, *`p2`*, or *`p3`* |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| *`p1`*`&#124;`*`p2`*`&#124;`*`p3`* | 选择；匹配任何模式 *`p1`*、*`p2`* 或 *`p3`* |'
- en: '| `*` | Zero or more instances of preceding element |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 前导元素的零个或多个实例 |'
- en: '| `+` | One or more instances of preceding element |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 前导元素的一个或多个实例 |'
- en: '| `{`*`n`*`}` | *`n`* instances of preceding element |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `{`*`n`*`}` | 前导元素的 *`n`* 个实例 |'
- en: '| `{`*`m`*`,`*`n`*`}` | *`m`* through *`n`* instances of preceding element
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `{`*`m`*`,`*`n`*`}` | *`m`* 到 *`n`* 个前导元素的实例 |'
- en: Many of these pattern elements are the same as those available for MySQL’s `REGEXP`
    regular-expression operator (see [Recipe 7.11](ch07.xhtml#nch-strings-strings-pat-regexp)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式元素中的许多与 MySQL 的 `REGEXP` 正则表达式运算符可用元素相同（参见[Recipe 7.11](ch07.xhtml#nch-strings-strings-pat-regexp)）。
- en: To match a literal instance of a character that is special within patterns,
    such as `*`, `^`, or `$`, precede it with a backslash. Similarly, to include a
    character within a character class construction that is special in character classes
    (`[`, `]`, or `-`), precede it with a backslash. To include a literal `^` in a
    character class, list it somewhere other than as the first character between the
    parentheses.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配模式中特殊字符（如`*`、`^`或`$`）的文字实例，请在其前面加上反斜杠。类似地，要在字符类构造中包含在字符类中特殊的字符（`[`、`]`或`-`），请在其前面加上反斜杠。要在字符类中包含文字`^`，请将其列在括号之间不作为第一个字符。
- en: 'Many of the validation patterns shown in the following recipes are of the form
    `^`*`pat`*`$`. Beginning and ending a pattern with `^` and `$` has the effect
    of requiring *`pat`* to match the entire string that you test. This is common
    in data validation contexts because it’s generally desirable to know that a pattern
    matches an entire input value, not only part of it. (To be sure that a value represents
    an integer, for example, it does no good to know only that it contains an integer
    somewhere.) This is not a hard-and-fast rule, however, and sometimes it’s useful
    to perform a more relaxed test by omitting the `^` and `$` characters as appropriate.
    For example, if you want to strip leading and trailing whitespace from a value,
    use one pattern anchored only to the beginning of the string, and another anchored
    only to the end:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示的许多验证模式的形式是`^`*`pat`*`$`。用`^`和`$`开头和结尾的模式的效果是要求*`pat`*匹配您测试的整个字符串。在数据验证环境中，这是常见的，因为通常希望知道模式是否完全匹配整个输入值，而不仅仅是部分匹配。但这不是一成不变的规则，有时根据需要可以省略适当的`^`和`$`字符执行更轻松的测试。例如，如果要从值中去除前导和尾随空格，请使用一个仅锚定到字符串开头的模式，以及另一个仅锚定到字符串结尾的模式：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That’s such a common operation, in fact, that it’s a good candidate for being
    written as a utility function. The *cookbook_utils.py* file contains a function
    `trim_whitespace()` that performs both substitutions and returns the result:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是一个常见操作，可以作为实用函数编写。*cookbook_utils.py*文件包含一个执行两个替换并返回结果的`trim_whitespace()`函数：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To remember subsections of a string matched by a pattern, use parentheses around
    the relevant pattern parts. After a successful match, you can refer to the matched
    substrings using the variables `\1`, `\2`, and so forth inside the regular expression
    or using match number as an argument of the method `group`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住模式匹配字符串的子部分，请在相关模式部分周围使用括号。成功匹配后，可以在正则表达式内部使用变量`\1`、`\2`等引用匹配的子字符串，或者作为`group`方法的参数使用匹配编号：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you want to indicate that an element within a pattern is optional, follow
    it with a `?` character. To match values consisting of a sequence of digits, optionally
    beginning with a minus sign, and optionally ending with a period, use this pattern:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要指示模式中的元素是可选的，请在其后面加上`?`字符。要匹配由一系列数字组成的值，可选择以负号开头，并可选择以句点结尾，请使用此模式：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use parentheses to group alternations within a pattern. The following pattern
    matches time values in *`hh:mm`* format, optionally followed by `AM` or `PM`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号在模式内部分组交替项。以下模式匹配*`hh:mm`*格式的时间值，可选择后跟`AM`或`PM`：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The use of parentheses in that pattern also has the side effect of remembering
    the optional part in `\1`. To suppress that side effect, use `(?:`*`pat`* `)`
    instead:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在该模式中使用括号还会记住`\1`中的可选部分。要抑制该副作用，请改用`(?:`*`pat`*`)`：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You now have sufficient background in Python pattern matching to enable construction
    of useful validation tests for several types of data values. The following recipes
    provide patterns that can be used to test for broad content types, numbers, temporal
    values, and email addresses or URLs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在具备了足够的Python模式匹配背景，可以构建用于多种数据值的有用验证测试。以下食谱提供可用于测试广泛内容类型、数字、时间值以及电子邮件地址或URL的模式。
- en: The *transfer* directory of the `recipes` distribution contains a *test_pat.py*
    script that reads input values, matches them against several patterns, and reports
    which patterns each value matches. The script is easily extensible, so you can
    use it as a test harness to try your own patterns.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipes`发行版的*transfer*目录包含一个*test_pat.py*脚本，该脚本读取输入值，将其与多个模式进行匹配，并报告每个值匹配的模式。该脚本易于扩展，因此您可以将其用作测试框架，以尝试自己的模式。'
- en: 14.7 Using Patterns to Match Broad Content Types
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.7 使用模式匹配广泛内容类型
- en: Problem
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to classify values into categories.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将值分类到不同类别中。
- en: Solution
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a pattern that uses a similarly broad categories.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个使用类似广泛类别的模式。
- en: Discussion
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'To check whether values are empty or nonempty, or consist only of certain types
    of characters, the patterns listed in the [Table 14-2](#nch-format-format-pat-broad-chars)
    may suffice:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查值是否为空或非空，或仅由某些类型的字符组成，可使用 [表 14-2](#nch-format-format-pat-broad-chars) 中列出的模式。
- en: Table 14-2\. Commonly used categories of characters
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-2\. 常用字符类别
- en: '| Pattern | Type of value the pattern matches |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 该模式匹配的值类型 |'
- en: '| --- | --- |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^$` | Empty value |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `^$` | 空值 |'
- en: '| `.` | Nonempty value |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 非空值 |'
- en: '| `^\s*$` | Whitespace, possibly empty |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `^\s*$` | 空格，可能为空 |'
- en: '| `^\s+$` | Nonempty whitespace |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `^\s+$` | 非空白格 |'
- en: '| `\S` | Nonempty, and not whitespace |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空，且非空白 |'
- en: '| `^\d+$` | Digits only, nonempty |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `^\d+$` | 仅数字，非空 |'
- en: '| `^[a-zA-Z]+$` | Alphabetic characters only (case insensitive), nonempty |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `^[a-zA-Z]+$` | 仅字母字符（不区分大小写），非空 |'
- en: '| `^\w+$` | Alphanumeric or underscore characters only, nonempty |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `^\w+$` | 仅字母数字或下划线字符，非空 |'
- en: 14.8 Using Patterns to Match Numeric Values
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.8 使用模式匹配数值
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make sure a string looks like a number.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望确保字符串看起来像一个数字。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a pattern that matches the type of number you’re looking for.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匹配您要查找的数字类型的模式。
- en: Discussion
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Patterns can be used to classify values into several types of numbers, as shown
    in the [Table 14-3](#nch-format-format-pat-numeric-int)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可用于将值分类为多种数字类型，如 [表 14-3](#nch-format-format-pat-numeric-int) 所示
- en: Table 14-3\. Patterns that match numbers
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-3\. 匹配数字的模式
- en: '| Pattern | Type of value the pattern matches |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 该模式匹配的值类型 |'
- en: '| --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^\d+$` | Unsigned integer |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `^\d+$` | 无符号整数 |'
- en: '| `^-?\d+$` | Negative or unsigned integer |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `^-?\d+$` | 负数或无符号整数 |'
- en: '| `^[-+]?\d+$` | Signed or unsigned integer |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `^[-+]?\d+$` | 有符号或无符号整数 |'
- en: '| `^[-+]?(\d+(\.\d*)?&#124;\.\d+)$` | Floating-point number |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `^[-+]?(\d+(\.\d*)?&#124;\.\d+)$` | 浮点数 |'
- en: 'The pattern `^\d+$` matches unsigned integers by requiring a nonempty value
    that consists only of digits from the beginning to the end of the value. If you
    care only that a value begins with an integer, you can match an initial numeric
    part and extract it. To do this, match only the initial part of the string (omit
    the `$` that requires the pattern to match to the end of the string) and place
    parentheses around the `\d+` part. Then refer to the matched number as `group(1)`
    after a successful match:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 模式 `^\d+$` 通过要求一个非空值，其值从开始到结束只包含数字，匹配无符号整数。如果你只关心值以整数开头，你可以匹配字符串的初始数字部分并提取它。为此，只匹配字符串的初始部分（省略要求模式匹配到字符串结尾的
    `$`），并在 `\d+` 部分周围加上括号。然后，在成功匹配后，将匹配的数字称为 `group(1)`：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Some kinds of numeric values have a special format or other unusual constraints.
    Here are a few examples and how to deal with them:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型的数值具有特殊的格式或其他不寻常的约束。以下是一些示例及其处理方法：
- en: ZIP codes
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP（邮政编码）
- en: 'ZIP and ZIP+4 codes are postal codes used for mail delivery in the United States.
    They have values like `12345` or `12345-6789` (that is, five digits, possibly
    followed by a dash and four more digits). To match one form or the other, or both
    forms, use the patterns shown in the [Table 14-4](#nch-format-format-pat-numeric-zips):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP 和 ZIP+4 是美国邮政编码，用于邮寄。它们的值如 `12345` 或 `12345-6789`（即五位数字，可能后跟一个短横线和四位数字）。要匹配其中一种形式或两种形式，请使用
    [表 14-4](#nch-format-format-pat-numeric-zips) 中显示的模式：
- en: Table 14-4\. Patterns that match ZIP codes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14-4\. 匹配邮政编码的模式
- en: '| Pattern | Type of value the pattern matches |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 该模式匹配的值类型 |'
- en: '| --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^\d{5}$` | ZIP code, five digits only |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `^\d{5}$` | ZIP 编码，仅五位数字 |'
- en: '| `^\d{5}-\d{4}$` | ZIP+4 code |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `^\d{5}-\d{4}$` | ZIP+4 编码 |'
- en: '| `^\d{5}(-\d{4})?$` | ZIP or ZIP+4 code |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `^\d{5}(-\d{4})?$` | ZIP 或 ZIP+4 编码 |'
- en: Credit card numbers
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 信用卡号
- en: 'Credit card numbers typically consist of digits, but it’s common for values
    to be written with spaces, dashes, or other characters between groups of digits.
    For example, the following numbers are equivalent:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 信用卡号通常由数字组成，但常见的写法是在数字组之间使用空格、短横线或其他字符。例如，以下号码是等效的：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To match such values, use this pattern:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配这样的值，请使用此模式：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '(Python permits the `\d` digit specifier within character classes.) However,
    that pattern doesn’t identify values of the wrong length, and it may be useful
    to remove extraneous characters before storing values in MySQL. To require credit
    card values to contain 16 digits, use a substitution that removes all nondigits,
    then check the length of the result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: （Python 允许在字符类中使用 `\d` 数字指定符号。）但是，该模式不能识别长度不正确的值，并且在存储值到 MySQL 前去除多余字符可能很有用。要求信用卡号必须包含
    16 位数字，可以使用替换方法去除所有非数字字符，然后检查结果的长度：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 14.9 Using Patterns to Match Dates or Times
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.9 使用模式匹配日期或时间
- en: Problem
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make sure a string looks like a date or time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望确保字符串看起来像是日期或时间。
- en: Solution
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a pattern that matches the type of temporal value you expect. Be sure to
    consider issues such as how strict to be about delimiters between subparts and
    the lengths of the subparts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匹配您期望的时间值类型的模式。务必考虑诸如子部分之间的分隔符严格程度以及子部分的长度等问题。
- en: Discussion
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Dates are a validation headache because they come in so many formats. Pattern
    tests are extremely useful for weeding out illegal values, but often insufficient
    for full verification: a date might have a number where you expect a month, but
    the date isn’t valid if the number is 13\. This section introduces some patterns
    that match a few common date formats. [Recipe 14.14](#nch-format-format-date-part)
    revisits this topic in more detail and discusses combining pattern tests with
    content verification.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 日期是验证的头疼问题，因为它们有许多不同的格式。模式测试非常有用以清除非法值，但通常不足以进行完整验证：例如，日期可能在您期望的月份处有一个数字，但如果数字为
    13，则日期无效。本节介绍了一些匹配几种常见日期格式的模式。[食谱 14.14](#nch-format-format-date-part) 更详细地重新讨论了这个主题，并讨论了如何将模式测试与内容验证结合起来。
- en: 'To require values to be dates in ISO (*`YYYY-MM-DD`*) format, use this pattern:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要求值为 ISO（*`YYYY-MM-DD`*）格式的日期，请使用此模式：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The pattern requires the `-` character as the delimiter between date parts.
    To permit either `-` or `/` as the delimiter, use a character class between the
    numeric parts:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式要求 `-` 字符作为日期部分之间的分隔符。要允许 `-` 或 `/` 作为分隔符，请在数字部分之间使用字符类：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This pattern will match dates in format *`YYYY-MM-DD`*, *`YYYY/MM/DD`*, *`YYYY/MM-DD`*,
    and *`YYYY-MM/DD`*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式将匹配格式为 *`YYYY-MM-DD`*、*`YYYY/MM/DD`*、*`YYYY/MM-DD`* 和 *`YYYY-MM/DD`* 的日期。
- en: 'To permit any nondigit delimiter (which corresponds to how MySQL operates when
    it interprets strings as dates), use this pattern:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许任何非数字分隔符（这与 MySQL 在将字符串解释为日期时的操作方式相对应），请使用此模式：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To permit leading zeros in values like `03` to be missing, just look for three
    nonempty digit sequences:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许类似 `03` 这样的值的前导零可能缺失，只需查找三个非空数字序列即可：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Of course, that pattern is so general that it also matches other values such
    as US Social Security numbers (which have the format 012-34-5678). To constrain
    the subpart lengths by requiring two to four digits in the year part and one or
    two digits in the month and day parts, use this pattern:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，该模式非常通用，也会匹配其他值，例如美国社会安全号码（其格式为 012-34-5678）。为了通过要求年部分中的二至四位数字和月日部分中的一到两位数字来约束子部分的长度，使用此模式：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For dates in other formats such as *`MM-DD-YY`* or *`DD-MM-YY`*, similar patterns
    apply, but the subparts are arranged in a different order. This pattern matches
    both of those formats:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他格式（如 *`MM-DD-YY`* 或 *`DD-MM-YY`*）的日期，类似的模式也适用，但子部分的排列顺序不同。该模式匹配这两种格式：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To check the values of individual date parts, use parentheses in the pattern
    and extract the substrings after a successful match. If you expect dates to be
    in ISO format, for example, do this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查单个日期部分的值，请在模式中使用括号，并在成功匹配后提取子字符串。例如，如果期望日期为 ISO 格式，请执行以下操作：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The library file *lib/cookbook_utils.py* in the `recipes` distribution contains
    several of these pattern tests, packaged as function calls. If the date doesn’t
    match the pattern, they return `None`. Otherwise, they return a reference to an
    array containing the broken-out values for the year, month, and day. This can
    be useful for performing further checking on the components of the date. For example,
    `is_iso_date()` looks for dates that match ISO format. It’s defined as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `recipes` 分发中的库文件 *lib/cookbook_utils.py* 包含几个这些模式测试，封装为函数调用。如果日期不匹配模式，它们将返回
    `None`。否则，它们将返回一个包含年、月和日分解值的数组引用。这对于对日期组件执行进一步检查非常有用。例如，`is_iso_date()` 寻找匹配 ISO
    格式的日期。定义如下：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function could be used as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下使用该函数：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You’ll often find additional processing necessary with dates because date-matching
    patterns help to weed out values that are syntactically malformed, but don’t assess
    whether the individual components contain legal values. To do that, some range
    checking is necessary. [Recipe 14.14](#nch-format-format-date-part) covers that
    topic.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，需要对日期进行额外处理，因为日期匹配模式有助于淘汰语法上有问题的值，但不能评估各个组件是否包含合法值。为了做到这一点，需要进行一些范围检查。[配方
    14.14](#nch-format-format-date-part) 涵盖了这个主题。
- en: 'If you’re willing to skip subpart testing and just want to rewrite the pieces,
    use a substitution. For example, to rewrite values assumed to be in *`MM-DD-YY`*
    format into *`YY-MM-DD`* format, do this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意跳过子部分测试，只想重写部分，请使用替换。例如，将假定为 *`MM-DD-YY`* 格式的值重写为 *`YY-MM-DD`* 格式，可以这样做：
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Time values are somewhat more orderly than dates, usually being written with
    hours first and seconds last, with two digits per part:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值通常比日期更有条理，通常先写小时，最后写秒，每部分两位数：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To be more lenient, permit the hours part to have a single digit, or the seconds
    part to be missing:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更宽松，允许小时部分为单个数字，或者允许秒部分缺失：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Mark parts of the time with parentheses if you want to range-check the individual
    parts, or perhaps to reformat the value to include a seconds part of `00` if it
    happens to be missing. However, this requires some care with the parentheses and
    the `?` characters in the pattern if the seconds part is optional. You want to
    permit the entire `:\d{2}` at the end of the pattern to be optional, but not to
    save the `:` character in `\3` if the third time section is present. To accomplish
    that, use `(?:`*`pat`*`)`, a grouping notation that doesn’t save the matched substring.
    Within that notation, use parentheses around the digits to save them. Then `\3`
    is `None` if the seconds part is not present, and contains the seconds digits
    otherwise:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想要对单独的时间部分进行范围检查或重新格式化值以包含缺失的秒部分 `00`，可以在时间模式中使用括号标记这些部分。但是，如果第三个时间部分是可选的，则在模式中括号和
    `?` 字符需要特别小心。您希望整个 `:\d{2}` 在模式末尾是可选的，但不保存 `\3` 中的 `:` 字符，如果第三个时间部分存在。为了实现这一点，请使用
    `(?:`*`pat`*`)`，这是一种不保存匹配子串的分组符号。在这种符号内，使用括号将数字保存起来。然后，如果秒部分不存在，`\3` 就是 `None`，否则它包含秒数：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To rewrite times from 12-hour format with AM and PM suffixes to 24-hour format,
    do this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要将带有 AM 和 PM 后缀的 12 小时制时间重写为 24 小时制，可以这样做：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The time parts are placed into groups `1`, `2`, and `3`, with `3` set to `None`
    if the seconds part is missing. The suffix goes into group `4` if it’s present.
    If the suffix is `AM` or missing (`None`), the value is interpreted as an AM time.
    If the suffix is `PM`, the value is interpreted as a PM time.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 时间部分被放置在 `1`、`2` 和 `3` 组中，如果秒部分缺失，则 `3` 组设为 `None`。后缀（如果存在）放入 `4` 组中。如果后缀是 `AM`
    或缺失 (`None`)，则将其解释为上午时间。如果后缀是 `PM`，则将其解释为下午时间。
- en: See Also
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'This recipe shows just the beginning of what you can do when processing dates
    for data-transfer purposes. Date and time testing and conversion can be highly
    idiosyncratic, and the sheer number of issues to consider is mind-boggling:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了在数据传输目的下处理日期时的初步内容。日期和时间的测试和转换可能会高度个性化，要考虑的问题数量之多令人难以置信：
- en: What is the basic date format? Dates come in several common styles, such as
    ISO (*`YYYY-MM-DD`*), US (*`MM-DD-YY`*), and British (*`DD-MM-YY`*) formats. And
    these are just some of the more standard formats. Many more are possible. For
    example, a datafile may contain dates written as `June` `17,` `1959` or as `17`
    `Jun` `'59`.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本日期格式是什么？日期有几种常见的风格，例如 ISO 格式（*`YYYY-MM-DD`*）、美国格式（*`MM-DD-YY`*）和英国格式（*`DD-MM-YY`*）。这些只是更标准的格式之一。还有很多可能的格式。例如，数据文件中的日期可能写成
    `June` `17,` `1959` 或 `17` `Jun` `'59`。
- en: Are trailing times permitted on dates, or perhaps required? When times are expected,
    is the full time required or just the hour and minute?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期末尾是否允许有时间，或者可能是必须的？期望时间时，是否需要全时间还是只需时和分？
- en: Do you permit special values like `now` or `today`?
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否允许特殊值如 `now` 或 `today`？
- en: Are date parts required to be delimited by a particular character, such as `-`
    or `/`, or are other delimiters permitted?
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期部分是否需要由特定字符（如 `-` 或 `/`）分隔，或者允许使用其他分隔符？
- en: Are date parts required to have a specific number of digits? Or are leading
    zeros on month and year values permitted to be missing?
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期部分是否需要特定数量的数字？月份和年份的前导零是否允许缺失？
- en: Are months written numerically, or represented as month names like `January`
    or `Jan`?
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份是用数字写的，还是用像`January`或`Jan`这样的月份名表示？
- en: How two-digit year values should be converted to have four digits? What is the
    transition point within the range `00` to `99` at which values change from one
    century to another?
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两位数年份应如何转换为四位数？在 `00` 到 `99` 范围内，值在哪个转换点上从一个世纪变为另一个世纪？
- en: Should date parts be checked to ensure their validity? Patterns can recognize
    strings that look like dates or times, but while they’re extremely useful for
    detecting malformed values, they may not be sufficient. A value like `1947-15-99`
    may match a pattern but isn’t a legal date. Pattern testing is thus most useful
    in conjunction with range checks on the individual parts of the date.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该检查日期部分以确保它们的有效性吗？模式可以识别看起来像日期或时间的字符串，但是虽然它们非常有用于检测格式错误的值，但可能还不足够。例如，`1947-15-99`
    这样的值可能会匹配一个模式，但它并不是一个合法的日期。因此，模式测试在与对日期的各个部分的范围检查结合使用时最为有用。
- en: The prevalence of these issues in data-transfer problems means that you’ll probably
    end up writing some of your own validators on occasion to handle very specific
    date formats. Other sections of this chapter can provide additional assistance.
    For example, [Recipe 14.13](#nch-format-format-year) covers conversion of two-digit
    year values to four-digit form, and [Recipe 14.14](#nch-format-format-date-part)
    discusses how to perform validity checking on components of date or time values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据传输问题中，这些问题的普遍存在意味着你可能会偶尔编写一些自定义验证器来处理非常特定的日期格式。本章的其他部分可以提供额外的帮助。例如，[配方 14.13](#nch-format-format-year)
    讨论了如何将两位数年份转换为四位数形式，而 [配方 14.14](#nch-format-format-date-part) 则讨论了如何对日期或时间值的组件执行有效性检查。
- en: 'You might be able to save yourself some work by using existing date-checking
    modules for your API language. Some possibilities: the Perl `Date` module; the
    Ruby `date` module; the Python `datetime` module; the PHP `DateTime` class; the
    Java `GregorianCalendar` and `SimpleDateTime` classes.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能够通过使用现有的日期检查模块来减少一些工作量，适用于你的 API 语言。一些可能的选择包括：Perl 的 `Date` 模块；Ruby 的 `date`
    模块；Python 的 `datetime` 模块；PHP 的 `DateTime` 类；Java 的 `GregorianCalendar` 和 `SimpleDateTime`
    类。
- en: 14.10 Using Patterns to Match Email Addresses or URLs
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.10 使用模式匹配电子邮件地址或 URL
- en: Problem
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to determine if a value looks like an email address or a URL.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你想确定一个值是否看起来像是一个电子邮件地址或一个 URL。
- en: Solution
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: In your application use a pattern, tuned to the desired level of strictness
    on which addresses you accept and which do not.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中使用一个模式，调整到你接受哪些地址和不接受哪些地址的期望严格程度。
- en: Discussion
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The immediately preceding recipes use patterns to identify classes of values
    such as numbers and dates, which are fairly typical applications for regular expressions.
    But pattern matching has much more widespread applicability for data validation.
    To give some idea of a few other types of values for which pattern matching can
    be used, this recipe shows a few tests for email addresses and URLs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 立即前面的配方使用模式来识别诸如数字和日期之类的值的类别，这些都是正则表达式的典型应用场景。但是，模式匹配在数据验证中具有更广泛的适用性。为了给出一些使用模式匹配的其他类型值的想法，本配方展示了一些用于电子邮件地址和
    URL 的测试。
- en: 'To check values that are expected to be email addresses, the pattern should
    require at least an `@` character with nonempty strings on either side:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查预期为电子邮件地址的值，模式应至少要求一个带有非空字符串的`@`字符：
- en: '[PRE53]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Full email address specification defined by [RFC5322](https://www.ietf.org/rfc/rfc5322.txt)
    and contains of many parts. Regular expression that rejects all invalid addresses
    and accepts all valid is pretty complicated to write. Check [*http://emailregex.com/*](http://emailregex.com/)
    for examples for popular programming languages to have an idea.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的电子邮件地址规范由 [RFC5322](https://www.ietf.org/rfc/rfc5322.txt) 定义，并包含许多部分。拒绝所有无效地址并接受所有有效地址的正则表达式相当复杂。参考
    [*http://emailregex.com/*](http://emailregex.com/) 获取流行编程语言的示例，以便了解更多。
- en: In this recipe we will show you a pretty minimal test that still is sufficient
    to help correcting most of innocent user errors, such as typos when they enter
    addresses into a web form.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将展示一个非常简单的测试，但它仍然足以帮助纠正大多数无辜用户在输入地址时的拼写错误。
- en: 'It’s difficult to come up with a fully general pattern that covers all the
    legal values and rejects all the illegal ones, but it’s easy to write a pattern
    that’s at least a little more restrictive. For example, in addition to being nonempty,
    the username and the domain name should consist entirely of characters other than
    `@` characters or spaces:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 很难找到一个通用的模式，涵盖所有合法值并排除所有非法值，但写一个至少更加严格的模式却很容易。例如，除了非空外，用户名和域名应完全由`@`字符或空格以外的字符组成：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You may also want to require that the domain name part contain at least two
    parts separated by a dot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还希望要求域名部分包含至少由点分隔的两部分：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To look for URL values that begin with a protocol specifier of `http://`, `https://`,
    `ftp://`, or `mailto:`, use an alternation that matches any of them at the beginning
    of the string.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找以`http://`、`https://`、`ftp://`或`mailto:`协议开头的URL值，请使用匹配任何一个在字符串开头的选择项。
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The alternatives in the pattern are grouped within parentheses because otherwise
    the `^` anchors only the first of them to the beginning of the string. The `re.I`
    flag follows the pattern because protocol specifiers in URLs are not case sensitive.
    The pattern is otherwise fairly unrestrictive because it permits anything to follow
    the protocol specifier. Add further restrictions as necessary.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内的模式选择项被分组，因为否则`^`锚定只适用于第一个。`re.I`标志跟随模式，因为URL中的协议标识符不区分大小写。除了允许协议标识符后跟任何内容外，该模式相当不限制。根据需要添加进一步限制。
- en: 14.11 Using Table Metadata to Validate Data
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.11 使用表元数据验证数据
- en: Problem
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to check input values against the legal members of an `ENUM` or `SET`
    column.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望根据`ENUM`或`SET`列的合法成员检查输入值。
- en: Solution
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Get the column definition, extract the list of members from it, and check data
    values against the list.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列定义，从中提取成员列表，并检查数据值是否与列表匹配。
- en: Discussion
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Some forms of validation involve checking input values against information stored
    in a database. This includes values to be stored in an `ENUM` or `SET` column,
    which can be checked against the valid members stored in the column definition.
    Database-backed validation also applies to values that must match those listed
    in a lookup table to be considered legal. For example, input records that contain
    customer IDs can be required to match a row in a `customers` table, and state
    abbreviations in addresses can be verified against a table that lists each state.
    This recipe describes `ENUM`- and `SET`-based validation, and [Recipe 14.12](#nch-format-format-lookup)
    discusses how to use lookup tables.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 某些验证形式涉及检查输入值是否与存储在数据库中的信息相匹配。这包括要存储在`ENUM`或`SET`列中的值，可以与列定义中存储的有效成员进行比较。基于数据库的验证还适用于必须与查找表中列出的内容匹配的值以被视为合法的情况。例如，包含客户ID的输入记录可以要求匹配`customers`表中的行，地址中的州缩写可以验证是否与列出每个州的表匹配。本文档介绍了基于`ENUM`和`SET`的验证，而[Recipe
    14.12](#nch-format-format-lookup)讨论了如何使用查找表。
- en: 'One way to check input values that correspond to the legal values of `ENUM`
    or `SET` columns is to get the list of legal column values into an array using
    the information in `INFORMATION_SCHEMA`, then perform an array membership test.
    For example, the favorite-color column `color` from the `profile` table is an
    `ENUM` defined as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与`ENUM`或`SET`列的合法值相对应的输入值的一种方法是使用`INFORMATION_SCHEMA`中的信息将合法列值列表转换为数组，然后执行数组成员测试。例如，`profile`表中的`color`列是作为以下定义的`ENUM`的最喜欢的颜色列：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you extract the list of enumeration members from the `COLUMN_TYPE` value
    and store them in a list `members`, you can perform the membership test like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从`COLUMN_TYPE`值中提取枚举成员列表并将其存储在列表`members`中，则可以像这样执行成员测试：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can convert the list `members` and `val` to upper case to perform a case-insensitive
    comparison because the default collation is `utf8mb4_0900_ai_ci`, which is case-insensitive.
    (If you have a column with a different collation, adjust accordingly. We discussed
    how to change column collation in [Recipe 7.5](ch07.xhtml#nch-strings-strings-charset-checking-changing))
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将列表`members`和`val`转换为大写以执行大小写不敏感比较，因为默认排序规则是`utf8mb4_0900_ai_ci`，即不区分大小写。(如果列具有不同的排序规则，请相应调整。我们在[Recipe
    7.5](ch07.xhtml#nch-strings-strings-charset-checking-changing)中讨论了如何更改列排序规则)
- en: 'In [Recipe 12.6](ch12.xhtml#nch-meta-meta-enum), we wrote a function `get_enumorset_info()`
    that returns `ENUM` or `SET` column metadata. This includes the list of members,
    so it’s easy to use that function to write another utility routine, `check_enum_value()`,
    that gets the legal enumeration values and performs the membership test. The routine
    takes four arguments: a database handle, the table name and column name for the
    `ENUM` column, and the value to check. It returns true or false to indicate whether
    the value is legal:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在[食谱12.6](ch12.xhtml#nch-meta-meta-enum)中，我们编写了一个函数`get_enumorset_info()`，它返回`ENUM`或`SET`列的元数据。这包括成员列表，因此很容易使用该函数编写另一个实用程序例程`check_enum_value()`，获取法律枚举值并执行成员测试。该例程接受四个参数：数据库句柄、`ENUM`列的表名和列名，以及要检查的值。它返回true或false，指示该值是否合法：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For single-value testing, such as to validate a value submitted in a web form,
    list lookup for each value works well. However, to test a lot of values (like
    an entire column in a datafile), it’s better to read the enumeration values into
    memory once, then use them repeatedly to check each data value. Furthermore, it’s
    a lot more efficient to perform dictionary lookups than list lookups (in Python
    at least). To do so, retrieve the legal enumeration values and store them as keys
    of a dictionary. Then test each input value by checking whether it exists as a
    dictionary key. It’s a little more effort to construct the dictionary, which is
    why `check_enum_value()` doesn’t do so. But for bulk validation, the improved
    lookup speed more than makes up for the dictionary construction overhead. (To
    check for yourself the relative efficiency of list membership tests versus dictionary
    lookups, try the *lookup_time.py* script in the *transfer* directory of the `recipes`
    distribution.)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单值测试，例如验证在网页表单中提交的值，每个值的列表查找效果很好。然而，对于测试大量值（如数据文件中的整列），最好是将枚举值一次性读入内存，然后重复使用它们来检查每个数据值。此外，在Python中，执行字典查找比列表查找效率要高得多。为此，获取法律枚举值并将它们存储为字典的键。然后通过检查每个输入值是否存在于字典键中来测试每个输入值。构建字典需要一些额外的工作量，这也是为什么`check_enum_value()`没有这样做的原因。但对于批量验证来说，改进的查找速度远远弥补了字典构建的开销。（要自行检查列表成员测试与字典查找的相对效率，请尝试`recipes`发行版的*transfer*目录中的*lookup_time.py*脚本。）
- en: 'Begin by getting the metadata for the column and convert the list of legal
    enumeration members to a dictionary:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先获取列的元数据，然后将法律枚举成员列表转换为字典：
- en: '[PRE61]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `for` loop makes each enumeration member exist as the key of a dictionary
    element. The dictionary key is what’s important here; the value associated with
    it is irrelevant. (The example shown sets the value to `1`, but you could use
    `None`, `0`, or any other value.) Note that the code converts the dictionary keys
    to lowercase before storing them. This is done because dictionary key lookups
    in Python are case sensitive. That’s fine if the values that you check also are
    case sensitive, but `ENUM` columns by default are not. By converting the enumeration
    values to a given lettercase before storing them in the dictionary, and then converting
    the values you want to check similarly, you perform, in effect, a case-insensitive
    key existence test:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环使每个枚举成员存在于字典元素的键中。这里重要的是字典键；与之关联的值是无关的。（所示示例将值设置为`1`，但你可以使用`None`、`0`或任何其他值。）请注意，在存储之前，代码将字典键转换为小写。这是因为Python中的字典键查找是区分大小写的。如果你检查的值也是区分大小写的，那么这样做是可以接受的，但默认情况下，`ENUM`列不区分大小写。通过在存储枚举值之前将其转换为给定的大小写，然后类似地转换你想要检查的值，实际上进行了一个不区分大小写的键存在测试：'
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The example converts enumeration values and input values to lowercase. You could
    just as well use uppercase, as long as you do so for all values consistently.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将枚举值和输入值转换为小写。只要所有值保持一致，你也可以使用大写。
- en: Note that the existence test may fail if the input value is the empty string.
    You must decide how to handle that case on a column-by-column basis. For example,
    if the column permits `NULL` values, you might interpret the empty string as equivalent
    to `NULL` and thus as being a legal value.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果输入值是空字符串，则存在测试可能失败。您必须决定如何根据列处理这种情况。例如，如果列允许`NULL`值，您可能会将空字符串解释为等同于`NULL`，因此视为合法值。
- en: The validation procedure for `SET` values is similar to that for `ENUM` values,
    except that an input value might consist of any number of `SET` members, separated
    by commas. For the value to be legal, each element in it must be legal. In addition,
    because <q>any number of members</q> includes <q>none,</q> the empty string is
    a legal value for any `SET` column.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SET`值的验证过程与`ENUM`值类似，只是输入值可能包含任意数量的`SET`成员，用逗号分隔。 为了使值合法，其中的每个元素都必须合法。 另外，因为<q>任意数量的成员</q>包括<q>无</q>，所以空字符串是任何`SET`列的合法值。
- en: 'For one-shot testing of individual input values, use a utility routine `check_set_value()`
    that is similar to `check_enum_value()`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个输入值的一次性测试，请使用类似于`check_enum_value()`的实用程序例程`check_set_value()`：
- en: '[PRE63]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: For bulk testing, construct a dictionary from the legal `SET` members. The procedure
    is the same as shown previously for producing a dictionary from `ENUM` elements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于批量测试，请构建从合法`SET`成员到字典的转换。 该过程与以前显示的从`ENUM`元素生成字典的过程相同。
- en: 'To validate a given input value against the `SET` member dictionary, convert
    it to the same lettercase as the hash keys, split it at commas to get a list of
    the individual elements of the value, and then check each one. If any of the elements
    are invalid, the entire value is invalid:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据`SET`成员字典验证给定的输入值，请将其转换为与哈希键相同的大小写，将其在逗号处分割为值的各个元素的列表，然后检查每个元素。 如果任何元素无效，则整个值无效：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After the loop terminates, `valid` is true if the value is legal for the `SET`
    column, and false otherwise. Empty strings are always legal `SET` values, but
    this code performs no special-case test for an empty string. No such test is necessary
    because in that case the `split()` operation returns an empty list, the loop never
    executes, and `valid` remains true.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 循环终止后，如果值对于`SET`列合法，则`valid`为true，否则为false。 空字符串始终是合法的`SET`值，但此代码不对空字符串执行特殊情况测试。
    在这种情况下，不需要此类测试，因为`split()`操作返回空列表，循环永不执行，并且`valid`保持为true。
- en: 14.12 Using a Lookup Table to Validate Data
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.12 使用查找表验证数据
- en: Problem
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Problem
- en: You want to check values to make sure they’re listed in a lookup table.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望检查值以确保它们在查找表中列出。
- en: Solution
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Issue statements to check whether the values are in the table. The best way
    to do this depends on the number of input values and the table size. In this recipe
    we will start our discussion from issuing individual statements, then create a
    hash from the entire lookup table and, finally, improve our algorithm by remembering
    already seen values to avoid querying database several times for large data sets.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 检查表中是否存在值的问题陈述。 最佳方法取决于输入值的数量和表的大小。 在这个示例中，我们将从发出单个语句开始讨论，然后从整个查找表创建哈希，最后通过记住已经看到的值来改进我们的算法，以避免在大数据集中多次查询数据库。
- en: Discussion
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To validate input values against the contents of a lookup table, the techniques
    are somewhat similar to those shown in [Recipe 14.11](#nch-format-format-meta)
    for checking `ENUM` and `SET` columns. However, whereas `ENUM` and `SET` columns
    usually have a small number of member values, a lookup table can have an essentially
    unlimited number of values. You might not want to read them all into memory.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要针对查找表的内容验证输入值，技术与[Recipe 14.11](#nch-format-format-meta)中用于检查`ENUM`和`SET`列的技术有些相似。
    然而，虽然`ENUM`和`SET`列通常只有少量成员值，但查找表可以有数量基本上无限的值。 您可能不希望将它们全部读入内存中。
- en: Validation of input values against the contents of a lookup table can be done
    several ways, as illustrated in the following discussion. The tests shown in the
    examples perform comparisons against values exactly as they are stored in the
    lookup table. To perform case-insensitive comparisons, convert all values to a
    consistent lettercase. (See the discussion of case conversion in [Recipe 14.11](#nch-format-format-meta).)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过几种方法对输入值与查找表的内容进行验证，如下面的讨论所示。 在示例中显示的测试执行与存储在查找表中的值完全相同。 要执行不区分大小写的比较，请将所有值转换为一致的大小写。
    （请参阅[Recipe 14.11](#nch-format-format-meta)中的大小写转换讨论。）
- en: Issue individual statements
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发出单个语句
- en: 'For one-shot operations, test a value by checking whether it’s listed in the
    lookup table. The following query returns true (nonzero) for a value that is present
    and false otherwise:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性操作，通过检查它是否在查找表中列出来测试一个值。 以下查询对于存在的值返回true（非零），否则返回false：
- en: '[PRE65]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This kind of test may be suitable for purposes such as checking a value submitted
    in a web form, but is inefficient for validating large datasets. It has no memory
    for the results of previous tests for values that have been seen before; consequently,
    you execute a query for every input value.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试可能适用于诸如检查提交的Web表单中的值之类的目的，但对于验证大型数据集来说效率低下。它没有为先前看到的值的结果保存内存；因此，您需要为每个输入值执行查询。
- en: Construct a hash from the entire lookup table
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从整个查找表构造哈希
- en: To validate a large number of values, it’s better to pull the lookup values
    into memory, save them in a data structure, and check each input value against
    the contents of that structure. Using an in-memory lookup avoids the overhead
    of executing a query for each value.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证大量值，最好将查找值放入内存中，将它们保存在数据结构中，并检查每个输入值是否与该结构的内容匹配。使用内存中的查找可以避免执行每个值的查询的开销。
- en: 'First, run a query to retrieve all the lookup table values and construct a
    dictionary from them:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行一个查询以检索所有查找表值，并从中构建一个字典：
- en: '[PRE66]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, perform a dictionary key existence test to check a given value:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行字典键存在性测试以检查给定值：
- en: '[PRE67]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This technique reduces database traffic to a single query. However, for a large
    lookup table, that could still be a lot of traffic, and you might not want to
    hold the entire table in memory.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型查找表，这种技术将数据库流量减少到单个查询。然而，这可能仍然是大量流量，并且您可能不希望将整个表保存在内存中。
- en: Remember already seen values to avoid database lookups
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记住已经看过的值，以避免数据库查找
- en: 'Another lookup technique mixes individual statements with a dictionary that
    stores lookup value existence information. This approach can be useful if you
    have a very large lookup table. Begin with an empty dictionary:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查找技术将单个语句与存储查找值存在信息的字典混合。如果你有一个非常庞大的查找表，这种方法可以很有用。从一个空字典开始：
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, for each value to be tested, check whether it’s present in the dictionary.
    If not, execute a query to check whether the value is present in the lookup table,
    and record the result of the query in the dictionary. The validity of the input
    value is determined by the value associated with the key, not by the existence
    of the key:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于要测试的每个值，请检查字典中是否存在。如果不存在，请执行查询以检查该值是否存在于查找表中，并记录查询结果在字典中。输入值的有效性由与键相关联的值决定，而不是键的存在：
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: For this method, the dictionary acts as a cache, so that you execute a lookup
    query for any given value only once, no matter how many times it occurs in the
    input. For datasets that have repeated values, this approach avoids issuing a
    separate query for every single test, while requiring an entry in the dictionary
    only for each unique value. It thus stands between the other two approaches in
    terms of the trade-off between database traffic and program memory requirements
    for the dictionary.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种方法，字典充当缓存，因此您只需为任何给定值执行一次查找查询，无论它在输入中出现多少次。对于具有重复值的数据集，这种方法避免了为每个单独的测试发出单独的查询，同时仅要求字典中的每个唯一值都有一个条目。因此，在数据库流量和程序内存需求之间的权衡方面，它处于其他两种方法之间。
- en: Note that the dictionary is used in a different manner for this method than
    for the previous method. Previously, the existence of the input value as a key
    in the dictionary determined the validity of the value, and the value associated
    with the dictionary key was irrelevant. For the dictionary-as-cache method, the
    meaning of key existence in the dictionary changes from <q>it’s valid</q> to <q>it’s
    been tested before.</q> For each key, the value associated with it indicates whether
    the input value is present in the lookup table. (If you store as keys only those
    values that are found to be in the lookup table, you issue a query for each instance
    of an invalid value in the input dataset, which is inefficient.)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于此方法，字典的使用方式与之前的方法不同。以前，字典中输入值作为键的存在确定了值的有效性，字典键相关联的值是无关紧要的。对于字典作为缓存的方法，字典中键的存在意义从“它是有效的”变为“它已经被测试过了”。对于每个键，与之相关联的值指示输入值是否存在于查找表中。（如果你只存储那些在查找表中发现为无效值的键，那么你在输入数据集中的每个无效值实例上都会发出一个查询，这是低效的。）
- en: 14.13 Converting Two-Digit Year Values to Four-Digit Form
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.13 将两位数年份值转换为四位数形式
- en: Problem
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert years in date values from two digits to four digits.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将日期值中的年份从两位数转换为四位数。
- en: Solution
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Let MySQL do this for you, or perform the operation yourself if MySQL’s conversion
    rules aren’t appropriate.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让MySQL为您完成这些操作，或者如果MySQL的转换规则不合适，可以自行执行操作。
- en: Discussion
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Two-digit year values are a problem because the century is not explicit in the
    data values. If you know the range of years spanned by your input, you can add
    the century without ambiguity. Otherwise, you can only guess. For example, the
    date 10/2/69 would be interpreted by most people in the US as as October 2, 1969\.
    But if it represents Mahatma Gandhi’s birth date, the year is actually 1869.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 两位数年份值是一个问题，因为数据值中没有明确的世纪。如果你知道输入的年份范围，可以在不含歧义地添加世纪。否则，只能猜测。例如，日期10/2/69在大多数美国人眼中是1969年10月2日。但如果它代表圣雄甘地的生日，则年份实际上是1869年。
- en: One way to convert years to four digits is to let MySQL do it. If you try to
    insert ino `YEAR` column a date containing a two-digit year, MySQL automatically
    converts it to four-digit form. MySQL uses a transition point of 1970; it interprets
    values from 00 to 69 as the years 2000 to 2069, and values from 70 to 99 as the
    years 1970 to 1999\. These rules are appropriate for year values in the range
    from 1970 to 2069\. If your values lie outside this range, add the proper century
    yourself before storing them into MySQL.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将年份转换为四位数的一种方法是让MySQL处理。如果你试图插入一个包含两位数年份的日期到`YEAR`列中，MySQL会自动将其转换为四位数形式。MySQL使用1970年作为过渡点；它将值从00到69解释为2000到2069年的年份，将值从70到99解释为1970到1999年的年份。这些规则适用于1970到2069年范围内的年份值。如果你的值超出此范围，存入MySQL之前请自行添加正确的世纪。
- en: '[PRE70]69[PRE71],`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE70]69[PRE71],`'
- en: -> `CAST``(``70` `AS` `YEAR``)` `AS` `` ` [PRE72] ` [PRE73]22[PRE74];`
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> `CAST``(``70` `AS` `YEAR``)` `AS` `` ` [PRE72] ` [PRE73]22[PRE74];`
- en: +------+------+------+ | 69   | 70   | 22   |
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: +------+------+------+ | 69   | 70   | 22   |
- en: +------+------+------+ | 2069 | 1970 | 2022 |
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: +------+------+------+ | 2069 | 1970 | 2022 |
- en: +------+------+------+
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: +------+------+------+
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'def yy_to_yyyy(year, transition_point = 70):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'def yy_to_yyyy(year, transition_point = 70):'
- en: 'if year < 100:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 'if year < 100:'
- en: year += 1900 if year >= transition_point else 2000
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: year += 1900 if year >= transition_point else 2000
- en: return year
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: return year
- en: '[PRE76]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'val = yy_to_yyyy (60)         # returns 2060'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'val = yy_to_yyyy (60)         # 返回2060'
- en: 'val = yy_to_yyyy (1960)       # returns 1960 (no conversion done)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'val = yy_to_yyyy (1960)       # 返回1960（未进行转换）'
- en: '[PRE77]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 00 .. 49 -> 2000 .. 2049
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 00 .. 49 -> 2000 .. 2049
- en: 50 .. 99 -> 1950 .. 1999
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 50 .. 99 -> 1950 .. 1999
- en: '[PRE78]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'val = yy_to_yyyy (60, 50)     # returns 1960'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'val = yy_to_yyyy (60, 50)     # 返回1960'
- en: 'val = yy_to_yyyy (1960, 50)   # returns 1960 (no conversion done)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'val = yy_to_yyyy (1960, 50)   # 返回1960（未进行转换）'
- en: '[PRE79]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: valid = is_valid_date(ref[0], ref[1], ref[2])
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: valid = is_valid_date(ref[0], ref[1], ref[2])
- en: '[PRE80]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'def is_valid_date(year, month, day):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'def is_valid_date(year, month, day):'
- en: print(year, month, day)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: print(year, month, day)
- en: 'if year < 0: # or (month < 0) or (day < 1):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 'if year < 0: # 或(month < 0)或(day < 1):'
- en: return 0
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回0
- en: 'if year > 9999 or month > 12 or day > days_in_month(year, month):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'if year > 9999 or month > 12 or day > days_in_month(year, month):'
- en: return 0
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return 0
- en: return 1
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: return 1
- en: '[PRE81]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'def is_leap_year(year):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 'def is_leap_year(year):'
- en: return ((year % 4 == 0) and ((year % 100 != 0) or (year % 400 == 0) ) )
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: return ((year % 4 == 0) and ((year % 100 != 0) or (year % 400 == 0) ) )
- en: 'def days_in_month(year, month):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 'def days_in_month(year, month):'
- en: day_tbl = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: day_tbl = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
- en: days = day_tbl[month - 1]
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: days = day_tbl[month - 1]
- en: 'if month == 2 and is_leap_year(year):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 'if month == 2 and is_leap_year(year):'
- en: days += 1
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: days += 1
- en: return days
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 返回天数
- en: '[PRE82]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'def is_24hr_time(val):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 'def is_24hr_time(val):'
- en: m = re.match('^(\d{1,2})\D(\d{2})\D(\d{2})$', val)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: m = re.match('^(\d{1,2})\D(\d{2})\D(\d{2})$', val)
- en: 'if m is None:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'if m is None:'
- en: return None
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return None
- en: return[int(m.group(1)), int(m.group(2)), int(m.group(3))]
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: return[int(m.group(1)), int(m.group(2)), int(m.group(3))]
- en: '[PRE83]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'def is_ampm_time(val):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 'def is_ampm_time(val):'
- en: m = re.match('^(\d{1,2})\D(\d{2})\D(\d{2})(?:\s*(AM|PM))?$', val, flags = re.I)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: m = re.match('^(\d{1,2})\D(\d{2})\D(\d{2})(?:\s*(AM|PM))?$', val, flags = re.I)
- en: 'if m is None:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 'if m is None:'
- en: return None
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return None
- en: (hour, min, sec) = (int(m.group(1)), (m.group(2)), (m.group(3)))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: (hour, min, sec) = (int(m.group(1)), (m.group(2)), (m.group(3)))
- en: '# supply missing seconds'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '# supply missing seconds'
- en: sec = '00' if sec is None else sec
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: sec = '00' if sec is None else sec
- en: 'if hour == 12 and (m.group(4) is None or m.group(4).upper() == "AM"):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'if hour == 12 and (m.group(4) is None or m.group(4).upper() == "AM"):'
- en: 'hour = ''00'' # 12:xx:xx AM times are 00:xx:xx'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'hour = ''00'' # 12:xx:xx AM times are 00:xx:xx'
- en: 'elif int(hour) < 12 and (m.group(4) is not None) and m.group(4).upper() ==
    "PM":'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif int(hour) < 12 and (m.group(4) is not None) and m.group(4).upper() ==
    "PM":'
- en: 'hour = hour + 12 # PM times other than 12:xx:xx'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'hour = hour + 12 # PM时间除了12:xx:xx'
- en: 'return [hour, min, sec] # return hour, minute, second'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 'return [hour, min, sec] # 返回小时、分钟、秒'
- en: '[PRE84]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '#!/usr/bin/python3'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python3'
- en: 'isoize_date.py: Read input data, look for values that match'
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: isoize_date.py：读取输入数据，查找与之匹配的值
- en: a date pattern, convert them to ISO format. Also converts
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: a date pattern, convert them to ISO format. Also converts
- en: 2-digit years to 4-digit years, using a transition point of 70.
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2-digit years to 4-digit years, using a transition point of 70.
- en: By default, this looks for dates in MM-DD-[CC]YY format.
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By default, this looks for dates in MM-DD-[CC]YY format.
- en: Does not check whether dates actually are valid (for example,
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Does not check whether dates actually are valid (for example,
- en: won't complain about 13-49-1928).
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: won't complain about 13-49-1928).
- en: Assumes tab-delimited, linefeed-terminated input lines.
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Assumes tab-delimited, linefeed-terminated input lines.
- en: import sys
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import re
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: import re
- en: import fileinput
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: import fileinput
- en: transition point at which 2-digit XX year values are assumed to be
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: transition point at which 2-digit XX year values are assumed to be
- en: 19XX (below that, they are treated as 20XX)
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19XX (below that, they are treated as 20XX)
- en: transition = 70
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: transition = 70
- en: 'for line in fileinput.input(sys.argv[1:]):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in fileinput.input(sys.argv[1:]):'
- en: 'val = line.split("\t", 10000);  # split, preserving all fields'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'val = line.split("\t", 10000);  # split, preserving all fields'
- en: 'for i in range(0, len(val)):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, len(val)):'
- en: look for strings in MM-DD-[CC]YY format
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: look for strings in MM-DD-[CC]YY format
- en: m = re.match('^(\d{1,2})\D(\d{1,2})\D(\d{2,4})$', val[i])
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: m = re.match('^(\d{1,2})\D(\d{1,2})\D(\d{2,4})$', val[i])
- en: 'if not m:'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not m:'
- en: continue
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: continue
- en: (month, day, year) = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (month, day, year) = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
- en: to interpret dates as DD-MM-[CC]YY instead, replace preceding
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: to interpret dates as DD-MM-[CC]YY instead, replace preceding
- en: 'line with the following one:'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'line with the following one:'
- en: (day, month, year) = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: (day, month, year) = (int(m.group(1)), int(m.group(2)), int(m.group(3)))
- en: convert 2-digit years to 4 digits, then update value in array
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: convert 2-digit years to 4 digits, then update value in array
- en: 'if year < 100:'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if year < 100:'
- en: year += 1900 if year >= transition else 2000
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: year += 1900 if year >= transition else 2000
- en: val[i] = "%04d-%02d-%02d" % (year, month, day)
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: val[i] = "%04d-%02d-%02d" % (year, month, day)
- en: print("\t".join (val))
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: print("\t".join (val))
- en: '[PRE85]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Sybil   04-13-70
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Sybil   04-13-70
- en: Nancy   09-30-69
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Nancy   09-30-69
- en: Ralph   11-02-73
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Ralph   11-02-73
- en: Lothair 07-04-63
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Lothair 07-04-63
- en: Henry   02-14-65
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Henry   02-14-65
- en: Aaron   09-17-68
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Aaron   09-17-68
- en: Joanna  08-20-52
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Joanna  08-20-52
- en: Stephen 05-01-60
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Stephen 05-01-60
- en: '[PRE86]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Sybil   1970-04-13
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Sybil   1970-04-13
- en: Nancy   2069-09-30
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Nancy   2069-09-30
- en: Ralph   1973-11-02
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Ralph   1973-11-02
- en: Lothair 2063-07-04
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Lothair 2063-07-04
- en: Henry   2065-02-14
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Henry   2065-02-14
- en: Aaron   2068-09-17
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Aaron   2068-09-17
- en: Joanna  2052-08-20
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Joanna  2052-08-20
- en: Stephen 2060-05-01
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Stephen 2060-05-01
- en: '[PRE87]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: name1   01/01/99    38
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: name1   01/01/99    38
- en: name2   12/31/00    40
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: name2   12/31/00    40
- en: name3   02/28/13    42
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: name3   02/28/13    42
- en: name4   01/02/18    44
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: name4   01/02/18    44
- en: '[PRE88]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: $ `cvt_date.pl --iformat=us --add-century newdata.txt`
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cvt_date.pl --iformat=us --oformat=br newdata.txt`
- en: name1   1999-01-01  38
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: name1   1999-01-01  38
- en: name2   2000-12-31  40
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: name2   2000-12-31  40
- en: name3   2013-02-28  42
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: name3   2013-02-28  42
- en: name4   2018-01-02  44
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: name4   2018-01-02  44
- en: '[PRE89]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: $ `cvt_date.pl --iformat=us --oformat=br newdata.txt`
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cvt_date.pl --iformat=us --oformat=br newdata.txt`
- en: name1   01-01-99    38
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: name1   01-01-99    38
- en: name2   31-12-00    40
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: name2   31-12-00    40
- en: name3   28-02-13    42
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: name3   28-02-13    42
- en: name4   02-01-18    44
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: name4   02-01-18    44
- en: '[PRE90]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Delaware        Dec. 7, 1787
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Delaware        Dec. 7, 1787
- en: Pennsylvania    Dec 12, 1787
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Pennsylvania    Dec 12, 1787
- en: New Jersey      Dec. 18, 1787
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: New Jersey      Dec. 18, 1787
- en: Georgia         Jan. 2, 1788
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Georgia         Jan. 2, 1788
- en: Connecticut     Jan. 9, 1788
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Connecticut     Jan. 9, 1788
- en: Massachusetts   Feb. 6, 1788
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Massachusetts   Feb. 6, 1788
- en: …
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '[PRE91]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Delaware        1787-12-07
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Delaware        1787-12-07
- en: Pennsylvania    1787-12-12
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Pennsylvania    1787-12-12
- en: New Jersey      1787-12-18
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: New Jersey      1787-12-18
- en: Georgia         1788-01-02
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: Georgia         1788-01-02
- en: Connecticut     1788-01-09
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Connecticut     1788-01-09
- en: Massachusetts   1788-02-06
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Massachusetts   1788-02-06
- en: …
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '[PRE92]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '#!/usr/bin/python3'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python3'
- en: 'monddyyyy_to_iso.py: Convert dates from mon[.] dd, yyyy to ISO format.'
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'monddyyyy_to_iso.py: Convert dates from mon[.] dd, yyyy to ISO format.'
- en: Assumes tab-delimited, linefeed-terminated input
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Assumes tab-delimited, linefeed-terminated input
- en: import re
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: import re
- en: import sys
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import fileinput
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: import fileinput
- en: import warnings
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: import warnings
- en: 'map = {"jan": 1, "feb": 2, "mar": 3, "apr": 4, "may": 5, "jun": 6,'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 'map = {"jan": 1, "feb": 2, "mar": 3, "apr": 4, "may": 5, "jun": 6,'
- en: '"jul": 7, "aug": 8, "sep": 9, "oct": 10, "nov": 11, "dec": 12'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"jul": 7, "aug": 8, "sep": 9, "oct": 10, "nov": 11, "dec": 12'
- en: '} # map 3-char month abbreviations to numeric month'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '} # map 3-char month abbreviations to numeric month'
- en: 'for line in fileinput.input(sys.argv[1:]):'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in fileinput.input(sys.argv[1:]):'
- en: 'values = line.rstrip().split("\t", 10000)    # split, preserving all fields'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 'values = line.rstrip().split("\t", 10000)    # split, preserving all fields'
- en: 'for i in range(0, len(values)):'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(0, len(values)):'
- en: reformat the value if it matches the pattern, otherwise assume
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: reformat the value if it matches the pattern, otherwise assume
- en: that it's not a date in the required format and leave it alone
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: that it's not a date in the required format and leave it alone
- en: m = re.match('^([^.]+)\.? (\d+), (\d+)$', values[i])
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: m = re.match('^([^.]+)\.? (\d+), (\d+)$', values[i])
- en: 'if m:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if m:'
- en: '# use lowercase month name'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# use lowercase month name'
- en: (month, day, year) = (m.group(1).lower(), int(m.group(2)), int(m.group(3)))
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (month, day, year) = (m.group(1).lower(), int(m.group(2)), int(m.group(3)))
- en: '#@ _CHECK_VALIDITY_'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '#@ _CHECK_VALIDITY_'
- en: 'if month in map:'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if month in map:'
- en: '#@ _CHECK_VALIDITY_'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '#@ _CHECK_VALIDITY_'
- en: values[i] = "%04d-%02d-%02d" % (year, map[month], day)
  id: totrans-511
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: values[i] = "%04d-%02d-%02d" % (year, map[month], day)
- en: 'else:'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: warn, but don't reformat
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: warn, but don't reformat
- en: warnings.warn("%s bad date?" % (values[i]))
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: warnings.warn("%s bad date?" % (values[i]))
- en: print("\t".join(values))
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: print("\t".join(values))
- en: '[PRE93]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: from cookbook_utils import *
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: from cookbook_utils import *
- en: '[PRE94]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'if month in map:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 'if month in map:'
- en: '[PRE95]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'if month in map and is_valid_date(year, map[month], day)):'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 'if month in map and is_valid_date(year, map[month], day)):'
- en: '[PRE96]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: name1   01/01/99    38
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: name1   01/01/99    38
- en: name2   12/31/00    40
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: name2   12/31/00    40
- en: name3   02/28/13    42
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: name3   02/28/13    42
- en: name4   01/02/18    44
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: name4   01/02/18    44
- en: '[PRE97]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: $ `cvt_date.py --iformat=us --add-century newdata.txt > tmp.txt`
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cvt_date.py --iformat=us --add-century newdata.txt > tmp.txt`
- en: '[PRE98]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: mysql> `LOAD DATA LOCAL INFILE 'newdata.txt'`
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: mysql> `LOAD DATA LOCAL INFILE 'newdata.txt'`
- en: -> `INTO TABLE t (name,@date,value)`
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> `INTO TABLE t (name,@date,value)`
- en: -> `SET date = STR_TO_DATE(@date,'%m/%d/%y');`
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> `SET date = STR_TO_DATE(@date,'%m/%d/%y');`
- en: '[PRE99]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: +-------+------------+-------+
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: +-------+------------+-------+
- en: '| name  | date       | value |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| name  | date       | value |'
- en: +-------+------------+-------+
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: +-------+------------+-------+
- en: '| name1 | 1999-01-01 |    38 |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| name1 | 1999-01-01 |    38 |'
- en: '| name2 | 2000-12-31 |    40 |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| name2 | 2000-12-31 |    40 |'
- en: '| name3 | 2013-02-28 |    42 |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| name3 | 2013-02-28 |    42 |'
- en: '| name4 | 2018-01-02 |    44 |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| name4 | 2018-01-02 |    44 |'
- en: +-------+------------+-------+
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: +-------+------------+-------+
- en: '[PRE100]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: mysql> `LOAD DATA LOCAL INFILE 'newdata.txt'`
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: mysql> `LOAD DATA LOCAL INFILE 'newdata.txt'`
- en: -> `INTO TABLE t (name,@date,value)`
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> `INTO TABLE t (name,@date,value)`
- en: -> `SET date = my_date_interp(@date);`
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> `SET date = my_date_interp(@date);`
- en: '[PRE101]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: CREATE TABLE datetbl
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE datetbl
- en: (
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: i   INT,
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: i   INT,
- en: c   CHAR(10),
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: c   CHAR(10),
- en: d   DATE,
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: d   DATE,
- en: dt  DATETIME,
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: dt  DATETIME,
- en: ts  TIMESTAMP,
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ts  TIMESTAMP,
- en: PRIMARY KEY(i)
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: PRIMARY KEY(i)
- en: );
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '[PRE102]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: SELECT
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT
- en: i,
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: i,
- en: c,
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: c,
- en: DATE_FORMAT(d, '%m-%d-%Y') AS d,
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: DATE_FORMAT(d, '%m-%d-%Y') AS d,
- en: DATE_FORMAT(dt, '%m-%d-%Y %T') AS dt,
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: DATE_FORMAT(dt, '%m-%d-%Y %T') AS dt,
- en: DATE_FORMAT(ts, '%m-%d-%Y %T') AS ts
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: DATE_FORMAT(ts, '%m-%d-%Y %T') AS ts
- en: FROM datetbl;
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: FROM datetbl;
- en: '[PRE103]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 3       abc     2005-12-31      2005-12-31 12:05:03     2005-12-31 12:05:03
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 3       abc     2005-12-31      2005-12-31 12:05:03     2005-12-31 12:05:03
- en: 4       xyz     2006-01-31      2006-01-31 12:05:03     2006-01-31 12:05:03
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 4       xyz     2006-01-31      2006-01-31 12:05:03     2006-01-31 12:05:03
- en: '[PRE104]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 3       abc     12-31-2005      12-31-2005 12:05:03     12-31-2005 12:05:03
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 3       abc     12-31-2005      12-31-2005 12:05:03     12-31-2005 12:05:03
- en: 4       xyz     01-31-2006      01-31-2006 12:05:03     01-31-2006 12:05:03
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 4       xyz     01-31-2006      01-31-2006 12:05:03     01-31-2006 12:05:03
- en: '[PRE105]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: $ `cvt_file.pl --iformat=csv somedata.csv \`
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cvt_file.pl --iformat=csv somedata.csv \`
- en: '`| yank_col.pl --columns=2,11,5,9 \`'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`| yank_col.pl --columns=2,11,5,9 \`'
- en: '`| cvt_date.py --columns=2 --iformat=us --add-century > tmp`'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`| cvt_date.py --columns=2 --iformat=us --add-century > tmp`'
- en: '[PRE106]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '#!/usr/bin/python3'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python3'
- en: 'validate_htwt.py: Height/weight validation example.'
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'validate_htwt.py: Height/weight validation example.'
- en: Assumes tab-delimited, linefeed-terminated input lines.
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Assumes tab-delimited, linefeed-terminated input lines.
- en: 'Input columns and the actions to perform on them are as follows:'
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'Input columns and the actions to perform on them are as follows:'
- en: '1: name; echo as given'
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1: name; echo as given'
- en: '2: birth; echo as given'
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2: birth; echo as given'
- en: '3: height; validate as positive integer'
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3: height; validate as positive integer'
- en: '4: weight; validate as positive integer'
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4: weight; validate as positive integer'
- en: import sys
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import fileinput
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: import fileinput
- en: import warnings
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: import warnings
- en: from cookbook_utils import *
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: from cookbook_utils import *
- en: line_num = 0
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: line_num = 0
- en: 'for line in fileinput.input(sys.argv[1:]):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 'for line in fileinput.input(sys.argv[1:]):'
- en: line_num += 1
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: line_num += 1
- en: (name, birth, height, weight) = line.rstrip().split ("\t", 4)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: (name, birth, height, weight) = line.rstrip().split ("\t", 4)
- en: 'if not is_positive_integer(height):'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not is_positive_integer(height):'
- en: warnings.warn(f"line {line_num}:height {height} is not a positive integer")
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: warnings.warn(f"line {line_num}:height {height} is not a positive integer")
- en: 'if not is_positive_integer(weight):'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not is_positive_integer(weight):'
- en: warnings.warn(f"line {line_num}:weight {weight} is not a positive integer")
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: warnings.warn(f"line {line_num}:weight {weight} is not a positive integer")
- en: '[PRE107]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: mysql> `LOAD DATA LOCAL INFILE 'tmp' INTO TABLE` *`tbl_name`*`;`
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: mysql> `LOAD DATA LOCAL INFILE 'tmp' INTO TABLE` *`tbl_name`*`;`
- en: '```'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
