- en: Chapter 16\. Using Joins and Subqueries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。使用联接和子查询
- en: 16.0 Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.0 介绍
- en: 'Most queries in earlier chapters used a single table, but for any application
    of even moderate complexity, you’ll likely need to use multiple tables. Some questions
    simply cannot be answered using a single table, and the real power of a relational
    database comes into play when you combine the information from multiple sources:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在前几章中的查询使用了单个表，但是对于任何稍微复杂的应用程序，您可能需要使用多个表。有些问题简单地无法使用单个表来回答，而当您将多个来源的信息结合在一起时，关系数据库的真正威力就显现出来：
- en: Combine rows from tables to obtain more comprehensive information than can be
    obtained from individual tables alone
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合表中的行以获得比仅从单个表中获得的信息更全面的信息
- en: Hold intermediate results for a multiple-stage operation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持多阶段操作的中间结果
- en: Modify rows in one table based on information from another
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据另一个表中的信息修改一个表中的行
- en: 'This chapter focuses on two types of statements that use multiple tables: joins
    between tables and subqueries that nest one `SELECT` within another. It covers
    the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用多个表的两种类型语句：表之间的联接和嵌套一个`SELECT`中的子查询。它涵盖以下主题：
- en: Comparing tables to find matches or mismatches
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 比较表以查找匹配项或不匹配项
- en: To solve such problems, you should know which types of joins apply. Inner joins
    show which rows in one table match rows in another. Outer joins show matching
    rows, but also find rows in one table *not* matched by rows in another.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这些问题，您应该了解适用哪些类型的联接。内联接显示一个表中与另一个表中的行匹配的行。外部联接显示匹配的行，但也找到一个表中未与另一个表中的行匹配的行。
- en: Deleting unmatched rows
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 删除不匹配的行
- en: If two datasets are related, but imperfectly, you can determine which rows are
    unmatched and remove them as necessary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个数据集相关但不完美，您可以确定哪些行不匹配并根据需要删除它们。
- en: Comparing a table to itself
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将表与自身进行比较
- en: Some problems require comparing a table to itself. This is similar to performing
    a join between different tables, except that you must use table aliases to disambiguate
    table references.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有些问题要求将表与自身进行比较。这类似于在不同表之间执行联接，但您必须使用表别名来消除表引用的歧义。
- en: Producing candidate-detail and many-to-many relationships
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 生成候选详细和多对多关系
- en: Joins enable production of lists or summaries when each item in one table can
    match many in the other, or when each item in either table can match many in the
    other.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表中的每个项目可以与另一个表中的多个项目匹配，或者当每个表中的任一项目可以与另一个表中的多个项目匹配时，联接可以生成列表或摘要。
- en: Scripts that create tables used in this chapter are located in the *tables*
    directory of the `recipes` distribution. For scripts that implement techniques
    discussed here, look in the *joins* directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的创建表的脚本位于`recipes`分发的*tables*目录中。要查找实现本章讨论的技术的脚本，请查看*joins*目录。
- en: 16.1 Finding Matches Between Tables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.1 在表之间查找匹配项
- en: Problem
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to perform a task that requires information from more than one table.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行需要来自多个表的信息的任务。
- en: Solution
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a join—that is, a query that lists multiple tables in its `FROM` clause
    and tells MySQL how to match information from them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用联接——即在其`FROM`子句中列出多个表并告诉MySQL如何匹配它们的查询。
- en: Discussion
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The essential idea behind a join is that it matches rows in one table with rows
    in one or more other tables. Joins enable you to combine information from multiple
    tables when each one answers only part of the question in which you’re interested.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 联接背后的基本思想是它将一个表中的行与一个或多个其他表中的行进行匹配。当每个表只回答您感兴趣问题的一部分时，联接使您能够合并来自多个表的信息。
- en: A complete join that produces all possible row combinations is called a Cartesian
    product. For example, joining each row in a 100-row table to each row in a 200-row
    table produces a result containing 100 × 200 = 20,000 rows. With larger tables,
    or joins between more than two tables, the result set for a Cartesian product
    easily becomes immense, so a join normally includes an `ON` or `USING` comparison
    clause to produce only the desired matches between tables. (This requires that
    each table have one or more columns of common information that link them together
    logically.) You can also include a `WHERE` clause that restricts which of the
    joined rows to select. Each clause narrows the focus of the query.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 产生所有可能的行组合的完全连接称为笛卡尔积。例如，将一个有 100 行的表中的每一行与一个有 200 行的表中的每一行连接，产生的结果包含 100 ×
    200 = 20,000 行。对于更大的表或连接超过两个表的情况，笛卡尔积的结果集很容易变得巨大，因此连接通常包括一个 `ON` 或 `USING` 比较子句，仅生成表之间所需的匹配（这要求每个表都有一个或多个共同的信息列，逻辑上将它们联系在一起）。还可以包括一个
    `WHERE` 子句，用于限制要选择的连接行。每个子句都可以缩小查询的焦点。
- en: 'This recipe introduces join syntax and demonstrates how joins answer specific
    types of questions when you are looking for matches between tables. Other sections
    show how to identify mismatches between tables (see [Recipe 16.2](#nch-multi-multi-outer-join))
    and how to compare a table to itself (see [Recipe 16.4](#nch-multi-multi-self-join)).
    The examples assume that you have an art collection and use the following two
    tables to record your acquisitions. `artist` lists those painters whose works
    you want to collect, and `painting` lists each painting you’ve actually purchased:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此处介绍连接语法并展示连接如何回答特定类型的问题，当您寻找表之间的匹配时。其他部分展示如何识别表之间的不匹配（参见 [Recipe 16.2](#nch-multi-multi-outer-join)）以及如何将表与自身进行比较（参见
    [Recipe 16.4](#nch-multi-multi-self-join)）。这些示例假定您拥有一个艺术收藏，并使用以下两个表记录您的收购信息。`artist`
    列出了那些您希望收藏其作品的画家，而 `painting` 则列出了您实际购买的每幅绘画作品：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You’ve just begun the collection, so the tables contain only a few rows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚开始收藏，因此表中只包含少量行：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The low values in the `price` column of the `painting` table betray the fact
    that your collection actually contains only cheap imitations, not the originals.
    Well, that’s all right: who can afford the originals?'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`painting` 表中 `price` 列中的低值揭示了您的收藏实际上只包含廉价的仿制品，而不是原作。好吧，没关系：谁能负担得起原作呢？'
- en: Each table contains partial information about your collection. For example,
    the `artist` table doesn’t tell you which paintings each artist produced, and
    the `painting` table lists artist IDs but not their names. To use the information
    in both tables, write a query that performs a join. A join names two or more tables
    after the `FROM` keyword. In the output column list, use `*` to select all columns
    from all tables, *`tbl_name`*`.*` to select all columns from a given table, or
    name specific columns from the joined tables or expressions based on those columns.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每张表包含关于您收藏的部分信息。例如，`artist` 表并未告诉您每位艺术家创作了哪些绘画作品，而 `painting` 表则列出了艺术家的 ID，但没有他们的名字。要使用这两个表中的信息，编写一个执行连接的查询。在
    `FROM` 关键字后面命名两个或更多表来执行连接。在输出列列表中，使用 `*` 从所有表中选择所有列，*`tbl_name`*`.*` 从给定表中选择所有列，或者根据这些列的连接表或表达式命名特定列。
- en: 'The simplest join involves two tables and selects all columns from each. The
    following join between the `artist` and `painting` tables shows this (the `ORDER`
    `BY` clause makes the result easier to read):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的连接涉及两个表，并从每个表中选择所有列。下面连接 `artist` 和 `painting` 表展示了这一点（`ORDER` `BY` 子句使结果更易读）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An `INNER` `JOIN` produces results that combine values in one table with values
    in another table. The preceding query specifies no restrictions on row matching,
    so the join generates all row combinations (that is, the Cartesian product). This
    result illustrates why such a join generally is not useful: it produces a lot
    of unmeaningful output. Clearly, you don’t maintain these tables to match every
    artist with every painting.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`INNER JOIN` 生成将一个表中的值与另一个表中的值组合的结果。前面的查询未指定行匹配的任何限制，因此连接生成所有行组合（即笛卡尔积）。这个结果说明为什么这样的连接通常是无用的：它产生大量无意义的输出。显然，您不会维护这些表以将每位艺术家与每幅绘画作品匹配。'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: In MySQL, `JOIN`, `CROSS JOIN`, and `INNER JOIN` are syntactic equivalents and
    can replace each other. You can use `CROSS JOIN`, or simply `JOIN`, in all places
    where we use `INNER JOIN`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中，`JOIN`、`CROSS JOIN` 和 `INNER JOIN` 是语法上的等价物，并可以互换使用。可以在我们使用 `INNER
    JOIN` 的所有地方使用 `CROSS JOIN` 或简单的 `JOIN`。
- en: 'To answer questions meaningfully, produce only the relevant matches by including
    appropriate join conditions. For example, to produce a list of paintings together
    with the artist names, associate rows from the two tables using a simple `WHERE`
    clause that matches values based on the artist ID column that is common to both
    tables and serves to link them:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有意义地回答问题，通过包含适当的连接条件仅生成相关的匹配。例如，要生成包含艺术家名称的画作列表，使用简单的 `WHERE` 子句将来自两个表的行关联起来，该子句基于艺术家
    ID 列的值进行匹配，该列是两个表共同的并用于链接它们的列：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The column names in the `WHERE` clause include table qualifiers to make it clear
    which `a_id` values to compare. The result indicates who painted each painting,
    and, conversely, which paintings by each artist are in your collection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句中的列名包括表限定符，以明确指出要比较的 `a_id` 值。结果显示了谁画了每幅画，反过来，每位艺术家的哪些画作在您的收藏中。'
- en: 'Another way to write the same join indicates the matching conditions with an
    `ON` clause:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写相同连接的方式使用 `ON` 子句指示匹配条件：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the special case of equality comparisons between columns with the same name
    in both tables, you can use an `INNER` `JOIN` with a `USING` clause instead. This
    requires no table qualifiers and names each joined column only once:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊情况下，当两个表中具有相同名称的列进行等值比较时，可以使用 `INNER JOIN` 结合 `USING` 子句。这不需要表限定符，并且每个连接的列只命名一次：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For `SELECT` `*` queries, the `USING` form produces a result that differs from
    the `ON` form: it returns only one instance of each join column, so `a_id` appears
    once, not twice.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SELECT *` 查询，`USING` 形式产生的结果与 `ON` 形式不同：它仅返回每个连接列的一个实例，因此 `a_id` 只出现一次，而不是两次。
- en: 'Any of `ON`, `USING`, or `WHERE` can include comparisons, so how do you know
    which join conditions to put in each clause? As a rule of thumb, it’s conventional
    to use `ON` or `USING` to specify how to join the tables, and the `WHERE` clause
    to restrict which of the joined rows to select. For example, to join tables based
    on the `a_id` column, but select only rows for paintings obtained in Kentucky,
    use an `ON` (or `USING`) clause to match the rows in the two tables, and a `WHERE`
    clause to test the `state` column:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON`、`USING` 或 `WHERE` 中的任何一个都可以包括比较，那么如何确定每个子句中放置哪些连接条件呢？作为一个经验法则，通常使用 `ON`
    或 `USING` 指定如何连接表，使用 `WHERE` 子句限制要选择的连接行。例如，要基于 `a_id` 列连接表，但仅选择在肯塔基州获取的画作的行，请使用
    `ON`（或 `USING`）子句匹配两个表中的行，并使用 `WHERE` 子句测试 `state` 列：'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding queries use `SELECT` `*` to display all columns. To be more selective,
    name only those columns in which you’re interested:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询使用 `SELECT *` 来显示所有列。为了更具选择性，只命名您感兴趣的那些列：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Joins can use more than two tables. Suppose that you prefer to see complete
    state names rather than abbreviations in the preceding query result. The `states`
    table used in earlier chapters maps state abbreviations to names; add it to the
    previous query to display name rather than abbreviation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Joins 可以使用超过两个表。假设您希望在前面的查询结果中看到完整的州名而不是缩写。在早期章节中使用的 `states` 表将州的缩写映射到名称；将其添加到前面的查询中，以显示名称而不是缩写：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another common use of three-way joins is enumerating many-to-many relationships
    (see [Recipe 16.6](#nch-multi-multi-many-to-many)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的三表连接用途是枚举多对多关系（见[Recipe 16.6](#nch-multi-multi-many-to-many)）。
- en: 'By including appropriate conditions in your joins, you can answer very specific
    questions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在连接中包含适当的条件，您可以回答非常具体的问题：
- en: 'Which paintings did Van Gogh paint? Use the `a_id` value to find matching rows,
    add a `WHERE` clause to restrict output to rows that contain the artist name,
    and select the title from those rows:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凡·高画了哪些画？使用 `a_id` 值查找匹配行，添加 `WHERE` 子句以限制输出到包含艺术家名称的行，并从这些行中选择标题：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Who painted the *Mona Lisa*? Again, use the `a_id` column to join the rows,
    but this time use the `WHERE` clause to restrict output to rows that contain the
    title, and select the artist name from those rows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁画了 *蒙娜丽莎*？再次使用 `a_id` 列连接行，但这次使用 `WHERE` 子句将输出限制为包含标题的行，并从这些行中选择艺术家名称：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For which artists did you purchase paintings in Kentucky or Indiana? This is
    similar to the previous statement, but tests a different column in the `painting`
    table (`state`) to restrict output to rows for `KY` or `IN`:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在肯塔基州或印第安纳州购买了哪些艺术家的画作？这与前一语句类似，但在 `painting` 表中测试不同的列（`state`），以将输出限制为 `KY`
    或 `IN` 的行：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The statement also uses `DISTINCT` to display each artist name just once. Try
    it without `DISTINCT`; Van Gogh appears twice because you obtained two Van Goghs
    in Kentucky.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该语句还使用 `DISTINCT` 显示每位艺术家的名称仅一次。尝试去掉 `DISTINCT`；Van Gogh 会出现两次，因为您在肯塔基州获得了两幅
    Van Gogh 的作品。
- en: 'Joins used with aggregate functions produce summaries. This statement shows
    how many paintings you have per artist:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与聚合函数一起使用的连接生成摘要。此语句显示每位艺术家有多少幅绘画：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A more elaborate statement uses aggregates to also show how much you paid for
    each artist’s paintings, in total and on average:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更为复杂的语句使用聚合，还显示了您为每位艺术家的绘画支付了多少，总计和平均数：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding summary statements produce output only for those artists in the
    `artist` table for whom you actually have acquired paintings. (For example, Monet
    is listed in the `artist` table but is not present in the summary because you
    have none of his paintings yet.) To summarize all artists, including those for
    whom you have no paintings, you must use a different kind of join—specifically,
    an outer join:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前述摘要语句仅为艺术家表中确实已获取其绘画的艺术家生成输出。（例如，Monet 在艺术家表中列出，但在摘要中未列出，因为您尚未拥有他的任何绘画。）要总结所有艺术家，包括那些您尚未获得其绘画的艺术家，您必须使用不同类型的连接，具体来说是外连接：
- en: Joins written with `INNER` `JOIN` are inner joins. They produce a result only
    for values in one table that match values in another table.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `INNER JOIN` 编写的连接是内连接。它们仅为一个表中与另一个表中的值匹配的值生成结果。
- en: An outer join can produce those matches as well, but also can show you which
    values in one table are missing from the other. [Recipe 16.2](#nch-multi-multi-outer-join)
    introduces outer joins.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外连接也可以生成这些匹配项，但还可以显示一个表中缺少另一个表中的哪些值。[Recipe 16.2](https://example.org/recipe_16.2)
    介绍了外连接。
- en: 'The *`tbl_name.col_name`* notation that qualifies a column name with a table
    name is always permitted in a join but can be shortened to just *`col_name`* if
    the name appears in only one of the joined tables. In that case, MySQL can determine
    without ambiguity which table the column comes from, and no table name qualifier
    is necessary. We can’t do that for the following join. Both tables have an `a_id`
    column, so the `ON` clause column references are ambiguous:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接中始终允许以表名限定列名的 *`tbl_name.col_name`* 符号化表示，但如果该名称仅出现在连接的一个表中，则可以缩短为 *`col_name`*。在这种情况下，MySQL
    可以明确确定列来自哪个表，无需表名限定符。我们无法在以下连接中这样做。两个表都有一个 `a_id` 列，因此 `ON` 子句列引用存在歧义：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By contrast, the following query is unambiguous. Each instance of `a_id` is
    qualified with the appropriate table name, only `artist` has a `name` column,
    and only `painting` has `title` and `state` columns:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下查询是明确的。每个 `a_id` 实例都带有适当的表名限定，只有 `artist` 有一个 `name` 列，而只有 `painting`
    有 `title` 和 `state` 列：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To make the meaning of a statement clearer to human readers, it’s often useful
    to qualify column names even when that’s not strictly necessary as far as MySQL
    is concerned. We tend to use qualified names in join examples for that reason.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让语句的含义对人类读者更加清晰，即使对于 MySQL 而言可能不是严格必需的，经常使用限定列名也是有用的。因此，我们倾向于在连接示例中使用限定名称。
- en: 'To avoid writing complete table names when qualifying column references, give
    each table a short alias and refer to its columns using the alias. The following
    two statements are equivalent:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在限定列引用时避免编写完整的表名，给每个表分配一个简短的别名，并使用该别名引用其列。以下两个语句是等效的：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `AS` *`alias_name`* clauses, the `AS` is optional.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AS` *`alias_name`* 子句中，`AS` 是可选的。
- en: For complicated statements that select many columns, aliases can save a lot
    of typing. In addition, for some types of statements, aliases are not only convenient
    but necessary, as will become evident when we get to the topic of self-joins (see
    [Recipe 16.4](#nch-multi-multi-self-join)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择许多列的复杂语句，使用别名可以节省大量输入。此外，对于某些类型的语句，别名不仅方便而且必要，特别是在涉及自连接的情况下（参见 [Recipe 16.4](https://example.org/recipe_16.4)）。
- en: 16.2 Finding Mismatches Between Tables
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.2 寻找表之间的不匹配
- en: Problem
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find rows in one table that have no match in another. Or you want
    to produce a list on the basis of a join between tables, and you want the list
    to include an entry for every row in the first table, including those for which
    no match occurs in the second table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要查找一个表中没有与另一个表匹配的行。或者，您想要基于表之间的连接生成一个列表，并且希望该列表包括第一个表中的每一行条目，包括第二个表中没有匹配的行。
- en: Solution
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use an outer join (a `LEFT` `JOIN` or a `RIGHT` `JOIN`) or a `NOT` `IN` subquery.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外连接（`LEFT JOIN`或`RIGHT JOIN`）或`NOT IN`子查询。
- en: Discussion
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '[Recipe 16.1](#nch-multi-multi-inner-join) focuses on inner joins, which find
    matches between two tables. However, the answers to some questions require determining
    which rows do *not* have a match (or, stated another way, which rows have values
    missing from the other table). For example, you might want to know artists in
    the `artist` table for whom you have no paintings yet. Similar questions occur
    in other contexts:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 16.1](#nch-multi-multi-inner-join)专注于内连接，它查找两个表之间的匹配项。然而，对于某些问题的答案需要确定哪些行*没有*匹配（或者换句话说，另一个表中缺少值的行）。例如，你可能想知道`artist`表中哪些艺术家还没有作品。在其他情况下也会出现类似的问题：'
- en: You have a list of potential customers, and another list of people who have
    placed orders. To focus sales efforts on people who are not yet actual customers,
    produce the set of people who are in the first list but not the second.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个潜在客户列表，还有一个已下订单的人员列表。为了将销售努力集中在尚未成为实际客户的人员上，生成第一个列表中存在但第二个列表中不存在的人员集合。
- en: You have one list of baseball players, and another list of players who have
    hit home runs. To determine which players in the first list have *not* hit a home
    run, produce the set of players who are in the first list but not the second.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个棒球运动员列表，还有一个击出全垒打的运动员列表。为了确定第一个列表中哪些运动员*没有*击出全垒打，生成第一个列表中存在但第二个列表中不存在的运动员集合。
- en: These types of questions require use of an outer join. Like inner joins, an
    outer join finds matches between tables. But unlike an inner join, an outer join
    also determines which rows in one table have no match in another. Two types of
    outer join are `LEFT` `JOIN` and `RIGHT` `JOIN`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的问题需要使用外连接。像内连接一样，外连接查找表之间的匹配项。但与内连接不同，外连接还确定一个表中哪些行在另一个表中没有匹配。外连接有两种类型，分别是`LEFT
    JOIN`和`RIGHT JOIN`。
- en: 'To see how outer joins are useful, consider the problem of determining which
    artists in the `artist` table are missing from the `painting` table. At present,
    the tables are small, so it’s easy to examine them visually and see that you have
    no paintings by Monet (there are no `painting` rows with an `a_id` value of 2):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解外连接的实用性，考虑一下以下问题：确定`artist`表中哪些艺术家在`painting`表中不存在。目前，这些表很小，所以可以通过目测轻松查看，发现你没有莫奈的绘画作品（`painting`表中没有`a_id`值为2的行）：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you acquire more paintings and the tables get larger, it won’t be so easy
    to eyeball them and answer questions by inspection. Can you answer it using SQL?
    Sure, although first attempts at a solution often look something like the following
    statement, which uses a not-equal condition to look for mismatches between the
    two tables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你获得更多绘画作品和表变得更大，通过目测来回答问题将不再那么容易。你能用SQL来回答吗？当然可以，尽管首次尝试的解决方案通常看起来像以下语句，它使用不等条件来查找两个表之间的不匹配：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The query may look plausible but its result obviously is not. For example, it
    falsely indicates that each painting was painted by several different artists.
    The problem is that the statement lists all combinations of values from the two
    tables in which the artist ID values aren’t the same. What you really need is
    a list of values in `artist` that aren’t present *at* *all* in `painting`, but
    an inner join can only produce results based on values that are present in both
    tables. It can’t tell you anything about values that are missing from one of them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 查询看起来可能是合理的，但其结果显然是错误的。例如，它错误地表明每幅画都是由几位不同的艺术家绘制的。问题在于该语句列出了两个表中艺术家ID值不相同的所有值组合。实际上，你需要的是`artist`中在`painting`中根本不存在的值列表，但内连接只能基于两个表中都存在的值生成结果。它无法告诉你有关其中一个表中缺少的值的任何信息。
- en: 'When faced with the need to find values in one table with no match in (or missing
    from) another table, you should get in the habit of thinking, <q>Aha, that’s a
    `LEFT` `JOIN` problem.</q> A `LEFT` `JOIN` is one type of outer join: it’s similar
    to an inner join in that it matches rows in the first (left) table with rows in
    the second (right) table. In addition, if a left table row has no match in the
    right table, a `LEFT` `JOIN` still produces a row—one in which all the columns
    from the right table are set to `NULL`. This means you can find values that are
    missing from the right table by looking for `NULL`. It’s easier to understand
    how this happens by working in stages. Begin with an inner join that displays
    matching rows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对需要在一个表中找到在另一个表中没有匹配或缺失的值时，你应该养成思维的习惯，<q>啊哈，这是一个 `LEFT` `JOIN` 的问题。</q> `LEFT`
    `JOIN` 是一种外连接的类型：它类似于内连接，它将第一个（左）表中的行与第二个（右）表中的行进行匹配。此外，如果左表的行在右表中没有匹配，`LEFT`
    `JOIN` 仍然会生成一行——其中来自右表的所有列都设置为 `NULL`。这意味着你可以通过查找 `NULL` 来找到在右表中缺失的值。通过逐步进行，你更容易理解这是如何发生的。从显示匹配行的内连接开始：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this output, the first `a_id` column comes from the `artist` table and the
    second one comes from the `painting` table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，第一个 `a_id` 列来自 `artist` 表，第二个来自 `painting` 表。
- en: 'Now substitute `LEFT` for `INNER` to see the result you get from an outer join:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 `INNER` 替换为 `LEFT`，看看外连接的结果：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compared to the inner join, the outer join produces an additional row for every
    `artist` row that has no `painting` table match, with all `painting` columns set
    to `NULL`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与内连接相比，外连接为每个没有 `painting` 表匹配的 `artist` 行生成了额外的行，其中所有 `painting` 列都设置为 `NULL`。
- en: 'Next, to restrict the output only to the unnmatched `artist` rows, add a `WHERE`
    clause that looks for `NULL` values in any `painting` column that cannot otherwise
    contain `NULL`. This filters out the rows that the inner join produces, leaving
    those produced only by the outer join:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了仅限制输出到不匹配的 `artist` 行，添加一个 `WHERE` 子句，在其中查找任何 `painting` 列中的 `NULL` 值，这些列本来不可能包含
    `NULL`。这样就会过滤掉内连接生成的行，只留下外连接生成的行：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, to show only the `artist` table values that are missing from the `painting`
    table, write the output column list to name only columns from the `artist` table.
    The result is that the `LEFT` `JOIN` lists those left-table rows containing `a_id`
    values not present in the right table:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了仅显示在 `painting` 表中缺失的 `artist` 表值，编写输出列列表以仅命名来自 `artist` 表的列。结果是 `LEFT`
    `JOIN` 列出了那些包含右表中不存在的 `a_id` 值的左表行：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A similar kind of operation reports each left-table value along with an indicator
    as to whether it’s present in the right table. To do this, perform a `LEFT` `JOIN`
    that counts the number of times each left-table value occurs in the right table.
    A count of zero indicates that the value is not present. The following statement
    lists each artist from the `artist` table and shows whether you have any paintings
    by the artist:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的操作报告每个左表值以及指示它是否在右表中存在的指标。为此，执行一个计算每个左表值在右表中出现次数的 `LEFT` `JOIN`。计数为零表示该值不存在。下面的语句列出了
    `artist` 表中的每位艺术家，并显示该艺术家是否有任何绘画作品：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A `RIGHT` `JOIN` is an outer join that is like `LEFT` `JOIN` but reverses the
    roles of the left and right tables. Semantically, `RIGHT` `JOIN` forces the matching
    process to produce a row from each table in the right table, even in the absence
    of a corresponding row in the left table. Syntactically, *`tbl1`* `LEFT` `JOIN`
    *`tbl2`* is equivalent to *`tbl2`* `RIGHT` `JOIN` *`tbl1`*. Therefore, references
    to `LEFT` `JOIN` in this book apply to `RIGHT` `JOIN` as well if you reverse the
    roles of the tables.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`RIGHT` `JOIN` 是一种外连接，类似于 `LEFT` `JOIN`，但是反转了左右表的角色。语义上，`RIGHT` `JOIN` 强制匹配过程生成右表中每个表的行，即使在左表中没有相应的行也是如此。从语法上讲，*`tbl1`*
    `LEFT` `JOIN` *`tbl2`* 等效于 *`tbl2`* `RIGHT` `JOIN` *`tbl1`*。因此，本书中对 `LEFT` `JOIN`
    的引用如果反转表的角色也适用于 `RIGHT` `JOIN`。'
- en: 'Another way to identify values present in one table but missing from another
    is to use a `NOT` `IN` subquery. The following example finds artists not represented
    in the `painting` table; compare it to the earlier `LEFT` `JOIN` that answers
    the same question:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种识别一个表中存在但另一个表中缺失值的方法是使用 `NOT` `IN` 子查询。下面的示例查找在 `painting` 表中没有代表的艺术家；与之前回答同样问题的
    `LEFT` `JOIN` 进行对比：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See Also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: As shown in this section, `LEFT` `JOIN` is useful for finding values with no
    match in another table or for showing whether each value is matched. `LEFT` `JOIN`
    may also be used to produce a summary that includes all items in a list, even
    those for which there’s nothing to summarize. This is very common for relationships
    between a candidate table and a detail table. For example, a `LEFT` `JOIN` can
    produce <q>total sales per customer</q> reports that list all customers, even
    those who bought nothing during the summary period. (For information about candidate-detail
    lists, see [Recipe 16.5](#nch-multi-multi-one-to-many).)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节所示，`LEFT` `JOIN`对于查找另一张表中没有匹配的值或显示每个值是否匹配非常有用。`LEFT` `JOIN`还可用于生成包含列表中所有项目的摘要，即使在汇总期间没有要汇总的内容也是如此。这在候选表与详细表之间的关系中非常常见。例如，`LEFT`
    `JOIN`可以生成<q>每位客户的总销售额</q>报告，列出所有客户，即使在汇总期间没有购买任何商品的客户也包括在内。（有关候选-详细列表的信息，请参见[Recipe
    16.5](#nch-multi-multi-one-to-many)。）
- en: '`LEFT` `JOIN` is also useful for consistency checking when you receive two
    datafiles that are supposed to be related, and you want to determine whether they
    really are. (That is, you want to check the integrity of their relationship.)
    Import each file into a MySQL table, and then run a couple `LEFT` `JOIN` statements
    to determine whether there are unattached rows in one table or the other—that
    is, rows that have no match in the other table. [Recipe 16.3](#nch-multi-multi-delete-unrelated)
    discusses how to identify (and optionally delete) these unattached rows.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您收到两个应该相关的数据文件并且想要确定它们是否真的相关时，`LEFT` `JOIN`也非常有用于一致性检查。也就是说，您希望检查它们的关系是否完整。将每个文件导入到MySQL表中，然后运行一对`LEFT`
    `JOIN`语句以确定一个表中是否有未连接的行，即另一个表中没有匹配的行。[Recipe 16.3](#nch-multi-multi-delete-unrelated)讨论了如何识别（并可选地删除）这些未连接的行。
- en: 16.3 Identifying and Removing Mismatched or Unattached Rows
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.3 标识和删除不匹配或未连接的行
- en: Problem
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You have two datasets that are related, but possibly imperfectly so. You want
    to determine whether there are records in either dataset that are <q>unattached</q>
    (not matched by any record in the other dataset), and perhaps remove them if so.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个相关的数据集，但可能不完全相关。您希望确定任一数据集中是否存在记录是<q>未连接</q>的（没有任何另一个数据集中的记录匹配），并且如果有，则可能删除这些记录。
- en: Solution
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: To identify unmatched values in each table, use a `LEFT` `JOIN` or a `NOT` `IN`
    subquery. To remove them, use `DELETE` with a `NOT` `IN` subquery.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在每个表中标识不匹配的值，使用`LEFT` `JOIN`或`NOT` `IN`子查询。要删除它们，请使用带有`NOT` `IN`子查询的`DELETE`语句。
- en: Discussion
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Inner joins are useful for identifying matches, and outer joins are useful for
    identifying mismatches. This property of outer joins is valuable when you have
    related datasets for which the relationship might be imperfect. Mismatches might
    be found, for example, when you must verify the integrity of two datafiles received
    from an external source.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 内连接对于识别匹配项很有用，外连接对于识别不匹配项很有用。当您有相关数据集，并且这些数据集之间的关系可能不完美时，外连接的这个属性非常有价值。例如，在必须验证来自外部来源的两个数据文件的完整性时，可能会发现不匹配。
- en: 'When you have related tables with unmatched rows, you can analyze and modify
    them using SQL statements. Specifically, restoring their relationship is a matter
    of identifying the unattached rows and then deleting them:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有相关的未匹配行的表时，可以使用SQL语句来分析和修改它们。具体来说，恢复它们的关系是识别未连接的行，然后删除它们：
- en: To identify unattached rows, use a `LEFT` `JOIN`, because this is a <q>find
    unmatched rows</q> problem; alternatively, use a `NOT` `IN` subquery (see [Recipe
    16.2](#nch-multi-multi-outer-join)).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别未连接的行，请使用`LEFT` `JOIN`，因为这是一个<q>查找未匹配行</q>的问题；或者，可以使用`NOT` `IN`子查询（参见[Recipe
    16.2](#nch-multi-multi-outer-join)）。
- en: To delete rows that are unmatched, use `DELETE` with a `NOT` `IN` subquery.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除不匹配的行，使用带有`NOT` `IN`子查询的`DELETE`语句。
- en: It’s useful to know about unmatched data because you can alert whoever gave
    you the data. The data collection method might have a flaw that must be corrected.
    For example, with sales data, a missing region might mean that some regional manager
    didn’t report in and the omission was overlooked.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 了解未匹配的数据很有用，因为您可以提醒提供数据的人。数据收集方法可能存在需要纠正的缺陷。例如，对于销售数据，缺少的地区可能意味着某些地区经理没有报告，而这个遗漏被忽视了。
- en: 'The following example shows how to identify and remove mismatched rows using
    two datasets that describe sales regions and volume of sales per region. One dataset
    contains the ID and location of each region:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用描述销售区域和每个区域销售量的两个数据集来识别和删除不匹配的行。一个数据集包含每个区域的ID和位置：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The other dataset contains sales volume figures. Each row contains the amount
    of sales for a given quarter of a year and indicates the sales region to which
    the row applies:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个数据集包含销售量数据。每行包含一年四分之一的销售额，并指示适用于该行的销售区域：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A little visual inspection reveals that neither table is fully matched by the
    other. Sales regions 2 and 4 are not represented in the sales volume table, and
    the sales volume table contains rows for region 5, which is not in the sales region
    table. But we don’t want to check the tables by inspection. We want to find unmatched
    rows by using SQL statements that do the work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一点视觉检查显示，两个表都没有完全匹配对方。销售区域2和4在销售量表中没有表示，而销售量表包含销售区域表中不存在的区域5的行。但我们不想通过视觉检查来检查表格。我们希望通过使用执行工作的SQL语句来查找不匹配的行。
- en: 'Mismatch identification is a matter of using outer joins. For example, to find
    sales regions for which there are no sales volume rows, use the following `LEFT`
    `JOIN`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 识别不匹配是使用外连接的问题。例如，要查找没有销售量行的销售区域，请使用以下`LEFT` `JOIN`：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Conversely, to find sales volume rows that are not associated with any known
    region, reverse the roles of the two tables:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要查找未与任何已知区域关联的销售量行，请反转两个表的角色：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, an ID appears more than once in the list if there are multiple
    volume rows for a missing region. To see each unmatched ID only once, use `SELECT`
    `DISTINCT`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果缺少区域的多个体积行，则一个ID在列表中出现多次。要仅查看每个不匹配的ID一次，请使用`SELECT` `DISTINCT`：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also identify mismatches using `NOT` `IN` subqueries:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`NOT` `IN`子查询识别不匹配：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To get rid of unmatched rows, use a `NOT` `IN` subquery in a `DELETE` statement.
    To remove `sales_region` rows that match no `sales_volume` rows, do this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要摆脱不匹配的行，请在`DELETE`语句中使用`NOT` `IN`子查询。要删除与没有`sales_volume`行匹配的`sales_region`行，请执行以下操作：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To remove mismatched `sales_volume` rows that match no `sales_region` rows,
    the statement is similar but with the table roles reversed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除不匹配的`sales_volume`行，这些行不与任何`sales_region`行匹配，可以使用类似的语句，只是表的角色相反：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 16.4 Comparing a Table to Itself
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.4 比较表与自身
- en: Problem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to compare rows in a table to other rows in the same table. For example,
    you want to find all paintings in your collection by the artist who painted *The
    Potato Eaters*. Or you want to know which states listed in the `states` table
    joined the Union in the same year as New York. Or you want to know which states
    did not join the Union in the same year as any other state.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要比较表中的行与同一表中的其他行。例如，您想找出您收藏的所有由绘制了*《土豆食者》*的艺术家的绘画。或者您想知道列在`states`表中的哪些州与纽约在同一年加入了联盟。或者您想知道哪些州没有与其他任何州在同一年加入联盟。
- en: Solution
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Problems that require comparing a table to itself involve an operation known
    as a self-join. It’s performed much like other joins, except that you must use
    table aliases so that you can refer to the same table different ways within the
    statement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 需要比较表与自身的问题涉及一种称为自连接的操作。它的执行方式与其他连接类似，但您必须使用表别名，以便在语句中可以以不同方式引用同一表。
- en: Discussion
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A special case of joining one table to another occurs when both tables are the
    same. This is called a self-join. This may be confusing or strange to think about
    at first, but it’s perfectly legal. You’ll likely find yourself using self-joins
    quite often because they are so important.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个表连接到另一个表时发生的一种特殊情况是，当两个表相同时。这被称为自连接。起初可能会感到困惑或奇怪，但这是完全合法的。您可能会经常使用自连接，因为它们非常重要。
- en: 'A tip-off that a self-join is required is that you want to know which pairs
    of rows in a table satisfy some condition. Suppose that your favorite painting
    is *The Potato Eaters*, and you want to identify all items in your collection
    that were painted by the same artist. The artist ID and painting titles that we
    begin with look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要自连接的一个提示是，您想知道表中哪些行对某些条件满足。假设您最喜欢的绘画是*《土豆食者》*，您想识别出您收藏的所有由同一位艺术家绘制的物品。我们从艺术家ID和绘画标题开始看起来像这样：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Solve the problem as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的方法如下：
- en: Identify which `painting` table row contains the title *The Potato Eaters*,
    so that you can refer to its `a_id` value.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定包含标题*The Potato Eaters*的`painting`表行，以便引用其`a_id`值。
- en: Match other rows in the table that have the same `a_id` value.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配表中具有相同`a_id`值的其他行。
- en: Display the titles from those matching rows.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示那些匹配行的标题。
- en: 'The trick lies in using the proper notation. First attempts at joining a table
    to itself often look something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于使用正确的表示法。首次尝试将表与自身连接通常看起来像这样：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The column references in that statement are ambiguous because MySQL cannot
    tell which instance of the `painting` table any given column name refers to. The
    solution is to alias at least one instance of the table so that you can distinguish
    column references by using different table qualifiers. The following statement
    shows how to do this, using the aliases `p1` and `p2` to refer to the `painting`
    table different ways:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在该语句中，列引用是模糊的，因为MySQL无法确定给定列名指向哪个`painting`表的实例。解决方案是至少给表的一个实例设置别名，这样你就可以通过使用不同的表限定符来区分列引用。以下语句显示了如何做到这一点，使用别名`p1`和`p2`来区分`painting`表的不同实例：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The statement output illustrates something typical of self-joins: when you
    begin with a reference value in one table instance (*The Potato Eaters*) to find
    matching rows in a second table instance (paintings by the same artist), the output
    includes the reference value. That makes sense: after all, the reference matches
    itself. To find only *other* paintings by the same artist, explicitly exclude
    the reference value from the output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句输出显示了自连接的典型特征：当你从一个表实例（*The Potato Eaters*）中的一个参考值开始，去查找第二个表实例（同一艺术家的绘画作品）中的匹配行时，输出包括参考值本身。这是有道理的：毕竟，该参考值与自身匹配。为了仅找到同一艺术家的*其他*绘画作品，请明确从输出中排除参考值：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding statements use ID value comparisons to match rows in the two
    table instances, but any kind of value can be used. For example, to use the `states`
    table to answer the question <q>Which states joined the Union in the same year
    as New York?</q> perform a temporal pairwise comparison based on the year part
    of the dates in the table’s `statehood` column:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句使用ID值比较来匹配两个表实例中的行，但可以使用任何类型的值。例如，要使用`states`表回答问题<q>哪些州与纽约同年加入联邦？</q>，请基于表中`statehood`列中日期的年份部分执行时间上的成对比较：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the example above we do not specify the year when New York joined the Union.
    Instead, we compare the value of the `statehood` column for the row where state
    name is “New York” and the same `statehood` column for other states.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们没有指定纽约加入联邦的年份。相反，我们比较了“New York”州名称行的`statehood`列的值和其他州相同的`statehood`列的值。
- en: 'Now suppose that you want to find *every* pair of states that joined the Union
    in the same year. In this case, the output potentially can include any pair of
    rows from the `states` table. A self-join is perfect for this problem:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想找到*每对*在同一年加入联邦的州。在这种情况下，输出可能包括`states`表中任意一对行。自连接非常适合解决这个问题：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The condition in the `ON` clause that requires state pair names not to be identical
    eliminates the trivially duplicate rows showing that each state joined the Union
    in the same year as itself. But you’ll notice that each remaining pair of states
    still appears twice. For example, there is one row that lists Delaware and New
    Jersey, and another that lists New Jersey and Delaware. This is often the case
    with self-joins: they produce pairs of rows that contain the same values, but
    for which the values are not in the same order.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ON`子句中的条件要求州名对不相同，从而消除了显示每个州与自己同年加入联邦的重复行。但你会注意到每对剩余的州仍然出现两次。例如，有一行列出了特拉华州和新泽西州，另一行列出了新泽西州和特拉华州。自连接经常会产生这种情况：它们生成包含相同值但值的顺序不同的行对。
- en: 'Because the values are not listed in the same order within the rows, they are
    not identical and you can’t get rid of these <q>near duplicates</q> by adding
    `DISTINCT` to the statement. To solve this problem, select rows in such a way
    that only one row from each pair ever appears in the query result. Slightly modify
    the `ON` clause, from:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为值在行内未按相同顺序列出，它们并不相同，你无法通过在语句中添加`DISTINCT`来摆脱这些<q>近似重复项</q>。为了解决这个问题，请以一种只有一行从每对中出现在查询结果中的方式选择行。稍微修改`ON`子句，从：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 'to:'
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using `<` rather than `<>` selects only those rows in which the first state
    name is lexically less than the second, and eliminates rows in which the names
    appear in opposite order (as well as rows in which the state names are identical).
    The resulting query produces the desired output without duplicates:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<`而不是`<>`只选择第一个州名称字母顺序小于第二个州名称的行，并消除名称按相反顺序出现的行（以及州名称相同的行）。由此产生的查询输出所需的输出而无重复项：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For self-join problems of the <q>Which values are *not* matched by other rows
    in the table?</q> variety, use a `LEFT` `JOIN` rather than an `INNER` `JOIN`.
    An instance of this is the question <q>Which states did not join the Union in
    the same year as any other state?</q> In this case, the solution uses a `LEFT`
    `JOIN` of the `states` table to itself:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于<q>表中哪些值*不*与其他行匹配？</q>类型的自连接问题，使用`LEFT` `JOIN`而不是`INNER` `JOIN`。这种情况的一个实例是问题<q>哪些州没有在同一年加入联盟？</q>在这种情况下，解决方案使用`states`表与其自身的`LEFT`
    `JOIN`：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For each row in the `states` table, the statement selects rows for which the
    state has a `statehood` value in the same year, not including that state itself.
    For rows having no such match, the `LEFT` `JOIN` forces the output to contain
    a row anyway, with all the `s2` columns set to `NULL`. Those rows identify the
    states with no other state that joined the Union in the same year.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`states`表中的每一行，该语句选择具有与该州在同一年具有`statehood`值的行，但不包括该州本身。对于没有这种匹配的行，`LEFT` `JOIN`强制输出仍然包含一行，其中所有`s2`列设置为`NULL`。这些行标识出在同一年没有其他州加入联盟的州。
- en: 16.5 Producing Candidate-Detail Lists and Summaries
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.5 生成候选-详细列表和摘要
- en: Problem
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Two tables have a relationship such that row in one table, usually called parent
    table with a candidate key, is referenced by one or mor erows in another table,
    usually called the child table with a detail row. In this situation, you want
    to produce a list that shows each parent row with its detail rows or a list that
    produces a summary of the detail rows for each parent row.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表之间有一种关系，即一个表中的行，通常称为具有候选键的父表，被另一个表中的一个或多个行引用，通常称为具有详细行的子表。在这种情况下，您希望生成一个显示每个父行及其详细行的列表，或者生成一个显示每个父行的详细行摘要的列表。
- en: Solution
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: This is a one-to-many relationship. The solution to this problem involves a
    join, but the type of join depends on the question you want answered. To produce
    a list containing only parent rows for which some detail row exists, use an inner
    join based on the primary key in the parent table. To produce a list that includes
    all parent rows, even those with no detail rows, use an outer join.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种一对多的关系。解决此问题的方法涉及连接，但连接的类型取决于您想要回答的问题。要生成仅包含存在某些详细行的父行的列表，请使用基于父表中的主键的内连接。要生成包含所有父行的列表，甚至包括没有详细行的父行，请使用外连接。
- en: Discussion
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: To produce a list from two tables that have a candidate-detail or parent-child
    relationship, a given row in one table might be matched by several rows in the
    other. These relationships occur frequently. For example, in business contexts,
    one-to-many relationships involve invoices per customer or items per invoice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要从具有候选-详细或父-子关系的两个表中生成列表，一个表中的给定行可能与另一个表中的多个行匹配。这些关系经常发生。例如，在业务背景下，一对多的关系涉及每个客户的发票或每张发票的项目。
- en: This recipe suggests some candidate-detail questions that you can ask (and answer)
    using the `artist` and `painting` tables from earlier in the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的示例提供了一些候选-详细问题，您可以使用本章前面的`artist`和`painting`表来询问（并回答）。
- en: 'One form of candidate-detail question for these tables is, <q>Which paintings
    did each artist paint?</q> This is a simple inner join (see [Recipe 16.1](#nch-multi-multi-inner-join)).
    Match each `artist` row to its corresponding `painting` rows based on the artist
    ID values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这些表的一种候选-详细问题，<q>每位艺术家绘制了哪些绘画？</q>这是一个简单的内连接（见[第16.1节](#nch-multi-multi-inner-join)）。根据艺术家ID值，将每个`artist`行与其相应的`painting`行进行匹配：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To also list artists for whom you have no paintings, the join output should
    include rows in one table that have no match in the other. That’s a form of <q>find
    the nonmatching rows</q> problem that requires an outer join (see [Recipe 16.2](#nch-multi-multi-outer-join)).
    Thus, to list each `artist` row, whether or not any `painting` rows match, use
    a `LEFT` `JOIN`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出您没有绘画的艺术家，连接输出应包括一个表中没有与另一个表匹配的行。这是一种需要外连接的<q>查找非匹配行</q>问题（见[第16.2节](#nch-multi-multi-outer-join)）。因此，要列出每个`artist`行，无论是否匹配任何`painting`行，请使用`LEFT`
    `JOIN`：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Rows in the result that have `NULL` in the `title` column correspond to artists
    listed in the `artist` table for whom you have no paintings.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中在 `title` 列中有 `NULL` 的行对应于 `artist` 表中列出的艺术家，对于这些艺术家，您没有绘画。
- en: 'The same principles apply when producing summaries using candidate and detail
    tables. For example, to summarize your art collection by number of paintings per
    artist, you might ask, <q>How many paintings are there per artist in the `painting`
    table?</q> To find the answer based on artist ID but displaying the artist’s name
    (from the `artist` table), count the paintings with this statement:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 生成使用候选表和详细表的汇总时，同样的原则适用。 例如，要按艺术家的绘画数量汇总您的艺术收藏，您可以问，“在 `painting` 表中每位艺术家有多少幅画？”
    要根据艺术家 ID 找到答案但显示艺术家的姓名（来自 `artist` 表），请使用此语句计算绘画数量：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On the other hand, you might ask, <q>How many paintings did each artist paint?</q>
    This is the same question as the previous one (and the same statement answers
    it), as long as every artist in the `artist` table has at least one corresponding
    `painting` table row. But if you have artists in the `artist` table not yet represented
    by any paintings in your collection, they do not appear in the statement output.
    To produce a summary that also includes artists with no paintings in the `painting`
    table, use a `LEFT` `JOIN`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，您可能会问，“每位艺术家画了多少幅画？” 这与前一个问题相同（同一个语句回答），只要 `artist` 表中的每位艺术家至少有一行对应的 `painting`
    表。 但是，如果 `artist` 表中有尚未由您收藏中的任何绘画代表的艺术家，则它们不会出现在语句输出中。 要生成包括在 `painting` 表中没有绘画的艺术家的汇总，请使用
    `LEFT` `JOIN`：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Beware of a subtle error that is easy to make when writing that kind of statement.
    Suppose that you write the `COUNT()` function slightly differently, like so:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这种类型的语句时，要注意一个微妙的错误，这种错误很容易犯。 假设您稍微不同地编写了 `COUNT()` 函数，如下所示：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now every artist appears to have at least one painting. Why the difference?
    The problem is the use of `COUNT(*)` rather than `COUNT(painting.a_id)`. The way
    `LEFT` `JOIN` works for unmatched rows in the left table is that it generates
    a row with all the columns from the right table set to `NULL`. In the example,
    the right table is `painting`. The statement that uses `COUNT(painting.a_id)`
    works correctly because `COUNT(`*`expr`*`)` counts only non-`NULL` values. The
    statement that uses `COUNT(*)` is incorrect because it counts *rows*, including
    those containing `NULL` that correspond to missing artists.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每位艺术家似乎至少有一幅画。 为什么会有这种差异？ 问题在于使用 `COUNT(*)` 而不是 `COUNT(painting.a_id)`。 `LEFT`
    `JOIN` 对于左表中未匹配的行的处理方式是生成一个行，其中右表的所有列均设置为 `NULL`。 在此示例中，右表是 `painting`。 使用 `COUNT(painting.a_id)`
    的语句运行正确，因为 `COUNT(`*`expr`*`)` 仅计算非 `NULL` 值。 使用 `COUNT(*)` 的语句是错误的，因为它计算包括那些对应于缺失艺术家的
    `NULL` 的行在内的*行*。
- en: '`LEFT` `JOIN` is suitable for other types of summaries as well. To produce
    additional columns showing the total and average prices of the paintings for each
    artist in the `artist` table, use this statement:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`LEFT` `JOIN` 也适用于其他类型的汇总。 要为 `artist` 表中每位艺术家的绘画总价和平均价添加额外列，请使用以下语句：'
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that `COUNT()` is zero for artists that are not represented, but `SUM()`
    and `AVG()` are `NULL`. The latter two functions return `NULL` when applied to
    a set of values with no non-`NULL` values. To display a sum or average value of
    zero in that case, replace `SUM(`*`expr`*`)` and `AVG(`*`expr`*`)` with `IFNULL(SUM(`*`expr`*`),0)`
    and `IFNULL(AVG(`*`expr`*`),0)`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于未被代表的艺术家，`COUNT()` 为零，但 `SUM()` 和 `AVG()` 为 `NULL`。 当应用于没有非 `NULL` 值的值集时，后两个函数返回
    `NULL`。 在这种情况下显示零的和平均值，请用 `IFNULL(SUM(`*`expr`*`)，0)` 和 `IFNULL(AVG(`*`expr`*`)，0)`
    替换 `SUM(`*`expr`*`)` 和 `AVG(`*`expr`*`)`。
- en: 16.6 Enumerating a Many-to-Many Relationship
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.6 枚举一对多关系
- en: Problem
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to display a relationship between tables when any row in either table
    might be matched by multiple rows in the other.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当任一表中的任何行可能与另一表中的多行匹配时，您希望显示表之间的关系。
- en: Solution
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: This is a many-to-many relationship. It requires a third table for associating
    your two primary tables and a three-way join to produce the correspondences between
    them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一对多关系。 它需要一个第三个表来关联您的两个主表，并进行三向连接以生成它们之间的对应关系。
- en: Discussion
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `artist` and `painting` tables used in earlier sections have a one-to-many
    relationship: a given artist may have produced many paintings, but each painting
    was created by only one artist. One-to-many relationships are relatively simple
    and the two related tables can be joined using a column that is common to both.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中使用的`artist`和`painting`表有一对多的关系：一个艺术家可能制作了许多绘画，但每幅绘画只由一个艺术家创作。一对多关系相对简单，可以使用两个相关表中共有的列进行连接。
- en: 'A many-to-many relationship between tables is more complex. It occurs when
    a row in one table may have many matches in the other, and vice versa. An example
    is the relationship between movies and actors: each movie may have multiple actors,
    and each actor may have appeared in multiple movies. One way to represent this
    relationship uses a table structured as follows, with a row for each movie-actor
    combination:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表之间的多对多关系更复杂。当一个表中的一行可以在另一个表中有多个匹配项，反之亦然时，就会出现多对多关系。电影和演员之间的关系是一个例子：每部电影可能有多位演员，每位演员可能出演过多部电影。表示这种关系的一种方法是使用以下结构的表，每个电影-演员组合有一行：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The table captures the nature of this many-to-many relationship, but it’s also
    in nonnormal form because it unnecessarily stores repetitive information. For
    example, information for each movie is recorded multiple times. To better represent
    this many-to-many relationship, use multiple tables:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此表捕捉了这种多对多关系的本质，但也是在非规范化形式，因为它不必要地存储了重复的信息。例如，每部电影的信息被记录了多次。为了更好地表示这种多对多关系，使用多个表：
- en: Store each movie year and name once in a table named `movies`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为`movies`的表中仅存储每部电影的年份和名称一次。
- en: Store each actor name once in a table named `actors`.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在名为`actors`的表中仅存储每个演员的姓名一次。
- en: Create a third table, `movies_actors_link`, that stores movie-actor associations
    and serves as a link, or bridge, between the two primary tables. To minimize the
    information stored in this table, assign unique IDs to each movie and actor within
    their respective tables, and store only those IDs in the `movies_actors_link`
    table.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第三个表 `movies_actors_link`，它存储电影-演员关联，并作为两个主要表之间的链接或桥梁。为了最小化存储在此表中的信息，分别为每部电影和每位演员分配唯一的ID，并仅在`movies_actors_link`表中存储这些ID。
- en: 'The resulting `movie` and `actor` tables look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`movie`和`actor`表如下所示：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `movies_actors_link` table associates movies and actors as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies_actors_link` 表将电影和演员关联如下：'
- en: '[PRE52]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You’ll surely notice that the content of the `movies_actors_link` table is
    entirely meaningless from a human perspective. That’s okay: we need never display
    it explicitly. Its utility derives from its ability to link the two primary tables
    in queries, without appearing in query output itself. The next few examples illustrate
    this principle. They answer questions about the movies or actors, using three-way
    joins that relate the two primary tables using the link table.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定会注意到，从人类的角度来看，`movies_actors_link` 表的内容完全毫无意义。这没关系：我们永远不需要明确显示它。它的实用性在于能够在查询中链接两个主要表，而不会出现在查询输出中。接下来的几个例子说明了这个原理。它们通过使用三表连接来回答关于电影或演员的问题，将两个主要表关联到链接表。
- en: 'List all the pairings that show each movie and who acted in it. This statement
    enumerates all the correspondences between the `movie` and `actor` tables and
    reproduces the information that was originally in the nonnormal `movies_actors`
    table:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有显示每部电影及其演员的配对。此语句枚举了`movie`和`actor`表之间的所有对应关系，并复制了最初位于非规范化`movies_actors`表中的信息：
- en: '[PRE53]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'List the actors in a given movie:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出给定电影中的演员：
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'List the movies in which a given actor has acted:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出一个给定演员参演的所有电影：
- en: '[PRE55]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 16.7 Finding Per-Group Minimum or Maximum Values
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.7 查找每组的最小或最大值
- en: Problem
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to find which row within each group of rows in a table contains the
    maximum or minimum value for a given column. For example, you want to determine
    the most expensive painting in your collection for each artist.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望找出表中每个组中包含给定列的最大或最小值的行。例如，你想要确定你收藏的每位艺术家的最贵的绘画。
- en: Solution
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a temporary table to hold the per-group maximum or minimum values, then
    join the temporary table with the original one to pull out the matching row for
    each group. If you prefer a single-query solution, use a subquery in the `FROM`
    clause rather than a temporary table.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个临时表来保存每组的最大或最小值，然后将临时表与原始表连接以提取每组的匹配行。如果你更喜欢单查询解决方案，则在`FROM`子句中使用子查询，而不是临时表。
- en: Discussion
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Many questions involve finding largest or smallest values in a particular table
    column, but it’s also common to want to know other values in the row that contains
    the value. For example, using the `artist` and `painting` tables with the techniques
    from [Recipe 10.6](ch10.xhtml#nch-sum-sum-assoc), it’s possible to answer questions
    such as <q>What is the most expensive painting in the collection, and who painted
    it?</q> One solution is to store the highest price in a user-defined variable,
    then use the variable to identify the row containing the price so that you can
    retrieve other columns from it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 许多问题涉及查找特定表列中的最大或最小值，但通常还想知道包含该值的行中的其他值。例如，使用来自[第10.6节](ch10.xhtml#nch-sum-sum-assoc)的`artist`和`painting`表的技术，可以回答诸如<q>收藏品中最昂贵的画作是什么，由谁绘制？</q>的问题。一种解决方案是将最高价格存储在用户定义变量中，然后使用该变量标识包含价格的行，以便可以从中检索其他列：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The same thing can be done by creating a temporary table to hold the maximum
    price and joining it with the other tables:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建一个临时表来执行相同的操作，以存储最大价格并将其与其他表连接：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: On the face of it, using a temporary table and a join is just a more complicated
    way of answering the question than with a user-defined variable. Does this technique
    have any practical value? Yes, it does, because it leads to a more general technique
    for answering more difficult questions. The previous statements show information
    only for the single most expensive painting in the entire `painting` table. What
    if your question is, <q>What is the most expensive painting *for each artist*?</q>
    You can’t use a user-defined variable to answer that question because the answer
    requires finding one price per artist, and a variable holds only a single value.
    But the technique of using a temporary table works well because the table can
    hold multiple rows, and a join can find matches for all of them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，使用临时表和连接只是比使用用户定义变量回答问题更复杂的一种方式。这种技术是否有实际价值呢？有，因为它可以导致一种更一般的技术来回答更难的问题。前面的陈述仅显示整个`painting`表中最昂贵的单幅画信息。如果你的问题是：<q>每位艺术家最昂贵的画作是什么？</q>你不能使用用户定义变量来回答这个问题，因为答案需要找到每位艺术家的一个价格，并且变量只能保存单个值。但是使用临时表的技术效果很好，因为表可以保存多行，连接可以找到所有匹配项。
- en: 'To answer the question, select each artist ID and the corresponding maximum
    painting price into a temporary table. This table contains not only the maximum
    painting price but the maximum within each group, where <q>group</q> is defined
    as <q>paintings by a given artist.</q> Then use the artist IDs and prices stored
    in the temporary table to match rows in the `painting` table, and join the result
    with the `artist` table to get the artist names:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答问题，选择每个艺术家ID及其对应的最大画作价格放入临时表中。该表不仅包含最大画作价格，而且在每个组内都是最大的，其中<q>组</q>定义为<q>某位艺术家的画作。</q>然后使用临时表中存储的艺术家ID和价格与`painting`表中的行匹配，并将结果与`artist`表连接以获取艺术家姓名：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To avoid explicitly creating temporary tables and obtain the same result with
    a single statement, use Common Table Expressions (CTEs).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免显式创建临时表并以单个语句获得相同结果，请使用通用表达式（CTEs）。
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We discuss CTEs in detail in [Recipe 10.18](ch10.xhtml#nch-sum-sum-with).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第10.18节](ch10.xhtml#nch-sum-sum-with)中详细讨论了CTEs。
- en: 'Another way to obtain the same result with a single statement, is to use a
    subquery in the `FROM` clause that retrieves the same rows contained in the temporary
    table:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`FROM`子句中使用子查询检索与临时表中包含的相同行，可以以单个语句获得相同结果的另一种方法：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Yet another way to answer maximum-per-group questions is to use a `LEFT` `JOIN`
    that joins a table to itself. The following statement identifies the highest-priced
    painting per artist ID (use `IS` `NULL` to select all the rows from `p1` for which
    there is *no* row in `p2` with a higher price):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种回答每组最大值问题的方法是使用`LEFT JOIN`将表与自身连接。以下语句识别每位艺术家ID的最高价画作（使用`IS NULL`选择`p1`中所有没有在`p2`中有更高价格行的行）：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To display artist names rather than ID values, join the result of the `LEFT`
    `JOIN` to the `artist` table:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示艺术家姓名而不是ID值，请将`LEFT JOIN`的结果与`artist`表连接：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The self-`LEFT` `JOIN` method is perhaps less intuitive than using a temporary
    table, a CTE, or a subquery.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用临时表来回答最大-每组问题可能比使用临时表、CTE或子查询更不直观的自连接`LEFT JOIN`方法。
- en: See Also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: This recipe showed how to answer maximum-per-group questions by selecting summary
    information into a temporary table and joining that table to the original one
    or by using a subquery in the `FROM` clause. These techniques have application
    in many contexts. One of them is calculation of team standings, where the standings
    for each group of teams are determined by comparing each team in the group to
    the team with the best record. [Recipe 17.12](ch17.xhtml#nch-stats-stats-standings)
    discusses how to do this.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本篇介绍了如何通过将摘要信息选择到临时表中并将该表与原始表连接，或者通过在`FROM`子句中使用子查询来回答最大-每组问题的技术。这些技术在许多场景中都有应用。其中之一是计算团队排名，其中每个团队组的排名是通过将该组中的每个团队与成绩最佳的团队进行比较来确定的。[第17.12节](ch17.xhtml#nch-stats-stats-standings)讨论了如何做到这一点。
- en: 16.8 Using a Join to Fill or Identify Holes in a List
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.8 使用联接填充或标识列表中的空白
- en: Problem
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to produce a summary by category, but some categories are missing from
    the data to be summarized. Consequently, the summary has missing categories as
    well.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望按类别生成总结，但是一些类别在要总结的数据中不存在。因此，总结中也缺少这些类别。
- en: Solution
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a reference table that lists each category and produce the summary based
    on a `LEFT` `JOIN` between the list and the table containing your data. Every
    category in the reference table will appear in the result, even those not present
    in the data to be summarized.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列出每个类别的参考表，并基于列表和包含数据的表之间的`LEFT` `JOIN`生成总结。结果中将显示参考表中的每个类别，即使这些类别在要总结的数据中不存在。
- en: Discussion
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A summary query normally produces entries only for categories actually present
    in the data. Suppose that you want to summarize the `driver_log` table (introduced
    in [Chapter 9](ch09.xhtml#nch-sort)), to determine how many drivers were on the
    road each day. The table has these rows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，总结查询仅对实际存在于数据中的类别生成条目。假设您想要总结`driver_log`表（见[第9章](ch09.xhtml#nch-sort)介绍），以确定每天上路的司机数量。表具有以下行：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A simple summary showing the number of active drivers per day looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的总结显示每天活跃司机的数量如下：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, the summary category is date, but the summary is <q>incomplete</q> in
    the sense that it includes entries only for dates represented in the `driver_log`
    table. To produce a summary that includes all categories (all dates within the
    date range represented in the table), including those for which no driver was
    active, create a reference table that lists each date:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，总结类别是日期，但从字面上来看，总结是<q>不完整的</q>，因为它仅包括`driver_log`表中表示的日期的条目。要生成一个包含所有类别（表中日期范围内的所有日期）的总结，包括那些没有活跃司机的日期，请创建一个参考表，列出每个日期：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then join the reference table to the `driver_log` table using a `LEFT` `JOIN`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`LEFT` `JOIN`将参考表与`driver_log`表联接：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now the summary includes a row for every date in the range because the `LEFT`
    `JOIN` forces the output to include a row for every date in the reference table,
    even those missing from the `driver_log` table.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，总结包括范围内的每个日期的行，因为`LEFT` `JOIN`强制输出包含参考表中的每个日期的行，即使在`driver_log`表中缺少这些日期也是如此。
- en: 'The example just shown uses the reference table with a `LEFT` `JOIN` to fill
    holes in the summary. It’s also possible to use the reference table to *detect*
    holes in the dataset—that is, to determine which categories are not present in
    the data to be summarized. The following statement shows those dates on which
    no driver was active by looking for reference rows for which no `driver_log` table
    rows have a matching category value:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才展示的示例使用参考表与`LEFT` `JOIN`来填充总结中的空白。还可以使用参考表来*检测*数据集中的空白，即确定哪些类别在要总结的数据中不存在。以下语句显示了通过查找没有与类别值匹配的`driver_log`表行的参考行来找出在哪些日期上没有活跃司机：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Reference tables that contain a list of categories are quite useful in summary
    context, as just shown. But creating such tables manually is mind-numbing and
    error-prone. It is much easier to use recursive CTE for this purpose.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 包含类别列表的参考表在总结上下文中非常有用，就像刚才展示的那样。但是手动创建这样的表格是枯燥乏味且容易出错的。使用递归CTE来实现这一目的要简单得多。
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We discuss recursive CTEs in more details in [Recipe 15.16](ch15.xhtml#nch-sum-sum-recursive-cte)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第15.16节](ch15.xhtml#nch-sum-sum-recursive-cte)中更详细地讨论了递归CTE。
- en: 'If you need a very long list of dates that you expect to re-use often you may
    prefer to store them in a table instead of generating series each time you need
    them. In this case, a stored procedure that uses the endpoints of the range of
    category values to generate the reference table for you helps automate the process.
    In essence, this type of procedure acts as an iterator that generates a row for
    each value in the range. The following procedure, `make_date_list()`, shows an
    example of this approach. It creates a reference table containing a row for every
    date in a particular date range. It also indexes the table so that it will be
    fast in large joins:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个非常长的日期列表，预计会经常重复使用，您可能更喜欢将它们存储在表中，而不是每次都生成系列。在这种情况下，使用类别值范围的端点来生成参考表的存储过程将帮助自动化该过程。实质上，这种类型的存储过程充当一个迭代器，为范围内的每个值生成一行。以下存储过程
    `make_date_list()` 展示了这种方法的一个示例。它创建一个包含特定日期范围内每个日期的参考表。它还对表进行索引，以便在大型连接中速度快：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use `make_date_list()` to generate the reference table, `dates`, like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `make_date_list()` 生成参考表 `dates`，如下所示：
- en: '[PRE70]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Then use the `dates` table as shown earlier in this section to fill holes in
    the summary or to detect holes in the dataset.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像本节前面展示的那样使用 `dates` 表，以填补摘要中的空洞或检测数据集中的空洞。
- en: You can find the `make_date_list()` procedure in the *joins* directory of the
    `recipes` distribution. It requires the `exec_stmt()` and `quote_identifier()`
    helper routines (see [Recipe 11.6](ch11.xhtml#nch-routines-dynamic-sql-helpers)),
    located in the *routines* directory. The *joins* directory also contains a Perl
    script, *make_date_list.pl*, that implements an alternate approach; it generates
    date reference tables from the command line.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `recipes` 发行版的 *joins* 目录中找到 `make_date_list()` 存储过程。它需要 *routines* 目录中的
    `exec_stmt()` 和 `quote_identifier()` 辅助例程（参见 [Recipe 11.6](ch11.xhtml#nch-routines-dynamic-sql-helpers)）。*joins*
    目录还包含一个 Perl 脚本 *make_date_list.pl*，实现了一种替代方法；它可以从命令行生成日期参考表。
- en: 16.9 Using a Join to Control Query Sort Order
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.9 使用连接控制查询排序顺序
- en: Problem
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sort a statement’s output using a characteristic of the output that
    cannot be specified using `ORDER` `BY`. For example, you want to sort a set of
    rows by subgroups, putting first those groups with the most rows and last those
    groups with the fewest rows. But <q>number of rows in each group</q> is not a
    property of individual rows, so you can’t use it for sorting.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用输出的特性对语句的输出进行排序，但无法使用 `ORDER BY` 指定输出的特性。例如，您希望按子组对一组行进行排序，首先放置具有最多行的组，最后放置具有最少行的组。但是，“每个组中的行数”不是单个行的属性，因此无法用于排序。
- en: Solution
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Derive the ordering information and store it in an auxiliary table. Then join
    the original table to the auxiliary table, using the auxiliary table to control
    the sort order.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 派生排序信息并将其存储在辅助表中。然后将原始表与辅助表连接，使用辅助表来控制排序顺序。
- en: Discussion
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Most of the time you sort a query result using an `ORDER` `BY` clause that
    names which column or columns to use for sorting. But sometimes the values you
    want to sort by aren’t present in the rows to be sorted. This is the case when
    you want to use group characteristics to order the rows. The following example
    uses the `driver_log` table to illustrate this. The following query sorts the
    table using the ID column, which is present in the rows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，您会使用 `ORDER BY` 子句对查询结果进行排序，指定用于排序的列。但有时，要排序的值并不在要排序的行中。这种情况出现在您希望使用组特征来排序行时。以下示例使用
    `driver_log` 表来说明这一点。以下查询通过ID列对表进行排序，该列存在于行中：
- en: '[PRE71]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: But what if you want to display a list and sort it on the basis of a summary
    value not present in the rows? That’s a little trickier. Suppose that you want
    to show each driver’s rows by date, but place those drivers who drive the most
    miles first. You can’t do this with a summary query because then you wouldn’t
    get back the individual driver rows. But you can’t do it without a summary query,
    either, because the summary values are required for sorting. The way out of the
    dilemma is to create another table containing the summary value per driver and
    join it to the original table. That way you can produce the individual rows and
    also sort them by the summary values.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想显示一个列表并根据行中不存在的汇总值对其进行排序，那就有点棘手了。假设您想按日期显示每个司机的行，但要先显示驾驶里程最多的司机。您无法使用汇总查询来实现这一点，因为那样您将无法获得单个司机的行。但是，如果没有汇总查询，也无法实现，因为排序需要汇总值。摆脱困境的方法是创建另一个表，其中包含每个司机的汇总值，并将其与原始表连接。这样，您可以生成单个行，并根据汇总值对它们进行排序。
- en: 'To summarize the driver totals into another table, do this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要将司机总计汇总到另一个表中，请执行以下操作：
- en: '[PRE72]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'That produces the values we need to put the names in the proper total-miles
    order:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生我们需要按正确总英里数排序名称的值：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then use the `name` values to join the summary table to the `driver_log` table,
    and use the `driver_miles` values to sort the result:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`name`值将汇总表连接到`driver_log`表，并使用`driver_miles`值对结果进行排序：
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding statement shows the mileage totals in the result. That’s only
    to clarify how the values are being sorted. It’s not actually necessary to display
    them; they’re needed only for the `ORDER` `BY` clause.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明显示了结果中的英里总数。这只是为了澄清数值如何排序。实际上并不需要显示它们；它们只需要用于`ORDER BY`子句。
- en: 'To avoid using the temporary table, use a CTE:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用临时表，可以使用CTE：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Alternatively, select the same rows using a subquery in the `FROM` clause:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`FROM`子句中使用子查询选择相同的行：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 16.10 Joining Results of Multiple Queries
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.10 连接多个查询的结果
- en: Problem
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to join results of two or more queries.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望连接两个或多个查询的结果。
- en: Solution
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Run the queries and store results in the temporary tables, then access those
    temporary tables to obtain final result. Or, use named subqueries, then join their
    results. Or, use our favorite method: CTEs that will help you to perform this
    task in the easiest and clear manner.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 运行查询并将结果存储在临时表中，然后访问这些临时表以获取最终结果。或者，使用命名子查询，然后连接它们的结果。或者，使用我们最喜欢的方法：使用CTE以最简单和清晰的方式执行此任务。
- en: Discussion
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: You may need to join not only tables but results of other queries. Assume you
    are working with tables `city` and `states` from the `recipes` distribution, and
    want to find capital names of the states that belong to the 10 states with the
    highest population. At the same time, you want to include into your search results
    only those states where the largest city is the same as the capital.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不仅需要连接表，还需要连接其他查询的结果。假设您正在使用`recipes`分发中的`city`和`states`表，并希望找到属于人口最多的10个州的首府名称。同时，您希望仅将最大城市与首府相同的州包含在搜索结果中。
- en: 'This task is very easy to solve if you first split it into three parts:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务如果你首先将其分解为三个部分，非常容易解决：
- en: 'Find all states where the capital and the largest city are the same. You can
    do it with a query:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找所有首府和最大城市相同的州。可以通过以下查询完成：
- en: '[PRE77]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Find 10 states with the highest population:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出人口最多的10个州：
- en: '[PRE78]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Join the results to select rows that exist in both.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接结果以选择存在于两者中的行。
- en: 'There are three ways to do this: by creating intermediate temporary tables,
    by joining subquery results, and by using CTEs.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以做到这一点：通过创建中间临时表、通过连接子查询结果以及使用CTE。
- en: Using Intermediate Temporary Tables
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用中间临时表
- en: Store results of the queries into temporary tables, then select from them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询结果存储到临时表中，然后从中选择。
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Tip
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Keyword `TEMPORARY` for the `CREATE TABLE` statement instructs MySQL to create
    a table, visible for the current session only and which will be destroyed after
    you close the session. See [Recipe 6.3](ch06.xhtml#nch-tblmgmt-tblmgmt-temp) for
    further details.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`语句中的关键字`TEMPORARY`指示MySQL创建一个表，仅对当前会话可见，会话关闭后将被销毁。有关详细信息，请参见[Recipe
    6.3](ch06.xhtml#nch-tblmgmt-tblmgmt-temp)。'
- en: Using Named Subqueries
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名子查询
- en: If you only need to access the intermediate results once, you can avoid creating
    temporary tables by using subqueries and joining their results.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只需要访问一次中间结果，可以通过使用子查询和连接它们的结果来避免创建临时表。
- en: '[PRE80]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[![1](Images/1.png)](#co_nch-multi-multi-subquery-join-outer_co)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_nch-multi-multi-subquery-join-outer_co)'
- en: Start the query from selecting columns you need in the final result
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从选择最终结果中所需的列开始查询
- en: '[![2](Images/2.png)](#co_nch-multi-multi-subquery-join-lc_co)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_nch-multi-multi-subquery-join-lc_co)'
- en: Put the first subquery into brackets and assign it a unique name.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个子查询放入括号中，并分配一个唯一名称。
- en: '[![3](Images/3.png)](#co_nch-multi-multi-subquery-join-ts_co)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_nch-multi-multi-subquery-join-ts_co)'
- en: Do the same for the second subquery.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个子查询执行相同操作。
- en: '[![4](Images/4.png)](#co_nch-multi-multi-subquery-join-where_co)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_nch-multi-multi-subquery-join-where_co)'
- en: Narrow the search with clause `WHERE`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WHERE`子句缩小搜索范围。
- en: Using Common Table Expressions (CTEs)
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通用表达式（CTEs）
- en: With CTEs start by naming your subqueries, then join their results like if they
    were regular MySQL tables.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CTEs首先为您的子查询命名，然后像处理常规MySQL表一样连接它们的结果。
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 16.11 Referring to Join Output Column Names in Programs
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16.11 在程序中引用连接输出列名
- en: Problem
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to process the result of a join from within a program, but column names
    in the result set aren’t unique.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在程序内部处理连接的结果，但结果集中的列名不唯一。
- en: Solution
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Rewrite the query using column aliases so that each column has a unique name.
    Alternatively, refer to the columns by position.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 重写查询，使用列别名使每列具有唯一名称。或者，按位置引用列。
- en: Discussion
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Joins typically retrieve columns from related tables and it’s not unusual for
    columns selected from different tables to have the same names. Consider the following
    join that shows the items in your art collection. For each painting, it displays
    artist name, painting title, the state in which you acquired the item, and its
    price:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 连接通常从相关表中检索列，并且从不同表中选择的列具有相同的名称并不罕见。考虑以下显示艺术品收藏中项目的联接的情况。对于每幅绘画，它显示艺术家姓名，绘画标题，您获取项目的州份及其价格：
- en: '[PRE82]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The statement uses table qualifiers for each output column, but MySQL doesn’t
    include table names in the column headings, so not all column names in the output
    are distinct. If you process the join result from within a program and fetch rows
    into a data structure that references column values by name, nonunique column
    names cause values to become inaccessible. Suppose that you fetch rows in a Perl
    DBI script like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句对每个输出列使用表限定符，但MySQL不包括表名在列标题中，因此输出中并非所有列名都是唯一的。如果在程序中处理连接结果，并将行提取到引用列值的数据结构中，非唯一列名会导致值无法访问。假设您在Perl
    DBI脚本中这样提取行：
- en: '[PRE83]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Fetching rows into the hash yields three hash elements (`name`, `title`, `price`);
    one of the `name` elements is lost. To solve this problem, supply aliases that
    make the column names unique:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将行提取到哈希中产生三个哈希元素（`name`，`title`，`price`）；其中一个`name`元素丢失了。为了解决此问题，提供使列名唯一的别名：
- en: '[PRE84]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now fetching rows into a hash yields four hash elements (`painter`, `title`,
    `state`, `price`).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将行提取到哈希中产生四个哈希元素（`painter`，`title`，`state`，`price`）。
- en: 'To address the problem without column renaming, fetch the row into something
    other than a hash. For example, fetch the row into an array and refer to the columns
    by ordinal position within the array:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决不更改列名的问题，将行提取到除哈希之外的其他内容。例如，将行提取到数组中，并按数组中的序数位置引用列：
- en: '[PRE85]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
