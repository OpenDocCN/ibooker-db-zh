# 第一部分：存储引擎

任何数据库管理系统的主要工作是可靠地存储数据并使其对用户可用。我们使用数据库作为数据的主要来源，帮助我们在应用程序的不同部分之间共享数据。我们不必在每次创建新应用程序时找到存储和检索信息的方法，也不必发明新的数据组织方式，而是直接使用数据库。这样，我们可以集中精力于应用程序逻辑，而不是基础设施。

由于术语*数据库管理系统*（DBMS）相当庞大，在本书中，我们使用更紧凑的术语，*数据库系统* 和 *数据库*，来指代相同的概念。

数据库是模块化系统，由多个部分组成：接受请求的传输层，确定运行查询最有效方法的查询处理器，执行操作的执行引擎，以及存储引擎（见“数据库管理系统架构”）。

*存储引擎*（或数据库引擎）是数据库管理系统的软件组件，负责在内存和磁盘上存储、检索和管理数据，旨在捕获每个节点的持久、长期内存[[REED78]](app01.html#REED78)。虽然数据库可以响应复杂的查询，但存储引擎更细粒度地查看数据，并提供简单的数据操作 API，允许用户创建、更新、删除和检索记录。可以这样看待：数据库管理系统是构建在存储引擎之上的应用程序，提供了模式、查询语言、索引、事务和许多其他有用的功能。

为了灵活性，键和值都可以是任意字节序列，没有规定的形式。它们的排序和表示语义由更高级别的子系统定义。例如，您可以在一张表中使用`int32`（32 位整数）作为键，而在另一张表中使用`ascii`（ASCII 字符串）作为键；从存储引擎的角度来看，这些键都只是序列化的条目。

诸如[BerkeleyDB](https://databass.dev/links/92)，[LevelDB](https://databass.dev/links/93)及其后代[RocksDB](https://databass.dev/links/94)，[LMDB](https://databass.dev/links/95)及其后代[libmdbx](https://databass.dev/links/96)，[Sophia](https://databass.dev/links/97)，[HaloDB](https://databass.dev/links/98)等存储引擎最初独立于现在嵌入到的数据库管理系统中进行开发。使用可插拔的存储引擎使得数据库开发人员能够使用现有的存储引擎引导数据库系统，并专注于其他子系统。

同时，数据库系统组件之间的清晰分离为切换不同引擎（可能更适合特定用例）开辟了机会。例如，MySQL，一个流行的数据库管理系统，有几个[存储引擎](https://databass.dev/links/99)，包括 InnoDB、MyISAM 以及[RockDB](https://databass.dev/links/100)（在[MyRocks](https://databass.dev/links/101)分发中）。MongoDB 允许在[WiredTiger](https://databass.dev/links/102)、In-Memory 和（现已不推荐使用的）[MMAPv1](https://databass.dev/links/103)存储引擎之间切换。

## 第一部分 比较数据库

您选择的数据库系统可能会产生长期后果。如果存在某个数据库由于性能问题、一致性问题或操作挑战而不适合的可能性，最好在开发周期的早期了解这一点，因为迁移到不同系统可能是非平凡的。在某些情况下，可能需要对应用程序代码进行重大更改。

每个数据库系统都有其优点和缺点。为了减少昂贵迁移的风险，在决定特定数据库之前，可以投入一些时间来增强对其满足应用需求能力的信心。

基于它们的组件（例如使用哪种存储引擎、数据如何共享、复制和分布等）、它们的排名（由咨询机构如[ThoughtWorks](https://www.thoughtworks.com/de/radar)或数据库比较网站如[DB-Engines](https://db-engines.com/de/ranking)或[Database of Databases](https://dbdb.io)分配的任意流行度值）或实现语言（C++、Java 或 Go 等）来比较数据库可能导致无效和过早的结论。这些方法仅适用于高级别比较，并且可能像在 HBase 和 SQLite 之间选择一样粗略，因此即使对每个数据库的工作原理和内部结构有一些肤浅的理解，也有助于得出更加权衡的结论。

每次比较都应从明确定义目标开始，因为即使有轻微偏见，也可能完全无效整个调查。如果您正在寻找一个适合您拥有的工作负载（或计划促进的工作负载）的数据库，您可以做的最好的事情是模拟这些工作负载针对不同的数据库系统，测量对您重要的性能指标，并进行比较结果。一些问题，特别是当涉及性能和可伸缩性时，只有在一段时间后或容量增长时才会显现出来。为了检测潜在问题，最好在尽可能模拟真实生产设置的环境中进行长期运行的测试。

模拟真实世界的工作负载不仅帮助你了解数据库的性能，还帮助你学习如何操作、调试，并发现其社区的友好程度和帮助性。选择数据库始终是这些因素的综合体，并且性能往往并不是最重要的方面：通常最好使用一个数据保存较慢的数据库，而不是一个数据丢失较快的数据库。

要比较数据库，理解用例的细节非常有帮助，并定义当前和预期的变量，例如：

+   模式和记录大小

+   客户端数量

+   查询类型和访问模式

+   读写查询的速率

+   这些变量的预期变化

了解这些变量可以帮助回答以下问题：

+   数据库是否支持所需的查询？

+   这个数据库能处理我们计划存储的数据量吗？

+   单个节点可以处理多少读写操作？

+   系统应该有多少个节点？

+   如何根据预期的增长率扩展集群？

+   维护过程是什么？

有了这些问题的答案，你可以构建一个测试集群并模拟你的工作负载。大多数数据库已经有压力测试工具，可以用来重现特定的使用场景。如果在数据库生态系统中没有标准的压力测试工具来生成真实的随机工作负载，这可能是一个警示信号。如果有什么阻止你使用默认工具，你可以尝试使用现有的通用工具，或者从头开始实现一个。

如果测试显示出积极的结果，熟悉数据库代码可能会有所帮助。查看代码时，通常首先了解数据库的各个部分以及如何查找不同组件的代码，然后浏览这些代码。对数据库代码库有一个大致的概念有助于更好地理解它产生的日志记录、其配置参数，并帮助找出使用它的应用程序甚至数据库代码本身中的问题。

如果我们可以将数据库作为黑盒子使用，并且永远不必查看其内部，那将是很好的。但实践表明，sooner or later，会出现 bug、故障、性能回退或其他问题，最好做好准备。如果你了解并理解数据库的内部机制，可以减少业务风险并提高快速恢复的机会。

用于基准测试、性能评估和比较的流行工具之一是[Yahoo! Cloud Serving Benchmark](https://databass.dev/links/104)（YCSB）。 YCSB 提供了一个框架和一套通用的工作负载，可以应用于不同的数据存储。就像任何通用工具一样，必须谨慎使用此工具，因为很容易得出错误的结论。为了进行公平比较和做出明智的决策，有必要投入足够的时间来了解数据库在必须执行的真实条件下的表现，并相应地调整基准测试。

这并不意味着基准测试仅能用于比较数据库。基准测试还可以用于定义和测试服务级别协议的细节，理解系统需求，进行容量规划等等。在使用数据库之前，您对数据库了解得越多，将在生产中运行时节省的时间就越多。

选择数据库是一个长期决策，最好跟踪新发布的版本，了解具体变更及其原因，并制定升级策略。新版本通常包含改进和修复的错误和安全问题，但可能引入新的错误、性能退化或意外行为，因此在推出新版本之前测试是至关重要的。查看数据库实施者如何处理以前的升级可能会给您一个关于未来预期的好主意。过去的平稳升级并不保证未来的升级也会顺利进行，但过去复杂的升级可能表明未来的升级也不会轻松。

## 第一部分：理解权衡

作为用户，我们可以看到数据库在不同条件下的行为，但在处理数据库时，我们必须做出直接影响这种行为的选择。

设计存储引擎绝对比简单地实现教科书数据结构复杂得多：有很多细节和边缘情况从一开始就很难做到正确。我们需要设计物理数据布局和组织指针，决定序列化格式，理解数据如何进行垃圾回收，存储引擎如何完全适配数据库系统的语义，找出如何在并发环境中使其工作，并确保在任何情况下都不会丢失任何数据。

不仅需要做出许多决策，而且大多数决策都涉及权衡。例如，如果我们按照插入到数据库中的顺序保存记录，我们可以更快地存储它们，但如果我们按字典顺序检索它们，我们必须在返回结果给客户端之前重新排序它们。正如您将在本书中看到的那样，存储引擎设计有许多不同的方法，每种实现都有其优缺点。

在查看不同的存储引擎时，我们讨论它们的优点和缺点。如果每种情况下都有绝对最优的存储引擎，那么每个人都会选择使用它。但由于这种情况不存在，我们需要根据工作负载和使用情况来明智选择。

存储引擎有很多种，使用各种数据结构，用不同的语言实现，从低级语言如 C，到高级语言如 Java。所有存储引擎面临相同的挑战和限制。为了与城市规划作类比，可以为特定人口建造城市，并选择向*上*建造或向*外*扩展。在这两种情况下，同样数量的人可以适应城市，但这些方法会导致完全不同的生活方式。向上建造城市时，人们住在公寓里，人口密度可能导致更小区域内的更多交通；在更分散的城市中，人们更可能住在房子里，但通勤需要覆盖更大的距离。

类似地，存储引擎开发人员的设计决策使它们更适合不同的用途：有些优化于低读写延迟，有些试图最大化密度（每个节点存储的数据量），有些集中于操作简单性。

您可以在章节摘要中找到完整的用于实施和其他额外参考资料的算法。阅读本书应使您能够有效地与这些资源合作，并对已描述概念的现有替代方案有深入的理解。

^(1) 服务级别协议（SLA）是服务提供商对所提供服务质量的承诺。除其他事项外，SLA 可以包括有关延迟、吞吐量、抖动以及故障次数和频率的信息。
