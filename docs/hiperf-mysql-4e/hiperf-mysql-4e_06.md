# 第六章：模式设计与管理

良好的逻辑和物理设计是高性能的基石，您必须为您将运行的特定查询设计模式。这通常涉及权衡。例如，反规范化的模式可以加快某些类型的查询，但会减慢其他查询。添加计数器和汇总表是优化查询的好方法，但维护它们可能很昂贵。MySQL 的特定功能和实现细节在很大程度上影响这一点。

同样，您的模式将随着时间的推移而发展—这是由于您了解如何存储和访问数据以及您的业务需求随时间变化的结果。这意味着您应该计划模式更改作为频繁事件。在本章后面，我们将指导您如何避免这一活动成为组织的运营瓶颈。

本章节以及接下来专注于索引的章节，涵盖了 MySQL 特定的模式设计部分。我们假设您知道如何设计数据库，因此这不是一个介绍性的章节，甚至不是一个关于数据库设计的高级章节。作为一章关于 MySQL 数据库设计的章节，它关于在使用 MySQL 而不是其他关系数据库管理系统（RDBMS）设计数据库时有何不同。如果您需要学习数据库设计的基础知识，我们建议阅读 Clare Churcher 的书籍*Beginning Database Design*（Apress）。

本章是接下来两章的准备。在这三章中��我们将探讨逻辑设计、物理设计和查询执行的互动。这需要一个全局的方法以及对细节的关注。您需要了解整个系统，以了解每个部分如何影响其他部分。在阅读关于索引的第七章和关于查询优化的第八章之后，您可能会发现重新阅读本章很有用。许多讨论的主题不能孤立考虑。

# 选择最佳数据类型

MySQL 支持各种各样的数据类型，选择正确的类型来存储您的数据对于获得良好的性能至关重要。以下简单的准则可以帮助您做出更好的选择，无论您存储的是什么类型的数据：

通常情况下，较小的通常更好

一般来说，尽量使用可以正确存储和表示您的数据的最小数据类型。较小的数据类型通常更快，因为它们在磁盘、内存和 CPU 缓存中占用的空间更少。它们通常也需要更少的 CPU 周期来处理。

但是，请确保不要低估您需要存储的值的范围，因为在模式的多个位置增加数据类型范围可能是一个痛苦且耗时的操作。如果您对使用哪种数据类型最好感到犹豫，请选择您认为不会超出的最小数据类型。（如果系统不是非常繁忙或存储的数据不多，或者如果您处于设计过程的早期阶段，您可以稍后轻松更改。）

简单就是好

处理简单数据类型通常需要较少的 CPU 周期。例如，整数比字符更便宜，因为字符集和排序规则使字符比较复杂。以下是两个例子：您应该将日期和时间存储在 MySQL 的内置类型中，而不是作为字符串，您应该使用整数存储 IP 地址。我们稍后会进一步讨论这些主题。

尽量避免`NULL`

许多表包括可空列，即使应用程序不需要存储`NULL`（值的缺失），仅仅因为这是默认值。通常最好将列指定为`NOT NULL`，除非您打算在其中存储`NULL`。对于引用可空列的查询，MySQL 更难优化，因为它们使索引、索引统计信息和值比较变得更加复杂。可空列使用更多的存储空间，并且需要 MySQL 内部的特殊处理。将`NULL`列更改为`NOT NULL`的性能改进通常很小，因此除非知道它们会引起问题，否则不要将其视为现有模式中要查找和更改的优先事项。

决定为给定列使用什么数据类型的第一步是确定适当的一般类型类别：数字、字符串、时间戳。这通常很简单，但我们提到了一些选择不直观的特殊情况。

下一步是选择具体类型。MySQL 的许多数据类型可以存储相同类型的数据，但在它们可以存储的值范围、允许的精度或所需的物理空间（在磁盘和内存中）方面有所不同。一些数据类型还具有特殊的行为或属性。

例如，`DATETIME`和`TIMESTAMP`列可以存储相同类型的数据：日期和时间，精确到一秒。然而，`TIMESTAMP`仅使用一半的存储空间，具有时区感知能力，并具有特殊的自动更新功能。另一方面，它的可允许值范围要小得多，有时其特殊功能可能成为一种障碍。

我们在这里讨论基本数据类型。MySQL 支持许多别名以实现兼容性，例如`INTEGER`（映射到`INT`）、`BOOL`（映射到`TINYINT`）和`NUMERIC`（映射到`DECIMAL`）。这些只是别名。它们可能会让人困惑，但不会影响性能。如果您使用别名数据类型创建表，然后检查`SHOW CREATE TABLE`，您会看到 MySQL 报告基本类型，而不是您使用的别名。

## 整数

有两种数字：整数和实数（带有小数部分的数字）。如果您要存储整数，请使用整数类型之一：`TINYINT`、`SMALLINT`、`MEDIUMINT`、`INT`或`BIGINT`。它们分别需要 8、16、24、32 和 64 位的存储空间。它们可以存储从−2^(`(N – 1)`)到 2^(`(N – 1)`) `−` 1 的值，其中*N*是它们使用的存储空间的位数。

整数类型可以选择具有`UNSIGNED`属性，该属性不允许负值，并且可以将您可以存储的正值的上限大约加倍。例如，`TINYINT UNSIGNED`可以存储范围从 0 到 255 的值，而不是从−128 到 127。

有符号和无符号类型使用相同的存储空间并具有相同的性能，因此使用适合您数据范围的类型。

您的选择决定了 MySQL 如何*存储*数据，无论是在内存中还是在磁盘上。然而，整数计算通常使用 64 位的`BIGINT`整数。（有一些聚合函数的例外，它们使用`DECIMAL`或`DOUBLE`执行计算。）

MySQL 允许您为整数类型指定“宽度”，例如`INT(11)`。对于大多数应用程序来说，这是没有意义的：它不限制合法值的范围，而只是指定 MySQL 交互工具（如命令行客户端）为显示目的保留的字符数。对于存储和计算目的，`INT(1)`与`INT(20)`是相同的。

## 实数

实数是具有小数部分的数字。但它们不仅仅适用于小数；您还可以使用`DECIMAL`存储太大以至于不适合`BIGINT`的整数。MySQL 支持精确和不精确类型。

`FLOAT` 和 `DOUBLE` 类型支持使用标准浮点数运算进行近似计算。如果您需要准确了解浮点数结果是如何计算的，您需要研究您平台的浮点数实现。

您可以通过几种方式指定浮点列的所需精度，这可能会导致 MySQL 在存储值时选择不同的数据类型或在存储值时对其进行四舍五入。这些精度限定符是非标准的，因此我们建议您指定您想要的类型，但不指定精度。

浮点类型通常使用比`DECIMAL`更少的空间来存储相同范围的值。`FLOAT`列使用 4 个字节的存储空间。`DOUBLE`使用 8 个字节，具有比`FLOAT`更高的精度和更大的值范围。与整数一样，您只是选择存储类型；MySQL 在浮点类型的内部计算中使用`DOUBLE`。

由于额外的空间要求和计算成本，仅当您需要对分数进行精确计算时才应使用`DECIMAL`，例如，当存储财务数据时。但在某些高交易量情况下，实际上更合理的是使用`BIGINT`，并将数据存储为您需要处理的最小货币分数的某个倍数。假设您需要将财务数据存储到千分之一美分。您可以将所有美元金额乘以一百万，并将结果存储在`BIGINT`中，避免浮点存储的不精确性和精确`DECIMAL`数学的成本。

## 字符串类型

MySQL 支持多种字符串数据类型，每种类型都有许多变体。每个字符串列都可以有自己的字符集和该字符集的排序规则，或者排序规则。

### `VARCHAR` 和 `CHAR` 类型

两种主要的字符串类型是`VARCHAR`和`CHAR`，它们存储字符值。不幸的是，很难准确解释这些值在磁盘和内存中是如何存储的，因为实现取决于存储引擎。我们假设您正在使用 InnoDB；如果不是，请阅读您存储引擎的文档。

让我们看看`VARCHAR`和`CHAR`值通常是如何存储在磁盘上的。请注意，存储引擎可能会以不同于内存中存储`CHAR`或`VARCHAR`值的方式来存储该值在磁盘上的方式，并且服务器在从存储引擎检索值时可能会将该值转换为另一种存储格式。以下是这两种类型的一般比较：

`VARCHAR`

`VARCHAR` 存储可变长度的字符字符串，是最常见的字符串数据类型。它可能需要比固定长度类型更少的存储空间，因为它只使用所需的空间（即，存储较短值时使用的空间较少）。

`VARCHAR` 使用 1 或 2 个额外字节来记录值的长度：如果列的最大长度为 255 字节或更少，则使用 1 个字节，如果超过 255 字节，则使用 2 个字节。假设使用`latin1`字符集，`VARCHAR(10)`将使用最多 11 个字节的存储空间。`VARCHAR(1000)`最多可以使用 1,002 个字节，因为它需要 2 个字节来存储长度信息。

`VARCHAR` 有助于性能，因为它节省空间。但是，由于行是可变长度的，当您更新它们时，它们可能会增长，这可能会导致额外的工作。如果一行增长并且不再适合其原始位置，则行为取决于存储引擎。例如，InnoDB 可能需要拆分页面以将行放入其中。其他存储引擎可能根本不会在原地更新数据。

当最大列长度远大于平均长度时，很少更新字段，因此碎片化不是问题时，以及使用复杂字符集（如 UTF-8）时，通常值得使用`VARCHAR`。

对于 InnoDB 来说情况就比较棘手了，它可以将长`VARCHAR`值存储为 BLOB。我们稍后会讨论这个问题。

`CHAR`

`CHAR` 是固定长度的：MySQL 总是为指定数量的字符分配足够的空间。在存储 `CHAR` 值时，MySQL 会移除任何尾随空格。根据需要填充值以进行比较。

如果您希望存储非常短的字符串或所有值几乎相同长度，则 `CHAR` 是一个不错的选择。例如，对于用户密码的 `MD5` 值，它们始终是相同长度，`CHAR` 是一个不错的选择。对于经常更改的数据，`CHAR` 也比 `VARCHAR` 更好，因为固定长度的行不容易出现碎片化。对于非常短的列，`CHAR` 也比 `VARCHAR` 更有效率；一个设计为仅容纳 `Y` 和 `N` 值的 `CHAR(1)` 在单字节字符集中只会使用 1 个字节，但 `VARCHAR(1)` 会使用 2 个字节，因为长度字节。

这种行为可能有点令人困惑，因此我们将通过一个示例来说明。首先，我们创建一个具有单个 `CHAR(10)` 列的表，并将一些值存储在其中：

```sql
mysql> CREATE TABLE char_test( char_col CHAR(10));
mysql> INSERT INTO char_test(char_col) VALUES
    -> ('string1'), (' string2'), ('string3 ');

```

当我们检索这些值时，尾随空格已被去除：

```sql
mysql> SELECT CONCAT("'", char_col, "'") FROM char_test;
+----------------------------+
| CONCAT("'", char_col, "'") |
+----------------------------+
| 'string1'                  |
| ' string2'                 |
| 'string3'                  |
+----------------------------+
```

如果我们将相同的值存储在 `VARCHAR(10)` 列中，我们在检索时会得到以下结果，其中 `string3` 上的尾随空格未被移除：

```sql
mysql> SELECT CONCAT("'", varchar_col, "'") FROM varchar_test;
+-------------------------------+
| CONCAT("'", varchar_col, "'") |
+-------------------------------+
| 'string1'                     |
| ' string2'                    |
| 'string3 '                    |
+-------------------------------+
```

`CHAR` 和 `VARCHAR` 的兄弟类型是 `BINARY` 和 `VARBINARY`，它们存储二进制字符串。二进制字符串与传统字符串非常相似，但它们存储的是字节而不是字符。填充也不同：MySQL 使用 `\0`（零字节）而不是空格填充 `BINARY` 值，并且在检索时不会去除填充值。

当您需要存储二进制数据并希望 MySQL 将值作为字节而不是字符进行比较时，这些类型非常有用。按字节进行比较的优势不仅仅是大小写不敏感的问题。MySQL 实际上是逐个字节比较 `BINARY` 字符串，根据每个字节的数值进行比较。因此，二进制比较比字符比较要简单得多，因此更快。

### BLOB 和 TEXT 类型

`BLOB` 和 `TEXT` 是设计用于分别存储大量数据的字符串数据类型，作为二进制或字符字符串。

实际上，它们各自是数据类型系列：字符类型有 `TINYTEXT`、`SMALLTEXT`、`TEXT`、`MEDIUMTEXT` 和 `LONGTEXT`，而二进制类型有 `TINYBLOB`、`SMALLBLOB`、`BLOB`、`MEDIUMBLOB` 和 `LONGBLOB`。`BLOB` 是 `SMALLBLOB` 的同义词，`TEXT` 是 `SMALLTEXT` 的同义词。

与所有其他数据类型不同，MySQL 将每个 `BLOB` 和 `TEXT` 值视为具有自己身份的对象。存储引擎通常会对它们进行特殊存储；当它们很大时，InnoDB 可能会为它们使用单独的“外部”存储区域。每个值在行中需要占用 1 到 4 个字节的存储空间，并且在外部存储中需要足够的空间来实际保存该值。

`BLOB` 和 `TEXT` 族之间唯一的区别是，`BLOB` 类型存储没有排序规则或字符集的二进制数据，而 `TEXT` 类型具有字符集和排序规则。

MySQL 对 `BLOB` 和 `TEXT` 列的排序与其他类型不同：它只对这些列的前 `max_sort_length` 字节进行排序，而不是对整个字符串进行排序。如果需要按照前几个字符进行排序，可以减少 `max_sort_length` 服务器变量。

MySQL 无法对这些数据类型的完整长度进行索引，也无法使用索引进行排序。

### 使用 ENUM 而不是字符串类型

有时您可以使用 `ENUM` 列代替传统的字符串类型。`ENUM` 列可以存储一组预定义的不同字符串值。MySQL 将它们非常紧凑地存储在 1 或 2 个字节中，具体取决于列表中值的数量。它将每个值内部存储为表示其在字段定义列表中位置的整数。以下是一个示例：

```sql
mysql> CREATE TABLE enum_test(
    -> e ENUM('fish', 'apple', 'dog') NOT NULL
    -> );
mysql> INSERT INTO enum_test(e) VALUES('fish'), ('dog'), ('apple');

```

这三行实际上存储的是整数，而不是字符串。您可以在数字上下文中检索它们，看到值的双重性质：

```sql
mysql> SELECT e + 0 FROM enum_test;
+-------+
| e + 0 |
+-------+
|     1 |
|     3 |
|     2 |
+-------+
```

如果您为 `ENUM` 常量指定数字，例如 `ENUM('1', '2', '3')`，这种二义性可能会让人困惑。我们建议您不要这样做。

另一个令人惊讶的是，`ENUM` 字段按内部整数值排序，而不是按字符串本身排序：

```sql
mysql> SELECT e FROM enum_test ORDER BY e;
+-------+
| e     |
+-------+
| fish  |
| apple |
| dog   |
+-------+
```

您可以通过按照希望排序的顺序指定 `ENUM` 成员来解决此问题。您还可以在查询中明确指定排序顺序使用 `FIELD()`，但这会阻止 MySQL 使用索引进行排序：

```sql
mysql> SELECT e FROM enum_test ORDER BY FIELD(e, 'apple', 'dog', 'fish');
+-------+
| e     |
+-------+
| apple |
| dog   |
| fish  |
+-------+
```

如果我们按字母顺序定义值，我们就不需要这样做了。

因为 MySQL 将每个值存储为整数并必须进行查找以将其转换为其字符串表示形式，所以 `ENUM` 列具有一些开销。通常，它们的较小大小可以抵消这种开销，但并非总是如此。特别是，将 `CHAR` 或 `VARCHAR` 列连接到 `ENUM` 列可能比连接到另一个 `CHAR` 或 `VARCHAR` 列慢。

为了说明，我们对我们的一个应用程序中的表执行了 MySQL 执行此类连接的速度基准测试。该表具有相当宽的主键：

```sql
CREATE TABLE webservicecalls (
 day date NOT NULL,
 account smallint NOT NULL,
 service varchar(10) NOT NULL,
 method varchar(50) NOT NULL,
 calls int NOT NULL,
 items int NOT NULL,
 time float NOT NULL,
 cost decimal(9,5) NOT NULL,
 updated datetime,
 PRIMARY KEY (day, account, service, method)
) ENGINE=InnoDB;
```

该表包含约 110,000 行，仅约 10 MB，因此完全适合内存。`service` 列包含 5 个不同的值，平均长度为 4 个字符，而 `method` 列包含 71 个值，平均长度为 20 个字符。

我们复制了此表，并将 `service` 和 `method` 列转换为 `ENUM`，如下所示：

```sql
CREATE TABLE webservicecalls_enum (
 ... omitted ...
 service ENUM(...values omitted...) NOT NULL,
 method ENUM(...values omitted...) NOT NULL,
 ... omitted ...
) ENGINE=InnoDB;
```

然后，我们通过主键列测量了连接表的性能。以下是我们使用的查询：

```sql
mysql> SELECT SQL_NO_CACHE COUNT(*)
    -> FROM webservicecalls
    -> JOIN webservicecalls USING(day, account, service, method);

```

我们修改了此查询以连接不同组合的 `VARCHAR` 和 `ENUM` 列。表 6-1 显示了结果。³

表 6-1\. 连接 `VARCHAR` 和 `ENUM` 列的速度

| 测试 | 每秒查询数 |
| --- | --- |
| `VARCHAR` 连接到 `VARCHAR` | 2.6 |
| `VARCHAR` 连接到 `ENUM` | 1.7 |
| `ENUM` 连接到 `VARCHAR` | 1.8 |
| `ENUM` 连接到 `ENUM` | 3.5 |

在将列转换为 `ENUM` 后，连接速度更快，但将 `ENUM` 列连接到 `VARCHAR` 列则较慢。在这种情况下，转换这些列看起来是一个好主意，只要它们不必连接到 `VARCHAR` 列。在设计中，通常使用“查找表”与整数主键来避免在连接中使用基于字符的值。

然而，将列转换为 `ENUM` 还有另一个好处：根据 `SHOW TABLE STATUS` 中的 `Data_length` 列，将这两列转换为 `ENUM` 使表的大小减小了约三分之一。在某些情况下，即使 `ENUM` 列必须连接到 `VARCHAR` 列，这也可能是有益的。此外，转换后的主键本身大小仅为转换前的一半。由于这是一个 InnoDB 表，如果此表上有其他索引，减小主键大小也会使它们变得更小。

###### 警告

虽然 `ENUM` 类型在存储值方面非常高效，但更改可以在 `ENUM` 中的有效值总是需要模式更改。如果您尚未拥有像我们稍后在本章中描述的自动化模式更改的强大系统，这种操作需求可能会成为一个主要不便，如果您的 `ENUM` 经常更改。我们稍后还会提到模式设计中的“太多 `ENUM`”反模式。

## 日期和时间类型

MySQL 有许多类型用于各种日期和时间值，例如 `YEAR` 和 `DATE`。MySQL 可以存储的时间的最细粒度是微秒。大多数时间类型没有替代方案，因此没有哪一个是最佳选择的问题。唯一的问题是当您需要同时存储日期和时间时该怎么办。MySQL 为此目的提供了两种非常相似的数据类型：`DATETIME` 和 `TIMESTAMP`。对于许多应用程序，任何一个都可以工作，但在某些情况下，一个比另一个更好。让我们来看一下：

`DATETIME`

这种类型可以存储大范围的值，从公元 1000 年到公元 9999 年，精度为一微秒。它将日期和时间打包成一个整数，格式为 YYYYMMDDHHMMSS，与时区无关。这使用了 8 个字节的存储空间。

默认情况下，MySQL 以可排序、明确的格式显示`DATETIME`值，例如 2008-01-16 22:37:08。这是表示日期和时间的 ANSI 标准方式。

`TIMESTAMP`

如其名称所示，`TIMESTAMP`类型存储了自 1970 年 1 月 1 日格林尼治时间（GMT）午夜以来经过的秒数，与 Unix 时间戳相同。`TIMESTAMP`只使用 4 个字节的存储空间，因此其范围比`DATETIME`要小得多：从 1970 年到 2038 年 1 月 19 日。MySQL 提供了`FROM_UNIXTIME()`和`UNIX_TIMESTAMP()`函数来将 Unix 时间戳转换为日期，反之亦然。

`TIMESTAMP`显示的值也取决于时区。MySQL 服务器、操作系统和客户端连接都有时区设置。

因此，存储值`0`的`TIMESTAMP`实际上显示为 1969-12-31 19:00:00 在东部标准时间（EST），它与 GMT 相差五个小时。值得强调的是：如果你从多个时区存储或访问数据，`TIMESTAMP`和`DATETIME`的行为将会有很大的不同。前者保留相对于使用的时区的值，而后者保留日期和时间的文本表示。

`TIMESTAMP`还具有`DATETIME`没有的特殊属性。默认情况下，当你插入一行而没有为第一个`TIMESTAMP`列指定值时，MySQL 会将第一个`TIMESTAMP`列设置为当前时间。MySQL 还默认情况下在更新行时更新第一个`TIMESTAMP`列的值，除非你在`UPDATE`语句中明确赋值。你可以为任何`TIMESTAMP`列配置插入和更新行为。最后，`TIMESTAMP`列默认为`NOT NULL`，这与其他每种数据类型都不同。

## 位压缩数据类型

MySQL 有一些存储类型，使用值内的单个位来紧凑存储数据。所有这些类型在技术上都是字符串类型，无论底层存储格式和操作如何：

`BIT`

你可以使用`BIT`列在单个列中存储一个或多个真/假值。`BIT(1)`定义一个包含单个位的字段，`BIT(2)`存储 2 位，依此类推；`BIT`列的最大长度为 64 位。InnoDB 将每个列存储为足以包含位的最小整数类型，因此你不会节省任何存储空间。

MySQL 将`BIT`视为字符串类型，而不是数值类型。当你检索一个`BIT(1)`值时，结果是一个字符串，但内容是二进制值 0 或 1，而不是 ASCII 值“0”或“1”。但是，如果你在数值上下文中检索值，结果将是位字符串转换为的数字。如果你将值`b'00111001'`（这是 57 的二进制等价值）存储到一个`BIT(8)`列中并检索它，你将得到包含字符代码 57 的字符串。这恰好是 ASCII 字符代码“9”。但在数值上下文中，你将得到值`57`：

```sql
mysql> CREATE TABLE bittest(a bit(8));
mysql> INSERT INTO bittest VALUES(b'00111001');
mysql> SELECT a, a + 0 FROM bittest;
+------+-------+
| a    | a + 0 |
+------+-------+
| 9    |    57 |
+------+-------+
```

这可能会非常令人困惑，因此我们建议您谨慎使用`BIT`。对于大多数应用程序，我们认为最好避免使用这种类型。

如果你想在一个存储空间中存储一个真/假值，另一个选项是创建一个可空的`CHAR(0)`列。这个列可以存储值的缺失（`NULL`）或零长度值（空字符串）。这在实践中是可行的，但可能会让其他人在使用数据库中的数据时感到晦涩，使编写查询变得困难。除非你非常专注于节省空间，否则我们仍建议使用`TINYINT`。

`SET`

如果您需要存储许多真/假值，请考虑将许多列合并为一个列，使用 MySQL 的原生`SET`数据类型，MySQL 在内部表示为一组位的紧凑集合。它使用存储效率高，MySQL 有函数如`FIND_IN_SET()`和`FIELD()`，使其在查询中易于使用。

整数列上的位运算

一个替代`SET`的方法是使用整数作为一组位的紧凑集合。例如，您可以在`TINYINT`中打包 8 位，并使用位运算符进行操作。您可以通过在应用程序代码中为每个位定义命名常量来简化此过程。

与`SET`相比，这种方法的主要优势在于您可以在不使用`ALTER TABLE`的情况下更改字段表示的“枚举”。缺点是您的查询更难编写和理解（当第 5 位设置时意味着什么？）。有些人习惯于位操作，有些人则不习惯，因此您是否想尝试这种技术在很大程度上取决于个人口味。

一个紧凑位的示例应用是存储权限的访问控制列表（ACL）。每个位或`SET`元素代表一个值，例如`CAN_READ`、`CAN_WRITE`或`CAN_DELETE`。如果您使用`SET`列，您将让 MySQL 在列定义中存储位到值的映射；如果您使用整数列，您将在应用程序代码中存储映射。以下是使用`SET`列的查询示例：

```sql
mysql> CREATE TABLE acl (
    -> perms SET('CAN_READ', 'CAN_WRITE', 'CAN_DELETE') NOT NULL
    -> );
mysql> INSERT INTO acl(perms) VALUES ('CAN_READ,CAN_DELETE');
mysql> SELECT perms FROM acl WHERE FIND_IN_SET('CAN_READ', perms);
+---------------------+
| perms               |
+---------------------+
| CAN_READ,CAN_DELETE |
+---------------------+
```

如果您使用整数，可以将该示例写成如下形式：

```sql
mysql> SET @CAN_READ := 1 << 0,
    -> @CAN_WRITE := 1 << 1,
    -> @CAN_DELETE := 1 << 2;
mysql> CREATE TABLE acl (
    -> perms TINYINT UNSIGNED NOT NULL DEFAULT 0
    -> );
mysql> INSERT INTO acl(perms) VALUES(@CAN_READ + @CAN_DELETE);
mysql> SELECT perms FROM acl WHERE perms & @CAN_READ;
+-------+
| perms |
+-------+
| 5     |
+-------+
```

我们使用变量来定义值，但您可以在代码中使用常量代替。

## JSON 数据

越来越普遍地使用 JSON 作为系统之间交换数据的格式。MySQL 有一个原生的 JSON 数据类型，使得直接在表内部操作 JSON 结构的部分变得容易。纯粹主义者可能会建议在数据库中存储原始 JSON 是一种反模式，因为理想情况下，模式是 JSON 中字段的表示。新手可能会看到 JSON 数据类型，并通过避免创建和管理独立字段来看到一条捷径。哪种方法更好在很大程度上是主观的，但我们将客观地通过呈现一个示例用例并比较查询速度和数据大小来进行比较。

我们的示例数据是[由 NASA 提供的发现的 202 个近地小行星和彗��的列表](https://oreil.ly/2oZX9)。测试是在一个四核、16 GB RAM 虚拟机上的 MySQL 8.0.22 上进行的。数据示例：

```sql
 [
   {
      "designation":"419880 (2011 AH37)",
      "discovery_date":"2011-01-07T00:00:00.000",
      "h_mag":"19.7",
      "moid_au":"0.035",
      "q_au_1":"0.84",
      "q_au_2":"4.26",
      "period_yr":"4.06",
      "i_deg":"9.65",
      "pha":"Y",
      "orbit_class":"Apollo"
   }
]
```

这些数据代表了一个指定，发现日期，以及关于实体的收集的数据，包括数字和文本字段。

首先，我们将 JSON 中的数据集转换为每个条目一行。这导致了一个看起来相对简单的模式：

```sql
mysql> DESC asteroids_json;
+-----------+------+------+-----+---------+-------+
| Field     | Type | Null | Key | Default | Extra |
+-----------+------+------+-----+---------+-------+
| json_data | json | YES  |     | NULL    |       |
+-----------+------+------+-----+---------+-------+
```

其次，我们将此 JSON 数据转换为列，使用适当的数据类型进行转换。这导致了以下模式：

```sql
mysql> DESC asteroids_sql;
+----------------+-------------+------+-----+---------+-------+
| Field          | Type        | Null | Key | Default | Extra |
+----------------+-------------+------+-----+---------+-------+
| designation    | varchar(30) | YES  |     | NULL    |       |
| discovery_date | date        | YES  |     | NULL    |       |
| h_mag          | float       | YES  |     | NULL    |       |
| moid_au        | float       | YES  |     | NULL    |       |
| q_au_1         | float       | YES  |     | NULL    |       |
| q_au_2         | float       | YES  |     | NULL    |       |
| period_yr      | float       | YES  |     | NULL    |       |
| i_deg          | float       | YES  |     | NULL    |       |
| pha            | char(3)     | YES  |     | NULL    |       |
| orbit_class    | varchar(30) | YES  |     | NULL    |       |
+----------------+-------------+------+-----+---------+-------+
```

第一个比较是数据大小：

```sql
mysql> SHOW TABLE STATUS\G
*************************** 1\. row ***************************
 Name: asteroids_json
 Engine: InnoDB
 Version: 10
 Row_format: Dynamic
 Rows: 202
 Avg_row_length: 405
 Data_length: 81920
 Max_data_length: 0
 Index_length: 0

*************************** 2\. row ***************************
 Name: asteroids_sql
 Engine: InnoDB
 Version: 10
 Row_format: Dynamic
 Rows: 202
 Avg_row_length: 243
 Data_length: 49152
 Max_data_length: 0
 Index_length: 0
```

我们的 SQL 版本使用了三个 16 KB 页面，而我们的 JSON 版本使用了五个 16 KB 页面。这并不令人感到意外。JSON 数据类型将使用更多空间来存储用于定义 JSON 的额外字符（大括号、方括号、冒号等）以及空格。在这个小例子中，通过将 JSON 转换为特定数据类型，数据存储的大小可以得到改善。

可能存在数据大小不那么重要的有效用例。这两者之间的查询延迟如何？

要在 SQL 中选择单个列的所有内容，我们的语法很简单：

```sql
SELECT designation FROM asteroids_sql;
```

在我们第一次运行此查询时，未被 InnoDB 缓冲池缓存，我们得到了 1.14 毫秒（ms）的结果。第二次执行，将其放入内存中，我们得到了 0.44 毫秒。

对于 JSON，我们能够访问 JSON 结构内的字段：

```sql
SELECT json_data->'$.designation' FROM asteroids_json
```

同样，我们的第一次执行，未缓存，执行时间为 1.13 毫秒。后续执行时间约为 0.80 毫秒。在这个执行速度下，我们预计会有一定的变化——我们在一个虚拟机环境中谈论数百微秒的差异。在我们看来，这两个查询都执行得相当快，尽管值得注意的是 JSON 查询仍然比 SQL 查询长大约两倍。

针对特定行的访问呢？对于单行查找，我们利用使用索引：

```sql
ALTER TABLE asteroids_sql ADD INDEX ( designation );
```

当我们进行单行查找时，我们的 SQL 版本运行时间为 0.33 毫秒，而我们的 JSON 版本运行时间为 0.58 毫秒，给予 SQL 版本优势。这很容易解释：我们的索引允许 InnoDB 返回 1 行而不是 202 行。

将索引查询与全表扫描进行比较是不公平的。为了公平竞争，我们需要使用*生成列*功能提取指定，并创建针对该虚拟生成列的索引：

```sql
ALTER TABLE asteroids_json ADD COLUMN designation VARCHAR(30) GENERATED ALWAYS AS
(json_data->"$.designation"), ADD INDEX ( designation );
```

这给我们的 JSON 表上的模式看起来像这样：

```sql
mysql> DESC asteroids_json;
+-------------+-------------+------+-----+---------+-------------------+
| Field       | Type        | Null | Key | Default | Extra             |
+-------------+-------------+------+-----+---------+-------------------+
| json_data   | json        | YES  |     | NULL    |                   |
| designation | varchar(30) | YES  | MUL | NULL    | VIRTUAL GENERATED |
+-------------+-------------+------+-----+---------+-------------------+
```

我们的模式现在从`json_data`列生成一个虚拟列用于指定，并对其进行索引。现在，我们重新运行我们的单行查找，使用索引列而不是 JSON 列路径运算符(`->`)。由于字段数据在 JSON 中被引用，我们需要在 SQL 中也引用它：

```sql
SELECT * FROM asteroids_json WHERE designation='"(2010 GW62)"';
```

这个查询在 0.4 毫秒内执行，与我们的 SQL 版本 0.33 毫秒相当接近。

从我们之前的简单测试案例中，使用的表空间量似乎是为什么你会使用 SQL 列而不是存储原始 JSON 文档的主要原因。速度仍然比 SQL 列更快。总的来说，选择使用本机 SQL 还是 JSON 取决于在数据库中存储 JSON 的便利性是否超过性能。如果你每天访问这些数据数百万次或数十亿次，速度差异将会累积。

## 选择标识符

一般来说，*标识符*是指引用行的方式，通常也是使其唯一的方式。例如，如果你有一个关于用户的表，你可能想为每个用户分配一个数字 ID 或一个唯一的用户名。这个字段可能是你的`PRIMARY KEY`的一部分或全部。

选择标识符列的良好数据类型非常重要。你更有可能将这些列与其他值进行比较（例如，在连接中），并将它们用于查找而不是其他列。你还可能在其他表中将它们用作外键，因此当你为标识符列选择数据类型时，你可能也在相关表中选择该类型。（正如我们在本章前面演示的那样，最好在相关表中使用相同的数据类型，因为你可能会用它们进行连接。）

在选择标识符列的类型时，你需要考虑的不仅是存储类型，还有 MySQL 如何在该类型上执行计算和比较。例如，MySQL 在内部将`ENUM`和`SET`类型存储为整数，但在字符串上下文中进行比较时将它们转换为字符串。

一旦选择了类型，请确保在所有相关表中使用相同的类型。类型应完全匹配，包括`UNSIGNED`等属性。⁵混合不同的数据类型可能会导致性能问题��即使没有问题，隐式类型转换在比较过程中也可能导致难以发现的错误。这些错误甚至可能在很久之后才出现，当你忘记你正在比较不同的数据类型时。

选择可以容纳所需值范围的最小大小，并在必要时留出未来增长的空间。例如，如果你有一个存储美国州名的`state_id`列，你不需要成千上万或数百万的值，所以不要使用`INT`。一个`TINYINT`应该足够，而且比较小 3 个字节。如果你在其他表中将这个值用作外键，3 个字节可能会产生很大的差异。这里我们给出一些建议。

### 整数类型

整数通常是标识符的最佳选择，因为它们快速且可以与`AUTO_INCREMENT`一起使用。`AUTO_INCREMENT`是一个为每一行生成新整数类型的列属性。例如，一个计费系统可能需要为每个客户生成一个新的发票。使用`AUTO_INCREMENT`意味着生成的第一张发票是 1，第二张是 2，依此类推。请注意，你应该确保为你预期的数据增长选择正确的整数大小。有不止一个关于由于意外耗尽整数而导致系统停机的故事。

### ENUM 和 SET

`ENUM`和`SET`类型通常不适合作为标识符的选择，尽管它们可以用于包含状态或“类型”值的静态“定义表”。`ENUM`和`SET`列适合保存像订单状态或产品类型这样的信息。

举个例子，如果你使用`ENUM`字段来定义产品的类型，你可能希望有一个主键为相同`ENUM`字段的查找表。在这种情况下，你会想要将`ENUM`用作标识符，但对于大多数情况，你应该避免这样做。

### 字符串类型

如果可能的话，避免使用字符串类型作为标识符，因为它们占用大量空间，通常比整数类型慢。

你还应该非常小心完全“随机”的字符串，比如由`MD5()`、`SHA1()`或`UUID()`生成的字符串。你用它们生成的每个新值都会以任意方式分布在一个大空间中，这可能会减慢`INSERT`和某些类型的`SELECT`查询：⁶

+   它们会减慢`INSERT`查询，因为插入的值必须放在索引中的随机位置。这会导致页面分裂、随机磁盘访问以及聚集索引碎片化对于聚集存储引擎。

+   它们会减慢`SELECT`查询，因为逻辑上相邻的行在磁盘和内存中会被广泛分散。

+   随机值会导致缓存在所有类型的查询中表现不佳，因为它们破坏了引用局部性，这是缓存工作的方式。如果整个数据集都是“热点”，那么在内存中缓存任何特定部分的数据都没有优势，如果工作集不适合内存，缓存将有很多刷新和未命中。

如果你存储通用唯一标识符（UUID）值，你应该去掉破折号，或者更好的是，使用`UNHEX()`将 UUID 值转换为 16 字节数字，并将其存储在`BINARY(16)`列中。你可以使用`HEX()`函数以十六进制格式检索值。

## 特殊数据类型

有些数据类型与可用的内置类型不直接对应。一个很好的例子是 IPv4 地址。人们经常使用`VARCHAR(15)`列来存储 IP 地址。然而，它们实际上是无符号 32 位整数，而不是字符串。点分四进制表示法只是一种让人类更容易阅读的写法。你应该将 IP 地址存储为无符号整数。MySQL 提供了`INET_ATON()`和`INET_NTOA()`函数来在这两种表示法之间转换。使用无符号 32 位整数，空间使用量从`VARCHAR(15)`的约 16 字节缩减到 4 字节。如果你担心数据库中的可读性，并且不想继续使用函数查看行数据，记住 MySQL 有视图，你可以使用它们更轻松地查看数据。

# MySQL 中的模式设计陷阱

尽管有普遍的好坏设计原则，但也存在由于 MySQL 的实现方式而引起的问题，这意味着你也可能犯 MySQL 特定的错误。本节讨论了我们在 MySQL 模式设计中观察到的问题。这可能有助于你避免这些错误，并选择与 MySQL 特定实现更好配合的替代方案。

## 太多列

MySQL 的存储引擎 API 通过在行缓冲格式中在服务器和存储引擎之间复制行；然后服务器将缓冲区解码为列。将行缓冲区转换为具有解码列的行数据结构可能是昂贵的。InnoDB 的行格式总是需要转换的。这种转换的成本取决于列的数量。当我们调查一个具有极宽表（数百列）的客户的高 CPU 消耗问题时，我们发现这可能会变得昂贵，尽管实际上只使用了少数列。如果您计划使用数百列，请注意服务器的性能特性将有所不同。

## 太多的连接

所谓的实体-属性-值（EAV）设计模式是一个经典的普遍糟糕的设计模式，特别在 MySQL 中效果不佳。MySQL 对于每个连接有 61 个表的限制，而 EAV 数据库需要许多自连接。我们看到许多 EAV 数据库最终超过了这个限制。然而，即使比 61 少得多的连接，规划和优化查询的成本对于 MySQL 来说可能会成为问题。作为一个粗略的经验法则，如果您需要查询以非常快的速度和高并发性执行，最好每个查询有十几个或更少的表。

## 万能的 ENUM

谨防过度使用`ENUM`。这是我们看到的一个例子：

```sql
CREATE TABLE ... (
 country enum(','0','1','2',...,'31')
```

模式中大量使用了这种模式。在任何具有枚举值类型的数据库中，这可能是一个值得怀疑的设计决定，因为它实际上应该是一个整数，可以作为“字典”或“查找”表的外键。

## 伪装的 ENUM

`ENUM`允许列保存来自一组定义值中的一个值。`SET`允许列保存来自一组定义值中的一个或多个值。有时这些可能很容易混淆。这里有一个例子：

```sql
CREATE TABLE ...(
 is_default set('Y','N') NOT NULL default 'N'
```

那几乎肯定应该是一个`ENUM`而不是一个`SET`，假设它不能同时为真和假。

## NULL 并非在这里发明

我们之前提到避免使用`NULL`的好处，确实，我们建议在可能的情况下考虑替代方案。即使您需要在表中存储“无值”事实时，也许您并不需要使用`NULL`。也许您可以使用零、一个特殊值或空字符串代替。

然而，您也可以走向极端。当您需要表示未知值时，不要太害怕使用`NULL`。在某些情况下，使用`NULL`比使用神奇的常量更好。从受限类型的域中选择一个值，比如使用−1 表示未知整数，可能会使您的代码变得复杂，引入错误，并且总体上会搞得一团糟。处理`NULL`并不总是容易的，但通常比其他替代方案更好。

这是我们经常看到的一个例子：

```sql
CREATE TABLE ... (
 dt DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00'
```

那个虚假的全零值可能会引起很多问题。（您可以配置 MySQL 的`SQL_MODE`来禁止无意义的日期，这对于尚未创建满是错误数据的新应用程序来说是一个特别好的做法。）

在相关主题上，MySQL 确实对`NULL`进行索引，而 Oracle 不会在索引中包含非值。

现在我们已经讨论了很多关于数据类型、如何选择它们以及不应该做什么的实用建议，让我们继续讨论另一个好的、迭代的模式设计：模式管理。

# 模式管理

运行模式更改是数据库工程师必须承担的最常见任务之一。当你开始运行数十甚至数百个具有不同业务背景和不断发展功能的数据库实例时，你希望小心处理这些模式更改不会成为整个组织的瓶颈，但仍然安全地进行，并且不会干扰运营。本节将介绍如何将模式更改管理视为“数据存储平台”的一部分，应该指导这一策略的核心价值观，你可以引入哪些工具来实现这一策略，以及如何将其与更大的软件交付生命周期结合起来。

## 模式管理作为数据存储平台的一部分

如果你与任何快速增长组织的工程领导人交谈，你会发现工程师速度和从特性设计到在生产环境中运行的时间是他们优化事项的首要任务。在这种情况下，你在规划规模化管理模式时的任务是不允许模式管理成为一个手动过程，这会成为整个工程组织进展的瓶颈，只有一个或几个人。

### 为成功设置合作团队

随着组织中依赖 MySQL 实例的团队数量增加，你希望始终成为这些团队成功的推动者，而不是他们需要通过才能完成工作的门槛。这也适用于模式更改，这意味着你希望创建一条路径来部署模式更改，而不是“只有数据库团队才能做到”。

### 集成模式管理与持续集成

在我们讨论了一些能够实现规模化模式管理的工具之后，我们将谈论如何将它们与 CI 管道集成。但现在我们想强调的是，如果你从这样一个前提开始，即模式更改将由特性团队而不仅仅是数据库团队来管理，那么你需要尽可能接近这些团队已经部署代码更改的工作流程。[科学已经证明](https://oreil.ly/hozRf)，将模式管理视为代码部署的团队经历了更积极的特性交付过程，并看到团队速度的提高。我们将讨论能够支持这种迭代的工具，考虑到软件交付实践。

### 模式更改的源代码控制

我们都在部署代码时使用源代码控制，对吧？那么为什么不也用于数据库模式应该是什么样子呢？在规模化模式管理的第一步是确保你有支持和跟踪所做更改的源代码控制。这不仅仅是一件好事™，而且在许多情况下，你的合规团队要求这样做，正如你将在第十三章中看到的。让我们来看看一些能够迭代数据库模式的工具。

###### 注意

对于你的组织最大的价值，使用工程团队用于代码部署的相同 CI 工具。

#### 付费选项

过去几年，作为企业工具的数据库模式管理领域发展迅速，特别是对于 MySQL 安装的支持增加。如果你正在寻找一个现成的解决方案来帮助你的组织管理模式更改，这里有一些你应该考虑的事项：

成本

成本模型各不相同，因此如果你选择的解决方案会按目标（要管理的模式）收费，那么你应该小心，因为这可能会很快累积起来。

在线模式管理

截至目前，付费解决方案（如[Flyway](https://flywaydb.org)）尚无明确的路径以非阻塞方式为您运行模式更改，尽管其竞争对手[Liquibase](https://www.liquibase.org)为 Percona 的在线模式更改提供了一个得到良好支持的插件。您需要了解每个供应商为您做出的权衡，并了解这些权衡对您的可用性意味着什么，特别是如果您计划使用这些供应商来管理大型数据库（磁盘上有多个 TB）的模式更改。

开箱即用的集成

大多数这些工具都对您公司内部软件使用的语言以及为与现有软件交付流程集成提供的挂钩做出了假设。如果您的公司是高度多语言的，或者正在更改主要软件语言，这可能会排除一些供应商。我们将在下一节中介绍在实施模式源控制管理时需要“自己动手”时该怎么做。

#### 使用开源

如果购买付费工具超出了您的能力范围，或者如果您有正当理由认为当前的解决方案都不适合您的组织，您可以使用现有的开源工具和您组织的 CI 管道来实现相同的结果。

一个显著的开源解决方案，用于在多个环境中通过版本控制管理模式更改的是[Skeema](https://www.skeema.io)。Skeema 本身不会在生产环境中为您运行模式更改——我们将很快介绍如何做到这一点——但它是一个很好的工具，用于跟踪每个数据库集群中的源代码控制存储库中的更改以及跨多个环境。其 CLI 实现在与您选择的 CI 解决方案集成时提供了很大的灵活性。如何直接将 Skeema 与您的 CI 解决方案集成将需要考虑 CI 解决方案具有的功能。[Twilio Sendgrid 团队的这篇博客文章](https://oreil.ly/8YhBS)解释了他们如何将 Skeema 与 Buildkite 集成，以实现寻求管理其数据库更改的功能团队的自主权。

请注意，无论这个解决方案如何与您的 CI 集成，它还需要访问所有环境（包括生产环境）来运行模式更改。这也意味着与您的安全团队合作，以确保您正在创建正确的访问控制，以实现使用持续集成自动化模式部署模式的好处。

###### 注意

如果您已经在使用 Vitess 扩展您的数据库基础设施的道路上，您应该知道 Vitess 也会为您管理模式更改。确保检查文档的特定部分。

在过去几年中，具有自动化和合规性思维的跨环境管理模式更改领域已经显著增长。以下是您在做出选择时的一些最终收获：

+   尽可能接近现有的软件部署工具和工作流程。您希望这对您更大的工程组织来说是熟悉的。

+   使用一个可以集成基本模式更改的基本检查的工具，以确保满足一些基本要求。如果新表不使用正确的字符集或者如果您决定不允许外键，则您的解决方案应自动失败拉取请求。

+   如果您所在的组织是多语言并且正在快速增长，请确保您不会意外引入人为瓶颈，例如一个存储库用于所有数据库和所有模式更改。请记住这里的目标是工程团队速度。

### 在生产环境中运行模式更改

现在我们已经介绍了跟踪和管理为您的组织部署模式更改的选项，让我们讨论*如何*在生产环境中运行这些更改，而不会影响您的数据库的正常运行时间或依赖于它们的服务。

#### 本地 DDL 语句

MySQL 在 5.6 版本中引入了非阻塞模式的模式更改，但在该主要版本中，该功能带有一些注意事项，实际上只能用于非常特定的模式更改类型。

到 8.0 版本成为 GA 时，MySQL 中对本机 DDL 的支持大大扩展，尽管仍不是普遍的。更改主键、更改字符集、打开逐表加密以及添加或删除外键都是您仍然无法使用`INPLACE` alter 本地进行的模式更改的示例。⁷我们强烈建议您通过文档熟悉使用`INPLACE`或`INSTANT`算法所允许的更改，这是在 MySQL 中进行模式更改而无需停机的首选本地方式。

然而，即使您需要的更改在 8.0 及更高版本中得到了技术上的支持，如果正在更改的表非常庞大，如果 InnoDB 内部保留的表更改日志文件太大，您可能会遇到回滚，从而撤销数小时或数天的工作。您可能需要使用外部工具的另一个原因是，如果您强烈希望使用节流机制控制表更改发生的速度。这是您可以通过即将讨论的外部工具来管理的事项。

#### 使用外部工具运行模式更改

如果您尚无法运行最新且最强大的 MySQL 版本，并且具有所有模式更改的灵活性，您仍然可以将 CI 工具与可用的开源工具结合使用，在不影响服务的情况下自动在生产环境中运行模式更改。实现此目标的两个主要选项是 Percona 的`pt-online-schema-change`和 GitHub 的`gh-ost`。两者的文档都包含了您学习如何安装和使用工具所需的所有信息，因此我们将重点讨论如何选择使用哪种工具，应该考虑的主要权衡以及如何提高在生产中作为自动化模式部署流程的一部分使用任一工具的安全性。

###### 警告

需要注意的一点是：任何运行模式更改的外部工具都需要制作您正在更改的表的完整副本。该工具仅使该过程影响较小，不需要破坏性写锁定，但只有 MySQL 中的本机 DDL 才能在不进行完整表复制的情况下更改表模式。

`pt-online-schema-change`的主要吸引力在于其稳定性以及在 MySQL 社区中的长期使用。它主要利用触发器来实现对各种大小的表进行模式更改，对数据库可用性的影响非常小，当切换到新表版本时。但其核心设计也伴随着权衡。在学习如何使用`pt-online-schema-change`来支持您的模式部署流程时，请记住以下几点：

触发器有限制

在 MySQL 8.0 之前，您不能在同一表上有多个具有相同操作的触发器。这意味着什么？如果您有一个名为`sales`的表，并且您已经需要在其上维护一个插入时间触发器，MySQL 在 8.0 之前不允许在该表上添加另一个插入触发器。如果尝试对其运行`pt-online-schema-change`模式更改，则当尝试添加所需的触发器时，该工具将产生错误。尽管我们通常强烈反对将表触发器作为业务逻辑的一部分，但仍会有情况下，遗留选择会创建约束，并且这将成为您选择模式更改机制时的权衡计算的一部分。

触发器会影响性能

Percona 进行了[一些优秀的基准测试](https://oreil.ly/aGdKk)，显示即使在表上定义触发器也会产生性能影响。对于大多数安装来说，这种性能惩罚可能是看不见的，但如果您恰好在非常高的每秒事务吞吐率下运行数据库实例，您可能需要更仔细地观察 `pt-online-schema-change` 引入的触发器的影响，并调整以更保守地中止。

运行并发迁移

由于其使用触发器以及在 MySQL 8.0 之前触发器的限制，您会发现无法使用 `pt-online-schema-change` 在同一张表上运行多个模式更改。这可能最初是一个小小的不便，但如果将该工具整合到一个完全自动化的模式迁移流水线中，它可能会成为团队的瓶颈。

外键约束

尽管该工具在存在外键的情况下对模式更改有一定程度的支持，但您需要仔细阅读文档，并确定哪种权衡对您的数据和事务吞吐量影响最小。

`gh-ost` 是 GitHub 的数据工程团队专门为管理模式更改过程而创建的解决方案，旨在在不使用触发器的情况下管理模式更改过程，同时也不会对服务产生影响。在表复制阶段不使用触发器跟踪更改，而是作为副本连接到您的集群副本之一，并将基于行的复制日志作为更改日志消耗。

使用 `gh-ost` 进行模式更改时需要仔细考虑的一件事是您的现有数据库是否使用外键。虽然 `pt-online-schema-change` 试图支持父表或子表在外键关系中的模式更改，但这是一个复杂的选择，充满了权衡。 （我们牺牲一致性来保证运行时间吗？还是冒一些可能不一致的风险？）另一方面，如果您要修改的表中存在外键，`gh-ost` 大多数情况下会为您做出选择并完全退出。作为 `gh-ost` 的主要贡献者，Shlomi Noach 在一篇长篇但非常有用的[博文](https://oreil.ly/6A10o)中解释了使用外键和在线模式更改工具的环境，这些工具最终仍然是外部于数据库引擎，这种权衡很难理解，他建议如果您还需要在线模式更改，则根本不要使用外键。

如果您和您的团队对此任务还很陌生，并且正在为组织的模式更改 CI 铺平道路，我们认为 `gh-ost` 是更好的解决方案，只要您也有纪律不引入外键。考虑到它使用二进制日志而不是触发器来跟踪更改，我们认为它是更安全的选择，您不必担心触发器的性能损失，它更加不受您运行的 MySQL 版本的影响（即使在某些情况下它甚至可以与基于语句的复制一起工作），并且它已经在大规模部署中得到验证。

什么时候 `pt-online-schema-change` 是首选选项？如果您运行一些旧数据库，其中已经存在外键并且删除它们是一个困难的提议，您会发现 `pt-online-schema-change` 尝试更广泛地支持外键，但您必须承担选择对数据完整性和运行时间最安全的选项的认知负担。此外，`gh-ost` 利用二进制日志来执行其工作，因此如果由于某种原因该工具无法访问这些日志，则 `pt-online-schema-change` 仍然是一个可行的选择。

理想情况下，总有一天我们都可以在 MySQL 中本地执行在线模式更改，但那一天还没有到来。在那之前，开源生态系统在使模式更改变得更容易自动化方面已经取得了长足的进步。让我们讨论如何将所有这些工具组合在一起，为模式更改的完全成熟的 CI/CD 流水线。

### 用于模式更改的 CI/CD 流水线

现在我们已经涵盖了许多工具，从帮助管理模式定义版本控制的工具到在生产中进行更改并最小化停机时间的工具，您可以看到我们拥有完整的模式更改持续集成和部署的部件，这可以消除您组织中工程师生产力的一个巨大瓶颈。让我们把它整合起来：

组织您的模式源控制

首先，您必须通过将每个数据库集群的模式定义分开存储在一个存储库中来开始。如果这里的目标是为不同团队以不同速度运行其更改提供灵活性，那么将所有数据库的所有模式定义合并到一个存储库中是没有意义的。这种分离还允许每个团队在存储库中定义不同的 linting 检查。一些团队可能需要非常特定的字符集和排序规则，而其他团队可能对默认设置感到满意。这里合作伙伴团队的灵活性至关重要。

确保记录工程团队成员如何从他们的笔记本电脑上的模式更改到在所有环境上运行并在进入生产之前运行测试的工作流程。在这里，拉取请求模型可以非常有用，帮助每个团队定义请求模式更改时要运行的测试，以自动化方式在推广并在更多环境或生产中运行更改之前。

安全性的基线配置

为您选择的在线模式更改工具定义基线配置。您是为依赖您提供灵活、可扩展但也安全解决方案的合作伙伴团队提供工具的团队。在考虑如何实现在线模式更改工具时，可能是时候对需要成为测试模式更改拉取请求的模式设计考虑发表意见了。例如，如果您决定更喜欢`gh-ost`的安全性和无触发器设计，这意味着您必须成为一个不包含外键的数据库平台。不去讨论这种选择的权衡，如果最终决定“消灭外键”，那么您应该确保这一点被编码到您如何在预提交挂钩或您的 Skeema 存储库中测试模式更改的方式中，以便避免在环境层次结构中引入不良模式更改。同样，您应该为您的在线模式更改工具决定一个基本配置，为生产中的更改提供基本安全网。您可能希望在这种配置中引入的示例包括最大的 MySQL 线程运行或最大允许的系统负载。存储库模板可以是一个强大的工具，使正确的事情成为任何功能团队创建新数据库并希望跟踪和管理模式更改的存储库时的简单事情。

每个团队的管道灵活性

当您在存储库中为每个数据库组织模式定义时，您允许每个拥有该数据库的团队决定其管道应该是自动化还是人为管理的最大灵活性。一个团队可能仍处于新产品迭代阶段，只要定义的测试通过，他们就可以自动推广模式拉取请求。另一个团队可能拥有更加关键的数据库，并需要更加谨慎的方法，更倾向于在 CI 系统可以将其推广到下一个环境之前，要求操作员批准拉取请求。

当您设计组织如何实现可扩展的模式更改部署时，保持目标在眼前：速度与安全性相结合，使您不断增长的工程组织在从想法到生产功能的公司移动中，数据库工程团队不成为瓶颈。

# 总结

良好的模式设计是相当普遍的，但当然 MySQL 有特殊的实现细节需要考虑。简而言之，尽可能保持事物简单和小型是个好主意。MySQL 喜欢简单，与您的数据库一起工作的人也会喜欢。请记住以下准则：

+   设计时避免极端情况，比如会导致查询非常复杂或表格有大量列的模式。（一个“oodles”介于 scad 和 gazillion 之间。）

+   使用小型、简单、适当的数据类型，并避免使用`NULL`，除非它实际上是模拟数据现实的正确方式。

+   尽量使用相同的数据类型来存储相似或相关的值，特别是如果它们将用于连接条件。

+   注意变长字符串，可能会导致对临时表和排序进行悲观的全长内存分配。

+   如果可以的话，尽量使用整数作为标识符。

+   避免使用传统的 MySQL 特性，比如为浮点数指定精度或为整数指定显示宽度。

+   对`ENUM`和`SET`要小心。它们很方便，但有时可能会被滥用，而且有时会很棘手。最好避免使用`BIT`。

数据库设计是一门科学。如果您非常关注数据库设计，请考虑使用专门的源材料。⁸

还要记住，您的模式将随着业务需求和从用户那里学到的东西而发展，这意味着具有管理模式更改的健壮软件生命周期是使这种演变对您的组织安全和可扩展的关键部分。

¹ 记住长度是以字符为单位指定的，而不是字节。多字节字符集可能需要超过 1 个字节来存储每个字符。

² 如果值在检索后必须保持不变，请小心处理`BINARY`类型。MySQL 会用`\0`填充到所需长度。

³ 时间是用于相对比较的，因为 CPU、内存和其他硬件的速度随时间变化。

⁴ `TIMESTAMP`行为的规则复杂，并且在各个 MySQL 版本中有所更改，因此您应该验证您得到的行为是否符合您的要求。通常在对`TIMESTAMP`列进行更改后，检查`SHOW CREATE TABLE`的输出是个好主意。

⁵ 如果使用 InnoDB 存储引擎，除非数据类型完全匹配，否则可能无法创建外键。由此产生的错误消息“ERROR 1005 (HY000): Can’t create table”可能会令人困惑，具体情况取决于上下文，关于此问题的问题经常出现在 MySQL 邮件列表上。（奇怪的是，你可以在长度不同的`VARCHAR`列之间创建外键。）

⁶ 另一方面，对于一些有很多写入者的非常大的表，这种伪随机值实际上可以帮助消除“热点”。

⁷ 查看[MySQL 文档](https://oreil.ly/nFMKg)以获取更多信息。

⁸ 想要深入阅读的话，可以考虑阅读迈克尔·J·赫尔南德斯（Pearson）的*Database Design for Mere Mortals*。 
