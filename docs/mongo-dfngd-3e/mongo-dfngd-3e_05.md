# 第四章：查询

本章详细讨论了查询。主要涵盖的主题如下：

+   您可以使用 `$` 条件来查询范围、集合包含、不等式等更多内容。

+   查询返回一个数据库游标，它在需要时惰性地返回文档批次。

+   您可以在游标上执行许多元操作，包括跳过一定数量的结果、限制返回的结果数量和对结果进行排序。

# 查找入门

`find` 方法用于在 MongoDB 中执行查询。查询返回集合中的文档子集，从不返回文档到返回整个集合。哪些文档被返回由 `find` 的第一个参数决定，该参数是指定查询条件的文档。

空查询文档（即 `{}`）匹配集合中的所有内容。如果没有给定查询文档，则 `find` 默认为 `{}`。例如，以下示例：

```
> db.c.find()
```

匹配集合中的每个文档 *c*（并以批量返回这些文档）。

当我们开始向查询文档添加键值对时，我们开始限制我们的搜索范围。这对大多数类型都很直接：数字匹配数字，布尔值匹配布尔值，字符串匹配字符串。查询简单类型的方式就像指定您要查找的值一样简单。例如，要查找所有 `"age"` 值为 `27` 的文档，我们可以将该键值对添加到查询文档中：

```
> db.users.find({"age" : 27})
```

如果我们要匹配一个字符串，例如具有值 `"joe"` 的 `"username"` 键，我们可以改为使用该键值对：

```
> db.users.find({"username" : "joe"})
```

多个条件可以通过向查询文档添加更多键值对来串联在一起，这些条件被解释为“*`condition1`* AND *`condition2`* AND … AND *`conditionN`*。” 例如，要获取所有年龄为 27 岁且用户名为“joe”的用户，我们可以查询如下：

```
> db.users.find({"username" : "joe", "age" : 27})
```

## 指定要返回的键

有时您不需要文档中返回的所有键值对。如果是这种情况，可以将第二个参数传递给 `find`（或 `findOne`），指定您想要的键。这不仅减少了通过网络发送的数据量，还减少了客户端解码文档所需的时间和内存。

例如，如果您有一个用户集合，只对 `"username"` 和 `"email"` 键感兴趣，可以使用以下查询仅返回这些键：

```
> db.users.find({}, {"username" : 1, "email" : 1})
{
    "_id" : ObjectId("4ba0f0dfd22aa494fd523620"),
    "username" : "joe",
    "email" : "joe@example.com"
}
```

如前一输出所示，默认情况下会返回 `"_id"` 键，即使没有显式请求它。

您还可以使用第二个参数来排除查询结果中特定的键值对。例如，可能有包含各种键的文档，但您只知道绝对不希望返回 `"fatal_weakness"` 键：

```
> db.users.find({}, {"fatal_weakness" : 0})
```

这也可以防止返回 `"_id"`：

```
> db.users.find({}, {"username" : 1, "_id" : 0})
{
    "username" : "joe",
}
```

## 限制

查询存在一些限制。就数据库而言，查询文档的值必须是一个常量。（在您自己的代码中可能是一个普通变量。）也就是说，它不能引用文档中另一个键的值。例如，如果我们正在管理库存，有`"in_stock"`和`"num_sold"`两个键，我们不能通过以下查询来比较它们的值：

```
> db.stock.find({"in_stock" : "this.num_sold"}) // doesn't work
```

有方法可以实现这一点（参见“$where Queries”），但通常通过稍微重组文档来实现更好的性能，例如使用`"initial_stock"`和`"in_stock"`键。然后，每当有人购买物品时，我们将`"in_stock"`键的值减少一个。最后，我们可以执行简单的查询来检查哪些物品已经售罄：

```
> db.stock.find({"in_stock" : 0})
```

# 查询条件

查询可以超出上一节描述的精确匹配，还可以匹配更复杂的条件，例如范围、OR 子句和否定。

## 查询条件运算符

`"$lt"`、`"$lte"`、`"$gt"`和`"$gte"`都是比较运算符，分别对应于 <、<=、> 和 >=。它们可以组合使用来查找一系列的值。例如，要查找年龄在 18 到 30 岁之间的用户，我们可以这样做：

```
> db.users.find({"age" : {"$gte" : 18, "$lte" : 30}})
```

这将查找所有`"age"`字段大于或等于`18`且小于或等于`30`的文档。

这些类型的范围查询通常对日期非常有用。例如，要找到在 2007 年 1 月 1 日之前注册的人员，我们可以这样做：

```
> start = new Date("01/01/2007")
> db.users.find({"registered" : {"$lt" : start}})
```

根据您如何创建和存储日期，精确匹配可能不太有用，因为日期是以毫秒精度存储的。通常情况下，您可能需要整天、整周或整月，因此需要进行范围查询。

要查询键值不等于某个值的文档，必须使用另一个条件运算符`"$ne"`，它代表“不等于”。如果您想找到所有没有用户名为“joe”的用户，可以使用以下查询：

```
> db.users.find({"username" : {"$ne" : "joe"}})
```

`"$ne"`可以与任何类型一起使用。

## OR 查询

在 MongoDB 中有两种方法进行 OR 查询。`"$in"`可以用来查询单个键的多个值。`"$or"`更通用；它可以用来查询多个键中给定值的任何一个。

如果一个键有多个可能的匹配值，请使用`"$in"`的数组条件。例如，假设我们正在进行抽奖，获奖的票号分别是 725、542 和 390。为了找到所有这三个文档，我们可以构建以下查询：

```
> db.raffle.find({"ticket_no" : {"$in" : [725, 542, 390]}})
```

`"$in"`非常灵活，允许您指定不同类型和值的条件。例如，如果我们正在逐步迁移我们的模式以使用用户名而不是用户 ID 号码，我们可以通过以下方式查询：

```
> db.users.find({"user_id" : {"$in" : [12345, "joe"]}})
```

这将匹配`"user_id"`等于`12345`和`"user_id"`等于`"joe"`的文档。

如果 `"$in"` 提供的是一个包含单个值的数组，则其行为与直接匹配该值相同。例如，`{ticket_no: {$in: [725]}}` 与 `{ticket_no: 725}` 匹配相同的文档。

`"$in"` 的反义是 `"$nin"`，它返回不匹配数组中任何条件的文档。如果我们想要返回在抽奖中没有赢得任何东西的所有人，我们可以用这个查询：

```
> db.raffle.find({"ticket_no" : {"$nin" : [725, 542, 390]}})
```

此查询返回那些没有具有这些号码的票的人。

`"$in"` 为单个键提供了 OR 查询，但如果我们需要找到 `"ticket_no"` 是 `725` 或 `"winner"` 是 `true` 的文档，我们需要使用 `"$or"` 条件。`"$or"` 接受一个可能条件的数组。在抽奖案例中，使用 `"$or"` 如下所示：

```
> db.raffle.find({"$or" : [{"ticket_no" : 725}, {"winner" : true}]})
```

`"$or"` 可以包含其他条件。例如，如果我们想匹配任意三个 `"ticket_no"` 值或 `"winner"` 键，则可以使用以下方式：

```
> db.raffle.find({"$or" : [{"ticket_no" : {"$in" : [725, 542, 390]}},
...                        {"winner" : true}]})
```

使用普通的 AND 类型查询，你希望尽可能少的参数尽可能缩小结果范围。OR 类型查询则相反：如果第一个参数匹配尽可能多的文档，则效率最高。

虽然 `"$or"` 总是有效，但尽可能使用 `"$in"`，因为查询优化器处理它更有效率。

## $not

`"$not"` 是一种元条件：它可以应用在任何其他条件之上。例如，让我们考虑模数运算符 `"$mod"`。`"$mod"` 查询的是其值除以给定的第一个值后余数为第二个值的键：

```
> db.users.find({"id_num" : {"$mod" : [5, 1]}})
```

前面的查询返回了 `"id_num"` 为 `1`、`6`、`11`、`16` 等的用户。如果我们想要返回 `"id_num"` 为 `2`、`3`、`4`、`5`、`7`、`8`、`9`、`10`、`12` 等的用户，可以使用 `"$not"`：

```
> db.users.find({"id_num" : {"$not" : {"$mod" : [5, 1]}}})
```

`"$not"` 结合正则表达式特别有用，用于查找所有不匹配给定模式的文档（正则表达式的使用在章节 “Regular Expressions” 中描述）。

# 类型特定查询

如 第二章 中所述，MongoDB 具有多种可以在文档中使用的类型。某些类型在查询时具有特殊行为。

## null

null 的行为有些奇怪。它确实匹配自身，因此如果我们有一个包含以下文档的集合：

```
> db.c.find()
{ "_id" : ObjectId("4ba0f0dfd22aa494fd523621"), "y" : null }
{ "_id" : ObjectId("4ba0f0dfd22aa494fd523622"), "y" : 1 }
{ "_id" : ObjectId("4ba0f148d22aa494fd523623"), "y" : 2 }
```

我们可以按预期的方式查询 `"y"` 键为 `null` 的文档：

```
> db.c.find({"y" : null})
{ "_id" : ObjectId("4ba0f0dfd22aa494fd523621"), "y" : null }
```

然而，`null` 也匹配“不存在”。因此，查询具有值为 `null` 的键将返回所有缺少该键的文档：

```
> db.c.find({"z" : null})
{ "_id" : ObjectId("4ba0f0dfd22aa494fd523621"), "y" : null }
{ "_id" : ObjectId("4ba0f0dfd22aa494fd523622"), "y" : 1 }
{ "_id" : ObjectId("4ba0f148d22aa494fd523623"), "y" : 2 }
```

如果我们只想找到值为 `null` 的键，我们可以检查该键是否为 `null` 并存在，使用 `"$exists"` 条件：

```
> db.c.find({"z" : {"$eq" : null, "$exists" : true}})
```

## 正则表达式

`"$regex"` 提供了正则表达式功能，用于在查询中匹配字符串模式。正则表达式对于灵活的字符串匹配非常有用。例如，如果我们想找到所有名为“Joe”或“joe”的用户，可以使用正则表达式进行大小写不敏感匹配：

```
> db.users.find( {"name" : {"$regex" : /joe/i } })
```

正则表达式标志（例如 `i`）是允许的但不是必需的。如果我们想匹配不仅是“joe”不同大小写形式，还包括“joey”，我们可以继续改进我们的正则表达式：

```
> db.users.find({"name" : /joey?/i})
```

MongoDB 使用 Perl 兼容正则表达式（PCRE）库来匹配正则表达式；任何 PCRE 允许的正则表达式语法在 MongoDB 中都是允许的。在使用查询之前，建议在 JavaScript shell 中检查您的语法，以确保它匹配您认为的内容。

###### 注意

MongoDB 可以利用前缀正则表达式（例如 `/^joey/`）的索引进行查询。索引 *不能* 用于不区分大小写的搜索（`/^joey/i`）。当正则表达式以插入符号 (`^`) 或左锚点 (`\A`) 开头时，它被称为“前缀表达式”。如果正则表达式使用区分大小写的查询，那么如果字段存在索引，匹配可以针对索引中的值进行。如果它也是前缀表达式，那么搜索可以限制在索引中由该前缀创建的范围内的值。

正则表达式也可以匹配自身。很少有人将正则表达式插入到数据库中，但如果您插入一个，可以与其本身匹配：

```
> db.foo.insertOne({"bar" : /baz/})
> db.foo.find({"bar" : /baz/})
{
    "_id" : ObjectId("4b23c3ca7525f35f94b60a2d"),
    "bar" : /baz/
}
```

## 查询数组

查询数组元素的行为设计得与标量查询相同。例如，如果数组是像这样的水果列表：

```
> db.food.insertOne({"fruit" : ["apple", "banana", "peach"]})
```

以下查询将成功匹配文档：

```
> db.food.find({"fruit" : "banana"})
```

我们可以像查询类似于（非法）文档 `{"fruit" : "apple", "fruit" : "banana", "fruit" : "peach"}` 的方式来查询它。

### “$all”

如果您需要通过多个元素匹配数组，可以使用 `"$all"`。这允许您匹配一个元素列表。例如，假设我们创建一个包含三个元素的集合：

```
> db.food.insertOne({"_id" : 1, "fruit" : ["apple", "banana", "peach"]})
> db.food.insertOne({"_id" : 2, "fruit" : ["apple", "kumquat", "orange"]})
> db.food.insertOne({"_id" : 3, "fruit" : ["cherry", "banana", "apple"]})
```

然后我们可以通过使用 `"$all"` 查询来找到所有包含 `"apple"` 和 `"banana"` 元素的文档：

```
> db.food.find({fruit : {$all : ["apple", "banana"]}})
{"_id" : 1, "fruit" : ["apple", "banana", "peach"]}
{"_id" : 3, "fruit" : ["cherry", "banana", "apple"]}
```

顺序不重要。请注意，第二个结果中 `"banana"` 出现在 `"apple"` 之前。使用带有 `"$all"` 的单元素数组等同于不使用 `"$all"`。例如，`{fruit : {$all : ['apple']}` 将与 `{fruit : 'apple'}` 匹配相同的文档。

您还可以通过整个数组进行精确匹配查询。但是，如果任何元素缺失或多余，精确匹配将不会匹配文档。例如，这将匹配我们三个文档中的第一个：

```
> db.food.find({"fruit" : ["apple", "banana", "peach"]})
```

但这不会：

```
> db.food.find({"fruit" : ["apple", "banana"]})
```

这也不会：

```
> db.food.find({"fruit" : ["banana", "apple", "peach"]})
```

如果您想查询数组的特定元素，可以使用 *`key`*.*`index`* 的语法指定索引：

```
> db.food.find({"fruit.2" : "peach"})
```

数组始终从 0 开始索引，因此这将使第三个数组元素与字符串 `"peach"` 匹配。

### “$size”

查询数组的一个有用的条件是 `"$size"`，它允许您查询特定大小的数组。以下是一个示例：

```
> db.food.find({"fruit" : {"$size" : 3}})
```

一个常见的查询是获取一系列大小。 `"$size"` 不能与另一个 `$` 条件结合使用（在这个例子中是 `"$gt"`），但可以通过向文档添加 `"size"` 键来实现此查询。然后，每次向数组添加元素时，增加 `"size"` 的值。如果原始更新看起来像这样：

```
> db.food.update(criteria, {"$push" : {"fruit" : "strawberry"}})
```

它可以简单地更改为这样：

```
> db.food.update(criteria,
... {"$push" : {"fruit" : "strawberry"}, "$inc" : {"size" : 1}})
```

自增非常快，因此任何性能损失都可以忽略不计。像这样存储文档允许你执行这样的查询：

```
> db.food.find({"size" : {"$gt" : 3}})
```

不幸的是，这种技术与 `"$addToSet"` 运算符的结合效果不佳。

### `"$slice"`

如本章前面提到的，`find` 的可选第二个参数指定要返回的键。特殊的 `"$slice"` 运算符可以用来返回数组键的子集。

例如，假设我们有一个博客文章文档，并且想返回前 10 条评论：

```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : 10}})
```

或者，如果我们想要最后 10 条评论，我们可以使用 `-10`：

```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : -10}})
```

`"$slice"` 也可以通过指定偏移量和要返回的元素数量返回结果中的页面中的页面：

```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : [23, 10]}})
```

这将跳过前 23 个元素，并返回第 24 到 33 个元素。如果数组中的元素少于 33 个，它将返回尽可能多的元素。

除非另有说明，使用 `"$slice"` 时文档中的所有键都会被返回。这与其他键规范不同，其他键规范会抑制未提及的键的返回。例如，如果我们有一个博客文章文档如下所示：

```
{
    "_id" : ObjectId("4b2d75476cc613d5ee930164"),
    "title" : "A blog post",
    "content" : "...",
    "comments" : [
        {
            "name" : "joe",
            "email" : "joe@example.com",
            "content" : "nice post."
        },
        {
            "name" : "bob",
            "email" : "bob@example.com",
            "content" : "good post."
        }
    ]
}
```

如果我们使用 `"$slice"` 来获取最后一条评论，我们将得到以下内容：

```
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : -1}})
{
    "_id" : ObjectId("4b2d75476cc613d5ee930164"),
    "title" : "A blog post",
    "content" : "...",
    "comments" : [
        {
            "name" : "bob",
            "email" : "bob@example.com",
            "content" : "good post."
        }
    ]
}
```

即使没有显式包含在键规范中，`"title"` 和 `"content"` 仍然会被返回。

### 返回匹配的数组元素

`"$slice"` 在你知道元素索引时非常有用，但有时你希望返回任何与你的条件匹配的数组元素。你可以使用 `$` 运算符返回匹配的元素。给定前面的博客示例，你可以通过以下方式获取 Bob 的评论：

```
> db.blog.posts.find({"comments.name" : "bob"}, {"comments.$" : 1})
{
    "_id" : ObjectId("4b2d75476cc613d5ee930164"),
    "comments" : [
        {
            "name" : "bob",
            "email" : "bob@example.com",
            "content" : "good post."
        }
    ]
}
```

注意，这只返回每个文档的第一个匹配项：如果 Bob 在这篇文章上留了多条评论，只返回在 `"comments"` 数组中的第一条。

### 数组和范围查询的交互

文档中的标量（非数组元素）必须符合查询条件的每个子句。例如，如果你查询 `{"x" : {"$gt" : 10, "$lt" : 20}}`，`"x"` 必须同时大于 10 和小于 20。然而，如果文档的 `"x"` 字段是一个数组，那么文档匹配的条件是 `"x"` 中有一个元素满足每个查询子句 *但每个查询子句可以匹配不同的数组元素*。

理解这种行为的最佳方法是看一个例子。假设我们有以下文档：

```
{"x" : 5}
{"x" : 15}
{"x" : 25}
{"x" : [5, 25]}
```

如果我们想找到所有 `"x"` 在 10 到 20 之间的文档，我们可能会天真地将查询结构化为 `db.test.find({"x" : {"$gt" : 10, "$lt" : 20}})`，并期望得到一个文档： `{"x" : 15}`。然而，运行此查询，我们得到了两个文档：

```
> db.test.find({"x" : {"$gt" : 10, "$lt" : 20}})
{"x" : 15}
{"x" : [5, 25]}
```

既不是 5 也不是 25 在 10 和 20 之间，但是文档被返回，因为 25 匹配了第一个子句（它大于 10），而 5 匹配了第二个子句（它小于 20）。

这使得对数组进行范围查询基本无效：范围将匹配任何多元素数组。有几种方法可以获得预期的行为。

首先，你可以使用 `"$elemMatch"` 强制 MongoDB 将两个子句与单个数组元素进行比较。然而，问题在于 `"$elemMatch"` 不会匹配非数组元素：

```
> db.test.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}})
> // no results
```

文档 `{"x" : 15}` 不再与查询匹配，因为 `"x"` 字段不是数组。也就是说，在字段中混合使用数组和标量值时，你应该有充分的理由。许多用例不需要混合使用。对于这些情况，`"$elemMatch"` 为数组元素的范围查询提供了一个很好的解决方案。

如果你在查询字段上有索引（参见第五章），你可以使用 `min` 和 `max` 限制查询遍历的索引范围到 `"$gt"` 和 `"$lt"` 的值：

```
> db.test.find({"x" : {"$gt" : 10, "$lt" : 20}}).min({"x" : 10}).max({"x" : 20})
{"x" : 15}
```

现在这将仅遍历从 10 到 20 的索引，忽略了 5 和 25 的条目。你只能在查询字段上有索引时使用 `min` 和 `max`，并且必须将索引的所有字段传递给 `min` 和 `max`。

在查询可能包含数组的文档上使用 `min` 和 `max` 通常是个好主意。对数组的 `"$gt"`/`"$lt"` 查询的索引边界是低效的。它基本上接受任何值，因此将搜索每个索引条目，而不仅仅是在范围内的条目。

## 查询嵌入文档

有两种查询嵌入文档的方法：查询整个文档或查询其各个键/值对。

对整个嵌入文档的查询与普通查询完全相同。例如，如果我们有一个看起来像这样的文档：

```
{
    "name" : {
        "first" : "Joe",
        "last" : "Schmoe"
    },
    "age" : 45
}
```

我们可以查询名为 Joe Schmoe 的人如下：

```
> db.people.find({"name" : {"first" : "Joe", "last" : "Schmoe"}})
```

然而，完整子文档的查询必须完全匹配子文档。如果 Joe 决定添加一个中间名字段，突然这个查询就不再起作用了；它不匹配整个嵌入文档！这种查询也是有序敏感的：`{"last" : "Schmoe", "first" : "Joe"}` 不会匹配。

如果可能的话，通常最好只查询嵌入文档的特定键或键。然后，如果你的模式发生变化，你所有的查询不会突然因为它们不再是精确匹配而断开。你可以使用点符号来查询嵌入键：

```
> db.people.find({"name.first" : "Joe", "name.last" : "Schmoe"})
```

现在，如果 Joe 添加了更多的键，这个查询仍然可以匹配他的姓和名。

此点符号标记是查询文档与其他文档类型之间的主要区别。查询文档可以包含点号，表示“进入嵌入文档”。点符号也是插入时不能包含`.`字符的原因。人们在尝试将 URL 保存为键时经常遇到此限制的情况。解决办法之一是在插入或检索之前始终执行全局替换，将不合法的 URL 字符替换为点字符。

随着文档结构变得更加复杂，嵌入文档的匹配可能会变得有些棘手。例如，假设我们存储博客文章，并且想要找到 Joe 发表的评分至少为 5 的评论。我们可以如下建模：

```
> db.blog.find()
{
    "content" : "...",
    "comments" : [
        {
            "author" : "joe",
            "score" : 3,
            "comment" : "nice post"
        },
        {
            "author" : "mary",
            "score" : 6,
            "comment" : "terrible post"
        }
    ]
}
```

现在，我们不能使用`db.blog.find({"comments" : {"author" : "joe", "score" : {"$gte" : 5}}})`进行查询。嵌入文档匹配必须匹配整个文档，而这不匹配`"comment"`键。同样也不能这样做`db.blog.find({"comments.author" : "joe", "comments.score" : {"$gte" : 5}})`，因为作者条件可能与评分条件匹配不同的评论。也就是说，它会返回上述文档：它会匹配第一个评论中的`"author" : "joe"`和第二个评论中的`"score" : 6`。

要正确分组条件，而不需要指定每个键，请使用`"$elemMatch"`。这个名称模糊的条件允许您部分指定匹配数组中单个嵌入文档的条件。正确的查询如下：

```
> db.blog.find({"comments" : {"$elemMatch" : 
... {"author" : "joe", "score" : {"$gte" : 5}}}})
```

`"$elemMatch"`允许您“分组”您的条件。因此，只有当您在嵌入文档中有多个键需要匹配时才需要它。

# `$where` 查询

键/值对是一种相当表达力强的查询方式，但有些查询无法表示。对于无法通过其他方式完成的查询，有`"$where"`子句可以使用，允许您在查询中执行任意 JavaScript。这允许您在查询中执行（几乎）任何操作。为了安全起见，应该严格限制或消除`"$where"`子句的使用。终端用户不应被允许执行任意`"$where"`子句。

使用`"$where"`最常见的情况是比较文档中两个键的值。例如，假设我们有这样的文档：

```
> db.foo.insertOne({"apple" : 1, "banana" : 6, "peach" : 3})
> db.foo.insertOne({"apple" : 8, "spinach" : 4, "watermelon" : 4})
```

我们希望返回任意两个字段相等的文档。例如，在第二个文档中，`"spinach"`和`"watermelon"`具有相同的值，因此我们希望返回该文档。MongoDB 不太可能会有一个`$`条件来处理这个问题，所以我们可以使用`"$where"`子句在 JavaScript 中执行它：

```
> db.foo.find({"$where" : function () {
... for (var current in this) {
...     for (var other in this) {
...         if (current != other && this[current] == this[other]) {
...             return true;
...         }
...     }
... }
... return false;
... }});
```

如果函数返回`true`，则该文档将成为结果集的一部分；如果返回`false`，则不会。

除非绝对必要，否则不应使用`"$where"`查询：它们比常规查询慢得多。每个文档都必须从 BSON 转换为 JavaScript 对象，然后通过`"$where"`表达式运行。索引也不能用于满足`"$where"`条件。因此，只有在没有其他方法可以执行查询时才应使用`"$where"`。通过与`"$where"`结合使用其他查询过滤器可以减少惩罚。如果可能，将使用索引根据非`$where`子句进行过滤；`"$where"`表达式将仅用于微调结果。MongoDB 3.6 添加了`$expr`运算符，允许在 MongoDB 查询语言中使用聚合表达式。它比`$where`更快，因为不执行 JavaScript，并建议在可能的情况下使用它来替换此运算符。

进行复杂查询的另一种方式是使用聚合工具之一，这在第七章中有所涵盖。

# 游标

数据库使用*游标*从`find`返回结果。游标的客户端实现通常允许您控制查询的最终输出的很多方面。您可以限制结果的数量，跳过一些结果，按任意键的任意组合和方向对结果进行排序，并执行许多其他强大的操作。

要在 shell 中创建游标，请将一些文档放入集合中，对它们进行查询，并将结果分配给一个本地变量（使用`"var"`定义的变量是局部的）。在这里，我们创建一个非常简单的集合并查询它，将结果存储在`cursor`变量中：

```
> for(i=0; i<100; i++) {
...     db.collection.insertOne({x : i});
... }
> var cursor = db.collection.find();
```

这样做的优点是您可以一次查看一个结果。如果将结果存储在全局变量或根本不存储变量中，MongoDB shell 将自动迭代并显示前几个文档。这是我们到目前为止看到的行为，并且通常是您查看集合内容而不是使用 shell 进行实际编程时想要的行为。

要遍历结果，您可以使用游标的`next`方法。您可以使用`hasNext`检查是否有另一个结果。典型的遍历结果的循环如下所示：

```
> while (cursor.hasNext()) {
...     obj = cursor.next();
...     // do stuff
... }
```

`cursor.hasNext()`检查是否存在下一个结果，`cursor.next()`获取下一个结果。

`cursor`类还实现了 JavaScript 的迭代器接口，因此您可以在`forEach`循环中使用它：

```
> var cursor = db.people.find();
> cursor.forEach(function(x) {
...     print(x.name);
... });
adam
matt
zak
```

当您调用`find`时，shell 不会立即查询数据库。它会等到您开始请求结果时才发送查询，这使您可以在执行查询之前对查询进行附加选项的链式调用。几乎`cursor`对象上的每个方法都返回游标本身，因此您可以按任意顺序链式调用选项。例如，以下所有方式都是等效的：

```
> var cursor = db.foo.find().sort({"x" : 1}).limit(1).skip(10);
> var cursor = db.foo.find().limit(1).sort({"x" : 1}).skip(10);
> var cursor = db.foo.find().skip(10).limit(1).sort({"x" : 1});
```

到目前为止，查询还没有执行。所有这些函数只是构建查询而已。现在，假设我们调用以下内容：

```
> cursor.hasNext()
```

在这一点上，查询将被发送到服务器。Shell 一次获取前 100 个结果或前 4 MB 的结果（以较小者为准），这样下一次调用`next`或`hasNext`就不必再次与服务器通信。客户端浏览了第一批结果后，Shell 将再次联系数据库，并通过`getMore`请求获取更多结果。`getMore`请求基本上包含一个游标标识符，并询问数据库是否还有更多结果，如果有，则返回下一批。这个过程持续到游标耗尽并返回所有结果为止。

## 限制、跳过和排序

最常见的查询选项包括限制返回的结果数量、跳过一定数量的结果以及排序。所有这些选项必须在向数据库发送查询之前添加。

要设置限制，请将`limit`函数链接到`find`的调用中。例如，要仅返回三个结果，请使用：

```
> db.c.find().limit(3)
```

如果在集合中查询的匹配文档少于三个，则只返回匹配文档的数量；`limit`设置的是上限，而不是下限。

`skip`的工作方式类似于`limit`：

```
> db.c.find().skip(3)
```

这将跳过前三个匹配的文档并返回其余的匹配项。如果集合中的文档少于三个，则不会返回任何文档。

`sort`接受一个对象：一组键/值对，其中键是键名，值是排序方向。排序方向可以是`1`（升序）或`−1`（降序）。如果给定多个键，则结果将按顺序排序。例如，要按`"username"`升序和`"age"`降序排序结果，我们这样做：

```
> db.c.find().sort({username : 1, age : -1})
```

这三种方法可以结合使用。这对分页非常方便。例如，假设你运营一个在线商店，有人搜索*mp3*。如果你想每页显示 50 个结果，并按价格从高到低排序，可以这样做：

```
> db.stock.find({"desc" : "mp3"}).limit(50).sort({"price" : -1})
```

如果用户点击“下一页”查看更多结果，则可以简单地在查询中添加一个 skip，这将跳过前 50 个匹配项（用户在第一页上已经看过的）：

```
> db.stock.find({"desc" : "mp3"}).limit(50).skip(50).sort({"price" : -1})
```

然而，大的跳过并不太高效；在下一节中有建议如何避免它们。

### 比较顺序

MongoDB 有一套类型比较的层次结构。有时你会有一个单一的键包含多种类型：例如整数和布尔值，或字符串和 null 值。如果对混合类型的键进行排序，则会按预定义的顺序进行排序。从最小到最大的值，这个排序顺序如下：

1.  最小值

1.  Null

1.  数字（整数、长整数、双精度、小数）

1.  字符串

1.  对象/文档

1.  数组

1.  二进制数据

1.  对象 ID

1.  布尔值

1.  日期

1.  时间戳

1.  正则表达式

1.  最大值

## 避免大跳过

对少量文档使用`skip`是可以接受的。但是对于大量结果，由于需要找到并且丢弃所有被跳过的结果，`skip`可能会很慢。大多数数据库在索引中保留更多元数据以帮助处理跳过，但 MongoDB 目前不支持此功能，因此应避免大量跳过。通常可以基于前一个查询计算下一个查询的结果。

### 无`skip`分页结果

分页的最简单方法是使用`limit`返回第一页结果，然后从开头返回每个后续页：

```
> // do not use: slow for large skips
> var page1 = db.foo.find(criteria).limit(100)
> var page2 = db.foo.find(criteria).skip(100).limit(100)
> var page3 = db.foo.find(criteria).skip(200).limit(100)
...
```

然而，根据您的查询，通常可以找到一种方法进行分页而无需跳过。例如，假设我们想按照`"date"`降序显示文档，我们可以通过以下方式获取第一页结果：

```
> var page1 = db.foo.find().sort({"date" : -1}).limit(100)
```

然后，假设日期是唯一的，我们可以使用最后一个文档的`"date"`值作为获取下一页的条件：

```
var latest = null;

// display first page
while (page1.hasNext()) {
   latest = page1.next();
   display(latest);
}

// get next page
var page2 = db.foo.find({"date" : {"$lt" : latest.date}});
page2.sort({"date" : -1}).limit(100);
```

现在查询不需要包括跳过。

### 查找随机文档

一个相当常见的问题是如何从集合中获取一个随机文档。天真（并且缓慢）的解决方案是计算文档数，然后进行`find`，跳过从零到集合大小之间的随机数量的文档：

```
> // do not use
> var total = db.foo.count()
> var random = Math.floor(Math.random()*total)
> db.foo.find().skip(random).limit(1)
```

以这种方式获取随机元素实际上效率非常低：您必须进行计数（如果使用条件可能会很昂贵），并且跳过大量元素可能会耗时。

这需要一些预见性，但如果您知道您将在集合中查找随机元素，有一种更有效的方法。诀窍是在插入每个文档时添加额外的随机键。例如，如果我们正在使用 Shell，我们可以使用`Math.random()`函数（生成 0 到 1 之间的随机数）：

```
> db.people.insertOne({"name" : "joe", "random" : Math.random()})
> db.people.insertOne({"name" : "john", "random" : Math.random()})
> db.people.insertOne({"name" : "jim", "random" : Math.random()})
```

现在，当我们想要从集合中找到一个随机文档时，我们可以计算一个随机数，并将其用作查询条件，而不是使用`skip`：

```
> var random = Math.random()
> result = db.people.findOne({"random" : {"$gt" : random}})
```

有一定几率`random`大于集合中任何`"random"`值，并且不会返回结果。我们可以通过简单地返回另一方向的文档来防范这种情况：

```
> if (result == null) {
...     result = db.people.findOne({"random" : {"$lte" : random}})
... }
```

如果集合中没有任何文档，这种技术最终会返回`null`，这是有道理的。

这种技术可以用于任意复杂的查询；只需确保有一个包含随机键的索引即可。例如，如果我们想在加州找到一个随机的水管工，我们可以在`"profession"`、`"state"`和`"random"`上创建一个索引：

```
> db.people.ensureIndex({"profession" : 1, "state" : 1, "random" : 1})
```

这样可以快速找到随机结果（详见第五章了解更多关于索引的信息）。

## 永存的游标

游标有两个方面：面向客户端的游标和客户端代表的数据库游标。到目前为止，我们一直在谈论客户端的那个，但我们将简要看看服务器上发生了什么。

在服务器端，游标占用内存和资源。一旦游标耗尽了结果或客户端发送消息告知其终止，数据库可以释放其正在使用的资源。释放这些资源使得数据库可以用于其他事务，这是好的，因此我们希望确保游标可以迅速释放（在合理范围内）。

有几种情况可能会导致游标的“死亡”（及随后的清理）。首先，当游标完成对匹配结果的迭代时，它将自我清理。另一种方式是，当客户端上的游标超出作用域时，驱动程序会向数据库发送特殊消息，告知可以终止该游标。最后，即使用户尚未遍历所有结果且游标仍在作用域内，数据库游标在 10 分钟的不活动后也会自动“死亡”。这样，如果客户端崩溃或存在错误，MongoDB 将不会留下成千上万个开放的游标。

这种“超时死亡”通常是期望的行为：很少有应用程序希望用户坐在那里等待几分钟才能得到结果。然而，有时你可能知道需要一个长时间保持的游标。在这种情况下，许多驱动程序已经实现了一个名为`immortal`或类似机制的函数，告诉数据库不要超时游标。如果关闭游标的超时时间，你必须迭代其所有结果或将其终止，以确保它被关闭。否则，它将继续留在数据库中占用资源，直到服务器重新启动。
