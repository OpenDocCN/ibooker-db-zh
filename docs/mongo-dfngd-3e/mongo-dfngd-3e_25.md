# 第二十章：耐久性

耐久性是数据库系统的一个属性，确保已提交到数据库的写操作将永久存储。例如，如果票务预订系统报告您的音乐会座位已被预订，那么即使预订系统的某些部分崩溃，您的座位也将保持预订状态。对于 MongoDB，我们需要考虑集群（或更具体地说，副本集）级别的耐久性。

本章将涵盖以下内容：

+   MongoDB 如何通过日志记录在副本集成员级别保证耐久性

+   MongoDB 如何通过写关注（write concern）在集群级别保证耐久性

+   如何配置你的应用程序和 MongoDB 集群以满足你所需的耐久性级别

+   MongoDB 如何通过读关注（read concern）在集群级别保证耐久性

+   如何在副本集中设置事务的耐久性级别

在本章中，我们将讨论副本集中的耐久性。三成员副本集是推荐用于生产应用程序的最基本集群。这里的讨论适用于成员更多的副本集和分片集群。

# 通过日志记录实现成员级别的耐久性

为了在服务器故障时提供耐久性，MongoDB 使用称为*日志*的写前日志（WAL）。写前日志是数据库系统中常用的耐久性技术。其基本思想是在将更改应用到数据库本身之前，我们仅将要进行的更改的表示写入持久性介质（即磁盘）。在许多数据库系统中，写前日志用于提供原子性数据库属性。然而，MongoDB 使用其他技术来确保原子写入。

从 MongoDB 4.0 开始，当应用程序向副本集执行写入操作时，MongoDB 为所有复制集合中的数据创建使用与操作日志（oplog）相同格式的日志条目。如在第十一章所述，MongoDB 使用基于语句的复制，基于操作日志（oplog）。oplog 中的语句是对每个文档受到写入影响的实际 MongoDB 更改的表示。因此，oplog 语句易于应用到副本集的任何成员，无论版本、硬件或其他副本集成员之间的差异如何。此外，每个 oplog 语句都是幂等的，这意味着可以多次应用，并且结果总是对数据库的相同更改。

与大多数数据库一样，MongoDB 保持内存中的日志和数据库数据文件的视图。默认情况下，它每 50 毫秒刷新一次日志条目到磁盘，并每 60 秒刷新一次数据库文件到磁盘。刷新数据文件的 60 秒间隔称为*检查点*。日志用于为自上次检查点以来写入的数据提供持久性。就持久性问题而言，如果服务器突然停止，重新启动时可以使用日志来重放在关闭之前未刷新到磁盘的任何写入。

对于日志文件，MongoDB 在*dbPath*目录下创建一个名为*journal*的子目录。WiredTiger（MongoDB 的默认存储引擎）日志文件的名称格式为*WiredTigerLog.<sequence>*，其中*<sequence>*是从*0000000001*开始的零填充数字。除非是非常小的日志记录，MongoDB 会压缩写入到日志的数据。日志文件的最大大小限制约为 100 MB。一旦日志文件超过该限制，MongoDB 会创建一个新的日志文件，并开始在那里写入新记录。因为日志文件只需要用来恢复自上次检查点以来的数据，MongoDB 会在写入新检查点后自动删除“旧”的日志文件，即写在最近检查点之前的日志文件。

如果发生崩溃（或`kill -9`），*mongod*将在启动时重新播放其日志文件。默认情况下，丢失写入的最大范围是在最后 100 毫秒内进行的写入，加上刷新日志写入到磁盘所需的时间。

如果您的应用程序需要更短的日志刷新间隔，有两个选项。一个是使用`--journalCommitInterval`选项来更改*mongod*命令的间隔。此选项接受从 1 到 500 毫秒的值。另一个选项，我们将在下一节中讨论，是在写关注中指定所有写入应该记录到磁盘。缩短日志到磁盘的间隔会对性能产生负面影响，因此在更改日志记录默认值之前，您需要确保了解对应用程序的影响。

# 在集群级别使用写关注进行持久性

使用写关注，您可以指定应用程序在响应写入请求时需要什么级别的确认。在副本集中，网络分区、服务器故障或数据中心宕机可能导致写入未被复制到每个成员，甚至大多数成员。当副本集恢复到正常状态时，可能会回滚未复制到大多数成员的写入。在这些情况下，客户端和数据库可能对已提交的数据有不同的视图。

某些情况下，允许写操作回滚的应用程序可能是可以接受的。例如，在某种社交应用程序中回滚少量评论可能是可以接受的。MongoDB 支持在群集级别提供一系列耐久性保证，以便应用程序设计者选择最适合其用例的耐久性级别。

## `writeConcern`的`w`和`wtimeout`选项

MongoDB 查询语言支持为所有插入和更新方法指定写关注。例如，假设我们有一个电子商务应用程序，并希望确保所有订单都是耐久的。将订单写入数据库可能看起来像以下示例：

```
try {
   db.products.insertOne(
       { sku: "H1100335456", item: "Electric Toothbrush Head", quantity: 3 },
       { writeConcern: { w : "majority", wtimeout : 100 } }
   );
} catch (e) {
   print (e);
}
```

所有插入和更新方法都需要第二个参数，即文档。在该文档中，您可以指定`writeConcern`的值。在前面的示例中，我们指定的写关注表明，只有在成功将写操作成功复制到应用程序复制集的大多数成员时，我们才希望从服务器收到写完成的确认。此外，如果在 100 毫秒内未将写操作复制到复制集的大多数成员，则应返回错误。在这种错误情况下，MongoDB 不会撤消在写关注超过时间限制之前执行的成功数据修改操作——应用程序将决定如何处理这些情况下的超时。一般来说，您应该配置`wtimeout`值，以便应用程序只在不寻常的情况下遇到超时，且应用程序在响应超时错误时应确保数据的正确状态。在大多数情况下，您的应用程序应尝试确定超时是否是由于网络通信中的瞬时减速或更重要的原因造成的。

在写关注文档中的`w`值，您可以指定`"majority"`（就像在本例中所做的那样）。或者，您可以指定介于零和复制集成员数之间的整数。最后，可以标记复制集成员，例如识别用于报告与 OLTP 工作负载相比的 SSD 与旋转磁盘，或标识用于报告与 OLTP 工作负载相比的成员。您可以将标签集指定为`w`的值，以确保写入仅在至少一台符合提供的标签集的复制集成员上提交后才得到确认。

## `writeConcern`的`j`（日志记录）选项

除了为`w`选项提供一个值外，您还可以使用写关注文档中的`j`选项请求确认写操作已写入日志。对于`j`的值为`true`，MongoDB 仅在所请求的成员数（即`w`的值）已将操作写入其磁盘日志后才确认成功写入。继续我们的示例，如果我们希望确保所有写入都被大多数成员日志记录，我们可以按以下方式更新代码：

```
try {
   db.products.insertOne(
       { sku: "H1100335456", item: "Electric Toothbrush Head", quantity: 3 },
       { writeConcern: { w : "majority", wtimeout : 100, j : true } }
   );
} catch (e) {
   print (e);
}
```

在不等待日志记录的情况下，每个成员大约有 100 毫秒的短暂窗口期，在此期间，如果服务器进程或硬件故障，写操作可能会丢失。然而，等待日志记录后再确认写入到副本集成员会对性能产生影响。

在处理应用程序耐久性问题时，必须仔细评估应用程序的需求，并权衡所选耐久性设置的性能影响。

# 在集群级别使用读关注的耐久性

在 MongoDB 中，`read concerns` 允许配置何时读取结果。这可以让客户端在这些写入持久化之前看到写入结果。可以将读关注与写关注一起使用，以控制向应用程序提供的一致性和可用性保证级别。它们不应与 `read preferences` 混淆，后者处理数据从何处读取；具体而言，读偏好决定从副本集中的数据承载成员读取数据。默认的 `read preferences` 是从主节点读取。

`Read concern` 确定正在读取的数据的一致性和隔离特性。默认的 `readConcern` 是 `local`，返回的数据不保证已写入到大多数数据承载的副本集成员。这可能导致数据在将来被回滚。`majority` concern 只返回已被大多数副本集成员确认的持久数据（不会被回滚）。在 MongoDB 3.4 中，添加了 `linearizable` concern。它确保返回的数据反映了在读操作开始前已完成的所有成功的大多数确认写入。它可能会等待并发执行的写入操作完成后再提供结果。

同样地，使用 `write concerns` 时，您需要权衡 `read concerns` 的性能影响，以及它们在选择适当的关注点时提供的耐久性和隔离保证。

# 使用写关注的事务耐久性

在 MongoDB 中，对单个文档的操作是原子的。您可以使用嵌入文档和数组在单个文档中表达实体之间的关系，而不是使用规范化的数据模型将实体和关系分割到多个集合中。因此，许多应用程序不需要多文档事务。

但是，对于需要对多个文档进行原子更新的用例，MongoDB 提供了针对副本集执行多文档事务的能力。多文档事务可以跨多个操作、文档、集合和数据库使用。

事务要求事务内的所有数据更改都成功。如果任何操作失败，事务将中止并且所有数据更改都将被丢弃。如果所有操作都成功，事务中进行的所有数据更改都将被保存，并且写操作将对未来读取可见。

与单个写操作一样，您可以为事务指定写关注点。您在事务级别设置写关注点，而不是在单个操作级别。在提交时，事务使用事务级别的写关注点来提交写操作。在事务内部设置的单个操作的写关注点将被忽略。

您可以在事务开始时为事务提交设置写关注点。不支持事务的写关注点为`0`。如果您为事务使用写关注点为`1`，则如果发生故障转移，可以回滚事务。您可以使用`"majority"`写关注点来确保在副本集中因网络和服务器故障而导致故障转移时事务的持久性。以下提供了一个示例：

```
function updateEmployeeInfo(session) {
    employeesCollection = session.getDatabase("hr").employees;
    eventsCollection = session.getDatabase("reporting").events;

    session.startTransaction( {writeConcern: { w: "majority" } } );

    try{
        employeesCollection.updateOne( { employee: 3 }, 
                                       { $set: { status: "Inactive" } } );
        eventsCollection.insertOne( { employee: 3, status: { new: "Inactive", 
                                      old: "Active" } } );
    } catch (error) {
        print("Caught exception during transaction, aborting.");
        session.abortTransaction();
        throw error;
    }

    commitWithRetry(session);
}
```

# MongoDB 不保证的内容

有几种情况下 MongoDB 无法保证持久性，比如硬件问题或文件系统漏洞。特别是，如果硬盘损坏，MongoDB 无法保护您的数据。

此外，不同类型的硬件和软件可能具有不同的持久性保证。例如，一些较便宜或较旧的硬盘在写入被排队等待时报告写入成功，而不是实际写入时。MongoDB 无法在此级别防止错误报告：如果系统崩溃，可能会丢失数据。

基本上，MongoDB 的安全性取决于底层系统：如果硬件或文件系统破坏数据，MongoDB 无法阻止。使用复制来防御系统问题。如果一台机器故障，希望另一台仍然正常运行。

# 检查损坏情况

`validate`命令可用于检查集合是否损坏。要在*movies*集合上运行`validate`，请执行：

```
db.movies.validate({full: true})
{
	"ns" : "sample_mflix.movies",
	"nInvalidDocuments" : NumberLong(0),
	"nrecords" : 45993,
	"nIndexes" : 5,
	"keysPerIndex" : {
		"_id_" : 45993,
		"$**_text" : 3671341,
		"genres_1_imdb.rating_1_metacritic_1" : 94880,
		"tomatoes_rating" : 45993,
		"getMovies" : 45993
	},
	"indexDetails" : {
		"$**_text" : {
			"valid" : true
		},
		"_id_" : {
			"valid" : true
		},
		"genres_1_imdb.rating_1_metacritic_1" : {
			"valid" : true
		},
		"getMovies" : {
			"valid" : true
		},
		"tomatoes_rating" : {
			"valid" : true
		}
	},
	"valid" : true,
	"warnings" : [ ],
	"errors" : [ ],
	"extraIndexEntries" : [ ],
	"missingIndexEntries" : [ ],
	"ok" : 1
}
```

主要的字段是`"valid"`，希望它是`true`。如果不是，`validate`将提供有关发现的损坏的详细信息。

`validate`的大部分输出描述了集合的内部结构和用于理解集群中操作顺序的时间戳。这些对于调试并不特别有用。（详见附录 B 了解更多关于集合内部的信息。）

您只能在集合上运行`validate`，它还将检查字段`indexDetails`中的相关索引。但这需要一个完整的`validate`，可以通过`{ full: true }`选项进行配置。

^(1) MongoDB 使用不同的格式来写入本地数据库，该数据库存储用于复制过程和其他特定实例数据的数据，但其原理和应用方式类似。
