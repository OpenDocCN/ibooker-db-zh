# 第二十三章：制作备份

定期备份系统非常重要。备份可以有效保护免受大多数类型的故障影响，而通过从干净的备份进行恢复几乎可以解决所有问题。本章涵盖了制作备份的常见选项：

+   单服务器备份，包括快照备份和恢复过程

+   备份副本集的特殊考虑事项

+   构建一个分片集群

仅当您对在紧急情况下部署备份感到有信心时，备份才有用。因此，无论您选择哪种备份技术，请务必练习制作备份和从备份中恢复，直到您熟悉恢复过程。

# 备份方法

有多种选项可以备份 MongoDB 集群。MongoDB Atlas，官方 MongoDB 云服务，提供连续备份和云提供商快照。连续备份会增量备份集群中的数据，确保备份通常仅落后操作系统几秒钟。云提供商快照使用集群云服务提供商（例如 Amazon Web Services，Microsoft Azure 或 Google Cloud Platform）的快照功能提供本地化备份存储。对于大多数情况，最佳的备份解决方案是连续备份。

MongoDB 还通过 Cloud Manager 和 Ops Manager 提供备份功能。Cloud Manager 是 MongoDB 的托管备份、监控和自动化服务。Ops Manager 是一个本地解决方案，具有与 Cloud Manager 类似的功能。

对于直接管理 MongoDB 集群的个人和团队，有几种备份策略。本章的其余部分将概述这些策略。

# 备份服务器

有多种方法可以创建备份。无论使用哪种方法，备份都可能对系统造成压力：通常需要将所有数据读入内存。因此，备份通常应该在副本集的次要成员（而不是主要成员）上进行，或者对于独立服务器，在非高峰时间进行。

本节中的技术适用于任何*mongod*，无论是独立服务器还是副本集的成员，除非另有说明。

## 文件系统快照

文件系统快照使用系统级工具创建 MongoDB 数据文件所在设备的副本。这些方法完成迅速且可靠，但需要在 MongoDB 之外进行额外的系统配置。

MongoDB 3.2 添加了对使用 WiredTiger 存储引擎进行卷级备份的支持，当这些实例的数据文件和日志文件驻留在不同卷上时。然而，为了创建一个一致的备份，必须锁定数据库并在备份过程中暂停对数据库的所有写操作。

在 MongoDB 3.2 之前，使用 WiredTiger 创建 MongoDB 实例的卷级备份要求数据文件和日志文件驻留在同一个卷上。

快照通过在实时数据和特殊快照卷之间创建指针来工作。这些指针在理论上等同于“硬链接”。随着工作数据与快照的分歧，快照过程采用写时复制策略。因此，快照仅存储修改后的数据。

制作快照后，您将快照映像挂载到文件系统上，并从快照中复制数据。生成的备份包含所有数据的完整副本。

快照拍摄时数据库必须有效。这意味着数据库接受的所有写操作都需要完全写入磁盘：要么写入日志，要么写入数据文件。如果备份时还有未写入磁盘的写操作，则备份将不会反映这些更改。

对于 WiredTiger 存储引擎，数据文件反映了最后一个检查点时的一致状态。检查点每分钟发生一次。

快照创建整个磁盘或卷的映像。除非您需要备份整个系统，否则请考虑将 MongoDB 数据文件、日志（如果适用）和配置隔离在一个不包含任何其他数据的逻辑磁盘上。或者，将所有 MongoDB 数据文件存储在专用设备上，以便您可以备份而不复制多余的数据。

确保您从快照中复制数据到其他系统。这样可以确保数据免受站点故障的影响。

如果您的*mongod*实例启用了日志记录，则可以使用任何类型的文件系统或卷/块级快照工具来创建备份。

如果您在基于 Linux 的系统上管理自己的基础设施，请使用 Linux 逻辑卷管理器（LVM）配置系统，以提供磁盘包和提供快照功能。LVM 允许动态调整大小的文件系统的灵活组合和分割物理磁盘分区。您还可以在云/虚拟化环境中使用基于 LVM 的设置。

在 LVM 的初始设置中，首先我们为物理卷分配磁盘分区（`pvcreate`），然后将其中一个或多个分配给卷组（`vgcreate`），然后创建逻辑卷（`lvcreate`），引用卷组。我们可以在逻辑卷上建立文件系统（`mkfs`），创建后可以挂载以供使用（`mount`）。

### 快照备份和恢复过程

本节概述了在 Linux 系统上使用 LVM 进行简单备份的过程。虽然工具、命令和路径在您的系统上可能略有不同，但以下步骤提供了备份操作的高级概述。

仅将以下程序用作备份系统和基础设施的指南。生产备份系统必须考虑特定环境中的多个应用程序特定要求和因素。

要使用 LVM 创建快照，请以`root`用户发出以下格式的命令：

```
# lvcreate --size 100M --snapshot --name mdb-snap01 /dev/vg0/mongodb
```

此命令使用 `--snapshot` 选项创建名为 `mdb-snap01` 的 LVM 快照，该快照位于 `vg0` 卷组中的 `mongodb` 卷上，路径为 `/dev/vg0/mdb-snap01`。根据您的操作系统的 LVM 配置，系统、卷组和设备的位置和路径可能会略有不同。

由于参数 `--size 100M` 的限制，快照的容量为 100 MB。这个大小不反映磁盘上数据的总量，而是当前 */dev/vg0/mongodb* 状态与快照 (*/dev/vg0/mdb-snap01*) 之间差异的量。

当命令返回时，快照将存在。您可以随时直接从快照恢复，或者创建一个新的逻辑卷，并从快照恢复到备用映像。

尽管快照非常适合快速创建高质量备份，但作为存储备份数据的格式并不理想。快照通常依赖于并驻留在与原始磁盘映像相同的存储基础设施上。因此，非常重要的是将这些快照归档并存储在其他地方。

创建快照后，挂载快照并将数据复制到独立存储。或者，执行如下过程，对快照图像进行块级复制，例如：

`# umount /dev/vg0/mdb-snap01`

`# dd if=/dev/vg0/mdb-snap01 | gzip > mdb-snap01.gz`

此命令序列执行以下操作：

+   确保 */dev/vg0/mdb-snap01* 设备未被挂载

+   使用 `dd` 命令执行整个快照图像的块级复制，并将结果压缩为当前工作目录中的一个 gzipped 文件

###### 警告

`dd` 命令将在当前工作目录中创建一个大的 *.gz* 文件。确保在有足够空闲空间的文件系统中运行 *这个命令*。

要恢复使用 LVM 创建的快照，请执行以下命令序列：

`# lvcreate --size 1G --name mdb-new vg0`

`# gzip -d -c mdb-snap01.gz | dd of=/dev/vg0/mdb-new`

`# mount /dev/vg0/mdb-new /srv/mongodb`

此序列执行以下操作：

+   在 */dev/vg0* 卷组中创建一个名为 *mdb-new* 的新逻辑卷。新设备的路径将为 */dev/vg0/mdb-new*。您可以使用不同的名称，并将 1G 更改为所需的卷大小。

+   将 *mdb-snap01.gz* 文件解压并解档到 *mdb-new* 磁盘映像中。

+   挂载 *mdb-new* 磁盘映像到 */srv/mongodb* 目录。根据需要修改挂载点以对应您的 MongoDB 数据文件位置或其他位置。

恢复的快照将具有陈旧的 `mongod.lock` 文件。如果不从快照中删除此文件，MongoDB 可能会认为陈旧的锁文件指示了一个不干净的关闭。如果您启用了 `storage.journal.enabled` 并且没有使用 `db.fsyncLock()`，则不需要删除 `mongod.lock` 文件。如果您使用了 `db.fsyncLock()`，则需要删除该锁。

要恢复备份而不写入压缩的 *.gz* 文件，请使用以下命令序列：

`# umount /dev/vg0/mdb-snap01`

`# lvcreate --size 1G --name mdb-new vg0`

`# dd if=/dev/vg0/mdb-snap01 of=/dev/vg0/mdb-new`

`# mount /dev/vg0/mdb-new /srv/mongodb`

可以使用组合过程和 SSH 实现离系统备份。这个序列与之前解释的过程完全相同，只是使用 SSH 在远程系统上存档并压缩备份：

`umount /dev/vg0/mdb-snap01`

`dd if=/dev/vg0/mdb-snap01 | ssh username@example.com gzip > /opt/backup/mdb-snap01.gz`

`lvcreate --size 1G --name mdb-new vg0`

`ssh username@example.com gzip -d -c /opt/backup/mdb-snap01.gz | dd of=/dev/vg0/mdb-new`

`mount /dev/vg0/mdb-new /srv/mongodb`

从 MongoDB 3.2 开始，为了使用 WiredTiger 对 MongoDB 实例进行卷级备份，不再需要数据文件和日志驻留在单个卷上。然而，在备份过程中必须锁定数据库并暂停对数据库的所有写入，以确保备份的一致性。

如果您的 *mongod* 实例正在运行而没有使用日志或将日志文件存储在单独的卷上，则必须将所有写操作刷新到磁盘并锁定数据库以防止备份过程中的写入。如果您有副本集配置，则备份时请使用未接收读取的次要成员（即隐藏成员）。

要执行此操作，请在 `mongo` shell 中使用 `db.fsyncLock()` 方法：

```
> db.fsyncLock();
```

然后执行先前描述的备份操作。

快照完成后，在 `mongo` shell 中发出以下命令解锁数据库：

```
> db.fsyncUnlock();
```

此过程在以下部分中有更详细的描述。

## 复制数据文件

另一种创建单服务器备份的方法是复制数据目录中的所有内容。由于不能同时复制所有文件而没有文件系统支持，因此必须在复制数据文件时防止其变化。这可以通过称为 `fsyncLock` 的命令来完成：

```
> db.fsyncLock()
```

此命令锁定数据库以防止进一步的写入，并将所有脏数据刷新到磁盘（`fsync`），确保数据目录中的文件具有最新的一致信息且不在变化。

运行此命令后，*mongod* 将排队所有传入的写入。在解锁之前，它不会处理任何进一步的写入。请注意，此命令会停止对*所有*数据库（而不仅仅是连接到的数据库）的写入。

一旦 `fsyncLock` 命令返回，将所有数据目录中的文件复制到备份位置。在 Linux 上，可以使用以下命令完成：

```
$ cp -R /data/db/* /mnt/external-drive/backup
```

确保将数据目录中的每个文件和文件夹都复制到备份位置。排除文件或目录可能会导致备份无法使用或损坏。

完成数据复制后，请解锁数据库以允许其再次写入：

```
> db.fsyncUnlock()
```

你的数据库将会正常处理写操作。

请注意，使用认证和`fsyncLock`存在一些锁定问题。如果使用认证，请不要在调用`fsyncLock`和`fsyncUnlock`之间关闭 Shell。如果断开连接，您可能无法重新连接并且必须重新启动*mongod*。`fsyncLock`设置在重新启动之间不会持久化；*mongod*始终会解锁启动。

作为`fsyncLock`的替代方法，你可以关闭*mongod*，复制文件，然后再次启动*mongod*。关闭*mongod*会有效地将所有更改刷新到磁盘，并在备份期间防止新的写入操作发生。

要从数据目录的副本中恢复，请确保*mongod*没有在运行，并且要将要恢复的数据目录清空。将备份的数据文件复制到数据目录，然后启动*mongod*。例如，以下命令将恢复之前显示的命令备份的文件：

```
$ cp -R /mnt/external-drive/backup/* /data/db/
$ mongod -f mongod.conf
```

尽管有关部分数据目录副本的警告，如果您知道要复制的内容以及使用`--directoryperdb`选项，您可以使用此方法备份单个数据库。要备份一个名为*myDB*的单个数据库（仅在使用`--directoryperdb`选项时可用），复制整个*myDB*目录。部分数据目录副本仅在使用`--directoryperdb`选项时才可能。

您可以通过仅复制具有正确数据库名称的文件来恢复特定数据库到您的数据目录中。如果要这样逐个还原，必须从干净的关闭开始。如果发生崩溃或硬关闭，请勿尝试从备份中恢复单个数据库：替换整个目录并启动*mongod*以允许重放日志文件。

###### 警告

永远不要与*mongodump*（稍后描述）一起使用`fsyncLock`。根据数据库的其他操作，*mongodump*可能会永远挂起如果数据库被锁定。

## 使用 mongodump

最后一种制作单服务器备份的方法是使用*mongodump*。之所以将*mongodump*放在最后提到，是因为它有一些缺点。它速度较慢（获取备份和从中恢复）并且在复制集方面存在一些问题，这些问题在“复制集的特定注意事项”中有讨论。但是，它也有一些好处：是备份单个数据库、集合甚至集合子集的好方法。

*mongodump*有多种选项，可以通过运行`mongodump --help`查看。在这里，我们将重点介绍用于备份的最有用的选项。

要备份所有数据库，只需运行*mongodump*。如果在与*mongod*相同的机器上运行*mongodump*，只需指定*mongod*运行的端口即可：

```
$ mongodump -p 31000
```

*mongodump* 将在当前目录下创建一个 *dump* 目录，其中包含所有数据的备份。这个 *dump* 目录按数据库和集合分别组织成文件夹和子文件夹。实际数据存储在 *.bson* 文件中，这些文件只是将每个集合中的每个文档以 BSON 格式串联在一起。你可以使用随 MongoDB 一起提供的 *bsondump* 工具查看 *.bson* 文件。

你甚至不需要运行服务器就可以使用 *mongodump*。你可以使用 `--dbpath` 选项指定你的数据目录，*mongodump* 将使用数据文件进行数据复制：

```
$ mongodump --dbpath /data/db
```

如果 *mongod* 在运行，则不应使用 `--dbpath`。

*mongodump* 的一个问题是它不是即时备份：备份进行时系统可能正在写入。因此，可能出现这样的情况，用户 A 开始了一个导致 *mongodump* 转储数据库 *A* 的备份，但同时用户 B 删除了 *A*。然而，*mongodump* 已经完成了转储，因此你将得到一个与原始服务器状态不一致的数据快照。

为了避免这种情况，如果你正在使用 `--replSet` 运行 *mongod*，你可以使用 *mongodump* 的 `--oplog` 选项。这将跟踪备份期间在服务器上发生的所有操作，因此可以在还原备份时重新播放这些操作。这为你提供了源服务器数据的一致时间点快照。

如果你向 *mongodump* 提供一个副本集连接字符串（例如，``"*`setName`*/*`seed1`*,*`seed2`*,*`seed3`*"``），它将自动选择主节点进行备份。如果你想使用副本节点，你可以指定一个 `read preference`。`read preference` 可以通过 `--uri connection string`、`uri readPreferenceTags` 选项或 `--readPreference` 命令行选项来指定。有关各种设置和选项的详细信息，请参阅 [the *mongodump* MongoDB documentation page](https://oreil.ly/GH3-O)。

要从 *mongodump* 备份还原数据，请使用 *mongorestore* 工具：

```
$ mongorestore -p 31000 --oplogReplay dump/
```

如果你在转储数据库时使用了 `--oplog` 选项，你必须在使用 *mongorestore* 还原时使用 `--oplogReplay` 选项来获取时间点快照。

如果你正在替换运行中的服务器上的数据，你可能（或者可能不）希望使用 `--drop` 选项，在还原之前删除集合。

*mongodump* 和 *mongorestore* 的行为随着时间的推移而发生了变化。为了防止兼容性问题，请尽量使用这两个工具的相同版本（你可以通过运行 `mongodump --version` 和 `mongorestore --version` 来查看它们的版本）。

###### 警告

从 MongoDB 版本 4.2 开始，你不能再将 *mongodump* 或 *mongorestore* 用作备份分片集群的策略。这些工具不保证跨分片的事务的原子性。

### 使用 mongodump 和 mongorestore 移动集合和数据库

你可以将数据恢复到与你备份的完全不同的数据库和集合中。如果不同的环境使用不同的数据库名称（比如*dev*和*prod*），但使用相同的集合名称，则这可能非常有用。

要将*.bson*文件恢复到特定的数据库和集合中，请在命令行上指定目标：

```
$ mongorestore --db newDb --collection someOtherColl dump/oldDB/oldColl.bson
```

也可以使用 SSH 与这些工具一起执行数据迁移，使用这些工具的归档功能，无需任何磁盘 I/O。这将三个阶段简化为一个操作，以前你必须备份到磁盘，然后将这些备份文件复制到目标服务器，然后在该服务器上运行*mongorestore*来恢复备份：

```
$ ssh eoin@proxy.server.com mongodump --host source.server.com\ --archive 
        | ssh eoin@target.server.com mongorestore --archive
```

压缩可以与这些工具的归档功能结合使用，进一步减少执行数据迁移时发送的信息量。以下是使用这些工具的归档和压缩功能执行相同 SSH 数据迁移示例：

```
$ ssh eoin@proxy.server.com mongodump --host source.server.com\ --archive 
        --gzip | ssh eoin@target.server.com mongorestore --archive --gzip
```

### 唯一索引的管理复杂性

如果你的集合中有唯一索引（除了`"_id"`以外），你应该考虑使用不同于*mongodump*/*mongorestore*的备份类型。唯一索引要求在复制过程中数据不会以违反唯一索引约束的方式发生变化。确保这一点的最安全方法是选择一种“冻结”数据的方法，然后按照前两节中的任一描述进行备份。

如果你决定使用*mongodump*/*mongorestore*，在从备份恢复数据时可能需要预处理你的数据。

# 副本集的特定考虑因素

在备份副本集时的主要额外考虑因素是，除了数据之外，你还必须捕获副本集的状态，以确保对部署进行准确的时间点快照。

通常，应从次要节点进行备份：这样可以减轻主节点的负载，并且你可以锁定次要节点而不影响你的应用程序（只要你的应用程序不发送读请求到次要节点）。你可以使用前面概述的任一三种方法之一来备份副本集成员，但建议使用文件系统快照或数据文件复制。这些技术都可以应用于副本集的次要节点而无需修改。

当启用复制时，使用*mongodump*不是那么简单。首先，如果你使用*mongodump*，必须使用`--oplog`选项进行备份，以获取一个时间点的快照；否则备份的状态将不会与集群中其他成员的状态匹配。当从*mongodump*备份中恢复时，你还必须创建一个操作日志，否则恢复后的成员将不知道它同步到了哪里。

要从 *mongodump* 备份中恢复副本集成员，请将目标副本集成员作为独立服务器启动，并使用空数据目录运行 *mongorestore*（如前一节所述），并使用 `--oplogReplay` 选项。现在它应该具有完整的数据副本，但仍然需要一个 oplog。使用 `createCollection` 命令创建一个 oplog：

```
> use local
> db.createCollection("oplog.rs", {"capped" : true, "size" : 10000000})
```

指定集合的字节大小。请参阅 “调整 Oplog 大小” 以获取有关 oplog 大小调整的建议。

现在您需要填充 oplog。最简单的方法是将转储的 *oplog.bson* 文件恢复到 *local.oplog.rs* 集合中：

```
$ mongorestore -d local -c oplog.rs dump/oplog.bson
```

注意，这不是 oplog 本身的转储（*dump/local/oplog.rs.bson*），而是在转储过程中发生的 oplog 操作。一旦完成此 *mongorestore*，您可以将此服务器重新启动为副本集成员。

# 分片集群的特殊考虑因素

使用本章介绍的方法备份分片集群时的主要额外考虑因素是，您只能在它们活跃时备份各个分片，并且在活跃状态下几乎不可能“完美地”备份分片集群：无法在某一时刻获得集群整体状态的快照。然而，一般情况下，随着集群规模的增大，您几乎不太可能需要从备份中恢复整个集群。因此，在处理分片集群时，我们关注备份各个部分：配置服务器和副本集各自的备份。如果您需要能够备份整个集群到特定时间点，或者希望使用自动化解决方案，可以使用 MongoDB 的 Cloud Manager 或 Atlas 备份功能。

在对分片集群执行任何这些操作（备份或恢复）之前，请关闭平衡器。您无法在分片飞来飞去的情况下获取一个一致的世界快照。请参阅 “平衡数据” 以获取有关打开和关闭平衡器的说明。

## 备份和恢复整个集群

当集群非常小或处于开发阶段时，您可能确实希望转储和恢复整个集群。您可以通过关闭平衡器，然后通过 *mongos* 运行 *mongodump* 来实现这一点。这会在运行 *mongodump* 的机器上备份所有分片的数据。

要从这种类型的备份恢复，请运行连接到 *mongos* 的 *mongorestore*。

或者，在关闭平衡器后，您可以获取每个分片和配置服务器的文件系统或数据目录备份。但是，您将不可避免地在略有不同的时间点获得每个备份副本，这可能会或可能不会成为问题。此外，一旦启用平衡器并进行迁移，您从一个分片备份的一些数据将不再存在。

## 备份和恢复单个分片

大多数情况下，您只需要恢复集群中的一个分片。如果您不是太挑剔的话，可以使用刚才描述的单服务器方法之一从该分片的备份中恢复。

然而，有一个重要问题需要注意。假设您在星期一备份了集群。到了星期四，您的硬盘损坏了，您需要从备份中恢复。在这几天中，新的数据块可能已经移到了该分片。您星期一备份的分片不包含这些新的数据块。您可能可以使用配置服务器的备份来找出星期一消失的数据块在哪里，但这比简单地恢复分片要困难得多。在大多数情况下，恢复分片并丢失这些数据块中的数据是更可取的路径。

您可以直接连接到一个分片来从备份中恢复（而不通过*mongos*）。
