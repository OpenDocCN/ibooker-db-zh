# 第八章：处理日期和时间

# 8.0 介绍

MySQL 拥有多种数据类型来表示日期和时间，并提供许多操作这些数据的函数。MySQL 以特定的格式存储日期和时间，了解这些格式对于避免处理时间数据时的意外结果非常重要。本章涵盖了在 MySQL 中处理日期和时间值时的以下几个方面：

选择合适的时间数据类型

在创建表时，MySQL 提供了多种时间数据类型可供选择。了解它们的属性有助于适当地选择。

显示日期和时间

MySQL 默认使用特定格式显示时间值。您可以通过使用适当的函数生成其他格式。

更改客户端时区

服务器在客户端的当前时区解释`TIMESTAMP`和`DATETIME`值，而不是服务器自身的时区。不同时区的客户端应设置其时区，以便服务器能够正确解释它们的`TIMESTAMP`值。

确定当前日期和时间

MySQL 提供了返回日期和时间的函数。这些对于必须知道这些值或需要根据它们计算其他时间值的应用程序非常有用。

跟踪行修改时间

`TIMESTAMP`和`DATETIME`数据类型具有特殊属性，可以自动记录行的创建和最后修改时间。

将日期和时间拆分为组件值，从组件值创建日期和时间

当您只需要组件（如日期的月份部分或时间的小时部分）时，可以拆分日期和时间值。反之，您可以组合组件值来合成日期和时间。

在日期或时间之间进行转换以及与基本单位之间的转换

一些时间计算，如日期算术运算，通过使用日期或时间值所代表的天数或秒数而不是值本身，更容易执行。MySQL 可以在日期和时间值与天数或秒数等更基本的单位之间进行转换。

日期和时间算术

您可以添加或减去时间值以生成其他时间值或计算值之间的间隔。应用包括年龄确定、相对日期计算和日期偏移。

根据时间约束选择数据

在前述章节讨论的计算以产生输出值的同时，也可以用于`WHERE`子句中，指定如何使用时间条件选择行。

本章涵盖了几个 MySQL 函数，用于操作日期和时间值，但还有许多其他函数。要了解完整集合，请参阅[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html)。您可以利用提供给您的多种函数进行给定的时间计算。我们有时会展示达到给定结果的替代方法，本章讨论的许多问题可以用其他方法解决。我们邀请您进行实验以寻找其他解决方案。您可能会找到更有效或更直观的方法。

本章讨论的配方实现脚本位于`recipes`源分发的*dates*目录中。创建这些表的脚本位于*tables*目录中。

# 8.1 选择一个时间数据类型

## 问题

您需要存储时间数据，但不确定哪种数据类型最合适。

## 解决方案

根据要存储的信息特性及其使用需求选择数据类型。

## 讨论

要选择时间数据类型，请考虑以下问题：

+   您只需要时间、日期或组合日期和时间值？

+   您需要哪个值范围？

+   您是否希望列自动初始化为当前日期和时间？

MySQL 提供`DATE`和`TIME`数据类型，用于分别表示日期和时间值，以及`DATETIME`和`TIMESTAMP`类型，用于表示组合的日期和时间值。这些数值具有以下特点：

+   `DATE`数值采用*`YYYY-MM-DD`*格式，其中*`YY`*、*`MM`*和*`DD`*分别表示年、月和日部分。支持的`DATE`数值范围是`1000-01-01`至`9999-12-31`。

+   `TIME`数值采用*`hh:mm:ss`*格式，其中*`hh`*、*`mm`*和*`ss`*分别表示小时、分钟和秒部分。`TIME`数值通常可以视为一天中的时间值，但 MySQL 实际上将它们视为经过的时间。因此，它们可以大于`23:59:59`甚至为负数。（`TIME`列的实际范围是`-838:59:59`至`838:59:59`。）

+   `DATETIME`和`TIMESTAMP`是组合的日期和时间值，采用*`YYYY-MM-DD`* *`hh:mm:ss`*格式。

    `DATETIME`和`TIMESTAMP`数据类型在许多方面相似，但要注意以下差异：

    +   `DATETIME`支持范围为`1000-01-01 00:00:00`至`9999-12-31 23:59:59`，而`TIMESTAMP`数值仅在 1970 年部分到 2038 年之间有效。

    +   `TIMESTAMP`和`DATETIME`具有特殊的自动初始化和自动更新属性（参见配方 8.8），但在 MySQL 5.6.5 之前，`DATETIME`不具备此功能。

    +   当客户端插入`TIMESTAMP`值时，服务器将其从与客户端会话关联的时区转换为 UTC 并存储 UTC 值。当客户端检索`TIMESTAMP`值时，服务器执行相反操作，将 UTC 值转换回客户端会话时区。如果客户端位于与服务器不同的时区，则可以配置其会话，使此转换适合其自己的时区（参见 Recipe 8.4）。

+   包含时间部分的类型可以具有用于毫秒级分辨率的分数秒部分（参见 Recipe 8.2）。

本章中许多示例使用以下表，其中包含表示时间、日期和日期时间值的列。（`time_val`表有两列，用于时间间隔计算示例。）

```
mysql> `SELECT t1, t2 FROM time_val;`
+----------+----------+
| t1       | t2       |
+----------+----------+
| 15:00:00 | 15:00:00 |
| 05:01:30 | 02:30:20 |
| 12:30:20 | 17:30:45 |
+----------+----------+
mysql> `SELECT d FROM date_val;`
+------------+
| d          |
+------------+
| 1864-02-28 |
| 1900-01-15 |
| 1999-12-31 |
| 2000-06-04 |
| 2017-03-16 |
+------------+
mysql> `SELECT dt FROM datetime_val;`
+---------------------+
| dt                  |
+---------------------+
| 1970-01-01 00:00:00 |
| 1999-12-31 09:00:00 |
| 2000-06-04 15:45:30 |
| 2017-03-16 12:30:15 |
+---------------------+
```

在继续阅读之前，立即创建`time_val`、`date_val`和`datetime_val`表是个好主意。（在`recipes`分发的*tables*目录中使用适当的脚本。）

# 8.2 使用分数秒支持

## 问题

您的应用程序需要毫秒级时间值的分辨率。

## 解决方案

指定分数秒。

## 讨论

自 MySQL 5.6.4 起，支持包含时间部分的时间类型的分数秒：`DATETIME`、`TIME`和`TIMESTAMP`。对于需要毫秒级时间值分辨率的应用程序，这使您能够指定分数秒的精度，甚至可以达到微秒级别。

默认情况下没有分数秒部分，因此对于支持此功能的时间类型，需要在列声明中明确指定：在数据类型名称后包含`(`*`fsp`*`)`。*`fsp`*可以从 0 到 6，表示小数位数。0 表示<q>无</q>（分辨率为秒），6 表示分辨率为微秒。例如，要创建带有两位小数的`TIME`列（分辨率为百分之一秒），请使用以下语法：

```
mycol TIME(2)
```

对于特定事件（如赛车），精确的时间跟踪至关重要。全球最流行且最具时间敏感性的赛事之一是世界各地的 F1 赛车比赛。对于最快的赛车运动，时间跟踪需要详细的计时和技术支持。简而言之，使用多个转发器，必须跟踪的时间在万分之一秒内。

表 8-1. 2021 年土耳其大奖赛 - F1 罗斯表格

| 驾驶员 | 车辆 | 时间 |
| --- | --- | --- |
| 马克斯·维斯塔潘 | 红牛赛车本田 | `1:17.301` |
| 瓦尔特利·博塔斯 | 梅赛德斯 | `1:17.725` |
| 路易斯·汉密尔顿 | 梅赛德斯 | `1:17.810` |

返回当前时间或日期时间值的时间函数也支持分数秒。如果没有参数，默认值为无小数部分。否则，参数指定所需的分辨率。允许的值为 0 到 6，与声明时间列时相同：

```
mysql> `SELECT CURTIME(), CURTIME(2), CURTIME(6);`
+-----------+-------------+-----------------+
| CURTIME() | CURTIME(2)  | CURTIME(6)      |
+-----------+-------------+-----------------+
| 18:07:03  | 18:07:03.24 | 18:07:03.244950 |
+-----------+-------------+-----------------+
```

为了更好地演示，我们将以土耳其最近举行的一场 Formula 1 赛事的赛果为例（表 8-1）。

```
CREATE TABLE `formula1` (
    id INT AUTO_INCREMENT PRIMARY KEY,
    position INT UNSIGNED,
    no       INT UNSIGNED,
    driver   VARCHAR(25),
    car      VARCHAR(25),
    laps     SMALLINT,
    time     TIMESTAMP(3),
    points   SMALLINT
);
```

```
INSERT INTO formula1 VALUES(0,1,77,"Valtteri Bottas","MERCEDES",58,"2021-10-08 
\ 1:31:04.103",26);
INSERT INTO formula1 VALUES(0,2,33,"Max Verstappen","RED BULL RACING HONDA",58,
\"2021-10-08 1:45:58.243",18);
INSERT INTO formula1 VALUES(0,3,11,"Sergio Perez","RED BULL RACING HONDA",58,
\"2021-10-08 1:46:10.342",15);
```

```
SELECT POSITION as pos,
        no,
        driver,
        car,
        laps,
        date_format(time,'%H:%i:%s:%f') as time,
        points as pts
   FROM formula1 ORDER BY time;
+------+------+-----------------+-----------------------+------+-----------------+------+
| pos  | no   | driver          | car                   | laps | time            | pts  |
+------+------+-----------------+-----------------------+------+-----------------+------+
|    1 |   77 | Valtteri Bottas | MERCEDES              |   58 | 01:31:04:103000 |   26 |
|    2 |   33 | Max Verstappen  | RED BULL RACING HONDA |   58 | 01:45:58:243000 |   18 |
|    3 |   11 | Sergio Perez    | RED BULL RACING HONDA |   58 | 01:46:10:342000 |   15 |
+------+------+-----------------+-----------------------+------+-----------------+------+
```

为了得到驾驶员表现时间间隔的正确列表，我们将使用一个 CTE。我们将在食谱 10.18 中讨论 CTE（公共表达式）。以下是解决方案。

```
SELECT MIN(time) from formula1 into @fastest;

WITH time_gap AS (
  SELECT
    position,
    car,
    driver,
    time,
    TIMESTAMPDIFF(SECOND, time , @fastest) AS seconds
  FROM formula1
),

DIFFERENCES AS (
  SELECT
    position as pos,
    driver,
    car,
    time,
    seconds,
    MOD(seconds, 60) AS seconds_part,
    MOD(seconds, 3600) AS minutes_part
  FROM time_gap
)

SELECT
  pos,
  driver,
  time,
  CONCAT(
    FLOOR(minutes_part / 60), ' min ',
    SUBSTRING_INDEX(SUBSTRING_INDEX(seconds_part,'-',2),'-',-1),' secs'
  ) AS difference
FROM differences;
+------+-----------------+-------------------------+-----------------+
| pos  | driver          | time                    | difference      |
+------+-----------------+-------------------------+-----------------+
|    1 | Valtteri Bottas | 2021-10-08 01:31:04.103 | 0 min 0 secs    |
|    2 | Max Verstappen  | 2021-10-08 01:45:58.243 | -15 min 54 secs |
|    3 | Sergio Perez    | 2021-10-08 01:46:10.342 | -16 min 6 secs  |
+------+-----------------+-------------------------+-----------------+
```

# 8.3 改变 MySQL 的日期格式

## 问题

您想要更改 MySQL 用于表示日期值的 ISO 格式。

## 解决方案

你不能。然而，当存储日期时，你可以将非 ISO 输入值重写为 ISO 格式，并且你可以使用`DATE_FORMAT()`函数将 ISO 值重写为其他格式以便显示。

## 讨论

MySQL 用于`DATE`值的*`YYYY-MM-DD`*格式遵循 ISO 8601 标准表示日期。由于日期字符串中年、月和日部分具有固定长度且从左到右显示，这种格式具有将日期自然排序到适当时间顺序的有用属性。食谱 9.5 和食谱 10.15 讨论了基于日期值的排序和分组技术。

尽管 ISO 格式很常见，但并非所有数据库系统都使用它，这可能会在不同系统之间移动数据时引发问题。此外，人们通常喜欢以*`MM/DD/YY`*或*`DD-MM-YYYY`*等其他格式表示日期。这也可能是问题的源头，因为人们对日期的期望与 MySQL 实际表示它们的方式不匹配。

MySQL 新手经常问的一个问题是，“如何告诉 MySQL 以特定格式（例如*`MM/DD/YYYY`*）存储日期？”这是错误的问题。相反，应该问，“如果我有一个特定格式的日期，如何将其存储为 MySQL 支持的格式，反之亦然？”MySQL 始终以 ISO 格式存储日期，这一事实对数据输入（输入）和显示查询结果（输出）都有影响：

+   对于数据输入目的，要存储不是 ISO 格式的值，通常必须首先重写它们。如果不想重写它们，可以将它们存储为字符串（例如，在`CHAR`列中）。但是然后你无法将它们作为日期操作。

    第十三章涵盖了数据输入的日期重写主题，而第十四章讨论了检查日期以验证其有效性。在某些情况下，如果您的值接近 ISO 格式，则可能不需要重写。例如，当将它们存储到`DATE`列中时，MySQL 将解释字符串值`87-1-7`和`1987-1-7`以及数字`870107`和`19870107`为日期`1987-01-07`。

+   为了显示目的，可以将日期重写为非 ISO 格式。`DATE_FORMAT()` 函数提供了将日期值转换为其他格式的灵活性（请参阅本节后面的详细信息）。您还可以使用函数如 `YEAR()` 来提取日期的部分以供显示（请参见 Recipe 8.9）。有关进一步讨论，请参见 Recipe 14.17。

重写非 ISO 格式日期输入的一种方法是使用 `STR_TO_DATE()` 函数，该函数接受表示时间值的字符串和指定值的语法的格式字符串。<br>在格式化字符串中，使用形式为 `%`*`c`* 的特殊序列，其中 *`c`* 指定要期望的日期部分。<br>例如，`%Y`、`%M` 和 `%d` 表示四位数年份、月份名称和两位数日期。<br>要将值 `May` `13,` `2007` 插入到 `DATE` 列中，请执行以下操作：

```
mysql> `INSERT INTO t (d) VALUES(STR_TO_DATE('May 13, 2007','%M %d, %Y'));`
mysql> `SELECT d FROM t;`
+------------+
| d          |
+------------+
| 2007-05-13 |
+------------+
```

对于日期显示，MySQL 使用 ISO 格式（*`YYYY-MM-DD`*），除非另有说明。要以其他格式显示日期或时间，请使用 `DATE_FORMAT()` 或 `TIME_FORMAT()` 函数进行重写。如果需要更专业化的格式，这些函数无法提供，请编写存储函数。

`DATE_FORMAT()` 函数接受两个参数：`DATE`、`DATETIME` 或 `TIMESTAMP` 值，以及描述如何显示该值的字符串。格式字符串使用与 `STR_TO_DATE()` 相同类型的指示符。<br>以下语句显示了 `date_val` 表中的值，一是 MySQL 默认显示它们的方式，二是使用 `DATE_FORMAT()` 重新格式化它们：

```
mysql> `SELECT d, DATE_FORMAT(d,'%M %d, %Y') FROM date_val;`
+------------+----------------------------+
| d          | DATE_FORMAT(d,'%M %d, %Y') |
+------------+----------------------------+
| 1864-02-28 | February 28, 1864          |
| 1900-01-15 | January 15, 1900           |
| 1999-12-31 | December 31, 1999          |
| 2000-06-04 | June 04, 2000              |
| 2017-03-16 | March 16, 2017             |
+------------+----------------------------+
```

由于 `DATE_FORMAT()` 生成的列标题很长，通常很有用为其提供别名（请参见 Recipe 5.2），以使标题更简洁或更有意义：

```
mysql> `SELECT d, DATE_FORMAT(d,'%M %d, %Y') AS date FROM date_val;`
+------------+-------------------+
| d          | date              |
+------------+-------------------+
| 1864-02-28 | February 28, 1864 |
| 1900-01-15 | January 15, 1900  |
| 1999-12-31 | December 31, 1999 |
| 2000-06-04 | June 04, 2000     |
| 2017-03-16 | March 16, 2017    |
+------------+-------------------+
```

[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html) 提供了与 `DATE_FORMAT()`、`TIME_FORMAT()` 和 `STR_TO_DATE()` 一起使用的完整格式序列列表。<br>Table 8-2 显示了其中的一些：

Table 8-2\. 用于日期和时间格式化函数的格式序列

| Sequence | Meaning |
| --- | --- |
| `%Y` | 四位数年份 |
| `%y` | 两位数年份 |
| `%M` | 完整的月份名称 |
| `%b` | 月份名称的前三个字母 |
| `%m` | 两位数年份的月份（01..12） |
| `%c` | 年份中的月份（1..12） |
| `%d` | 两位数日期（01..31） |
| `%e` | 月份中的日期（1..31） |
| `%W` | 星期名称（Sunday..Saturday） |
| `%r` | 带有 AM 或 PM 后缀的 12 小时制时间 |
| `%T` | 24 小时制时间 |
| `%H` | 两位数小时 |
| `%i` | 两位数分钟 |
| `%s` | 两位数秒 |
| `%f` | 六位数微秒 |
| `%%` | 字面上的 `%` |

表中显示的与时间相关的格式序列仅在您向`DATE_FORMAT()`传递同时包含日期和时间部分（`DATETIME`或`TIMESTAMP`）的值时才有用。以下语句显示`datetime_val`表中的`DATETIME`值，使用包含每天时间的格式：

```
mysql> `SELECT dt,`
    -> `DATE_FORMAT(dt,'%c/%e/%y %r') AS format1,`
    -> `DATE_FORMAT(dt,'%M %e, %Y %T') AS format2`
    -> `FROM datetime_val;`
+---------------------+----------------------+----------------------------+
| dt                  | format1              | format2                    |
+---------------------+----------------------+----------------------------+
| 1970-01-01 00:00:00 | 1/1/70 12:00:00 AM   | January 1, 1970 00:00:00   |
| 1999-12-31 09:00:00 | 12/31/99 09:00:00 AM | December 31, 1999 09:00:00 |
| 2000-06-04 15:45:30 | 6/4/00 03:45:30 PM   | June 4, 2000 15:45:30      |
| 2017-03-16 12:30:15 | 3/16/17 12:30:15 PM  | March 16, 2017 12:30:15    |
+---------------------+----------------------+----------------------------+
```

`TIME_FORMAT()`类似于`DATE_FORMAT()`。它适用于`TIME`、`DATETIME`或`TIMESTAMP`值，但只理解格式字符串中与时间相关的说明符：

```
mysql> `SELECT dt,`
    -> `TIME_FORMAT(dt, '%r') AS '12-hour time',`
    -> `TIME_FORMAT(dt, '%T') AS '24-hour time'`
    -> `FROM datetime_val;`
+---------------------+--------------+--------------+
| dt                  | 12-hour time | 24-hour time |
+---------------------+--------------+--------------+
| 1970-01-01 00:00:00 | 12:00:00 AM  | 00:00:00     |
| 1999-12-31 09:00:00 | 09:00:00 AM  | 09:00:00     |
| 2000-06-04 15:45:30 | 03:45:30 PM  | 15:45:30     |
| 2017-03-16 12:30:15 | 12:30:15 PM  | 12:30:15     |
+---------------------+--------------+--------------+
```

如果`DATE_FORMAT()`或`TIME_FORMAT()`无法生成您想要的结果，请编写一个存储函数来实现。假设您想将 24 小时制的`TIME`值转换为带有`a.m.`或`p.m.`后缀而不是`AM`或`PM`的 12 小时制格式。以下函数可以完成此任务。它使用`TIME_FORMAT()`来执行大部分工作，然后去掉`%r`提供的后缀并替换为所需的后缀：

```
CREATE FUNCTION time_ampm (t TIME)
RETURNS VARCHAR(13) # mm:dd:ss {a.m.|p.m.} format
DETERMINISTIC
RETURN CONCAT(LEFT(TIME_FORMAT(t, '%r'), 9),
              IF(TIME_TO_SEC(t) < 12*60*60, 'a.m.', 'p.m.'));
```

使用如下函数：

```
mysql> `SELECT t1, time_ampm(t1) FROM time_val;`
+----------+---------------+
| t1       | time_ampm(t1) |
+----------+---------------+
| 15:00:00 | 03:00:00 p.m. |
| 05:01:30 | 05:01:30 a.m. |
| 12:30:20 | 12:30:20 p.m. |
+----------+---------------+
```

有关编写存储函数的更多信息，请参见第十一章。

# 8.4 设置客户端时区

## 问题

您有一个客户端应用程序，它从与服务器不同的时区连接。因此，当它存储`TIMESTAMP`值时，这些值没有正确的 UTC 值。

## 解决方案

客户端在连接到服务器后应设置`time_zone`系统变量。

## 讨论

时区设置对`TIMESTAMP`值有重要影响：

+   当 MySQL 服务器启动时，它会检查其操作环境以确定其时区。（要使用不同的值，请使用`--default-time-zone`选项启动服务器。）

+   对于每个连接的客户端，服务器根据客户端会话关联的时区解释`TIMESTAMP`值。当客户端插入`TIMESTAMP`值时，服务器将其从客户端时区转换为 UTC 并存储 UTC 值。（在内部，服务器将`TIMESTAMP`值存储为自`1970-01-01 00:00:00` UTC 以来的秒数。）当客户端检索`TIMESTAMP`值时，服务器执行相反的操作，将 UTC 值转换回客户端时区。

+   每个客户端在连接时的默认会话时区是服务器时区。如果所有客户端与服务器处于同一时区，则无需为正确的`TIMESTAMP`时区转换做任何特殊处理。但是，如果客户端位于与服务器不同的时区，并且在不进行正确时区校正的情况下插入`TIMESTAMP`值，则 UTC 值将不正确。

假设服务器和客户端 C1 处于同一时区，并且客户端 C1 发出以下语句：

```
mysql> `CREATE TABLE t (ts TIMESTAMP);`
mysql> `INSERT INTO t (ts) VALUES('2021-06-21 12:30:00');`
mysql> `SELECT ts FROM t;`
+---------------------+
| ts                  |
+---------------------+
| 2021-06-21 12:30:00 |
+---------------------+
```

在这里，客户端 C1 看到与其存储的相同值。不同的客户端 C2，如果检索它，也将看到相同的值，但是如果客户端 C2 位于不同的时区，则该值对其时区来说不正确。相反，如果客户端 C2 存储一个值，则当客户端 C1 检索时，该值对于客户端 C1 的时区也不正确。

为了解决这个问题，使得`TIMESTAMP`转换使用正确的时区，客户端应通过设置`time_zone`系统变量的会话值来显式设置其时区。假设服务器的全局时区比 UTC 提前六小时。每个客户端最初分配相同的值作为其会话时区：

```
mysql> `SELECT @@global.time_zone, @@session.time_zone;`
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| SYSTEM             | SYSTEM              |
+--------------------+---------------------+
```

当客户端 C2 连接时，它看到与客户端 C1 相同的`TIMESTAMP`值：

```
mysql> `SELECT ts FROM t;`
+---------------------+
| ts                  |
+---------------------+
| 2021-06-21 12:30:00 |
+---------------------+
```

但如果客户端 C2 比 UTC 仅提前四小时，则该值是不正确的。C2 应在连接后设置其时区，以便检索到的`TIMESTAMP`值适当地调整为其自身的会话：

```
mysql> `SET SESSION time_zone = '+04:00';`
mysql> `SELECT @@global.time_zone, @@session.time_zone;`
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| SYSTEM             | +04:00              |
+--------------------+---------------------+
mysql> `SELECT ts FROM t;`
+---------------------+
| ts                  |
+---------------------+
| 2021-06-21 16:30:00 |
+---------------------+
```

要查看`System Timezone`，请检查全局变量。

```
mysql> `SHOW GLOBAL VARIABLES LIKE "system_time_zone";`
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| system_time_zone | UTC   |
+------------------+-------+
```

客户端时区也会影响从返回当前日期和时间的函数中显示的值（请参阅 Recipe 8.7）。

## 另请参阅

要将一个时区的单个日期和时间值转换为另一个时区，请使用`CONVERT_TZ()`函数（请参阅 Recipe 8.6）。

# 8.5 设置服务器时区

## 问题

您有一个本地化的应用程序用于服务客户，但您希望拥有全局时区设置。

## 解决方案

服务器应该将`time_zone`系统变量设置为服务器上的`SYSTEM`值。该设置应该指向`UTC`值。因此系统时区`system_time_zone`值应设置为`UTC`。

## 讨论

MySQL 服务器维护多个时区设置：

+   服务器系统时区。当 MySQL 启动时，它会尝试确定`system_time_zone`变量。为了显式设置 MySQL 的系统时区，请在启动`mysqld`之前设置`TZ`环境变量。或者使用`mysqld_safe`的`--timezone`选项启动。这些变量的值受您的操作系统设置的允许。

+   服务器当前时区由全局`time_zone`值设置。在现代 Linux 操作系统上通常设置为`SYSTEM`。

    ```
    mysql> `SHOW GLOBAL VARIABLES LIKE "time_zone";`
    +---------------+--------+
    | Variable_name | Value  |
    +---------------+--------+
    | time_zone     | SYSTEM |
    +---------------+--------+
    ```

    您可以选择使用`SET GLOBAL`设置全局时区变量。这不会更改`@@session.time_zone`的值。

    ```
    mysql> `SET GLOBAL time_zone = "+03:00";`
    mysql> `SELECT @@global.time_zone, @@session.time_zone;`
    +--------------------+---------------------+
    | @@global.time_zone | @@session.time_zone |
    +--------------------+---------------------+
    | +03:00             | SYSTEM              |
    +--------------------+---------------------+
    ```

    表示与 UTC（协调世界时）相差的`time_zone`值偏移的字符串。在 MySQL 8.0.19 之前，此值必须在'-12:59'到'+13:00'（含）的范围内；从 MySQL 8.0.19 开始，允许范围为'-13:59'到'+14:00'（含）。未填充的时区不允许使用，除非它们预先加载到 MySQL 表中，因此您不能使用`UTC`等名称：

    ```
    mysql> `SET GLOBAL time_zone = "US/Eastern" ;`
    ERROR 1298 (HY000): Unknown or incorrect time zone: 'US/Eastern'
    ```

    如需填充时区表的说明，请参阅[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html#time-zone-installation)。

+   变量`system_time_zone`在服务器继承机器默认时区设置时设置。与`time_zone`变量不同，此变量在服务器启动后无法动态设置。从 MySQL 8.0.26 开始，如果服务器主机的时区发生变化，例如夏令时期间，`system_time_zone`将反映这些更改。如果在执行查询期间发生更改，则将缓存先前的值。

    ```
    mysql> `SHOW GLOBAL VARIABLES LIKE "system_time_zone";`
    +---------------+------------+
    | Variable_name | Value      |
    +---------------+------------+
    | time_zone     | US/Eastern |
    +---------------+------------+
    ```

# 8.6 在时区之间转移时间值

## 问题

您有一个日期时间值，但需要知道在另一个时区中会是什么时间。例如，您正在与世界各地的人进行电话会议，必须告诉他们在其当地时区的会议时间。

## 解决方案

使用`CONVERT_TZ()`函数。

## 讨论

`CONVERT_TZ()`函数在不同时区之间转换时间值。它接受三个参数：日期时间值和两个时区指示器。该函数将日期时间值解释为第一个时区中的值，并返回转换为第二个时区的值。

假设我们居住在美国伊利诺伊州芝加哥，并且与世界各地的人有会议。表 8-3 显示了每个会议参与者的位置及其时区名称：

表 8-3 会议参与者

| 位置 | 时区名称 |
| --- | --- |
| 美国伊利诺伊州芝加哥 | `US/Central` |
| 土耳其伊斯坦布尔 | `Europe/Istanbul` |
| 英国伦敦 | `Europe/London` |
| 加拿大阿尔伯塔埃德蒙顿 | `America/Edmonton` |
| 澳大利亚布里斯班 | `Australia/Brisbane` |

如果会议计划在 2021 年 11 月 28 日我们当地时间上午 8 点进行，那么其他参与者的当地时间将是多少？以下语句使用`CONVERT_TZ()`计算每个时区的本地时间：

```
mysql> `SET @dt = '2021-11-28 08:00:00';`
mysql> `SELECT @dt AS Chicago,`
    -> `CONVERT_TZ(@dt,'US/Central','Europe/Istanbul') AS Istanbul,`
    -> `CONVERT_TZ(@dt,'US/Central','Europe/London') AS London,`
    -> `CONVERT_TZ(@dt,'US/Central','America/Edmonton') AS Edmonton,`
    -> `CONVERT_TZ(@dt,'US/Central','Australia/Brisbane') AS Brisbane\G`
*************************** 1\. row ***************************
 Chicago: 2021-11-28 08:00:00
Istanbul: 2021-11-28 17:00:00
  London: 2021-11-28 14:00:00
Edmonton: 2021-11-28 07:00:00
Brisbane: 2021-11-29 00:00:00
```

希望布里斯班的参与者不介意在午夜后参加。

前述示例使用时区名称，因此需要您在`mysql`数据库中初始化支持命名时区的时区表（有关设置时区表的信息，请参阅[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html)）。如果无法使用命名时区，请用其相对于 UTC 的数字关系指定它们（这可能有些棘手；您可能需要考虑夏令时）。具有数字时区的相应语句如下所示：

```
mysql> `SELECT @dt AS Chicago,`
    -> `CONVERT_TZ(@dt,'-06:00','+03:00') AS Istanbul,`
    -> `CONVERT_TZ(@dt,'-06:00','+00:00') AS London,`
    -> `CONVERT_TZ(@dt,'-06:00','-07:00') AS Edmonton,`
    -> `CONVERT_TZ(@dt,'-06:00','+10:00') AS Brisbane\G`
*************************** 1\. row ***************************
 Chicago: 2021-11-28 08:00:00
Istanbul: 2021-11-28 17:00:00
  London: 2021-11-28 14:00:00
Edmonton: 2021-11-28 07:00:00
Brisbane: 2021-11-29 00:00:00
```

# 8.7 确定当前日期或时间

## 问题

您想知道今天的日期和/或时间。

## 解决方案

使用`CURDATE()`、`CURTIME()`或`NOW()`函数获取客户端会话时区中表达的值。使用`UTC_DATE()`、`UTC_TIME()`或`UTC_TIMESTAMP()`获取 UTC 时间的值。

## 讨论

某些应用程序必须知道当前日期或时间，例如写入时间戳日志记录的应用程序。这类信息对于与当前日期相关的日期计算也很有用，例如查找本月的第一天（或最后一天）或确定下周星期三的日期。

`CURDATE()`和`CURTIME()`函数分别返回当前日期和时间，而`NOW()`则返回合并的日期和时间值：

```
mysql> `SELECT CURDATE(), CURTIME(), NOW();`
+------------+-----------+---------------------+
| CURDATE()  | CURTIME() | NOW()               |
+------------+-----------+---------------------+
| 2021-11-28 | 08:42:57  | 2021-11-28 08:42:57 |
+------------+-----------+---------------------+
```

`CURRENT_DATE`、`CURRENT_TIME`和`CURRENT_TIMESTAMP`是`CURDATE()`、`CURTIME()`和`NOW()`的同义词，分别用于获取当前日期、时间或合并的日期和时间。

上述函数返回客户端会话时区中的值（参见 Recipe 8.4）。若需使用 UTC 时间的值，请改用`UTC_DATE()`、`UTC_TIME()`或`UTC_TIMESTAMP()`函数。

要确定任意时区的当前日期和时间，请将适当的 UTC 函数值传递给`CONVERT_TZ()`（参见 Recipe 8.6）。

要获取这些值的子部分，例如当前月份的日期或当前小时数，请使用 Recipe 8.9 中讨论的分解技术。

# 8.8 使用 TIMESTAMP 或 DATETIME 跟踪行修改时间

## 问题

你希望自动记录行创建时间或最后修改时间。

## 解决方案

使用`TIMESTAMP`和`DATETIME`数据类型的自动初始化和自动更新属性。

## 讨论

MySQL 支持存储日期时间值的`TIMESTAMP`和`DATETIME`数据类型。Recipe 8.1 介绍了这些类型的值范围。本篇重点介绍了能够自动跟踪行创建和更新时间的特殊列属性：

+   声明为带有`DEFAULT` `CURRENT_TIMESTAMP`属性的`TIMESTAMP`或`DATETIME`列会自动初始化为新行。只需在`INSERT`语句中省略该列，MySQL 会将其设置为行创建时间。

+   当你改变行中的任何其他列的当前值时，声明为带有`ON` `UPDATE` `CURRENT_TIMESTAMP`属性的`TIMESTAMP`或`DATETIME`列会自动更新为当前日期和时间。

这些特殊属性使得`TIMESTAMP`和`DATETIME`数据类型特别适合需要记录插入或更新行时的时间的应用程序。以下讨论展示了如何利用`TIMESTAMP`列的这些特性。尽管有一些稍后需要注意的差异，但是这些讨论同样适用于`DATETIME`列。

###### 注意

默认的`SQL_MODE`不允许`NULL`值，除非放宽条件。而 MySQL 8.0 之后不推荐使用`NO_ZERO_DATE`，应与`STRICT MODE`结合使用。

我们的示例表如下：

```
DROP TABLE IF EXISTS tsdemo;
CREATE TABLE `tsdemo` (
`val` INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
`ts_both` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
`ts_create` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
`ts_update` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB ;
```

`TIMESTAMP`列具有以下属性：

+   `ts_both`自动初始化并自动更新。这对于跟踪行的任何更改时间（无论是插入还是更新）非常有用。

+   `ts_create`仅自动初始化。当您希望列设置为创建行时的时间，但在此后保持恒定时，这将非常有用。

+   `ts_update`仅自动更新。它在创建行时设置为列默认值（或您明确指定的值），并在之后对行的更改自动更新。这种用法更为有限，例如，单独跟踪行创建和最后修改时间（使用`ts_update`与`ts_create`结合），而不是在单个列中像`ts_both`一样一起。

要查看表的工作原理，请向表中插入一些行（时间间隔几秒钟，使时间戳不同），然后选择其内容：

```
mysql> `INSERT INTO tsdemo (val,ts_both,ts_create,ts_update)      -> VALUES(0,NULL,NULL,NULL);`
mysql> `INSERT INTO tsdemo (val) VALUES(5);`
mysql> `INSERT INTO tsdemo (val,ts_both,ts_create,ts_update)`
    -> `VALUES(10,NULL,NULL,NULL);`
mysql> `SELECT val, ts_both, ts_create, ts_update FROM tsdemo;`
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   1 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 |
|   5 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 |
|  10 | 2022-03-06 14:35:34 | 2022-03-06 14:35:34 | 2022-03-06 14:35:34 |
+-----+---------------------+---------------------+---------------------+
```

前两个`INSERT`语句表明，通过完全省略它们从`INSERT`语句中省略它们，您可以将自动初始化列设置为当前日期和时间。第三个插入显示，您可以将`TIMESTAMP`列显式设置为当前日期和时间，即使它不自动初始化。这种`NULL`赋值行为不仅适用于`INSERT`语句；它也适用于`UPDATE`。您可以禁用对`NULL`赋值的特殊处理，我们将在本章后面介绍这个方法。

要查看自动更新的实际效果，请发出一个改变一行中`val`列的语句，并检查其对表内容的影响。结果显示自动更新列已更新（仅在修改的行中）：

```
mysql> `UPDATE tsdemo SET val = 11 WHERE val = 10;`
mysql> `SELECT val, ts_both, ts_create, ts_update FROM tsdemo;`
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   1 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 |
|   5 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 |
|  11 | 2022-03-06 14:38:04 | 2022-03-06 14:35:34 | 2022-03-06 14:38:04 |
+-----+---------------------+---------------------+---------------------+
```

如果修改多行，则每行中的自动更新列都会发生更新：

```
mysql> `UPDATE tsdemo SET val = val + 1;`
mysql> `SELECT val, ts_both, ts_create, ts_update FROM tsdemo;`
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   2 | 2022-03-06 14:38:45 | 2022-03-06 14:34:17 | 2022-03-06 14:38:45 |
|   6 | 2022-03-06 14:38:45 | 2022-03-06 14:35:16 | 2022-03-06 14:38:45 |
|  12 | 2022-03-06 14:38:45 | 2022-03-06 14:35:34 | 2022-03-06 14:38:45 |
+-----+---------------------+---------------------+---------------------+
```

如果`UPDATE`语句实际上没有更改行中的任何值，则不会修改自动更新列。要查看这一点，请将每行的`val`列设置为其当前值，然后查看表内容，以查看自动更新列保留其值：

```
mysql> `UPDATE tsdemo SET val = val;`
mysql> `SELECT val, ts_both, ts_create, ts_update FROM tsdemo;`
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   2 | 2022-03-06 14:38:45 | 2022-03-06 14:34:17 | 2022-03-06 14:38:45 |
|   6 | 2022-03-06 14:38:45 | 2022-03-06 14:35:16 | 2022-03-06 14:38:45 |
|  12 | 2022-03-06 14:38:45 | 2022-03-06 14:35:34 | 2022-03-06 14:38:45 |
+-----+---------------------+---------------------+---------------------+
```

如前所述，自动`TIMESTAMP`属性也适用于`DATETIME`，但有些差异：

+   对于表中的第一个`TIMESTAMP`列，如果未指定`DEFAULT`或`ON UPDATE`属性，则该列隐式定义为两者都包括。对于`DATETIME`，自动属性从不隐式应用；只有明确指定的那些属性。

+   现在不再可能将`NULL`设置为`TIMESTAMP`。要分配当前时间戳，请将列设置为`CURRENT_TIMESTAMP`或其同义词，例如`NOW()`。

要确定对于任何给定的`TIMESTAMP`列，当将`NULL`赋值给它时会发生什么，请使用`SHOW CREATE TABLE`查看列定义。如果定义包括`NULL`属性，则赋值`NULL`会存储`NULL`。如果定义包括`NOT NULL`属性，则可以指定`NULL`作为要赋值的值，但不能*存储*`NULL`，因为 MySQL 会存储当前日期和时间。

## 另请参阅

要模拟其他时间类型的`TIMESTAMP`自动初始化和自动更新属性，可以使用触发器（参见第十一章）。

# 8.9 提取日期或时间的部分

## 问题

您希望仅获取日期或时间的一部分。

## 解决方案

调用专门用于提取时间值部分的函数，如`MONTH()`或`MINUTE()`。如果您只需要值的单个组件，这通常是最快的提取方法。或者，使用包含您想获取的值部分的格式字符串的格式化函数，如`DATE_FORMAT()`或`TIME_FORMAT()`。

## 讨论

下面的讨论展示了提取时间值部分的不同方法。

### 使用组件提取函数分解日期或时间

MySQL 包括许多用于提取日期和时间子部分的函数。例如，`DATE()`和`TIME()`提取时间值的日期和时间组件：

```
mysql> `SELECT dt, DATE(dt), TIME(dt) FROM datetime_val;`
+---------------------+------------+----------+
| dt                  | DATE(dt)   | TIME(dt) |
+---------------------+------------+----------+
| 1970-01-01 00:00:00 | 1970-01-01 | 00:00:00 |
| 1999-12-31 09:00:00 | 1999-12-31 | 09:00:00 |
| 2000-06-04 15:45:30 | 2000-06-04 | 15:45:30 |
| 2017-03-16 12:30:15 | 2017-03-16 | 12:30:15 |
+---------------------+------------+----------+
```

表 8-4 展示了一些组件提取函数；请参阅[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)获取完整列表。日期相关函数适用于`DATE`、`DATETIME`或`TIMESTAMP`值。时间相关函数适用于`TIME`、`DATETIME`或`TIMESTAMP`值：

表 8-4\. 组件提取函数

| 函数 | 返回值 |
| --- | --- |
| `YEAR()` | 年份 |
| `MONTH()` | 月份数字（1 至 12） |
| `MONTHNAME()` | 月份名称（一月至十二月） |
| `DAYOFMONTH()` | 月中的天数（1 至 31） |
| `DAYNAME()` | 星期几名称（星期日至星期六） |
| `DAYOFWEEK()` | 星期几（1 至 7，分别对应星期日至星期六） |
| `WEEKDAY()` | 星期几（0 至 6，分别对应星期一到星期日） |
| `DAYOFYEAR()` | 年中的天数（1 至 366） |
| `HOUR()` | 时间的小时（0 至 23） |
| `MINUTE()` | 时间的分钟（0 至 59） |
| `SECOND()` | 时间的秒（0 至 59） |
| `MICROSECOND()` | 时间的微秒（0 至 59） |
| `EXTRACT()` | 各不相同 |

以下是一个示例：

```
mysql> `SELECT dt, YEAR(dt), DAYOFMONTH(dt), HOUR(dt), SECOND(dt)`
    -> `FROM datetime_val;`
+---------------------+----------+----------------+----------+------------+
| dt                  | YEAR(dt) | DAYOFMONTH(dt) | HOUR(dt) | SECOND(dt) |
+---------------------+----------+----------------+----------+------------+
| 1970-01-01 00:00:00 |     1970 |              1 |        0 |          0 |
| 1999-12-31 09:00:00 |     1999 |             31 |        9 |          0 |
| 2000-06-04 15:45:30 |     2000 |              4 |       15 |         30 |
| 2017-03-16 12:30:15 |     2017 |             16 |       12 |         15 |
+---------------------+----------+----------------+----------+------------+
```

```
mysql> `set @date_time="2021-11-24 22:11:12.000201";`
    -> `SELECT HOUR(@date_time) as Hour, MINUTE(@date_time)      ->  as Minute,SECOND(@date_time) as Second, MICROSECOND(@date_time) as MicroSecond;`
+------+--------+--------+-------------+
| Hour | Minute | Second | MicroSecond |
+------+--------+--------+-------------+
|   22 |     11 |     12 |         201 |
+------+--------+--------+-------------+
```

函数如`YEAR()`或`DAYOFMONTH()`提取的值与应用它们的时间值的子字符串具有明显的对应关系。其他组件提取函数提供了访问没有此类对应关系的值。其中一个是一年中的日期值：

```
mysql> `SELECT d, DAYOFYEAR(d) FROM date_val;`
+------------+--------------+
| d          | DAYOFYEAR(d) |
+------------+--------------+
| 1864-02-28 |           59 |
| 1900-01-15 |           15 |
| 1999-12-31 |          365 |
| 2000-06-04 |          156 |
| 2017-03-16 |           75 |
+------------+--------------+
```

另一个是星期几，可以按名称或数字获取：

+   `DAYNAME()`返回完整的星期几名称。有一个`DATE_FORMAT(d, '%a')`函数用于返回三字符名称缩写，您可以通过将全名传递给`DATE_FORMAT()`轻松获取它：

    ```
    mysql> `SELECT d, DAYNAME(d), DATE_FORMAT(d, '%a') FROM date_val;`
    +------------+------------+----------------------+
    | d          | DAYNAME(d) | DATE_FORMAT(d, '%a') |
    +------------+------------+----------------------+
    | 1864-02-28 | Sunday     | Sun                  |
    | 1900-01-15 | Monday     | Mon                  |
    | 1999-12-31 | Friday     | Fri                  |
    | 2000-06-04 | Sunday     | Sun                  |
    | 2017-03-16 | Thursday   | Thu                  |
    +------------+------------+----------------------+
    ```

+   要获得星期几的数字形式，请使用`DAYOFWEEK()`或`WEEKDAY()`，但要注意每个函数返回的值范围。`DAYOFWEEK()`返回 1 至 7 的值，分别对应星期日到星期六。`WEEKDAY()`返回 0 至 6 的值，分别对应星期一到星期日：

    ```
    mysql> `SELECT d, DAYNAME(d), DAYOFWEEK(d), WEEKDAY(d) FROM date_val;`
    +------------+------------+--------------+------------+
    | d          | DAYNAME(d) | DAYOFWEEK(d) | WEEKDAY(d) |
    +------------+------------+--------------+------------+
    | 1864-02-28 | Sunday     |            1 |          6 |
    | 1900-01-15 | Monday     |            2 |          0 |
    | 1999-12-31 | Friday     |            6 |          4 |
    | 2000-06-04 | Sunday     |            1 |          6 |
    | 2017-03-16 | Thursday   |            5 |          3 |
    +------------+------------+--------------+------------+
    ```

`EXTRACT()`是另一个用于获取时间值各部分的函数：

```
mysql> `SELECT dt, EXTRACT(DAY FROM dt), EXTRACT(HOUR FROM dt)`
    -> `FROM datetime_val;`
+---------------------+----------------------+-----------------------+
| dt                  | EXTRACT(DAY FROM dt) | EXTRACT(HOUR FROM dt) |
+---------------------+----------------------+-----------------------+
| 1970-01-01 00:00:00 |                    1 |                     0 |
| 1999-12-31 09:00:00 |                   31 |                     9 |
| 2000-06-04 15:45:30 |                    4 |                    15 |
| 2017-03-16 12:30:15 |                   16 |                    12 |
+---------------------+----------------------+-----------------------+
```

指示从值中提取什么的关键字应该是像 `YEAR`、`MONTH`、`DAY`、`HOUR`、`MINUTE` 或 `SECOND` 这样的单位说明符。单位说明符是单数形式，而不是复数形式。（请查看[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)获取完整列表。）

### 使用格式化函数分解日期或时间

`DATE_FORMAT()` 和 `TIME_FORMAT()` 函数重新格式化日期和时间值。通过指定适当的格式字符串，您可以提取时间值的各个部分：

```
mysql> `SELECT dt,`
    -> `DATE_FORMAT(dt,'%Y') AS year,`
    -> `DATE_FORMAT(dt,'%d') AS day,`
    -> `TIME_FORMAT(dt,'%H') AS hour,`
    -> `TIME_FORMAT(dt,'%s') AS second`
    -> `TIME_FORMAT(dt,'%f') AS microsecond`
    -> `FROM datetime_val;`
+---------------------+------+------+------+--------+-------------+
| dt                  | year | day  | hour | second | microsecond |
+---------------------+------+------+------+--------+-------------+
| 1970-01-01 00:00:00 | 1970 | 01   | 00   | 00     | 000000      |
| 1999-12-31 09:00:00 | 1999 | 31   | 09   | 00     | 000000      |
| 2000-06-04 15:45:30 | 2000 | 04   | 15   | 30     | 000000      |
| 2017-03-16 12:30:15 | 2017 | 16   | 12   | 15     | 000000      |
+---------------------+------+------+------+--------+-------------+
```

当您希望提取值的多个部分或以与默认格式不同的格式显示提取的值时，格式化函数非常有利。例如，要从 `DATETIME` 值中提取整个日期或时间，请执行以下操作：

```
mysql> `SELECT dt,`
    -> `DATE_FORMAT(dt,'%Y-%m-%d') AS 'date part',`
    -> `TIME_FORMAT(dt,'%T') AS 'time part'`
    -> `FROM datetime_val;`
+---------------------+------------+-----------+
| dt                  | date part  | time part |
+---------------------+------------+-----------+
| 1970-01-01 00:00:00 | 1970-01-01 | 00:00:00  |
| 1999-12-31 09:00:00 | 1999-12-31 | 09:00:00  |
| 2000-06-04 15:45:30 | 2000-06-04 | 15:45:30  |
| 2017-03-16 12:30:15 | 2017-03-16 | 12:30:15  |
+---------------------+------------+-----------+
```

要以非 *`YYYY-MM-DD`* 格式显示日期或者不显示秒部分的时间，请执行以下操作：

```
mysql> `SELECT dt,`
    -> `DATE_FORMAT(dt,'%M %e, %Y') AS 'descriptive date',`
    -> `TIME_FORMAT(dt,'%H:%i') AS 'hours/minutes'`
    -> `FROM datetime_val;`
+---------------------+-------------------+---------------+
| dt                  | descriptive date  | hours/minutes |
+---------------------+-------------------+---------------+
| 1970-01-01 00:00:00 | January 1, 1970   | 00:00         |
| 1999-12-31 09:00:00 | December 31, 1999 | 09:00         |
| 2000-06-04 15:45:30 | June 4, 2000      | 15:45         |
| 2017-03-16 12:30:15 | March 16, 2017    | 12:30         |
+---------------------+-------------------+---------------+
```

# 8.10 从组件值合成日期或时间

## 问题

您希望将日期或时间的各部分组合起来以生成完整的日期或时间值。或者您希望替换日期的部分以生成另一个日期。

## 解决方案

您有几个选项：

+   使用 `MAKETIME()` 从小时、分钟和秒部分构造 `TIME` 值。

+   使用 `DATE_FORMAT()` 或 `TIME_FORMAT()` 来组合现有值的部分和您想要替换的部分。

+   使用组件提取函数提取所需的部分，并使用 `CONCAT()` 重新组合这些部分。

## 讨论

将日期或时间值分解为组件的逆过程是从其组成部分合成时间值。合成日期和时间的技术包括使用组合函数、格式化函数和字符串连接。

`MAKETIME()` 函数将组件小时、分钟和秒值作为参数，并将它们组合成时间：

```
mysql> `SELECT MAKETIME(10,30,58), MAKETIME(-5,0,11);`
+--------------------+-------------------+
| MAKETIME(10,30,58) | MAKETIME(-5,0,11) |
+--------------------+-------------------+
| 10:30:58           | -05:00:11         |
+--------------------+-------------------+
```

日期合成通常是从给定日期开始执行，然后保留您希望使用的部分并替换其余部分。例如，要生成日期所在月份的第一天，请使用 `DATE_FORMAT()` 提取日期中的年份和月份部分，并将它们与 `01` 的日部分组合：

```
mysql> `SELECT d, DATE_FORMAT(d,'%Y-%m-01') FROM date_val;`
+------------+---------------------------+
| d          | DATE_FORMAT(d,'%Y-%m-01') |
+------------+---------------------------+
| 1864-02-28 | 1864-02-01                |
| 1900-01-15 | 1900-01-01                |
| 1999-12-31 | 1999-12-01                |
| 2000-06-04 | 2000-06-01                |
| 2017-03-16 | 2017-03-01                |
+------------+---------------------------+
```

`TIME_FORMAT()` 可以类似地使用。以下示例生成秒部分设置为 `00` 的时间值：

```
mysql> `SELECT t1, TIME_FORMAT(t1,'%H:%i:00') FROM time_val;`
+----------+----------------------------+
| t1       | TIME_FORMAT(t1,'%H:%i:00') |
+----------+----------------------------+
| 15:00:00 | 15:00:00                   |
| 05:01:30 | 05:01:00                   |
| 12:30:20 | 12:30:00                   |
+----------+----------------------------+
```

另一种构造时间值的方法是将日期部分提取函数与 `CONCAT()` 结合使用。然而，这种方法通常比刚讨论的 `DATE_FORMAT()` 技术更混乱，并且有时会产生稍微不同的结果：

```
mysql> `SELECT d, CONCAT(YEAR(d),'-',MONTH(d),'-01') FROM date_val;`
+------------+------------------------------------+
| d          | CONCAT(YEAR(d),'-',MONTH(d),'-01') |
+------------+------------------------------------+
| 1864-02-28 | 1864-2-01                          |
| 1900-01-15 | 1900-1-01                          |
| 1999-12-31 | 1999-12-01                         |
| 2000-06-04 | 2000-6-01                          |
| 2017-03-16 | 2017-3-01                          |
+------------+------------------------------------+
```

请注意，其中一些日期的月份值只有一个数字。为确保月份具有两位数（如 ISO 格式所需），请使用 `LPAD()` 根据需要添加前导零：

```
mysql> `SELECT d, CONCAT(YEAR(d),'-',LPAD(MONTH(d),2,'0'),'-01')`
    -> `FROM date_val;`
+------------+------------------------------------------------+
| d          | CONCAT(YEAR(d),'-',LPAD(MONTH(d),2,'0'),'-01') |
+------------+------------------------------------------------+
| 1864-02-28 | 1864-02-01                                     |
| 1900-01-15 | 1900-01-01                                     |
| 1999-12-31 | 1999-12-01                                     |
| 2000-06-04 | 2000-06-01                                     |
| 2017-03-16 | 2017-03-01                                     |
+------------+------------------------------------------------+
```

Recipe 8.18 展示了解决从非完全 ISO 日期生成 ISO 日期的问题的其他方法。

可以使用类似于创建`DATE`值的方法从小时、分钟和秒值生成`TIME`值。例如，要修改`TIME`值以使其秒部分为`00`，请提取小时和分钟部分，然后使用`CONCAT()`重新组合它们：

```
mysql> `SELECT t1,`
    -> `CONCAT(LPAD(HOUR(t1),2,'0'),':',LPAD(MINUTE(t1),2,'0'),':00')`
    ->   `AS recombined`
    -> `FROM time_val;`
+----------+------------+
| t1       | recombined |
+----------+------------+
| 15:00:00 | 15:00:00   |
| 05:01:30 | 05:01:00   |
| 12:30:20 | 12:30:00   |
+----------+------------+
```

要从单独的日期和时间值生成组合的日期时间值，只需将它们用空格分隔连接起来：

```
mysql>  `SET @d = '2009-06-03', @t = '16:15:08';`
mysql> `SELECT @d, @t, CONCAT(@d,' ',@t);`
+------------+----------+---------------------+
| @d         | @t       | CONCAT(@d,' ',@t)   |
+------------+----------+---------------------+
| 2009-06-03 | 16:15:08 | 2009-06-03 16:15:08 |
+------------+----------+---------------------+
```

# 8.11 将时间值和基本单位之间进行转换

## 问题

要将诸如时间或日期之类的临时值转换为基本单位，例如秒或天。这通常对执行时间算术运算（参见 Recipe 8.12 和 Recipe 8.13）非常有用或必要。

## 解决方案

转换方法取决于要转换的值类型：

+   要在时间值和秒之间进行转换，请使用`TIME_TO_SEC()`和`SEC_TO_TIME()`函数。

+   要在日期值和天之间进行转换，请使用`TO_DAYS()`和`FROM_DAYS()`函数。

+   要在日期时间值和秒之间进行转换，请使用`UNIX_TIMESTAMP()`和`FROM_UNIXTIME()`函数。

## 讨论

以下讨论展示了如何将多种类型的时间值转换为基本单位，反之亦然。

### 在时间和秒之间进行转换

`TIME`值是较简单单位（秒）的专业表示。要在它们之间进行转换，请使用`TIME_TO_SEC()`和`SEC_TO_TIME()`函数。

`TIME_TO_SEC()`将`TIME`值转换为相应的秒数，`SEC_TO_TIME()`则反之。以下语句演示了如何简单地进行双向转换：

```
mysql> `SELECT t1,`
    -> `TIME_TO_SEC(t1) AS 'TIME to seconds',`
    -> `SEC_TO_TIME(TIME_TO_SEC(t1)) AS 'TIME to seconds to TIME'`
    -> `FROM time_val;`
+----------+-----------------+-------------------------+
| t1       | TIME to seconds | TIME to seconds to TIME |
+----------+-----------------+-------------------------+
| 15:00:00 |           54000 | 15:00:00                |
| 05:01:30 |           18090 | 05:01:30                |
| 12:30:20 |           45020 | 12:30:20                |
+----------+-----------------+-------------------------+
```

要将时间值表示为分钟、小时或天，请执行适当的除法：

```
mysql> `SELECT t1,`
    -> `TIME_TO_SEC(t1) AS 'seconds',`
    -> `TIME_TO_SEC(t1)/60 AS 'minutes',`
    -> `TIME_TO_SEC(t1)/(60*60) AS 'hours',`
    -> `TIME_TO_SEC(t1)/(24*60*60) AS 'days'`
    -> `FROM time_val;`
+----------+---------+----------+---------+--------+
| t1       | seconds | minutes  | hours   | days   |
+----------+---------+----------+---------+--------+
| 15:00:00 |   54000 | 900.0000 | 15.0000 | 0.6250 |
| 05:01:30 |   18090 | 301.5000 |  5.0250 | 0.2094 |
| 12:30:20 |   45020 | 750.3333 | 12.5056 | 0.5211 |
+----------+---------+----------+---------+--------+
```

如果您希望整数值不包含小数部分，请在除法结果上使用`FLOOR()`。

如果将`TIME_TO_SEC()`传递给日期时间值，则会提取时间部分并丢弃日期部分。这提供了从`DATETIME`（或`TIMESTAMP`）值中提取时间的另一种方法，除了已在 Recipe 8.9 中讨论过的方法之外：

```
mysql> `SELECT dt,`
    -> `TIME_TO_SEC(dt) AS 'time part in seconds',`
    -> `SEC_TO_TIME(TIME_TO_SEC(dt)) AS 'time part as TIME'`
    -> `FROM datetime_val;`
+---------------------+----------------------+-------------------+
| dt                  | time part in seconds | time part as TIME |
+---------------------+----------------------+-------------------+
| 1970-01-01 00:00:00 |                    0 | 00:00:00          |
| 1999-12-31 09:00:00 |                32400 | 09:00:00          |
| 2000-06-04 15:45:30 |                56730 | 15:45:30          |
| 2017-03-16 12:30:15 |                45015 | 12:30:15          |
+---------------------+----------------------+-------------------+
```

### 在日期和天之间进行转换

如果您有一个日期但想要一个以天为单位的值，或反之，请使用`TO_DAYS()`和`FROM_DAYS()`函数。如果可以接受丢失时间部分，也可以将日期时间值转换为天自从公元前 0 年以来。

`TO_DAYS()`将日期转换为相应的天数，`FROM_DAYS()`则反之：

```
mysql> `SELECT d,`
    -> `TO_DAYS(d) AS 'DATE to days',`
    -> `FROM_DAYS(TO_DAYS(d)) AS 'DATE to days to DATE'`
    -> `FROM date_val;`
+------------+--------------+----------------------+
| d          | DATE to days | DATE to days to DATE |
+------------+--------------+----------------------+
| 1864-02-28 |       680870 | 1864-02-28           |
| 1900-01-15 |       693975 | 1900-01-15           |
| 1999-12-31 |       730484 | 1999-12-31           |
| 2000-06-04 |       730640 | 2000-06-04           |
| 2017-03-16 |       736769 | 2017-03-16           |
+------------+--------------+----------------------+
```

使用`TO_DAYS()`时，最好遵循[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)的建议，避免使用格里高利历（1582 年之前）开始的`DATE`值。在该日期之前的日历年和月份长度的变化使得谈论<q>day 0</q>的值变得困难。这与`TIME_TO_SEC()`不同，后者在`TIME`值和结果秒值之间的对应关系是明显的，并且具有 0 秒的有意义参考点。

如果你向`TO_DAYS()`传递一个日期和时间值，它将提取日期部分并丢弃时间部分。这提供了从`DATETIME`（或`TIMESTAMP`）值中提取日期的另一种方法，除了已在配方 8.9 中讨论过的方法之外：

```
mysql> `SELECT dt,`
    -> `TO_DAYS(dt) AS 'date part in days',`
    -> `FROM_DAYS(TO_DAYS(dt)) AS 'date part as DATE'`
    -> `FROM datetime_val;`
+---------------------+-------------------+-------------------+
| dt                  | date part in days | date part as DATE |
+---------------------+-------------------+-------------------+
| 1970-01-01 00:00:00 |            719528 | 1970-01-01        |
| 1999-12-31 09:00:00 |            730484 | 1999-12-31        |
| 2000-06-04 15:45:30 |            730640 | 2000-06-04        |
| 2017-03-16 12:30:15 |            736769 | 2017-03-16        |
+---------------------+-------------------+-------------------+
```

### 在日期和时间值与秒之间进行转换

对于`DATETIME`或`TIMESTAMP`值，它们在`TIMESTAMP`数据类型的范围内（从 1970 年初部分到 2038 年），`UNIX_TIMESTAMP()`和`FROM_UNIXTIME()`函数将秒数转换为 1970 年初以来经过的秒数，转换为秒比转换为天提供了更高的日期和时间值精度，尽管转换的值范围更为有限（`TIME_TO_SEC()`不适用于此，因为它丢弃日期）：

```
mysql> `SELECT dt,`
    -> `UNIX_TIMESTAMP(dt) AS seconds,`
    -> `FROM_UNIXTIME(UNIX_TIMESTAMP(dt)) AS timestamp`
    -> `FROM datetime_val;`
+---------------------+------------+---------------------+
| dt                  | seconds    | timestamp           |
+---------------------+------------+---------------------+
| 1970-01-01 00:00:00 |      21600 | 1970-01-01 00:00:00 |
| 1999-12-31 09:00:00 |  946652400 | 1999-12-31 09:00:00 |
| 2000-06-04 15:45:30 |  960151530 | 2000-06-04 15:45:30 |
| 2017-03-16 12:30:15 | 1489685415 | 2017-03-16 12:30:15 |
+---------------------+------------+---------------------+
```

函数名称中的<q>UNIX</q>与 1970 年开始的适用值范围之间存在关系：<q>Unix 纪元</q>始于`1970-01-01` `00:00:00` UTC。纪元是时间零点，或在 Unix 系统中测量时间的参考点。因此，你可能会发现前面的例子显示`datetime_val`表中第一个值的`UNIX_TIMESTAMP()`值为`21600`为什么不是`0`？这种明显的不一致是由于 MySQL 服务器将`UNIX_TIMESTAMP()`参数解释为客户端本地时区的值，并将其转换为 UTC（参见配方 8.4）。我们的服务器位于美国中部时区，比 UTC 西 6 小时（21600 秒）。根据时区解释`DATETIME`和数字，时间戳不会改变。将会话时区更改为`'+00:00'`以获取 UTC 时间，然后再次运行查询以观察不同的结果：

```
mysql> `set time_zone = '+00:00';`
mysql> `SELECT dt,`
    -> `UNIX_TIMESTAMP(dt) AS seconds,`
    -> `FROM_UNIXTIME(UNIX_TIMESTAMP(dt)) AS timestamp`
    -> `FROM datetime_val;`
+---------------------+------------+---------------------+
| dt                  | seconds    | timestamp           |
+---------------------+------------+---------------------+
| 1970-01-01 00:00:00 |          0 | 1970-01-01 00:00:00 |
| 1999-12-31 09:00:00 |  946630800 | 1999-12-31 09:00:00 |
| 2000-06-04 15:45:30 |  960133530 | 2000-06-04 15:45:30 |
| 2017-03-16 12:30:15 | 1489667415 | 2017-03-16 12:30:15 |
+---------------------+------------+---------------------+
```

`UNIX_TIMESTAMP()`也可以将`DATE`值转换为秒。它将这些值视为具有隐式时间部分`00:00:00`：

```
mysql> `SELECT`
    -> `CURDATE(),`
    -> `UNIX_TIMESTAMP(CURDATE()),`
    -> `FROM_UNIXTIME(UNIX_TIMESTAMP(CURDATE()))\G`
*************************** 1\. row ***************************
                               CURDATE(): 2021-11-28
               UNIX_TIMESTAMP(CURDATE()): 1638046800
FROM_UNIXTIME(UNIX_TIMESTAMP(CURDATE())): 2021-11-28 00:00:00
```

# 8.12 计算日期或时间间隔

## 问题

想知道两个日期或时间之间的间隔长短；也就是说，它们之间的间隔。

## 解决方案

要计算间隔，请使用一个时间差函数，或将你的值转换为基本单位并取差值。允许的函数取决于你想知道间隔的值的类型。

## 讨论

下面的讨论展示了执行区间计算的几种方法。

### 使用时间差函数计算间隔

要计算两个日期值之间的天数间隔，使用 `DATEDIFF()` 函数：

```
mysql> `SET @d1 = '2010-01-01', @d2 = '2009-12-01';`
mysql> `SELECT DATEDIFF(@d1,@d2) AS 'd1 - d2', DATEDIFF(@d2,@d1) AS 'd2 - d1';`
+---------+---------+
| d1 - d2 | d2 - d1 |
+---------+---------+
|      31 |     -31 |
+---------+---------+
```

`DATEDIFF()` 也适用于日期和时间值，但会忽略时间部分。这使其适用于为 `DATE`、`DATETIME` 或 `TIMESTAMP` 值生成日间隔。

要将 `TIME` 值作为另一个 `TIME` 值的间隔计算，使用 `TIMEDIFF()` 函数：

```
mysql> `SET @t1 = '12:00:00', @t2 = '16:30:00';`
mysql> `SELECT TIMEDIFF(@t1,@t2) AS 't1 - t2', TIMEDIFF(@t2,@t1) AS 't2 - t1';`
+-----------+----------+
| t1 - t2   | t2 - t1  |
+-----------+----------+
| -04:30:00 | 04:30:00 |
+-----------+----------+
```

`TIMEDIFF()` 也适用于日期和时间值。也就是说，它接受时间或日期和时间值，但参数的类型必须匹配。

将时间间隔表示为 `TIME` 值可以使用 Recipe 8.9 中展示的技术来分解其组件。例如，要按其组成的小时、分钟和秒值表达时间间隔，可以使用 `HOUR()`、`MINUTE()` 和 `SECOND()` 函数计算时间间隔的子部分。（别忘了，如果你的间隔可能为负数，你必须考虑这一点。）以下 SQL 语句展示了如何确定 `time_val` 表的 `t1` 和 `t2` 列之间间隔的组成部分：

```
mysql> `SELECT t1, t2,`
    -> `TIMEDIFF(t2,t1) AS 't2 - t1 as TIME',`
    -> `IF(TIMEDIFF(t2,t1) >= 0,'+','-') AS sign,`
    -> `HOUR(TIMEDIFF(t2,t1)) AS hour,`
    -> `MINUTE(TIMEDIFF(t2,t1)) AS minute,`
    -> `SECOND(TIMEDIFF(t2,t1)) AS second`
    -> `FROM time_val;`
+----------+----------+-----------------+------+------+--------+--------+
| t1       | t2       | t2 - t1 as TIME | sign | hour | minute | second |
+----------+----------+-----------------+------+------+--------+--------+
| 15:00:00 | 15:00:00 | 00:00:00        | +    |    0 |      0 |      0 |
| 05:01:30 | 02:30:20 | -02:31:10       | -    |    2 |     31 |     10 |
| 12:30:20 | 17:30:45 | 05:00:25        | +    |    5 |      0 |     25 |
+----------+----------+-----------------+------+------+--------+--------+
```

如果你使用日期或日期和时间值，`TIMESTAMPDIFF()` 函数提供了另一种计算间隔的方式。它使你能够指定应以哪些单位表示间隔：

```
TIMESTAMPDIFF(*`unit`*,*`val1`*,*`val2`*)
```

*`unit`* 是区间单位，*`val1`* 和 *`val2`* 是计算区间的值。使用 `TIMESTAMPDIFF()`，你可以以多种不同的方式表示区间：

```
mysql> `SET @dt1 = '1900-01-01 00:00:00', @dt2 = '1910-01-01 00:00:00';`
mysql> `SELECT`
    -> `TIMESTAMPDIFF(MINUTE,@dt1,@dt2) AS minutes,`
    -> `TIMESTAMPDIFF(HOUR,@dt1,@dt2) AS hours,`
    -> `TIMESTAMPDIFF(DAY,@dt1,@dt2) AS days,`
    -> `TIMESTAMPDIFF(WEEK,@dt1,@dt2) AS weeks,`
    -> `TIMESTAMPDIFF(YEAR,@dt1,@dt2) AS years;`
+---------+-------+------+-------+-------+
| minutes | hours | days | weeks | years |
+---------+-------+------+-------+-------+
| 5258880 | 87648 | 3652 |   521 |    10 |
+---------+-------+------+-------+-------+
```

允许的 *`unit`* 规范器包括 `MICROSECOND`、`SECOND`、`MINUTE`、`HOUR`、`DAY`、`WEEK`、`MONTH`、`QUARTER` 或 `YEAR`。请注意，每个都是单数形式，而不是复数形式。

注意 `TIMESTAMPDIFF()` 的这些属性：

+   如果第一个时间值大于第二个时间值，则其值为负数，这与 `DATEDIFF()` 和 `TIMEDIFF()` 的参数顺序相反。

+   尽管其名称中包含 `TIMESTAMP`，但 `TIMESTAMPDIFF()` 的参数并不限于 `TIMESTAMP` 数据类型的范围。

### 使用基本单位进行时间间隔计算

要计算时间值对之间的秒数间隔，可以使用 `TIME_TO_SEC()` 将它们转换为秒，并取其差值。要将结果的区间表达为 `TIME` 值，将其传递给 `SEC_TO_TIME()`。以下语句计算了 `time_val` 表的 `t1` 和 `t2` 列之间的区间，同时用秒和 `TIME` 值表示每个区间：

```
mysql> `SELECT t1, t2,`
    -> `TIME_TO_SEC(t2) - TIME_TO_SEC(t1) AS 't2 - t1 (in seconds)',`
    -> `SEC_TO_TIME(TIME_TO_SEC(t2) - TIME_TO_SEC(t1)) AS 't2 - t1 (as TIME)'`
    -> `FROM time_val;`
+----------+----------+----------------------+-------------------+
| t1       | t2       | t2 - t1 (in seconds) | t2 - t1 (as TIME) |
+----------+----------+----------------------+-------------------+
| 15:00:00 | 15:00:00 |                    0 | 00:00:00          |
| 05:01:30 | 02:30:20 |                -9070 | -02:31:10         |
| 12:30:20 | 17:30:45 |                18025 | 05:00:25          |
+----------+----------+----------------------+-------------------+
```

### 使用基本单位进行日期或日期和时间间隔计算

当你计算日期之间的间隔时，通过将两个日期转换为相对于给定参考点的共同单位，并取其差值，你的值范围决定了可用的转换方式：

+   `DATE`、`DATETIME`或`TIMESTAMP`值可追溯到`1970-01-01` `00:00:00` UTC——Unix 纪元——可以转换为自纪元以来经过的秒数。在这个范围内的日期，您可以计算精确到一秒的间隔。

+   自 1582 年格里高利历开始的旧日期可以转换为日值，并用于计算以天为间隔的间隔。

+   早于这两个参考点的日期提出了更多问题。在这种情况下，您可能会发现您的编程语言提供了在 SQL 中不可用或难以执行的计算。如果是这样，请考虑直接从 API 语言中处理日期值。例如，Date::Calc 和 Date::Manip 模块可用于 Perl 脚本。

要计算日期或日期时间值之间的天数间隔，请使用`TO_DAYS()`将它们转换为天数，并取差值。对于一周的间隔，做同样的事情并将结果除以七：

```
mysql> `SET @days = TO_DAYS('1884-01-01') - TO_DAYS('1883-06-05');`
mysql> `SELECT @days AS days, @days/7 AS weeks;`
+------+---------+
| days | weeks   |
+------+---------+
|  210 | 30.0000 |
+------+---------+
```

不能通过简单的除法将天数转换为月份或年份，因为这些单位的长度不同。要产生以这些单位表示的日期间隔，请使用之前在本配方中讨论过的`TIMESTAMPDIFF()`。

对于在 1970 年部分至 2038 年之间的`TIMESTAMP`范围内发生的日期时间值，您可以使用`UNIX_TIMESTAMP()`函数确定以秒为分辨率的间隔。对于以其他单位表示的间隔，可以轻松地将秒转换为分钟、小时、天或周，就像这个表达式展示的那样，这个表达式显示了两周之间的日期：

```
mysql> `SET @dt1 = '1984-01-01 09:00:00';`
mysql> `SET @dt2 = @dt1 + INTERVAL 14 DAY;`
mysql> `SET @interval = UNIX_TIMESTAMP(@dt2) - UNIX_TIMESTAMP(@dt1);`
mysql> `SELECT @interval AS seconds,`
    -> `@interval / 60 AS minutes,`
    -> `@interval / (60 * 60) AS hours,`
    -> `@interval / (24 * 60 * 60) AS days,`
    -> `@interval / (7 * 24 * 60 * 60) AS weeks;`
+---------+------------+----------+---------+--------+
| seconds | minutes    | hours    | days    | weeks  |
+---------+------------+----------+---------+--------+
| 1209600 | 20160.0000 | 336.0000 | 14.0000 | 2.0000 |
+---------+------------+----------+---------+--------+
```

如果您更喜欢没有小数部分的整数值，请在除法结果上使用`FLOOR()`。

对于超出`TIMESTAMP`范围的值，这种间隔计算方法更为通用（但更为混乱）：

1.  取值的日期部分之间的天数差，乘以 24 × 60 × 60 以转换为秒。

1.  根据值的时间部分之间的秒数差调整结果。

这是一个示例，使用两个日期时间值，它们相隔略少于三天：

```
mysql> `SET @dt1 = '1800-02-14 07:30:00';`
mysql> `SET @dt2 = '1800-02-17 06:30:00';`
mysql> `SET @interval =`
    ->   `((TO_DAYS(@dt2) - TO_DAYS(@dt1)) * 24*60*60)`
    ->   `+ TIME_TO_SEC(@dt2) - TIME_TO_SEC(@dt1);`
mysql> `SELECT @interval AS seconds, SEC_TO_TIME(@interval) AS TIME;`
+---------+----------+
| seconds | TIME     |
+---------+----------+
|  255600 | 71:00:00 |
+---------+----------+
```

# 8.13 添加日期或时间值

## 问题

您想要添加时间值。例如，您想要在时间中添加给定数量的秒，或者确定三周后的日期是什么。

## 解决方案

要添加日期或时间值，您有几个选项：

+   使用其中一种时间添加函数。

+   使用`+` `INTERVAL`或`-` `INTERVAL`运算符。

+   将值转换为基本单位，并求和。

适用的函数或运算符取决于值的类型。

## 讨论

以下讨论展示了几种添加时间值的方法。

### 使用时间添加函数或运算符添加时间值

要将时间添加到时间或日期时间值中，请使用`ADDTIME()`函数：

```
mysql> `SET @t1 = '12:00:00', @t2 = '15:30:00';`
mysql> `SELECT ADDTIME(@t1,@t2);`
+------------------+
| ADDTIME(@t1,@t2) |
+------------------+
| 27:30:00         |
+------------------+
mysql> `SET @dt = '1984-03-01 12:00:00', @t = '12:00:00';`
mysql> `SELECT ADDTIME(@dt,@t);`
+----------------------------+
| TIMESTAMP(@d,@t)           |
+----------------------------+
| 1984-03-01 15:30:00.000000 |
+----------------------------+
```

要将时间添加到日期或日期时间值中，请使用`TIMESTAMP()`函数：

```
mysql> `SET @d = '1984-03-01', @t = '15:30:00';`
mysql> `SELECT TIMESTAMP(@d,@t);`
+---------------------+
| TIMESTAMP(@d,@t)    |
+---------------------+
| 1984-03-01 15:30:00 |
+---------------------+
mysql> `SET @dt = '1984-03-01 12:00:00', @t = '12:00:00';`
mysql> `SELECT TIMESTAMP(@dt,@t);`
+----------------------------+
| TIMESTAMP(@dt,@t)          |
+----------------------------+
| 1984-03-02 00:00:00.000000 |
+----------------------------+
```

MySQL 还提供了`DATE_ADD()`和`DATE_SUB()`函数，用于向日期添加间隔或从日期减去间隔。每个函数接受一个日期（或日期时间）值`d`和一个使用以下语法表示的间隔：

```
DATE_ADD(d,INTERVAL *`val unit`*)
DATE_SUB(d,INTERVAL *`val unit`*)
```

`+` `INTERVAL`和`-` `INTERVAL`运算符类似：

```
d + INTERVAL *`val unit`*
d - INTERVAL *`val unit`*
```

*`unit`*是间隔单位，*`val`*是指示单位数量的表达式。一些常见的单位指示器包括`SECOND`、`MINUTE`、`HOUR`、`DAY`、`MONTH`和`YEAR`。请注意，每个单位都是单数形式，而不是复数形式。（查看[MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days)获取完整列表。）

使用`DATE_ADD()`或`DATE_SUB()`执行日期算术运算，例如这些操作：

+   确定从今天起三天后的日期：

    ```
    mysql> `SELECT CURDATE(), DATE_ADD(CURDATE(),INTERVAL 3 DAY);`
    ++------------+------------------------------------+
    | CURDATE()  | DATE_ADD(CURDATE(),INTERVAL 3 DAY) |
    +------------+------------------------------------+
    | 2021-11-24 | 2021-11-27                         |
    +------------+------------------------------------+
    ```

+   找到一周前的日期：

    ```
    mysql> `SELECT CURDATE(), DATE_SUB(CURDATE(),INTERVAL 1 WEEK);`
    +------------+-------------------------------------+
    | CURDATE()  | DATE_SUB(CURDATE(),INTERVAL 1 WEEK) |
    +------------+-------------------------------------+
    | 2021-11-24 | 2021-11-17                          |
    +------------+-------------------------------------+
    ```

+   对于需要知道日期和时间的问题，请从`DATETIME`或`TIMESTAMP`值开始。要回答“60 小时后是什么时间？”这个问题，请执行以下操作：

    ```
    mysql> `SELECT NOW(), DATE_ADD(NOW(),INTERVAL 60 HOUR);`
    +---------------------+----------------------------------+
    | NOW()               | DATE_ADD(NOW(),INTERVAL 60 HOUR) |
    +---------------------+----------------------------------+
    | 2021-11-24 22:44:19 | 2021-11-27 10:44:19              |
    +---------------------+----------------------------------+
    ```

+   一些间隔指示器具有日期和时间部分。以下将 14.5 小时添加到当前日期和时间：

    ```
    mysql> `SELECT NOW(), DATE_ADD(NOW(),INTERVAL '14:30' HOUR_MINUTE);`
    +---------------------+----------------------------------------------+
    | NOW()               | DATE_ADD(NOW(),INTERVAL '14:30' HOUR_MINUTE) |
    +---------------------+----------------------------------------------+
    | 2021-11-24 22:46:37 | 2021-11-25 13:16:37                          |
    +---------------------+----------------------------------------------+
    ```

    类似地，添加 3 天和 4 小时会产生以下结果：

    ```
    mysql> `SELECT NOW(), DATE_ADD(NOW(),INTERVAL '3 4' DAY_HOUR);`
    +---------------------+-----------------------------------------+
    | NOW()               | DATE_ADD(NOW(),INTERVAL '3 4' DAY_HOUR) |
    +---------------------+-----------------------------------------+
    | 2021-11-24 22:47:15 | 2021-11-28 02:47:15                     |
    +---------------------+-----------------------------------------+
    ```

`DATE_ADD()`和`DATE_SUB()`可以互换使用，因为一个与另一个在间隔值的符号方面是相同的。对于任何日期值`d`，这两个表达式是等价的：

```
DATE_ADD(d,INTERVAL -3 MONTH)
DATE_SUB(d,INTERVAL 3 MONTH)
```

你也可以使用`+` `INTERVAL`或`-` `INTERVAL`运算符执行日期间隔的加法或减法：

```
mysql> `SELECT CURDATE(), CURDATE() + INTERVAL 1 YEAR;`
+------------+-----------------------------+
| CURDATE()  | CURDATE() + INTERVAL 1 YEAR |
+------------+-----------------------------+
| 2021-11-24 | 2022-11-24                  |
+------------+-----------------------------+
mysql> `SELECT NOW(), NOW() - INTERVAL '1 12' DAY_HOUR;`
+---------------------+----------------------------------+
| NOW()               | NOW() - INTERVAL '1 12' DAY_HOUR |
+---------------------+----------------------------------+
| 2021-11-24 22:48:31 | 2021-11-23 10:48:31              |
+---------------------+----------------------------------+
```

`TIMESTAMPADD()`是另一种用于向日期或日期时间值添加间隔的函数。它的参数与`DATE_ADD()`类似，以下等式成立：

```
TIMESTAMPADD(*`unit`*,*`interval`*,d) = DATE_ADD(d,INTERVAL *`interval`* *`unit`*)
```

### 使用基本单位添加时间值

另一种向日期或日期时间值添加间隔的方法是通过执行转换为基本单位的函数进行时间“移位”。有关适用函数的背景信息，请参阅 Recipe 8.11。

### 使用基本单位添加时间值

使用基本单位添加时间类似于计算时间间隔，不同之处在于计算的是总和而不是差值。要将一个以秒为单位的间隔值添加到`TIME`值中，将`TIME`转换为秒，以便两个值都表示为相同的单位，然后将这些值相加，并将结果转换回`TIME`。例如，两小时等于 7,200 秒（2 × 60 × 60），因此以下语句将两小时添加到`time_val`表中每个`t1`值：

```
mysql> `SELECT t1,`
    -> `SEC_TO_TIME(TIME_TO_SEC(t1) + 7200) AS 't1 plus 2 hours'`
    -> `FROM time_val;`
+----------+-----------------+
| t1       | t1 plus 2 hours |
+----------+-----------------+
| 15:00:00 | 17:00:00        |
| 05:01:30 | 07:01:30        |
| 12:30:20 | 14:30:20        |
+----------+-----------------+
```

如果间隔本身表示为`TIME`，在将这些值相加之前，它也应转换为秒。以下示例计算`time_val`表中每行的两个`TIME`值的总和：

```
mysql> `SELECT t1, t2,`
    -> `TIME_TO_SEC(t1) + TIME_TO_SEC(t2)`
    ->   `AS 't1 + t2 (in seconds)',`
    -> `SEC_TO_TIME(TIME_TO_SEC(t1) + TIME_TO_SEC(t2))`
    ->   `AS 't1 + t2 (as TIME)'`
    -> `FROM time_val;`
+----------+----------+----------------------+-------------------+
| t1       | t2       | t1 + t2 (in seconds) | t1 + t2 (as TIME) |
+----------+----------+----------------------+-------------------+
| 15:00:00 | 15:00:00 |               108000 | 30:00:00          |
| 05:01:30 | 02:30:20 |                27110 | 07:31:50          |
| 12:30:20 | 17:30:45 |               108065 | 30:01:05          |
+----------+----------+----------------------+-------------------+
```

重要的是要认识到 MySQL `TIME`值表示经过的时间，而不是一天中的时间，因此它们在达到 24 小时后不会重置为 0。您可以在上一条语句的第一和第三输出行中看到这一点。要生成一天中的时间值，可以在将秒值转换回`TIME`值之前使用取模操作来执行 24 小时循环：一天中的秒数是 24 × 60 × 60，即 86,400。要将任何秒值`s`转换为在 24 小时范围内，使用`MOD()`函数或`%`取模运算符，如下所示：

```
MOD(s,86400)
s % 86400
s MOD 86400
```

这三个表达式是等效的。将它们中的第一个应用于前面示例中的时间计算，得到以下结果：

```
mysql> `SELECT t1, t2,`
    -> `MOD(TIME_TO_SEC(t1) + TIME_TO_SEC(t2), 86400)`
    ->   `AS 't1 + t2 (in seconds)',`
    -> `SEC_TO_TIME(MOD(TIME_TO_SEC(t1) + TIME_TO_SEC(t2), 86400))`
    ->   `AS 't1 + t2 (as TIME)'`
    -> `FROM time_val;`
+----------+----------+----------------------+-------------------+
| t1       | t2       | t1 + t2 (in seconds) | t1 + t2 (as TIME) |
+----------+----------+----------------------+-------------------+
| 15:00:00 | 15:00:00 |                21600 | 06:00:00          |
| 05:01:30 | 02:30:20 |                27110 | 07:31:50          |
| 12:30:20 | 17:30:45 |                21665 | 06:01:05          |
+----------+----------+----------------------+-------------------+
```

###### 注意

`TIME`列的允许范围是`-838:59:59`到`838:59:59`（即`-3020399`到`3020399`秒）。但是，`TIME` *表达式*的范围可以更大，因此当您添加时间值时，可能会产生超出此范围的结果，并且不能直接存储到`TIME`列中。

或者可以使用`TIMESTAMPDIFF()`函数来超出`TIMEDIFF()`函数的限制。

```
mysql> `SELECT NOW(),TIMESTAMPDIFF(minute,now(), '2023-01-01 00:00:00');`
+---------------------+----------------------------------------------------+
| NOW()               | TIMESTAMPDIFF(minute,now(), '2023-01-01 00:00:00') |
+---------------------+----------------------------------------------------+
| 2022-03-07 06:38:40 |                                             431601 |
+---------------------+----------------------------------------------------+
```

```
mysql> `SELECT NOW(),TIMESTAMPDIFF(day,now(), '2023-01-01 00:00:00');`
+---------------------+-------------------------------------------------+
| NOW()               | TIMESTAMPDIFF(day,now(), '2023-01-01 00:00:00') |
+---------------------+-------------------------------------------------+
| 2022-03-07 06:38:50 |                                             299 |
+---------------------+-------------------------------------------------+
```

### 使用基本单位添加到日期或日期时间值

将日期或日期时间值转换为基本单位后，可以进行偏移以生成其他日期。例如，要将日期向前或向后移动一周（七天），可以使用`TO_DAYS()`和`FROM_DAYS()`函数：

```
mysql> `SET @d = '1980-01-01';`
mysql> `SELECT @d AS date,`
    -> `FROM_DAYS(TO_DAYS(@d) + 7) AS 'date + 1 week',`
    -> `FROM_DAYS(TO_DAYS(@d) - 7) AS 'date - 1 week';`
+------------+---------------+---------------+
| date       | date + 1 week | date - 1 week |
+------------+---------------+---------------+
| 1980-01-01 | 1980-01-08    | 1979-12-25    |
+------------+---------------+---------------+
```

如果你不介意时间部分被截断，`TO_DAYS()`也可以将日期时间值转换为天数。

要保留时间部分，可以使用`UNIX_TIMESTAMP()`和`FROM_UNIXTIME()`，只要初始值和结果值都在`TIMESTAMP`值的允许范围内（从 1970 年到 2038 年部分）即可。以下语句将`DATETIME`值向前或向后移动一个小时（3,600 秒）：

```
mysql> `SET @dt = '1980-01-01 09:00:00';`
mysql> `SELECT @dt AS datetime,`
    -> `FROM_UNIXTIME(UNIX_TIMESTAMP(@dt) + 3600) AS 'datetime + 1 hour',`
    -> `FROM_UNIXTIME(UNIX_TIMESTAMP(@dt) - 3600) AS 'datetime - 1 hour';`
+---------------------+---------------------+---------------------+
| datetime            | datetime + 1 hour   | datetime - 1 hour   |
+---------------------+---------------------+---------------------+
| 1980-01-01 09:00:00 | 1980-01-01 10:00:00 | 1980-01-01 08:00:00 |
+---------------------+---------------------+---------------------+
```

# 8.14 计算年龄

## 问题

想要知道某人多大年龄。

## 解决方案

这是一个日期算术问题。它等同于计算日期间隔，但有所不同。对于年龄以年为单位的计算，需要考虑起始日期和结束日期在日历年中的相对位置。对于以月为单位的年龄计算，还需要考虑月份和日期在月份中的位置。

## 讨论

年龄确定是一种日期间隔计算类型。然而，您不能简单地计算天数差并除以 365，因为闰年会影响计算结果。（从 1995-03-01 到 1996-02-29 是 365 天，但在年龄计算中不算一年。）除以 365.25 略微更精确，但对于所有日期仍然不正确。

要计算年龄，请使用`TIMESTAMPDIFF()`函数。向其传递一个出生日期、当前日期和希望年龄以什么单位表达的参数：

```
TIMESTAMPDIFF(*`unit`*,*`birth`*,*`current`*)
```

`TIMESTAMPDIFF()`处理必要的计算，以调整不同月份和年份长度以及日期在日历年中的相对位置。假设一个`sibling`表列出了 Ilayda 和她妹妹 Lara 的出生日期。

```
mysql> `SELECT * FROM sibling;`
+--------+------------+
| name   | birth      |
+--------+------------+
| Ilayda | 2002-12-17 |
| Lara   | 2009-06-03 |
+--------+------------+
```

使用 `TIMESTAMPDIFF()`，您可以回答以下类似的问题：

+   Alkin 的孩子今天多少岁、多少个月和多少天了？

    ```
    mysql> `SELECT name,DATE_FORMAT(birth,'%Y-%m-%d') as dob,`
        -> `DATE_FORMAT(NOW(),'%Y-%m-%d') as today,`
        -> `TIMESTAMPDIFF( YEAR, birth, NOW() ) as age_years',`
        -> `FLOOR( TIMESTAMPDIFF( DAY, birth, now() ) % 30.4375 ) as age_days`   
        -> `FROM sibling;`
    +--------+------------+------------+-----------+------------+----------+
    | name   | dob        | today      | age_years | age_months | age_days |
    +--------+------------+------------+-----------+------------+----------+
    | Ilayda | 2002-12-17 | 2022-03-07 |        19 |          2 |       19 |
    | Lara   | 2009-06-03 | 2022-03-07 |        12 |          9 |        3 |
    +--------+------------+------------+-----------+------------+----------+
    ```

+   当 Lara 出生时，Ilayda 多大了，以年和月计算？

    ```
    mysql> `SELECT name, birth, '2009-06-03' AS 'Lara\'s birth',` 
        -> `TIMESTAMPDIFF(YEAR,birth,'2009-06-03') AS 'age in years',`
        -> `TIMESTAMPDIFF( MONTH, birth,'2009-06-09' ) % 12 as age_months,`
        -> `FLOOR( TIMESTAMPDIFF( DAY, birth,'2009-06-09' ) % 30.4375 ) as age_days`
        -> `FROM sibling WHERE name <> 'Lara';`
    +--------+------------+--------------+-----------+------------+----------+
    | name   | birth      | Lara's birth | age_years | age_months | age_days |
    +--------+------------+--------------+-----------+------------+----------+
    | Ilayda | 2002-12-17 | 2009-06-09   |         6 |          5 |       22 |
    +--------+------------+--------------+-----------+------------+----------+
    ```

欲了解更多关于使用这些函数进行日期计算的信息，请参阅 [MySQL 参考手册](https://dev.mysql.com/doc/refman/8.0/en/date-calculations.html)。

# 8.15 寻找月份的第一天、最后一天或长度

## 问题

给定一个日期，您想确定该日期所在月份的第一天或最后一天的日期，或者与该日期相隔 *`n`* 个月的月份的第一天或最后一天。相关问题是确定某月的天数。

## 解决方案

要确定某月的第一天的日期，请使用日期移动（日期算术的一种应用）。要确定最后一天的日期，请使用 `LAST_DAY()` 函数。要确定某月的天数，找到其最后一天的日期，并将其作为 `DAYOFMONTH()` 的参数使用。

## 讨论

有时您有一个参考日期，并希望达到一个与参考日期没有固定关系的目标日期。例如，当前月份的第一天或最后一天不是从当前日期固定天数的。

要找到给定日期的月份的第一天，请将日期向后移动比其 `DAYOFMONTH()` 值少一天：

```
mysql> `SELECT d, DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY) AS '1st of month'`
    -> `FROM date_val;`
+------------+--------------+
| d          | 1st of month |
+------------+--------------+
| 1864-02-28 | 1864-02-01   |
| 1900-01-15 | 1900-01-01   |
| 1999-12-31 | 1999-12-01   |
| 2000-06-04 | 2000-06-01   |
| 2017-03-16 | 2017-03-01   |
+------------+--------------+
```

通常情况下，要找到距离给定日期 *`n`* 个月的任何月份的第一天，计算该日期的月初，并将结果移动 *`n`* 个月：

```
DATE_ADD(DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY),INTERVAL *`n`* MONTH)
```

例如，要找到相对于给定日期的前一个和后一个月的第一天，*`n`* 分别为 `-1` 和 `1`：

```
mysql> `SELECT d,`
    -> `DATE_ADD(DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY),INTERVAL -1 MONTH)`
    ->   `AS '1st of previous month',`
    -> `DATE_ADD(DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY),INTERVAL 1 MONTH)`
    ->   `AS '1st of following month'`
    -> `FROM date_val;`
+------------+-----------------------+------------------------+
| d          | 1st of previous month | 1st of following month |
+------------+-----------------------+------------------------+
| 1864-02-28 | 1864-01-01            | 1864-03-01             |
| 1900-01-15 | 1899-12-01            | 1900-02-01             |
| 1999-12-31 | 1999-11-01            | 2000-01-01             |
| 2000-06-04 | 2000-05-01            | 2000-07-01             |
| 2017-03-16 | 2017-02-01            | 2017-04-01             |
+------------+-----------------------+------------------------+
```

对于给定日期，找到该月的最后一天更容易，因为有相应的函数：

```
mysql> `SELECT d, LAST_DAY(d) AS 'last of month'`
    -> `FROM date_val;`
+------------+---------------+
| d          | last of month |
+------------+---------------+
| 1864-02-28 | 1864-02-29    |
| 1900-01-15 | 1900-01-31    |
| 1999-12-31 | 1999-12-31    |
| 2000-06-04 | 2000-06-30    |
| 2017-03-16 | 2017-03-31    |
+------------+---------------+
```

对于一般情况，要找到任何日期 *`n`* 个月后的月末，先将日期移动该月数，然后将其传递给 `LAST_DAY()`：

```
LAST_DAY(DATE_ADD(d,INTERVAL *`n`* MONTH))
```

例如，要找到相对于给定日期的前一个和后一个月的最后一天，*`n`* 分别为 `-1` 和 `1`：

```
mysql> `SELECT d,`
    -> `LAST_DAY(DATE_ADD(d,INTERVAL -1 MONTH))`
    ->   `AS 'last of previous month',`
    -> `LAST_DAY(DATE_ADD(d,INTERVAL 1 MONTH))`
    ->  `AS 'last of following month'`
    -> `FROM date_val;`
+------------+------------------------+-------------------------+
| d          | last of previous month | last of following month |
+------------+------------------------+-------------------------+
| 1864-02-28 | 1864-01-31             | 1864-03-31              |
| 1900-01-15 | 1899-12-31             | 1900-02-28              |
| 1999-12-31 | 1999-11-30             | 2000-01-31              |
| 2000-06-04 | 2000-05-31             | 2000-07-31              |
| 2017-03-16 | 2017-02-28             | 2017-04-30              |
+------------+------------------------+-------------------------+
```

要找到某月的天数长度，请确定其最后一天的日期并使用 `DAYOFMONTH()` 从结果中提取日-月组件：

```
mysql> `SELECT d, DAYOFMONTH(LAST_DAY(d)) AS 'days in month' FROM date_val;`
+------------+---------------+
| d          | days in month |
+------------+---------------+
| 1864-02-28 |            29 |
| 1900-01-15 |            31 |
| 1999-12-31 |            31 |
| 2000-06-04 |            30 |
| 2017-03-16 |            31 |
+------------+---------------+
```

# 8.16 确定日期的星期几

## 问题

您想知道某个日期是星期几。

## 解决方案

使用 `DAYNAME()` 函数。

## 讨论

要确定给定日期的星期几名称，请使用 `DAYNAME()`：

```
mysql> `SELECT CURDATE(), DAYNAME(CURDATE());`
+------------+--------------------+
| CURDATE()  | DAYNAME(CURDATE()) |
+------------+--------------------+
| 2021-11-24 | Wednesday          |
+------------+--------------------+
```

`DAYNAME()` 经常与其他日期相关技术结合使用。例如，要确定月初的星期几，使用来自 Recipe 8.15 的月初表达式作为 `DAYNAME()` 的参数：

```
mysql> `SET @d = CURDATE();`
mysql> `SET @first = DATE_SUB(@d,INTERVAL DAYOFMONTH(@d)-1 DAY);`
mysql> `SELECT @d AS 'starting date',`
    -> `@first AS '1st of month date',`
    -> `DAYNAME(@first) AS '1st of month day';`
+---------------+-------------------+------------------+
| starting date | 1st of month date | 1st of month day |
+---------------+-------------------+------------------+
| 2021-11-24    | 2021-11-01        | Monday           |
+---------------+-------------------+------------------+
```

# 8.17 寻找给定周的任意工作日日期

## 问题

您想计算给定日期所在周的某个工作日的日期。假设您想知道与 `2014-07-09` 相同周内的星期二的日期。

## 解决方案

这是日期偏移的一个应用。找出给定日期的起始星期几与所需日期之间的天数，并将日期向前或向后偏移这么多天。

## 讨论

本节和下一节描述了在目标日期以星期天数指定时如何将一个日期转换为另一个日期。为了解决这类问题，您需要知道星期几的值。假设您从目标日期 `2014-07-09` 开始。要确定该日期所在星期中的星期二的日期，计算依赖于它是星期几。如果是星期一，则添加一天得到 `2014-07-10`，但如果是星期三，则减去一天得到 `2014-07-08`。

MySQL 提供了两个在此非常有用的函数。`DAYOFWEEK()` 将星期日视为一周的第一天，并返回 1 到 7，分别代表星期日到星期六。（这里的示例使用了 `DAYOFWEEK()`。）另一种星期几的操作涉及确定星期几的名称。`DAYNAME()` 可以用于此操作。

决定从某天到另一天的日期的计算，取决于您起始的那天以及您想要到达的那天。我发现最容易首先将参考日期移至一周的开始的已知点，然后再向前移动：

1.  将参考日期向前移动其 `DAYOFWEEK()` 值，这总是产生前一周的星期六日期。

1.  将星期六的日期向前移动一天，得到星期日的日期；向前移动两天，得到星期一的日期，依此类推。

在 SQL 中，这些操作可以针对日期 `d` 表达如下，其中 *`n`* 为 1 到 7，分别代表星期日到星期六的日期：

```
DATE_ADD(DATE_SUB(d,INTERVAL DAYOFWEEK(d) DAY),INTERVAL *`n`* DAY)
```

该表达式将“返回到星期六”和“前进”阶段拆分为单独的操作，但由于`DATE_SUB()`和`DATE_ADD()`的间隔都是以天为单位，该表达式可以简化为单个`DATE_ADD()`调用：

```
DATE_ADD(d,INTERVAL *`n`*-DAYOFWEEK(d) DAY)
```

将此公式应用于我们的 `date_val` 表中的日期，使用 *`n`* 为 1 表示星期日，为 7 表示星期六，以找到一周的第一天和最后一天，得到如下结果：

```
mysql> `SELECT d, DAYNAME(d) AS day,`
    -> `DATE_ADD(d,INTERVAL 1-DAYOFWEEK(d) DAY) AS Sunday,`
    -> `DATE_ADD(d,INTERVAL 7-DAYOFWEEK(d) DAY) AS Saturday`
    -> `FROM date_val;`
+------------+----------+------------+------------+
| d          | day      | Sunday     | Saturday   |
+------------+----------+------------+------------+
| 1864-02-28 | Sunday   | 1864-02-28 | 1864-03-05 |
| 1900-01-15 | Monday   | 1900-01-14 | 1900-01-20 |
| 1999-12-31 | Friday   | 1999-12-26 | 2000-01-01 |
| 2000-06-04 | Sunday   | 2000-06-04 | 2000-06-10 |
| 2017-03-16 | Thursday | 2017-03-12 | 2017-03-18 |
+------------+----------+------------+------------+
```

要确定目标日期所在星期的某个星期几的日期，相对于目标日期进行稍微修改。首先，确定包含目标日期的星期中所需星期几的日期，然后将结果偏移到所需的星期。

计算某周的某天日期是一个问题，可以分解为一个周内日期偏移（使用刚才给出的公式）和一个周偏移。这两个操作可以按任何顺序执行，因为在周内的偏移量不受是否首先将参考日期移到另一周中的影响。例如，按照上述公式计算一个星期的星期三，*`n`* 为 4。要计算两周前的星期三的日期，可以先执行周内日期偏移，如下所示：

```
mysql> `SET @target =`
    -> `DATE_SUB(DATE_ADD(CURDATE(),INTERVAL 4-DAYOFWEEK(CURDATE()) DAY),`
    -> `INTERVAL 14 DAY);`
mysql> `SELECT CURDATE(), @target, DAYNAME(@target);`
+------------+------------+------------------+
| CURDATE()  | @target    | DAYNAME(@target) |
+------------+------------+------------------+
| 2021-11-24 | 2021-11-10 | Wednesday        |
+------------+------------+------------------+
```

或者您可以先执行星期转换：

```
mysql> `SET @target =`
    -> `DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 14 DAY),`
    -> `INTERVAL 4-DAYOFWEEK(CURDATE()) DAY);`
mysql> `SELECT CURDATE(), @target, DAYNAME(@target);`
+------------+------------+------------------+
| CURDATE()  | @target    | DAYNAME(@target) |
+------------+------------+------------------+
| 2021-11-24 | 2021-11-10 | Wednesday        |
+------------+------------+------------------+
```

一些应用程序需要确定特定工作日的第*n*个实例的日期。例如，管理发薪日为每月第二个和第四个星期四的工资单，您必须知道这些日期。为了在任何给定月份执行此操作，您可以从月初日期开始并向前移动。将日期移动到该周的星期四很容易；关键是要计算向前移动多少周才能达到第二个和第四个星期四。如果月初日期在周日到周四之间的任何一天，则向前移动一周即可到达第二个星期四。如果月初日期在周五或之后，则向前移动两周。第四个星期四当然是再往后两周。

下面的 Perl 代码实现了这一逻辑，以找到 2021 年的所有发薪日。它运行一个循环，构造每年月份的第一天日期。对于每个月，它执行一个语句来确定第二个和第四个星期四的日期：

```
my $year = 2021;
print "MM/YYYY   2nd Thursday   4th Thursday\n";
foreach my $month (1..12)
{
  my $first = sprintf ("%04d-%02d-01", $year, $month);
  my ($thu2, $thu4) = $dbh->selectrow_array (qq{
 SELECT
 DATE_ADD(
 DATE_ADD(?,INTERVAL 5-DAYOFWEEK(?) DAY),
 INTERVAL IF(DAYOFWEEK(?) <= 5, 7, 14) DAY),
 DATE_ADD(
 DATE_ADD(?,INTERVAL 5-DAYOFWEEK(?) DAY),
 INTERVAL IF(DAYOFWEEK(?) <= 5, 21, 28) DAY)
 }, undef, $first, $first, $first, $first, $first, $first);
  printf "%02d/%04d   %s     %s\n", $month, $year, $thu2, $thu4;
}
```

该程序产生以下输出：

```
MM/YYYY   2nd Thursday   4th Thursday
MM/YYYY   2nd Thursday   4th Thursday
01/2021   2021-01-14     2021-01-28
02/2021   2021-02-11     2021-02-25
03/2021   2021-03-11     2021-03-25
04/2021   2021-04-08     2021-04-22
05/2021   2021-05-13     2021-05-27
06/2021   2021-06-10     2021-06-24
07/2021   2021-07-08     2021-07-22
08/2021   2021-08-12     2021-08-26
09/2021   2021-09-09     2021-09-23
10/2021   2021-10-14     2021-10-28
11/2021   2021-11-11     2021-11-25
12/2021   2021-12-09     2021-12-23
```

# 8.18 规范非完全 ISO 日期字符串

## 问题

您有一个接近但不完全符合 ISO 格式的日期，想要将其转换为 ISO 格式的日期。

## 解决方案

通过传递日期到一个始终返回 ISO 格式日期结果的函数来规范日期。

## 讨论

在配方 8.10 中，我们遇到了使用`CONCAT()`合成日期可能产生不完全符合 ISO 格式的问题。例如，以下语句生成的每月第一天的值可能月份部分只有一位数：

```
mysql> `SELECT d, CONCAT(YEAR(d),'-',MONTH(d),'-01') FROM date_val;`
+------------+------------------------------------+
| d          | CONCAT(YEAR(d),'-',MONTH(d),'-01') |
+------------+------------------------------------+
| 1864-02-28 | 1864-2-01                          |
| 1900-01-15 | 1900-1-01                          |
| 1999-12-31 | 1999-12-01                         |
| 2000-06-04 | 2000-6-01                          |
| 2017-03-16 | 2017-3-01                          |
+------------+------------------------------------+
```

配方 8.10 展示了使用`LPAD()`确保月份值为两位数的技术。另一种标准化接近 ISO 日期的方法是将其用于生成 ISO 日期结果的表达式中。对于日期`d`，以下任何表达式均可：

```
DATE_ADD(d,INTERVAL 0 DAY)
d + INTERVAL 0 DAY
FROM_DAYS(TO_DAYS(d))
STR_TO_DATE(d,'%Y-%m-%d')
```

使用这些表达式与`CONCAT()`操作的非 ISO 结果以多种方式产生 ISO 格式：

```
mysql> `SELECT`
    -> `CONCAT(YEAR(d),'-',MONTH(d),'-01') AS 'non-ISO',`
    -> `DATE_ADD(CONCAT(YEAR(d),'-',MONTH(d),'-01'),INTERVAL 0 DAY) AS 'ISO 1',`
    -> `CONCAT(YEAR(d),'-',MONTH(d),'-01') + INTERVAL 0 DAY AS 'ISO 2',`
    -> `FROM_DAYS(TO_DAYS(CONCAT(YEAR(d),'-',MONTH(d),'-01'))) AS 'ISO 3',`
    -> `STR_TO_DATE(CONCAT(YEAR(d),'-',MONTH(d),'-01'),'%Y-%m-%d') AS 'ISO 4'`
    -> `FROM date_val;`
+------------+------------+------------+------------+------------+
| non-ISO    | ISO 1      | ISO 2      | ISO 3      | ISO 4      |
+------------+------------+------------+------------+------------+
| 1864-2-01  | 1864-02-01 | 1864-02-01 | 1864-02-01 | 1864-02-01 |
| 1900-1-01  | 1900-01-01 | 1900-01-01 | 1900-01-01 | 1900-01-01 |
| 1999-12-01 | 1999-12-01 | 1999-12-01 | 1999-12-01 | 1999-12-01 |
| 2000-6-01  | 2000-06-01 | 2000-06-01 | 2000-06-01 | 2000-06-01 |
| 2017-3-01  | 2017-03-01 | 2017-03-01 | 2017-03-01 | 2017-03-01 |
+------------+------------+------------+------------+------------+
```

# 8.19 基于时间特性选择行

## 问题

您希望基于时间条件选择行。

## 解决方案

在`WHERE`子句中使用日期或时间条件。这可能基于直接比较列值与已知值，或者可能需要对列值应用函数以将其转换为更适合测试的形式，例如使用`MONTH()`来测试日期的月份部分。

## 讨论

大多数前面基于日期的技术都是通过示例语句来说明输出日期或时间值。要在语句中选择行并基于日期进行限制，请在`WHERE`子句中使用相同的技术。例如，您可以通过查找发生在给定日期之前或之后、在日期范围内的值，或匹配特定月份或日期值来选择行。

### 比较日期之间的差异

下面的语句查找来自 `date_val` 表的在 1900 年之前或在 1900 年代期间发生的行：

```
mysql> `SELECT d FROM date_val where d < '1900-01-01';`
+------------+
| d          |
+------------+
| 1864-02-28 |
+------------+
mysql> `SELECT d FROM date_val where d BETWEEN '1900-01-01' AND '1999-12-31';`
+------------+
| d          |
+------------+
| 1900-01-15 |
| 1999-12-31 |
+------------+
```

当你不知道在 `WHERE` 子句中需要什么确切日期时，通常可以使用表达式来计算它。例如，执行一个“历史上的今天”语句来搜索名为 `history` 的表中恰好发生在 50 年前的事件时，可以这样做：

```
SELECT * FROM history WHERE d = DATE_SUB(CURDATE(),INTERVAL 50 YEAR);
```

你会在报纸上看到这种事情，它们会列出过去时间的新闻事件。（实质上，该语句标识了那些达到其*`n`*周年纪念的事件。）为了检索发生在“今天”任何年份而不是特定年份“这一日期”的事件，该语句有些不同。在这种情况下，您需要查找与当前日历日匹配的行，忽略年份。有关该主题的讨论见“将日期与日历日进行比较”。

计算日期对于范围测试也是有用的。例如，要查找晚于 20 年前的日期，请使用 `DATE_SUB()` 计算截止日期：

```
mysql> `SELECT d FROM date_val WHERE d >= DATE_SUB(CURDATE(),INTERVAL 20 YEAR);`
+------------+
| d          |
+------------+
| 1999-12-31 |
| 2000-06-04 |
| 2017-03-16 |
+------------+
```

注意 `WHERE` 子句中的表达式将日期列 `d` 孤立在比较操作符的一侧。这通常是个好主意；如果列被索引，将其单独放在比较的一侧使得 MySQL 能够更高效地处理语句。为了说明这一点，前面的 `WHERE` 子句可以以逻辑上等效但对 MySQL 执行效率较低的方式编写：

```
WHERE DATE_ADD(d,INTERVAL 20 YEAR) >= CURDATE();
```

这里，`d` 列在表达式中被使用。这意味着必须检索*每一行*，以便可以评估和测试表达式，这使得列上的任何索引都变得无用。

有时候不太明显如何重写比较以将日期列孤立在一侧。例如，下面的 `WHERE` 子句仅在比较中使用了日期列的一部分：

```
WHERE YEAR(d) >= 1987 AND YEAR(d) <= 1991;
```

要重写第一个比较，请消除 `YEAR()` 调用，并将其右侧替换为完整日期：

```
WHERE d >= '1987-01-01' AND YEAR(d) <= 1991;
```

重写第二个比较有些棘手。你可以消除左侧的 `YEAR()` 调用，就像第一个表达式一样，但你不能只是在右侧的年份后面添加 `-01-01`。这会产生以下错误的结果：

```
WHERE d >= '1987-01-01' AND d <= '1991-01-01';
```

那样做失败了，因为从 `1991-01-02` 到 `1991-12-31` 的日期未通过测试，但应该通过。要正确重写第二个比较，请执行以下操作：

```
WHERE d >= '1987-01-01' AND d < '1992-01-01';
```

计算日期的另一种用途经常出现在创建有限生命周期行的应用程序中。这些应用程序必须能够确定在执行过期操作时要删除哪些行。你可以通过以下几种方式解决这个问题：

+   在每行中存储一个日期，指示其创建时间。（通过将列设置为`TIMESTAMP`或将其设置为`NOW()`来实现；详情请参见 Recipe 8.8。）稍后执行过期操作时，通过将该日期与当前日期进行比较，确定哪些行的创建日期过早。例如，过期超过*n*天的行的语句可能如下所示：

    ```
    DELETE FROM mytbl WHERE create_date < DATE_SUB(NOW(),INTERVAL *`n`* DAY);
    ```

+   在每行中存储一个明确的过期日期，通过在创建行时使用`DATE_ADD()`计算过期日期。对于应在*n*天后过期的行，操作如下：

    ```
    INSERT INTO mytbl (expire_date,...)
    VALUES(DATE_ADD(NOW(),INTERVAL *`n`* DAY),...);
    ```

    在这种情况下执行过期操作，比较过期日期与当前日期，以查看哪些已到期：

    ```
    DELETE FROM mytbl WHERE expire_date < NOW();
    ```

### 比较时间之间的差异

涉及时间的比较类似于涉及日期的比较。例如，要查找在`t1`列中发生在上午 9 点到下午 2 点的时间，可以使用以下表达式之一：

```
WHERE t1 BETWEEN '09:00:00' AND '14:00:00';
WHERE HOUR(t1) BETWEEN 9 AND 14;
```

对于索引的`TIME`列，第一种方法更有效。第二种方法的特性是不仅适用于`TIME`列，还适用于`DATETIME`和`TIMESTAMP`列。

### 比较日期与日历日期

要回答关于一年中特定日期的问题，请使用日历日期测试。以下示例演示了在查找生日时如何做到这一点：

+   今天谁过生日？这要求匹配特定的日历日期，因此在执行比较时提取月份和日期，但忽略年份：

    ```
    WHERE MONTH(d) = MONTH(CURDATE()) AND DAYOFMONTH(d) = DAYOFMONTH(CURDATE());
    ```

    这种语句通常用于生物数据，以找出出生在特定日期的演员、政治家、音乐家等列表。

    使用`DAYOFYEAR()`来解决“在这一天”的问题很诱人，因为它会生成更简单的语句。但是`DAYOFYEAR()`对闰年的处理不正确。2 月 29 日的存在会导致 3 月到 12 月的日期值出错。

+   本月谁过生日？在这种情况下，只需检查月份即可：

    ```
    WHERE MONTH(d) = MONTH(CURDATE());
    ```

+   下个月谁过生日？这里的技巧在于，不能简单地在当前月份上加一来获取符合日期的月份编号。这样会导致 12 月的日期得到 13。要确保获得 1（即 1 月），可以使用以下任一技术：

    ```
    WHERE MONTH(d) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));
    WHERE MONTH(d) = MOD(MONTH(CURDATE()),12)+1;
    ```
