# 第十七章：统计技术

# 17.0 介绍

本章涵盖了几个与基本统计技术相关的主题。在很大程度上，这些配方是建立在早期章节描述的技术之上的，比如在第十章中描述的摘要技术，以及在第十六章中的连接技术。因此，这里的示例展示了应用这些章节材料的其他方法。总体而言，本章讨论的主题包括：

+   技术，如计算描述性统计、生成频率分布、计数缺失值以及计算最小二乘回归或相关系数，来描述数据集。

+   随机化方法，例如如何生成随机数并将其应用于随机化一组行或从行中随机选择个体项

+   计算连续观测差异、累积和和移动平均的技术。

+   生成排名分配和生成团队排名的方法

统计涵盖了如此广泛和多样的主题，以至于本章只能浅尝辄止，并且只是简单地说明了 MySQL 可以应用于统计分析的一些潜在领域。请注意，某些统计量可以以不同的方式定义（例如，您是基于 *`n`* 自由度还是 *`n`*–1 来计算标准差？）。如果我用于某个术语的定义与您偏好的定义不符，请相应地调整此处展示的查询或算法。

您可以在`recipes`分发的*stats*目录中找到与此处讨论的示例相关的脚本，并且在*tables*目录中找到创建示例表格的脚本。

# 17.1 计算描述性统计

## 问题

您希望通过计算一般的描述性或摘要统计来描述数据集。

## 解决方案

许多常见的描述性统计，如均值和标准差，都是通过将聚合函数应用于您的数据来获得的。其他的，如中位数或众数，则是基于计数查询计算的。

## 讨论

假设一个`testscore`表包含表示主题 ID、年龄、性别和测试分数的观测：

```
mysql> `SELECT subject, age, sex, score FROM testscore ORDER BY subject;`
+---------+-----+-----+-------+
| subject | age | sex | score |
+---------+-----+-----+-------+
|       1 |   5 | M   |     5 |
|       2 |   5 | M   |     4 |
|       3 |   5 | F   |     6 |
|       4 |   5 | F   |     7 |
|       5 |   6 | M   |     8 |
|       6 |   6 | M   |     9 |
|       7 |   6 | F   |     4 |
|       8 |   6 | F   |     6 |
|       9 |   7 | M   |     8 |
|      10 |   7 | M   |     6 |
|      11 |   7 | F   |     9 |
|      12 |   7 | F   |     7 |
|      13 |   8 | M   |     9 |
|      14 |   8 | M   |     6 |
|      15 |   8 | F   |     7 |
|      16 |   8 | F   |    10 |
|      17 |   9 | M   |     9 |
|      18 |   9 | M   |     7 |
|      19 |   9 | F   |    10 |
|      20 |   9 | F   |     9 |
+---------+-----+-----+-------+
```

分析一组观察结果的一个良好的第一步是生成一些总结其整体特征的描述性统计。这类常见的统计值包括：

+   观测数量、它们的总和和它们的范围（最小和最大）

+   中心趋势的度量，如均值、中位数和众数

+   变异度量，如标准差和方差

除了中位数和众数外，所有这些都可以通过调用聚合函数轻松计算：

```
mysql> `SELECT COUNT(score) AS n,`
    -> `SUM(score) AS sum,`
    -> `MIN(score) AS minimum,`
    -> `MAX(score) AS maximum,`
    -> `AVG(score) AS mean,`
    -> `STDDEV_SAMP(score) AS 'std. dev.',`
    -> `VAR_SAMP(score) AS 'variance'`
    -> `FROM testscore;`
+----+------+---------+---------+--------+-----------+----------+
| n  | sum  | minimum | maximum | mean   | std. dev. | variance |
+----+------+---------+---------+--------+-----------+----------+
| 20 |  146 |       4 |      10 | 7.3000 |    1.8382 |   3.3789 |
+----+------+---------+---------+--------+-----------+----------+
```

`STDDEV_SAMP()`和`VAR_SAMP()`函数生成样本度量而不是总体度量。也就是说，对于一组*`n`*个值，它们生成基于*`n`*–1 自由度的结果。对于基于*`n`*自由度的总体度量，请使用`STDDEV_POP()`和`VAR_POP()`。`STDDEV()`和`VARIANCE()`是`STDDEV_POP()`和`VAR_POP()`的同义词。

标准差可用于识别异常值——与平均值相距异常远的值。例如，要选择距离平均值超过一个标准差的值，请执行以下操作：

```
SELECT AVG(score), STDDEV_SAMP(score) INTO @mean, @std FROM testscore;
SELECT score FROM testscore WHERE ABS(score-@mean) > @std;
```

MySQL 没有内置函数来计算一组值的众数或中位数，但您可以自行计算它们。要确定众数（最常出现的值），请计算每个值的计数并查看哪个最常见：

```
mysql> `SELECT score, COUNT(score) AS frequency`
    -> `FROM testscore GROUP BY score ORDER BY frequency DESC;`
+-------+-----------+
| score | frequency |
+-------+-----------+
|     9 |         5 |
|     6 |         4 |
|     7 |         4 |
|     4 |         2 |
|     8 |         2 |
|    10 |         2 |
|     5 |         1 |
+-------+-----------+
```

在这种情况下，9 是模态分数值。

可以像这样计算一组有序值的中位数：^(1)

+   如果值的数量为奇数，则中位数是中间值。

+   如果值的数量为偶数，则中位数是两个中间值的平均值。

基于该定义，使用以下过程确定存储在数据库中的一组观察值的中位数：

1.  发出查询以计算观察次数。从计数中，您可以确定中位数计算是否需要一个或两个值，并且它们在有序观察值集合中的索引是什么。

1.  发出包含`ORDER BY`子句以对观察进行排序和包含`LIMIT`子句以提取中间值或值的查询。

1.  如果有单个中间值，则它是中位数。否则，取中间值的平均值。

假设表`t`包含一个带有 37 个值（奇数）的`score`列。要获取中位数，请使用类似以下语句的选择单个值：

```
SELECT score FROM t ORDER BY score LIMIT 18,1;
```

如果列包含 38 个值（偶数），则选择两个值：

```
SELECT score FROM t ORDER BY score LIMIT 18,2;
```

然后从语句返回的值中取值，并从它们的平均值计算中位数。

下面的 Perl 函数实现了中位数计算。它接受一个数据库句柄以及包含一组观察值的数据库、表和列的名称。然后它生成检索相关值并返回它们平均值的语句：

```
sub median
{
my ($dbh, $db_name, $tbl_name, $col_name) = @_;
my ($count, $limit);

  $db_name = $dbh->quote_identifier ($db_name);
  $tbl_name = $dbh->quote_identifier ($tbl_name);
  $col_name = $dbh->quote_identifier ($col_name);

  $count = $dbh->selectrow_array (qq{
 SELECT COUNT($col_name) FROM $db_name.$tbl_name
 });
  return undef unless $count > 0;
  if ($count % 2 == 1)  # odd number of values; select middle value
  {
    $limit = sprintf ("LIMIT %d,1", ($count-1)/2);
  }
  else                  # even number of values; select middle two values
  {
    $limit = sprintf ("LIMIT %d,2", $count/2 - 1);
  }

  my $sth = $dbh->prepare (qq{
 SELECT $col_name FROM $db_name.$tbl_name ORDER BY $col_name $limit
 });
  $sth->execute ();
  my ($n, $sum) = (0, 0);
  while (my $ref = $sth->fetchrow_arrayref ())
  {
    ++$n;
    $sum += $ref->[0];
  }
  return $sum / $n;
}
```

前面的技术适用于存储在数据库中的一组值。如果您已经将有序的一组值提取到数组`@val`中，可以像这样计算中位数：

```
if (@val == 0)          # array is empty, median is undefined
{
  $median = undef;
}
elsif (@val % 2 == 1)   # array size is odd, median is middle number
{
  $median = $val[(@val-1)/2];
}
else                    # array size is even; median is average
{                       # of two middle numbers
  $median = ($val[@val/2 - 1] + $val[@val/2]) / 2;
}
```

该代码适用于具有初始下标为 0 的数组；对于使用基于 1 的数组索引的语言，请相应调整算法。

# 17.2 为组计算描述性统计信息

## 问题

您想为一组观察值的每个子组生成描述性统计信息。

## 解决方案

使用聚合函数，但使用`GROUP BY`子句将观察值排列成适当的组。

## 讨论

配方 17.1 展示了如何为`testscore`表中的整组分数计算描述性统计数据。更具体地说，使用`GROUP` `BY`将观察结果分组，并为每组计算统计数据。例如，`testscore`表中的对象按年龄和性别列出，因此可以通过适当的`GROUP` `BY`子句按年龄或性别（或两者）计算类似的统计数据。

下面是按年龄计算的方法：

```
mysql> `SELECT age, COUNT(score) AS n,`
    -> `SUM(score) AS sum,`
    -> `MIN(score) AS minimum,`
    -> `MAX(score) AS maximum,`
    -> `AVG(score) AS mean,`
    -> `STDDEV_SAMP(score) AS 'std. dev.',`
    -> `VAR_SAMP(score) AS 'variance'`
    -> `FROM testscore`
    -> `GROUP BY age;`
+-----+---+------+---------+---------+--------+-----------+----------+
| age | n | sum  | minimum | maximum | mean   | std. dev. | variance |
+-----+---+------+---------+---------+--------+-----------+----------+
|   5 | 4 |   22 |       4 |       7 | 5.5000 |    1.2910 |   1.6667 |
|   6 | 4 |   27 |       4 |       9 | 6.7500 |    2.2174 |   4.9167 |
|   7 | 4 |   30 |       6 |       9 | 7.5000 |    1.2910 |   1.6667 |
|   8 | 4 |   32 |       6 |      10 | 8.0000 |    1.8257 |   3.3333 |
|   9 | 4 |   35 |       7 |      10 | 8.7500 |    1.2583 |   1.5833 |
+-----+---+------+---------+---------+--------+-----------+----------+
```

按性别：

```
mysql> `SELECT sex, COUNT(score) AS n,`
    -> `SUM(score) AS sum,`
    -> `MIN(score) AS minimum,`
    -> `MAX(score) AS maximum,`
    -> `AVG(score) AS mean,`
    -> `STDDEV_SAMP(score) AS 'std. dev.',`
    -> `VAR_SAMP(score) AS 'variance'`
    -> `FROM testscore`
    -> `GROUP BY sex;`
+-----+----+------+---------+---------+--------+-----------+----------+
| sex | n  | sum  | minimum | maximum | mean   | std. dev. | variance |
+-----+----+------+---------+---------+--------+-----------+----------+
| M   | 10 |   71 |       4 |       9 | 7.1000 |    1.7920 |   3.2111 |
| F   | 10 |   75 |       4 |      10 | 7.5000 |    1.9579 |   3.8333 |
+-----+----+------+---------+---------+--------+-----------+----------+
```

按年龄和性别：

```
mysql> `SELECT age, sex, COUNT(score) AS n,`
    -> `SUM(score) AS sum,`
    -> `MIN(score) AS minimum,`
    -> `MAX(score) AS maximum,`
    -> `AVG(score) AS mean,`
    -> `STDDEV_SAMP(score) AS 'std. dev.',`
    -> `VAR_SAMP(score) AS 'variance'`
    -> `FROM testscore`
    -> `GROUP BY age, sex;`
+-----+-----+---+------+---------+---------+--------+-----------+----------+
| age | sex | n | sum  | minimum | maximum | mean   | std. dev. | variance |
+-----+-----+---+------+---------+---------+--------+-----------+----------+
|   5 | M   | 2 |    9 |       4 |       5 | 4.5000 |    0.7071 |   0.5000 |
|   5 | F   | 2 |   13 |       6 |       7 | 6.5000 |    0.7071 |   0.5000 |
|   6 | M   | 2 |   17 |       8 |       9 | 8.5000 |    0.7071 |   0.5000 |
|   6 | F   | 2 |   10 |       4 |       6 | 5.0000 |    1.4142 |   2.0000 |
|   7 | M   | 2 |   14 |       6 |       8 | 7.0000 |    1.4142 |   2.0000 |
|   7 | F   | 2 |   16 |       7 |       9 | 8.0000 |    1.4142 |   2.0000 |
|   8 | M   | 2 |   15 |       6 |       9 | 7.5000 |    2.1213 |   4.5000 |
|   8 | F   | 2 |   17 |       7 |      10 | 8.5000 |    2.1213 |   4.5000 |
|   9 | M   | 2 |   16 |       7 |       9 | 8.0000 |    1.4142 |   2.0000 |
|   9 | F   | 2 |   19 |       9 |      10 | 9.5000 |    0.7071 |   0.5000 |
+-----+-----+---+------+---------+---------+--------+-----------+----------+
```

# 17.3 生成频率分布

## 问题

您想知道表中每个值的发生频率。

## 解决方案

汇总数据集内容的频率分布。

## 讨论

常见的按组汇总技术应用包括生成*频率分布*，显示每个值出现的频率。对于`testscore`表，频率分布如下：

```
mysql> `SELECT score, COUNT(score) AS counts`
    -> `FROM testscore GROUP BY score;`
+-------+--------+
| score | counts |
+-------+--------+
|     4 |      2 |
|     5 |      1 |
|     6 |      4 |
|     7 |      4 |
|     8 |      2 |
|     9 |      5 |
|    10 |      2 |
+-------+--------+
```

将结果表达为百分比而不是计数，得到相对频率分布。为了显示每个计数占总数的百分比，使用一个查询获取观测总数，另一个查询计算每组的百分比：

```
mysql> `SET @n = (SELECT COUNT(score) FROM testscore);`
mysql> `SELECT score, (COUNT(score)*100)/@n AS percent`
    -> `FROM testscore GROUP BY score;`
+-------+---------+
| score | percent |
+-------+---------+
|     4 | 10.0000 |
|     5 |  5.0000 |
|     6 | 20.0000 |
|     7 | 20.0000 |
|     8 | 10.0000 |
|     9 | 25.0000 |
|    10 | 10.0000 |
+-------+---------+
```

上述分布总结了个别分数值的数量。然而，如果数据集包含大量不同的值，并且您希望显示只有少量类别的分布，则可能希望将值合并到类别中，并为每个类别生成计数。配方 10.13 讨论了“合并”技术。

频率分布的一个典型用途是将结果导出到图形程序中使用。但 MySQL 本身可以生成一个简单的 ASCII 图表，作为分布的视觉表示。要显示测试分数计数的 ASCII 条形图，请将计数转换为`*`字符的字符串：

```
mysql> `SELECT score, REPEAT('*',COUNT(score)) AS 'count histogram'`
    -> `FROM testscore GROUP BY score;`
+-------+-----------------+
| score | count histogram |
+-------+-----------------+
|     4 | **              |
|     5 | *               |
|     6 | ****            |
|     7 | ****            |
|     8 | **              |
|     9 | *****           |
|    10 | **              |
+-------+-----------------+
```

要绘制相对频率分布而不是频数值，使用百分比值：

```
mysql> `SET @n = (SELECT COUNT(score) FROM testscore);`
mysql> `SELECT score,`
    -> `REPEAT('*',(COUNT(score)*100)/@n) AS 'percent histogram'`
    -> `FROM testscore GROUP BY score;`
+-------+---------------------------+
| score | percent histogram         |
+-------+---------------------------+
|     4 | **********                |
|     5 | *****                     |
|     6 | ********************      |
|     7 | ********************      |
|     8 | **********                |
|     9 | ************************* |
|    10 | **********                |
+-------+---------------------------+
```

显然，ASCII 图表方法很粗糙，但是它是获取观察分布图的快速方式，不需要其他工具。

如果为一系列类别生成频率分布，其中某些类别在您的观测中没有表示，则输出中不显示缺少的类别。要强制显示每个类别，请使用参考表和`LEFT` `JOIN`（在配方 16.8 中讨论的技术）。对于`testscore`表，可能的分数范围从 0 到 10，因此参考表应包含每一个这些值：

```
mysql> `CREATE TABLE ref (score INT);`
mysql> `INSERT INTO ref (score)`
    -> `VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);`
```

然后将参考表与测试分数连接，生成频率分布。此查询显示计数以及直方图：

```
mysql> `SELECT ref.score, COUNT(testscore.score) AS counts,`
    -> `REPEAT('*',COUNT(testscore.score)) AS 'count histogram'`
    -> `FROM ref LEFT JOIN testscore ON ref.score = testscore.score`
    -> `GROUP BY ref.score;`
+-------+--------+-----------+
| score | counts | histogram |
+-------+--------+-----------+
|     0 |      0 |           |
|     1 |      0 |           |
|     2 |      0 |           |
|     3 |      0 |           |
|     4 |      2 | **        |
|     5 |      1 | *         |
|     6 |      4 | ****      |
|     7 |      4 | ****      |
|     8 |      2 | **        |
|     9 |      5 | *****     |
|    10 |      2 | **        |
+-------+--------+-----------+
```

此分布包括分数 0 到 3 的行，而在前面显示的频率分布中没有出现。

相对频率分布也适用相同的原则：

```
mysql> `SET @n = (SELECT COUNT(score) FROM testscore);`
mysql> `SELECT ref.score, (COUNT(testscore.score)*100)/@n AS percent,`
    -> `REPEAT('*',(COUNT(testscore.score)*100)/@n) AS 'percent histogram'`
    -> `FROM ref LEFT JOIN testscore ON ref.score = testscore.score`
    -> `GROUP BY ref.score;`
+-------+---------+---------------------------+
| score | percent | percent histogram         |
+-------+---------+---------------------------+
|     0 |  0.0000 |                           |
|     1 |  0.0000 |                           |
|     2 |  0.0000 |                           |
|     3 |  0.0000 |                           |
|     4 | 10.0000 | **********                |
|     5 |  5.0000 | *****                     |
|     6 | 20.0000 | ********************      |
|     7 | 20.0000 | ********************      |
|     8 | 10.0000 | **********                |
|     9 | 25.0000 | ************************* |
|    10 | 10.0000 | **********                |
+-------+---------+---------------------------+
```

# 17.4 计数缺失值

## 问题

一组观察结果不完整。您想知道缺失多少个值。

## 解决方案

计算集合中的`NULL`值数量。

## 讨论

对于任何数量的原因，观察结果集中可能缺少值：可能尚未进行测试，测试过程中可能出现错误导致无效观察等。您可以在数据集中表示这样的观察结果，将它们表示为`NULL`值，表示它们缺失或无效，然后使用摘要语句来描述数据集的完整性。

如果表`testscore_withmisses`包含要在单个维度上汇总的值，则简单摘要足以描述缺失的值。假设`testscore_withmisses`如下所示：

```
mysql> `SELECT subject, score FROM testscore_withmisses ORDER BY subject;`
+---------+-------+
| subject | score |
+---------+-------+
|       1 |    38 |
|       2 |  NULL |
|       3 |    47 |
|       4 |  NULL |
|       5 |    37 |
|       6 |    45 |
|       7 |    54 |
|       8 |  NULL |
|       9 |    40 |
|      10 |    49 |
+---------+-------+
```

`COUNT(*)`计算总行数，而`COUNT(score)`计算非缺失分数的数量。两个值之间的差异是缺失分数的数量，并且与总数的关系提供了缺失分数的百分比。进行以下计算：

```
mysql> `SELECT COUNT(*) AS 'n (total)',`
    -> `COUNT(score) AS 'n (nonmissing)',`
    -> `COUNT(*) - COUNT(score) AS 'n (missing)',`
    -> `((COUNT(*) - COUNT(score)) * 100) / COUNT(*) AS '% missing'`
    -> `FROM testscore_withmisses;`
+-----------+----------------+-------------+-----------+
| n (total) | n (nonmissing) | n (missing) | % missing |
+-----------+----------------+-------------+-----------+
|        10 |              7 |           3 |   30.0000 |
+-----------+----------------+-------------+-----------+
```

作为计数`NULL`值的替代方法，直接使用`SUM(ISNULL(score))`来计数它们。`ISNULL()`函数在其参数为`NULL`时返回 1，否则返回零：

```
mysql> `SELECT COUNT(*) AS 'n (total)',`
    -> `COUNT(score) AS 'n (nonmissing)',`
    -> `SUM(ISNULL(score)) AS 'n (missing)',`
    -> `(SUM(ISNULL(score)) * 100) / COUNT(*) AS '% missing'`
    -> `FROM testscore_withmisses;`
+-----------+----------------+-------------+-----------+
| n (total) | n (nonmissing) | n (missing) | % missing |
+-----------+----------------+-------------+-----------+
|        10 |              7 |           3 |   30.0000 |
+-----------+----------------+-------------+-----------+
```

如果值按组排列，则可以按组评估`NULL`值的发生次数。假设`testscore_withmisses2`包含分数，分布在两个因素 A 和 B 的条件中的主题，每个因素有两个水平：

```
mysql> `SELECT subject, A, B, score FROM testscore_withmisses2 ORDER BY subject;`
+---------+------+------+-------+
| subject | A    | B    | score |
+---------+------+------+-------+
|       1 |    1 |    1 |    18 |
|       2 |    1 |    1 |  NULL |
|       3 |    1 |    1 |    23 |
|       4 |    1 |    1 |    24 |
|       5 |    1 |    2 |    17 |
|       6 |    1 |    2 |    23 |
|       7 |    1 |    2 |    29 |
|       8 |    1 |    2 |    32 |
|       9 |    2 |    1 |    17 |
|      10 |    2 |    1 |  NULL |
|      11 |    2 |    1 |  NULL |
|      12 |    2 |    1 |    25 |
|      13 |    2 |    2 |  NULL |
|      14 |    2 |    2 |    33 |
|      15 |    2 |    2 |    34 |
|      16 |    2 |    2 |    37 |
+---------+------+------+-------+
```

为每个条件组合生成摘要，使用`GROUP` `BY`子句：

```
mysql> `SELECT A, B, COUNT(*) AS 'n (total)',`
    -> `COUNT(score) AS 'n (nonmissing)',`
    -> `COUNT(*) - COUNT(score) AS 'n (missing)',`
    -> `((COUNT(*) - COUNT(score)) * 100) / COUNT(*) AS '% missing'`
    -> `FROM testscore_withmisses2`
    -> `GROUP BY A, B;`
+------+------+-----------+----------------+-------------+-----------+
| A    | B    | n (total) | n (nonmissing) | n (missing) | % missing |
+------+------+-----------+----------------+-------------+-----------+
|    1 |    1 |         4 |              3 |           1 |   25.0000 |
|    1 |    2 |         4 |              4 |           0 |    0.0000 |
|    2 |    1 |         4 |              2 |           2 |   50.0000 |
|    2 |    2 |         4 |              3 |           1 |   25.0000 |
+------+------+-----------+----------------+-------------+-----------+
```

# 计算线性回归或相关系数 17.5

## 问题

您要计算两个变量的最小二乘回归线或表达它们之间关系强度的相关系数。

## 解决方案

应用摘要函数进行这些计算。

## 讨论

当存储两个变量 X 和 Y 的数据值在数据库中时，可以使用聚合函数轻松计算它们的最小二乘回归。相关系数也是如此。这两个计算实际上非常相似，并且执行这两个过程的许多术语是共通的。

假设您要使用`testscore`表中观察到的年龄和测试分数值计算最小二乘回归：

```
mysql> `SELECT age, score FROM testscore;`
+-----+-------+
| age | score |
+-----+-------+
|   5 |     5 |
|   5 |     4 |
|   5 |     6 |
|   5 |     7 |
|   6 |     8 |
|   6 |     9 |
|   6 |     4 |
|   6 |     6 |
|   7 |     8 |
|   7 |     6 |
|   7 |     9 |
|   7 |     7 |
|   8 |     9 |
|   8 |     6 |
|   8 |     7 |
|   8 |    10 |
|   9 |     9 |
|   9 |     7 |
|   9 |    10 |
|   9 |     9 |
+-----+-------+
```

以下方程表示回归线，其中`a`和`b`是线条的截距和斜率：

```
*`Y`* = *`bX`* + *`a`*
```

让`age`为*`X`*，`score`为*`Y`*，首先计算回归方程所需的项。这些项包括观测数量；每个变量的均值、总和和平方和；以及每个变量乘积的总和：^(2)

```
mysql> `SELECT COUNT(score), AVG(age), SUM(age), SUM(age*age),` 
    -> `AVG(score), SUM(score), SUM(score*score), SUM(age*score)`
    -> `INTO @n, @meanX, @sumX, @sumXX, @meanY, @sumY, @sumYY, @sumXY`
    -> `FROM testscore;`
Query OK, 1 row affected (0,00 sec)

mysql> `SELECT`
    -> `@n AS N,`
    -> `@meanX AS 'X mean',`
    -> `@sumX AS 'X sum',`
    -> `@sumXX AS 'X sum of squares',`
    -> `@meanY AS 'Y mean',`
    -> `@sumY AS 'Y sum',`
    -> `@sumYY AS 'Y sum of squares',`
    -> `@sumXY AS 'X*Y sum'`
    -> `FROM testscore\G`
*************************** 1\. row ***************************
               N: 20
          X mean: 7.000000000
           X sum: 140
X sum of squares: 1020
          Y mean: 7.300000000
           Y sum: 146
Y sum of squares: 1130
         X*Y sum: 1053
```

从这些术语中，按以下方式计算回归斜率和截距：

```
mysql> `SET @b := (@n*@sumXY - @sumX*@sumY) / (@n*@sumXX - @sumX*@sumX);`
mysql> `SET @a := (@meanY - @b*@meanX);`
mysql> `SELECT @b AS slope, @a AS intercept;`
+-------------+----------------------+
| slope       | intercept            |
+-------------+----------------------+
| 0.775000000 | 1.875000000000000000 |
+-------------+----------------------+
```

则回归方程为：

```
mysql> `SELECT CONCAT('Y = ',@b,'X + ',@a) AS 'least-squares regression';`
+-----------------------------------------+
| least-squares regression                |
+-----------------------------------------+
| Y = 0.775000000X + 1.875000000000000000 |
+-----------------------------------------+
```

要计算相关系数，请使用许多相同的术语：

```
mysql> `SELECT`
    -> `(@n*@sumXY - @sumX*@sumY)`
    -> `/ SQRT((@n*@sumXX - @sumX*@sumX) * (@n*@sumYY - @sumY*@sumY))`
    -> `AS correlation;`
+--------------------+
| correlation        |
+--------------------+
| 0.6117362044219903 |
+--------------------+
```

# 17.6 生成随机数

## 问题

您需要一组随机数来源。

## 解决方案

使用`RAND()`函数。

## 讨论

MySQL 有一个`RAND()`函数，可以生成 0 到 1 之间的随机数：

```
mysql> `SELECT RAND(), RAND(), RAND();`
+---------------------+--------------------+---------------------+
| RAND()              | RAND()             | RAND()              |
+---------------------+--------------------+---------------------+
| 0.37415416573561183 | 0.9068914557871329 | 0.41199481246247405 |
+---------------------+--------------------+---------------------+
```

当使用整数参数调用`RAND()`时，会用该值来种子化随机数生成器。您可以利用这一特性为查询结果的列生成可重复的数字系列。以下示例显示，没有参数的`RAND()`在每次查询时产生不同的列值，而`RAND(`*`N`*`)`则生成一个可重复的列：

```
mysql> `SELECT i, RAND(), RAND(10), RAND(20) FROM numbers;`
+------+---------------------+---------------------+---------------------+
| i    | RAND()              | RAND(10)            | RAND(20)            |
+------+---------------------+---------------------+---------------------+
|    1 | 0.00708185882035816 |  0.6570515219653505 | 0.15888261251047497 |
|    2 |  0.5417692908474889 | 0.12820613023657923 |  0.6355305003333189 |
|    3 |  0.6876009085100152 |  0.6698761160204896 |  0.7010046948688149 |
|    4 |  0.8126967007412544 |  0.9647622201263553 |  0.5984320040777623 |
+------+---------------------+---------------------+---------------------+
mysql> `SELECT i, RAND(), RAND(10), RAND(20) FROM numbers;`
+------+----------------------+---------------------+---------------------+
| i    | RAND()               | RAND(10)            | RAND(20)            |
+------+----------------------+---------------------+---------------------+
|    1 | 0.059957268703689115 |  0.6570515219653505 | 0.15888261251047497 |
|    2 |   0.9068000166740269 | 0.12820613023657923 |  0.6355305003333189 |
|    3 |  0.35412830799271194 |  0.6698761160204896 |  0.7010046948688149 |
|    4 | 0.050241520675124156 |  0.9647622201263553 |  0.5984320040777623 |
+------+----------------------+---------------------+---------------------+
```

为了以随机方式种子化`RAND()`，请选择基于熵源的种子值。可能的来源包括当前时间戳或连接标识符，可以单独使用，也可以组合使用：

```
RAND(UNIX_TIMESTAMP())
RAND(CONNECTION_ID())
RAND(UNIX_TIMESTAMP()+CONNECTION_ID())
```

但是，如果有其他种子值来源，则最好使用它们。例如，如果您的系统有*/dev/random*或*/dev/urandom*设备，请读取该设备并使用它生成种子值以种子化`RAND()`。

# 17.7 随机化一组行

## 问题

您希望随机化一组行或值。

## 解决方案

使用`ORDER` `BY` `RAND()`。

## 讨论

MySQL 的`RAND()`函数可用于随机化查询返回行的顺序。有些讽刺的是，通过在查询中添加`ORDER` `BY`子句来实现此随机化。该技术与电子表格随机化方法大致相当。假设电子表格包含以下一组值：

```
Patrick
Penelope
Pertinax
Polly
```

要将这些值随机排序，首先添加另一列，其中包含随机选择的数字：

```
Patrick            .73
Penelope           .37
Pertinax           .16
Polly              .48
```

然后根据随机数的值对行进行排序：

```
Pertinax           .16
Penelope           .37
Polly              .48
Patrick            .73
```

此时，原始值已随机排序；根据随机数排序行的效果是使与之相关联的值随机化。为重新随机化这些值，选择另一组随机数，并再次对行进行排序。

在 MySQL 中，通过将一组随机数与查询结果关联并按这些数字排序来实现类似效果。为此，请添加一个`ORDER` `BY` `RAND()`子句：

```
mysql> `SELECT name FROM rand_names ORDER BY RAND();`
+----------+
| name     |
+----------+
| Pertinax |
| Patrick  |
| Polly    |
| Penelope |
+----------+
mysql> `SELECT name FROM rand_names ORDER BY RAND();`
+----------+
| name     |
+----------+
| Polly    |
| Pertinax |
| Penelope |
| Patrick  |
+----------+
```

随机化一组行的应用包括任何使用无替换选择（从一组项目中选择每个项目直到没有项目为止）的情况。其中一些例子包括：

+   确定事件参与者的起始顺序。在表中列出参与者，然后随机选择他们的顺序。

+   在比赛中为参与者分配起始车道或门。在表中列出车道，然后随机选择一个车道顺序。

+   选择展示一组测验问题的顺序。

+   洗牌一副牌。在表中以每张牌一行的方式表示每张牌，并通过以随机顺序选择行来洗牌整副牌。逐张发牌直到牌组耗尽。

要使用最后一个示例作为说明，让我们实现一个卡牌洗牌算法。洗牌和发牌是随机化加上无重复选择：每张卡牌在再次发牌之前只发出一次；当牌堆用完时，重新洗牌以重新随机化其发牌顺序。在程序内，可以使用名为 `deck` 的 MySQL 表来执行此任务，该表具有 52 行，假设每张卡牌有 13 个面值和 4 种花色的组合：

1.  选择整个表，并将其存储到数组中。

1.  每次需要一张卡时，从数组中取下一个元素。

1.  当数组耗尽时，所有卡牌已发放。重新洗牌表以生成新的卡牌顺序。

如果您通过手动编写所有 `INSERT` 语句插入 52 张卡片记录来设置 `deck` 表格，这将是一项乏味的任务。在程序中，可以更轻松地以组合方式生成 `deck` 内容，生成每个面值和花色的配对。以下是一些 PHP 代码，创建了一个带有 `face` 和 `suit` 列的 `deck` 表，并使用嵌套循环为 `INSERT` 语句生成配对：

```
$sth = $dbh->exec ("DROP TABLE IF EXISTS deck");

$sth = $dbh->exec ("
 CREATE TABLE deck
 (
 face  ENUM('A', 'K', 'Q', 'J', '10', '9', '8',
 '7', '6', '5', '4', '3', '2') NOT NULL,
 suit  ENUM('hearts', 'diamonds', 'clubs', 'spades') NOT NULL
 )
");

$face_array = array ("A", "K", "Q", "J", "10", "9", "8",
                     "7", "6", "5", "4", "3", "2");
$suit_array = array ("hearts", "diamonds", "clubs", "spades");

# insert a "card" into the deck for each combination of suit and face

$sth = $dbh->prepare ("INSERT INTO deck (face,suit) VALUES(?,?)");
foreach ($face_array as $face)
  foreach ($suit_array as $suit)
    $sth->execute (array ($face, $suit));
```

洗牌牌堆只需发出以下语句即可：

```
SELECT face, suit FROM deck ORDER BY RAND();
```

要执行此操作并将结果存储在脚本内的数组中，请编写一个 `shuffle_deck()` 函数，该函数发出查询并将返回的值存储在数组中（再次以 PHP 显示）：

```
function shuffle_deck ($dbh)
{
  $sth = $dbh->query ("SELECT face, suit FROM deck ORDER BY RAND()");
  $sth->setFetchMode (PDO::FETCH_OBJ);
  return ($sth->fetchAll ());
}
```

使用一个计数器，其范围从 0 到 51，来表示选择哪张卡牌。当计数器达到 52 时，牌堆耗尽，应重新洗牌。

###### 警告

仅适用于行数较少的表格。按 `RAND()` 排序不允许 MySQL 使用索引解析 `ORDER BY`，因此在大表上执行此类查询将会很慢。

# 17.8 从一组行中选择随机项目

## 问题

您想从一组值中随机选择一个或多个项目。

## 解决方案

随机化值，然后选择第一个（或更多，如果需要多个）。

## 讨论

如果一组项目存储在 MySQL 中，请按以下方式随机选择其中一个：

1.  按照 配方 17.7 中描述的 `ORDER BY RAND()` 的随机顺序选择集合中的项目。

1.  在查询中添加 `LIMIT 1` 来选择第一个项目。

例如，要执行掷骰子的简单模拟，请创建一个包含值从 1 到 6 的行的 `die` 表，对应骰子的六个面：

```
CREATE TABLE die (n INT\);
```

然后随机选择表中的行：

```
mysql> `SELECT n FROM die ORDER BY RAND() LIMIT 1;`
+------+
| n    |
+------+
|    6 |
+------+
mysql> `SELECT n FROM die ORDER BY RAND() LIMIT 1;`
+------+
| n    |
+------+
|    4 |
+------+
mysql> `SELECT n FROM die ORDER BY RAND() LIMIT 1;`
+------+
| n    |
+------+
|    5 |
+------+
mysql> `SELECT n FROM die ORDER BY RAND() LIMIT 1;`
+------+
| n    |
+------+
|    4 |
+------+
```

当您重复此操作时，您将从集合中选择随机序列的项目。这是一种带替换的选择形式：从项目池中选择一个项目，然后将其返回到池中进行下一次选择。因为项目被替换，所以在连续选择时可能多次选择相同的项目。其他带替换的选择示例包括：

+   在网页上选择要显示的横幅广告

+   为每日引用应用选择一行

+   <q>挑一张牌，随便挑</q> 每次以一副完整的牌开始的魔术技巧

要选择多个项目，请更改 `LIMIT` 参数。例如，要从包含比赛参赛作品的名为 `drawing` 的表中随机抽取五个获奖条目，请使用 `RAND()` 结合 `LIMIT`：

```
SELECT * FROM drawing ORDER BY RAND() LIMIT 5;
```

当您从包含在某一列中包含从 1 到`n`的值的表中选择单个行时，会出现特殊情况。在这些情况下，可以避免对整个表进行 `ORDER` `BY` 操作。选择该范围内的一个随机数并选择匹配的行：

```
SET @id = FLOOR(RAND()**`n`*)+1;
SELECT ... FROM *`tbl_name`* WHERE id = @id;
```

这比随机选择一个表的 `ORDER` `BY` `RAND()` `LIMIT` `1` 更快，特别是在表的大小增加时。

# 17.9 计算连续行差值

## 问题

表格中的行包含连续的累积值，并且您希望计算连续行之间的差值。

## 解决方案

使用自连接匹配相邻行对并计算每对成员之间的差值。

## 讨论

当您有一组绝对（或累积）值，并希望将其转换为表示连续行对之间差值的相对值时，自连接非常有用。例如，如果您进行一次汽车旅行并在每个停靠点记录总行驶英里数，则可以计算连续点之间的差值以确定从一个停靠点到下一个停靠点的距离。以下是这样一张表格，显示了从得克萨斯州圣安东尼奥到威斯康星州麦迪逊的旅行停靠点。每一行显示了每次停靠时的总英里数：

```
mysql> `SELECT seq, city, miles FROM trip_log ORDER BY seq;`
+-----+------------------+-------+
| seq | city             | miles |
+-----+------------------+-------+
|   1 | San Antonio, TX  |     0 |
|   2 | Dallas, TX       |   263 |
|   3 | Benton, AR       |   566 |
|   4 | Memphis, TN      |   745 |
|   5 | Portageville, MO |   878 |
|   6 | Champaign, IL    |  1164 |
|   7 | Madison, WI      |  1412 |
+-----+------------------+-------+
```

自连接可以将这些累积值转换为连续的差值，这些差值表示从每个城市到下一个城市的距离。以下语句显示了如何使用行中的序列号来匹配连续行对并计算每对里程值之间的差值：

```
mysql> `SELECT t1.seq AS seq1, t2.seq AS seq2,`
    -> `t1.city AS city1, t2.city AS city2,`
    -> `t1.miles AS miles1, t2.miles AS miles2,`
    -> `t2.miles-t1.miles AS dist`
    -> `FROM trip_log AS t1 INNER JOIN trip_log AS t2`
    -> `ON t1.seq+1 = t2.seq`
    -> `ORDER BY t1.seq;`
+------+------+------------------+------------------+--------+--------+------+
| seq1 | seq2 | city1            | city2            | miles1 | miles2 | dist |
+------+------+------------------+------------------+--------+--------+------+
|    1 |    2 | San Antonio, TX  | Dallas, TX       |      0 |    263 |  263 |
|    2 |    3 | Dallas, TX       | Benton, AR       |    263 |    566 |  303 |
|    3 |    4 | Benton, AR       | Memphis, TN      |    566 |    745 |  179 |
|    4 |    5 | Memphis, TN      | Portageville, MO |    745 |    878 |  133 |
|    5 |    6 | Portageville, MO | Champaign, IL    |    878 |   1164 |  286 |
|    6 |    7 | Champaign, IL    | Madison, WI      |   1164 |   1412 |  248 |
+------+------+------------------+------------------+--------+--------+------+
```

`trip_log` 表中的 `seq` 列的存在对于计算连续差值值非常重要。它用于确定哪一行是另一行的前置行，并将每一行 `n` 与行 `n` `+1` 进行匹配。这意味着，要使用包含绝对或累积值的表格执行相对差值计算，必须包括一个没有间隙的序列列。如果表中包含序列列但存在间隙，请重新编号它（参见 Recipe 15.5）。如果表中不包含这样的列，请添加一个（参见 Recipe 15.9）。

当您为多个列计算连续差值并在计算中使用结果时，情况会变得更加复杂。以下表 `player_stats` 显示了一个棒球选手在赛季的每个月末的累积数字。`ab` 表示总打数，`h` 表示截至某一日期球员的总安打数。（第一行显示球员赛季的起始点，因此 `ab` 和 `h` 值为零。）

```
mysql> `SELECT id, date, ab, h, TRUNCATE(IFNULL(h/ab,0),3) AS ba`
    -> `FROM player_stats ORDER BY id;`
+----+------------+-----+----+-------+
| id | date       | ab  | h  | ba    |
+----+------------+-----+----+-------+
|  1 | 2013-04-30 |   0 |  0 | 0.000 |
|  2 | 2013-05-31 |  38 | 13 | 0.342 |
|  3 | 2013-06-30 | 109 | 31 | 0.284 |
|  4 | 2013-07-31 | 196 | 49 | 0.250 |
|  5 | 2013-08-31 | 304 | 98 | 0.322 |
+----+------------+-----+----+-------+
```

查询结果的最后一列还显示了每个日期的球员击球平均数。这一列未存储在表中，但可以轻松计算为击中数与上场数的比率。结果提供了球员赛季内击球表现变化的总体印象，但并未展示球员在每个单独月份的表现。要确定这一点，计算成对行之间的相对差异。通过将行*n*与行*n*`+1`自连接，可以轻松完成这些差异的计算，以计算每月的击球平均数：

```
mysql> `SELECT`
    -> `t1.id AS id1, t2.id AS id2,`
    -> `t2.date,`
    -> `t1.ab AS ab1, t2.ab AS ab2,`
    -> `t1.h AS h1, t2.h AS h2,`
    -> `t2.ab-t1.ab AS abdiff,`
    -> `t2.h-t1.h AS hdiff,`
    -> `TRUNCATE(IFNULL((t2.h-t1.h)/(t2.ab-t1.ab),0),3) AS ba`
    -> `FROM player_stats AS t1 INNER JOIN player_stats AS t2`
    -> `ON t1.id+1 = t2.id`
    -> `ORDER BY t1.id;`
+-----+-----+------------+-----+-----+----+----+--------+-------+-------+
| id1 | id2 | date       | ab1 | ab2 | h1 | h2 | abdiff | hdiff | ba    |
+-----+-----+------------+-----+-----+----+----+--------+-------+-------+
|   1 |   2 | 2013-05-31 |   0 |  38 |  0 | 13 |     38 |    13 | 0.342 |
|   2 |   3 | 2013-06-30 |  38 | 109 | 13 | 31 |     71 |    18 | 0.253 |
|   3 |   4 | 2013-07-31 | 109 | 196 | 31 | 49 |     87 |    18 | 0.206 |
|   4 |   5 | 2013-08-31 | 196 | 304 | 49 | 98 |    108 |    49 | 0.453 |
+-----+-----+------------+-----+-----+----+----+--------+-------+-------+
```

这些结果比原始表格清楚地显示了球员赛季初表现不错，但在中段有所下滑，尤其是在七月份。它们还显示了球员在八月份表现多么出色。

# 17.10 查找累积和与移动平均

## 问题

您有一组随时间测量的观测值，想要计算每个测量点的累积和。或者您想要计算每个点的移动平均。

## 解决方案

使用自连接在每个测量点生成连续观测值集，然后应用聚合函数计算其总和或平均值。

## 讨论

配方 17.9 展示了如何通过自连接从绝对值计算相对值。自连接也可以相反地产生一系列观测值的累积值。以下表格显示了一系列连续几天内的降水测量值。每行的值显示了观测日期和英寸单位的降水量：

```
mysql> `SELECT date, precip FROM rainfall ORDER BY date;`
+------------+--------+
| date       | precip |
+------------+--------+
| 2014-06-01 |   1.50 |
| 2014-06-02 |   0.00 |
| 2014-06-03 |   0.50 |
| 2014-06-04 |   0.00 |
| 2014-06-05 |   1.00 |
+------------+--------+
```

要计算特定日期的累积降水量，将该日的降水量值加到所有先前日期的值中。例如，像这样确定截至`2014-06-03`的累积降水量：

```
mysql> `SELECT SUM(precip) FROM rainfall WHERE date <= '2014-06-03';`
+-------------+
| SUM(precip) |
+-------------+
|        2.00 |
+-------------+
```

要获取表中表示的所有日期的累积数据，单独为每一天计算数值是很繁琐的。通过一个自连接语句可以在一次操作中完成所有日期的计算。使用`rainfall`表的一个实例作为参照，并确定每行中的日期在另一个表的所有行中到该日期的`precip`值的总和。以下语句显示了每天的日常和累积降水量：

```
mysql> `SELECT t1.date, t1.precip AS 'daily precip',`
    -> `SUM(t2.precip) AS 'cum. precip'`
    -> `FROM rainfall AS t1 INNER JOIN rainfall AS t2`
    -> `ON t1.date >= t2.date`
    -> `GROUP BY t1.date;`
+------------+--------------+-------------+
| date       | daily precip | cum. precip |
+------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |
| 2014-06-02 |         0.00 |        1.50 |
| 2014-06-03 |         0.50 |        2.00 |
| 2014-06-04 |         0.00 |        2.00 |
| 2014-06-05 |         1.00 |        3.00 |
+------------+--------------+-------------+
```

自连接可以扩展到显示每个日期的经过的天数，以及每天降水量的移动平均值：

```
mysql> `SELECT t1.date, t1.precip AS 'daily precip',`
    -> `SUM(t2.precip) AS 'cum. precip',`
    -> `COUNT(t2.precip) AS 'days elapsed',`
    -> `AVG(t2.precip) AS 'avg. precip'`
    -> `FROM rainfall AS t1 INNER JOIN rainfall AS t2`
    -> `ON t1.date >= t2.date`
    -> `GROUP BY t1.date;`
+------------+--------------+-------------+--------------+-------------+
| date       | daily precip | cum. precip | days elapsed | avg. precip |
+------------+--------------+-------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |            1 |    1.500000 |
| 2014-06-02 |         0.00 |        1.50 |            2 |    0.750000 |
| 2014-06-03 |         0.50 |        2.00 |            3 |    0.666667 |
| 2014-06-04 |         0.00 |        2.00 |            4 |    0.500000 |
| 2014-06-05 |         1.00 |        3.00 |            5 |    0.600000 |
+------------+--------------+-------------+--------------+-------------+
```

在前面的语句中，可以通过`COUNT()`和`AVG()`轻松计算经过的天数和降水的移动平均值，因为表中没有缺失的天数。如果允许缺失的天数，则计算会变得更加复杂，因为每次计算的天数不再与行数相同。您可以通过删除没有降水的天的行来看到这一点，以生成表中的<q>空洞</q>：

```
mysql> `DELETE FROM rainfall WHERE precip = 0;`
mysql> `SELECT date, precip FROM rainfall ORDER BY date;`
+------------+--------+
| date       | precip |
+------------+--------+
| 2014-06-01 |   1.50 |
| 2014-06-03 |   0.50 |
| 2014-06-05 |   1.00 |
+------------+--------+
```

删除这些行不会改变保留日期的累积总和或移动平均值，但必须改变它们的计算方法。如果再次执行自连接，则会导致天数和平均降水列的结果不正确：

```
mysql> `SELECT t1.date, t1.precip AS 'daily precip',`
    -> `SUM(t2.precip) AS 'cum. precip',`
    -> `COUNT(t2.precip) AS 'days elapsed',`
    -> `AVG(t2.precip) AS 'avg. precip'`
    -> `FROM rainfall AS t1 INNER JOIN rainfall AS t2`
    -> `ON t1.date >= t2.date`
    -> `GROUP BY t1.date;`
+------------+--------------+-------------+--------------+-------------+
| date       | daily precip | cum. precip | days elapsed | avg. precip |
+------------+--------------+-------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |            1 |    1.500000 |
| 2014-06-03 |         0.50 |        2.00 |            2 |    1.000000 |
| 2014-06-05 |         1.00 |        3.00 |            3 |    1.000000 |
+------------+--------------+-------------+--------------+-------------+
```

要修复这个问题，用另一种方法确定经过的天数。获取每个求和中涉及的最小和最大日期，并从中计算天数：

```
DATEDIFF(MAX(t2.date),MIN(t2.date)) + 1
```

那个数值必须用于天数列和计算移动平均值。生成的语句如下：

```
mysql> `SELECT t1.date, t1.precip AS 'daily precip',`
    -> `SUM(t2.precip) AS 'cum. precip',`
    -> `DATEDIFF(MAX(t2.date),MIN(t2.date)) + 1 AS 'days elapsed',`
    -> `SUM(t2.precip) / (DATEDIFF(MAX(t2.date),MIN(t2.date)) + 1)`
    -> `AS 'avg. precip'`
    -> `FROM rainfall AS t1 INNER JOIN rainfall AS t2`
    -> `ON t1.date >= t2.date`
    -> `GROUP BY t1.date;`
+------------+--------------+-------------+--------------+-------------+
| date       | daily precip | cum. precip | days elapsed | avg. precip |
+------------+--------------+-------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |            1 |    1.500000 |
| 2014-06-03 |         0.50 |        2.00 |            3 |    0.666667 |
| 2014-06-05 |         1.00 |        3.00 |            5 |    0.600000 |
+------------+--------------+-------------+--------------+-------------+
```

正如这个例子所示，从相对值计算累积值只需要一个能够将行放置到正确顺序中的列（对于`rainfall`表来说，这是`date`列）。列中的值不必是连续的，甚至不必是数值。这与产生累积值的差异值的计算不同（参见 Recipe 17.9），后者需要一个包含不间断序列的表。

雨量示例中的移动平均值基于将累积降水总和除以截至每天的天数。当表中没有间隔时，天数与求和的值数相同，因此可以轻松找到连续的平均值。当行缺失时，计算变得更加复杂。这表明有必要考虑数据的性质并适当计算平均值。下一个示例在概念上与前面的示例类似，它计算累积总和和移动平均值，但以另一种方式执行计算。

下表显示了马拉松选手在 26 公里赛程的每个阶段的表现。每行中的值显示了每个阶段的长度（以公里为单位）以及选手完成该阶段所需的时间。换句话说，这些值涉及马拉松内的间隔，因此相对于整体而言是相对的：

```
mysql> `SELECT stage, km, t FROM marathon ORDER BY stage;`
+-------+----+----------+
| stage | km | t        |
+-------+----+----------+
|     1 |  5 | 00:15:00 |
|     2 |  7 | 00:19:30 |
|     3 |  9 | 00:29:20 |
|     4 |  5 | 00:17:50 |
+-------+----+----------+
```

要计算每个阶段的累积距离（以公里为单位），可以使用类似于这样的自连接：

```
mysql> `SELECT t1.stage, t1.km, SUM(t2.km) AS 'cum. km'`
    -> `FROM marathon AS t1 INNER JOIN marathon AS t2`
    -> `ON t1.stage >= t2.stage`
    -> `GROUP BY t1.stage;`
+-------+----+---------+
| stage | km | cum. km |
+-------+----+---------+
|     1 |  5 |       5 |
|     2 |  7 |      12 |
|     3 |  9 |      21 |
|     4 |  5 |      26 |
+-------+----+---------+
```

累积距离易于计算，因为它们可以直接求和。累积时间值的计算更为复杂：将时间转换为秒，对结果值进行总和，并将总和转换回时间值。要计算每个阶段结束时选手的平均速度，取累积距离除以累积时间的比率。将所有这些内容组合在一起得到以下语句：

```
mysql> `SELECT t1.stage, t1.km, t1.t,`
    -> `SUM(t2.km) AS 'cum. km',`
    -> `SEC_TO_TIME(SUM(TIME_TO_SEC(t2.t))) AS 'cum. t',`
    -> `SUM(t2.km)/(SUM(TIME_TO_SEC(t2.t))/(60*60)) AS 'avg. km/hour'`
    -> `FROM marathon AS t1 INNER JOIN marathon AS t2`
    -> `ON t1.stage >= t2.stage`
    -> `GROUP BY t1.stage;`
+-------+----+----------+---------+----------+--------------+
| stage | km | t        | cum. km | cum. t   | avg. km/hour |
+-------+----+----------+---------+----------+--------------+
|     1 |  5 | 00:15:00 |       5 | 00:15:00 |      20.0000 |
|     2 |  7 | 00:19:30 |      12 | 00:34:30 |      20.8696 |
|     3 |  9 | 00:29:20 |      21 | 01:03:50 |      19.7389 |
|     4 |  5 | 00:17:50 |      26 | 01:21:40 |      19.1020 |
+-------+----+----------+---------+----------+--------------+
```

从这可以看出，运动员在比赛第二阶段的平均速度略有增加，但之后又下降，这可能是疲劳导致的结果。

# 17.11 分配排名

## 问题

您希望对一组值分配排名。

## 解决方案

决定排名方法，然后按所需顺序排列值并应用该方法。

## 讨论

一些统计测试需要对数值进行排名。本节描述了三种排名方法，并展示了如何使用窗口函数实现每种方法。示例假设表`ranks`包含以下要按降序排名的分数：

```
mysql> `SELECT score FROM ranks ORDER BY score DESC;`
+-------+
| score |
+-------+
|     5 |
|     4 |
|     4 |
|     3 |
|     2 |
|     2 |
|     2 |
|     1 |
+-------+
```

一种排名方法简单地将每个值分配到其值有序集合内的行号。要生成这样的排名，请使用窗口函数`ROW_NUMBER()`：

```
mysql> `SELECT ROW_NUMBER() OVER win AS 'rank',` 
    -> `score FROM ranks WINDOW win AS (ORDER BY score DESC);`
+------+-------+
| rank | score |
+------+-------+
|    1 |     5 |
|    2 |     4 |
|    3 |     4 |
|    4 |     3 |
|    5 |     2 |
|    6 |     2 |
|    7 |     2 |
|    8 |     1 |
+------+-------+
8 rows in set (0,00 sec)
```

这种排名方法不考虑可能出现的并列情况（数值相同的情况）。窗口函数`DENSE_RANK()`通过仅在数值变化时提升排名来解决这一问题：

```
mysql> `SELECT DENSE_RANK() OVER win AS 'rank',` 
    > `score FROM ranks WINDOW win AS (ORDER BY score DESC);`
+------+-------+
| rank | score |
+------+-------+
|    1 |     5 |
|    2 |     4 |
|    2 |     4 |
|    3 |     3 |
|    4 |     2 |
|    4 |     2 |
|    4 |     2 |
|    5 |     1 |
+------+-------+
```

窗口函数`RANK()`有点像其他两种方法的组合。它按行号对值进行排名，但在出现并列情况时，每个并列的值都获得与第一个值行号相同的排名。

```
mysql> `SELECT ROW_NUMBER() OVER win AS 'row',` 
    -> `RANK() OVER win AS 'rank',` 
    -> `score FROM ranks WINDOW win AS (ORDER BY score DESC);`
+------+------+-------+
| row  | rank | score |
+------+------+-------+
|    1 |    1 |     5 |
|    2 |    2 |     4 |
|    3 |    2 |     4 |
|    4 |    4 |     3 |
|    5 |    5 |     2 |
|    6 |    5 |     2 |
|    7 |    5 |     2 |
|    8 |    8 |     1 |
+------+------+-------+
```

在程序中分配排名也很容易。例如，以下 Ruby 片段使用第三种排名方法对`ranks`中的分数进行排名：

```
res = client.query("SELECT score FROM ranks ORDER BY score DESC")
  rownum = 0
  rank = 0
  prev_score = nil
  puts "Row\tRank\tScore\n"
  res.each do |row|
    score = row.values[0]
    rownum += 1
    rank = rownum if rownum == 1 || prev_score != score
    prev_score = score
    puts "#{rownum}\t#{rank}\t#{score}"
  end
```

第三种排名方法通常用于体育赛事。以下表格包含了 2001 棒球赛季中赢得 15 场或更多比赛的美国联盟投手：

```
mysql> `SELECT name, wins FROM al_winner ORDER BY wins DESC, name;`
+----------------+------+
| name           | wins |
+----------------+------+
| Mulder, Mark   |   21 |
| Clemens, Roger |   20 |
| Moyer, Jamie   |   20 |
| Garcia, Freddy |   18 |
| Hudson, Tim    |   18 |
| Abbott, Paul   |   17 |
| Mays, Joe      |   17 |
| Mussina, Mike  |   17 |
| Sabathia, C.C. |   17 |
| Zito, Barry    |   17 |
| Buehrle, Mark  |   16 |
| Milton, Eric   |   15 |
| Pettitte, Andy |   15 |
| Radke, Brad    |   15 |
| Sele, Aaron    |   15 |
+----------------+------+
```

可以按第三种方法对这些投手进行排名如下：

```
mysql> `SELECT ROW_NUMBER() OVER win AS 'row',` 
    -> `RANK() OVER win AS 'rank',` 
    -> `name, wins` 
    -> `FROM al_winner WINDOW win AS (ORDER BY wins DESC);`
+------+------+----------------+------+
| row  | rank | name           | wins |
+------+------+----------------+------+
|    1 |    1 | Mulder, Mark   |   21 |
|    2 |    2 | Clemens, Roger |   20 |
|    3 |    2 | Moyer, Jamie   |   20 |
|    4 |    4 | Garcia, Freddy |   18 |
|    5 |    4 | Hudson, Tim    |   18 |
|    6 |    6 | Zito, Barry    |   17 |
|    7 |    6 | Sabathia, C.C. |   17 |
|    8 |    6 | Mussina, Mike  |   17 |
|    9 |    6 | Mays, Joe      |   17 |
|   10 |    6 | Abbott, Paul   |   17 |
|   11 |   11 | Buehrle, Mark  |   16 |
|   12 |   12 | Milton, Eric   |   15 |
|   13 |   12 | Pettitte, Andy |   15 |
|   14 |   12 | Radke, Brad    |   15 |
|   15 |   12 | Sele, Aaron    |   15 |
+------+------+----------------+------+
```

## 参见

关于窗口函数的更多信息，请参见 Recipe 15.15。

# 17.12 计算球队排名

## 问题

您希望根据胜负记录计算球队的排名，包括落后的比赛（GB）值。

## 解决方案

确定哪个队伍处于第一名，然后将该结果连接到原始行中。

## 讨论

竞争对手之间的排名问题，但排名不基于单一度量，如 Recipe 17.11 中所述。排名基于两个值，即胜利和失败。球队根据谁有最佳的胜负记录进行排名，不在第一名的球队被分配一个“落后比赛”的值，指示他们落后第一名多少比赛。本节展示了如何计算这些值。第一个示例使用一个包含单个球队记录的表来说明计算逻辑。第二个示例使用一个包含多组记录的表（即联盟的两个分区以及赛季的两半）来说明计算逻辑。在这种情况下，需要使用连接来独立为每组球队执行计算。

考虑以下表格`standings1`，其中包含了一组单一的棒球队记录，代表了 1902 年北方联盟的最终排名：

```
mysql> `SELECT team, wins, losses FROM standings1`
    -> `ORDER BY wins-losses DESC;`
+-------------+------+--------+
| team        | wins | losses |
+-------------+------+--------+
| Winnipeg    |   37 |     20 |
| Crookston   |   31 |     25 |
| Fargo       |   30 |     26 |
| Grand Forks |   28 |     26 |
| Devils Lake |   19 |     31 |
| Cavalier    |   15 |     32 |
+-------------+------+--------+
```

行按胜负差异排序，这是将球队按照从第一名到最后一名的顺序排列的方法。但是球队排名的显示通常包括每支球队的胜率以及一个指示其他所有球队落后领先者多少场的数字。因此，让我们在输出中添加这些信息。计算百分比很容易。它是赢得的比赛数与总比赛数的比率，可以使用以下表达式确定：

```
wins / (wins + losses)
```

当一个球队还没有打过比赛时，这个表达式会涉及除以零的除法。为简单起见，我将假设至少有一个非零的比赛数。要处理这种情况，您可以使用一个更通用的表达式：

```
IF(wins=0,0,wins/(wins+losses))
```

这个表达式依赖于一个事实，即除非球队至少赢了一场比赛，否则不需要除法运算。

确定 GB 值有点棘手。它基于两支球队的胜负记录的关系，计算为两个值的平均数：

+   第一名球队比第二名球队多赢多少场比赛

+   第一名球队比第二名球队少多少场败仗

假设两支球队 A 和 B 的胜负记录如下：

```
+------+------+--------+
| team | wins | losses |
+------+------+--------+
| A    |   17 |     11 |
| B    |   14 |     12 |
+------+------+--------+
```

在这里，B 队必须再赢三场比赛，而 A 队必须再输一场比赛，才能使两支队伍平均。三和一的平均数是二，因此 B 队落后 A 队两场比赛。在数学上，计算两支球队的 GB 值如下：

```
((winsA - winsB) + (lossesB - lossesA)) / 2
```

稍微调整一下术语，表达式变成：

```
((winsA - lossesA) - (winsB - lossesB)) / 2
```

第二个表达式等同于第一个，但它将每个因素写为单个球队的胜负差异，而不是作为两支球队之间的比较。这样做更容易处理，因为可以独立确定每个因素从单一球队记录中。第一个因素代表第一名球队的胜负差异，因此如果首先计算该值，其他球队的 GB 值可以与之关联确定。

第一名球队是胜负差异最大的球队。要找到该值并将其保存在一个变量中，请使用以下语句：

```
mysql> `SET @wl_diff = (SELECT MAX(wins-losses) FROM standings1);`
```

然后按如下方式使用微分来生成包括胜率和 GB 值在内的球队排名：

```
mysql> `SELECT team, wins AS W, losses AS L,`
    -> `wins/(wins+losses) AS PCT,`
    -> `(@wl_diff - (wins-losses)) / 2 AS GB`
    -> `FROM standings1`
    -> `ORDER BY wins-losses DESC, PCT DESC;`
+-------------+------+------+--------+---------+
| team        | W    | L    | PCT    | GB      |
+-------------+------+------+--------+---------+
| Winnipeg    |   37 |   20 | 0.6491 |  0.0000 |
| Crookston   |   31 |   25 | 0.5536 |  5.5000 |
| Fargo       |   30 |   26 | 0.5357 |  6.5000 |
| Grand Forks |   28 |   26 | 0.5185 |  7.5000 |
| Devils Lake |   19 |   31 | 0.3800 | 14.5000 |
| Cavalier    |   15 |   32 | 0.3191 | 17.0000 |
+-------------+------+------+--------+---------+
```

此时需要解决几个微小的格式问题。通常，排名列表将百分比显示为三位小数，并将 GB 值显示为一位小数（但是第一名球队的 GB 值显示为`-`）。要显示*`n`*位小数，使用`TRUNCATE(`*`expr`*`,`*`n`*`)`。为了正确显示第一名球队的 GB 值，请使用`IF()`表达式将 0 映射到破折号：

```
mysql> `SELECT team, wins AS W, losses AS L,`
    -> `TRUNCATE(wins/(wins+losses),3) AS PCT,`
    -> `IF(@wl_diff = wins-losses,`
    ->    `'-',TRUNCATE((@wl_diff - (wins-losses))/2,1)) AS GB`
    -> `FROM standings1`
    -> `ORDER BY wins-losses DESC, PCT DESC;`
+-------------+------+------+-------+------+
| team        | W    | L    | PCT   | GB   |
+-------------+------+------+-------+------+
| Winnipeg    |   37 |   20 | 0.649 | -    |
| Crookston   |   31 |   25 | 0.553 | 5.5  |
| Fargo       |   30 |   26 | 0.535 | 6.5  |
| Grand Forks |   28 |   26 | 0.518 | 7.5  |
| Devils Lake |   19 |   31 | 0.380 | 14.5 |
| Cavalier    |   15 |   32 | 0.319 | 17.0 |
+-------------+------+------+-------+------+
```

这些语句按照胜负差异对团队进行排序，使用胜率作为打结者以防存在具有相同差异值的团队。当然，按百分比排序更简单，但这样做并不总能得到正确的排序。有趣的是，一个胜率较低的团队实际上可能在排名中高于一个胜率较高的团队。 （这通常发生在赛季初期，当团队可能已经相对不均匀地进行了大量比赛时。）考虑以下情况，即两支团队 A 和 B，它们具有以下行：

```
+------+------+--------+
| team | wins | losses |
+------+------+--------+
| A    |    4 |      1 |
| B    |    2 |      0 |
+------+------+--------+
```

应用 GB 和百分比计算到这些团队记录上得到以下结果，其中第一名的团队实际上比第二名的团队拥有更低的胜率：

```
+------+------+------+-------+------+
| team | W    | L    | PCT   | GB   |
+------+------+------+-------+------+
| A    |    4 |    1 | 0.800 | -    |
| B    |    2 |    0 | 1.000 | 0.5  |
+------+------+------+-------+------+
```

到目前为止展示的排名计算可以在没有 join 的情况下完成。它们仅涉及单一组团队记录，因此第一名团队的胜负差异可以存储在一个变量中。当数据集包含多组团队记录时，则会出现更复杂的情况。例如，1997 年北部联赛有两个分区（东部和西部）。此外，因为赛季的上半部分和下半部分的赢家在每个分区内争夺联赛冠军的权利，所以单独的排名保持了分别的排名。以下表`standings2`按赛季半程、分区和胜负差异排序，展示了这些行：

```
mysql> `SELECT half, division, team, wins, losses FROM standings2`
    -> `ORDER BY half, division, wins-losses DESC;`
+------+----------+-----------------+------+--------+
| half | division | team            | wins | losses |
+------+----------+-----------------+------+--------+
|    1 | Eastern  | St. Paul        |   24 |     18 |
|    1 | Eastern  | Thunder Bay     |   18 |     24 |
|    1 | Eastern  | Duluth-Superior |   17 |     24 |
|    1 | Eastern  | Madison         |   15 |     27 |
|    1 | Western  | Winnipeg        |   29 |     12 |
|    1 | Western  | Sioux City      |   28 |     14 |
|    1 | Western  | Fargo-Moorhead  |   21 |     21 |
|    1 | Western  | Sioux Falls     |   15 |     27 |
|    2 | Eastern  | Duluth-Superior |   22 |     20 |
|    2 | Eastern  | St. Paul        |   21 |     21 |
|    2 | Eastern  | Madison         |   19 |     23 |
|    2 | Eastern  | Thunder Bay     |   18 |     24 |
|    2 | Western  | Fargo-Moorhead  |   26 |     16 |
|    2 | Western  | Winnipeg        |   24 |     18 |
|    2 | Western  | Sioux City      |   22 |     20 |
|    2 | Western  | Sioux Falls     |   16 |     26 |
+------+----------+-----------------+------+--------+
```

为这些行生成排名需要分别为赛季的四个组合计算 GB 值。首先，计算每组的第一名团队的胜负差异并将其值保存到单独的`firstplace`表中：

```
mysql> `CREATE TEMPORARY TABLE firstplace`
    -> `SELECT half, division, MAX(wins-losses) AS wl_diff`
    -> `FROM standings2`
    -> `GROUP BY half, division;`
```

然后将`firstplace`表与原始排名表连接，将每个团队记录与正确的胜负差异关联起来计算其 GB 值：

```
mysql> `SELECT wl.half, wl.division, wl.team, wl.wins AS W, wl.losses AS L,`
    -> `TRUNCATE(wl.wins/(wl.wins+wl.losses),3) AS PCT,`
    -> `IF(fp.wl_diff = wl.wins-wl.losses,`
    ->    `'-',TRUNCATE((fp.wl_diff - (wl.wins-wl.losses)) / 2,1)) AS GB`
    -> `FROM standings2 AS wl INNER JOIN firstplace AS fp`
    -> `ON wl.half = fp.half AND wl.division = fp.division`
    -> `ORDER BY wl.half, wl.division, wl.wins-wl.losses DESC, PCT DESC;`
+------+----------+-----------------+------+------+-------+------+
| half | division | team            | W    | L    | PCT   | GB   |
+------+----------+-----------------+------+------+-------+------+
|    1 | Eastern  | St. Paul        |   24 |   18 | 0.571 | -    |
|    1 | Eastern  | Thunder Bay     |   18 |   24 | 0.428 | 6.0  |
|    1 | Eastern  | Duluth-Superior |   17 |   24 | 0.414 | 6.5  |
|    1 | Eastern  | Madison         |   15 |   27 | 0.357 | 9.0  |
|    1 | Western  | Winnipeg        |   29 |   12 | 0.707 | -    |
|    1 | Western  | Sioux City      |   28 |   14 | 0.666 | 1.5  |
|    1 | Western  | Fargo-Moorhead  |   21 |   21 | 0.500 | 8.5  |
|    1 | Western  | Sioux Falls     |   15 |   27 | 0.357 | 14.5 |
|    2 | Eastern  | Duluth-Superior |   22 |   20 | 0.523 | -    |
|    2 | Eastern  | St. Paul        |   21 |   21 | 0.500 | 1.0  |
|    2 | Eastern  | Madison         |   19 |   23 | 0.452 | 3.0  |
|    2 | Eastern  | Thunder Bay     |   18 |   24 | 0.428 | 4.0  |
|    2 | Western  | Fargo-Moorhead  |   26 |   16 | 0.619 | -    |
|    2 | Western  | Winnipeg        |   24 |   18 | 0.571 | 2.0  |
|    2 | Western  | Sioux City      |   22 |   20 | 0.523 | 4.0  |
|    2 | Western  | Sioux Falls     |   16 |   26 | 0.380 | 10.0 |
+------+----------+-----------------+------+------+-------+------+
```

然而，那种输出很难阅读。为了使其更易理解，您可以在程序内执行语句并重新格式化其结果，以单独显示每组团队记录。以下是一些 Perl 代码，通过在遇到新的排名组时开始新的输出组来实现这一点。代码假设刚刚执行了 join 语句，并且其结果通过语句句柄`$sth`可用：

```
my ($cur_half, $cur_div) = ("", "");
while (my ($half, $div, $team, $wins, $losses, $pct, $gb)
          = $sth->fetchrow_array ())
{
  if ($cur_half ne $half || $cur_div ne $div) # new group of standings?
  {
    # print standings header and remember new half/division values
    print "\n$div Division, season half $half\n";
    printf "%-20s  %3s  %3s  %5s  %s\n", "Team", "W", "L", "PCT", "GB";
    $cur_half = $half;
    $cur_div = $div;
  }
  printf "%-20s  %3d  %3d  %5s  %s\n", $team, $wins, $losses, $pct, $gb;
}
```

重新格式化的输出如下所示：

```
Eastern Division, season half 1
Team                    W    L    PCT  GB
St. Paul               24   18  0.571  -
Thunder Bay            18   24  0.428  6.0
Duluth-Superior        17   24  0.414  6.5
Madison                15   27  0.357  9.0

Western Division, season half 1
Team                    W    L    PCT  GB
Winnipeg               29   12  0.707  -
Sioux City             28   14  0.666  1.5
Fargo-Moorhead         21   21  0.500  8.5
Sioux Falls            15   27  0.357  14.5

Eastern Division, season half 2
Team                    W    L    PCT  GB
Duluth-Superior        22   20  0.523  -
St. Paul               21   21  0.500  1.0
Madison                19   23  0.452  3.0
Thunder Bay            18   24  0.428  4.0

Western Division, season half 2
Team                    W    L    PCT  GB
Fargo-Moorhead         26   16  0.619  -
Winnipeg               24   18  0.571  2.0
Sioux City             22   20  0.523  4.0
Sioux Falls            16   26  0.380  10.0
```

刚刚显示的代码来自`recipes`发行版的`stats`目录中的*calc_standings.pl*脚本。该目录还包含一个 PHP 脚本*calc_standings.php*，以 HTML 表格的形式生成输出，您可能更喜欢在 Web 环境中生成排名。

^(1) 此处给出的中位数定义并不完全通用；它没有解决数据集中中间值重复的情况。

^(2) 要了解这些术语的来源，请参阅任何一本标准统计学教材。
